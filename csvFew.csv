key,title,description,assignee,type,priority,status,text
CAMEL-14041,scheduled poll consumer - Add option to limit number of polls,"In the timer/scheduler component you can set a max number of polls so the consumer stop after that.

We could add something similar so you can eg tell the consumer to run only once etc.",davsclaus,Improvement,Major,Resolved,"scheduled poll consumer - Add option to limit number of polls In the timer/scheduler component you can set a max number of polls so the consumer stop after that.

We could add something similar so you can eg tell the consumer to run only once etc."
CAMEL-14040,DefaultRegistry - findByType should return merged result incl fallback,Reported by Luca in camel-quarkus,davsclaus,Improvement,Major,Resolved,DefaultRegistry - findByType should return merged result incl fallback Reported by Luca in camel-quarkus
CAMEL-14035,JDBC StreamList and outputClass does not work,"Situation is simple:

I try to load data from jdbc by Stream to Java object

with such command jdbc:dbBean?outputType=StreamList&outputClass=myClass.

I estimate Java object on exit of flow? but i have Map<String, Object>.

Bug in JdbcProducer at lines 326.

if (outputType == JdbcOutputType.StreamList) {
 exchange.getOut().setBody(iterator);
 exchange.addOnCompletion(new ResultSetIteratorCompletion(iterator));
 // do not close resources as we are in streaming mode
 answer = false;
}

Here need wrap iterator to map objects by method newBeanInstance",davsclaus,Bug,Major,Resolved,"JDBC StreamList and outputClass does not work Situation is simple:

I try to load data from jdbc by Stream to Java object

with such command jdbc:dbBean?outputType=StreamList&outputClass=myClass.

I estimate Java object on exit of flow? but i have Map<String, Object>.

Bug in JdbcProducer at lines 326.

if (outputType == JdbcOutputType.StreamList) {
 exchange.getOut().setBody(iterator);
 exchange.addOnCompletion(new ResultSetIteratorCompletion(iterator));
 // do not close resources as we are in streaming mode
 answer = false;
}

Here need wrap iterator to map objects by method newBeanInstance"
CAMEL-14034,Orderes RoutesBuilder,"RoutesBuilder are now loaded according to the order the user add them but in some cases it may be needed to load them according to an order.

We should then make the RoutesBuilder interface extends Ordered and take it into account i.e. in MainSupport.",davsclaus,Improvement,Minor,Resolved,"Orderes RoutesBuilder RoutesBuilder are now loaded according to the order the user add them but in some cases it may be needed to load them according to an order.

We should then make the RoutesBuilder interface extends Ordered and take it into account i.e. in MainSupport."
CAMEL-14033,multiple consumers for namedReplyTo results in a cryptic nullPointer,"Per [https://camel.apache.org/components/latest/sjms-component.html#_clustering] you should not have multiple inOut producerEndpoints using the same replyTo address but if you do it results in a cryptic null pointer exception it would be nice to have a better error message of some sort directing you to use a unique replyTo address or temporary queue. Additionally if the replyTo is a topic then I don't believe it should result in an error and it may be better to actually use a message selector for this case.

java.lang.NullPointerException: nulljava.lang.NullPointerException: null at org.apache.camel.component.sjms.producer.InOutProducer$MessageConsumerResourcesFactory$1.onMessage(InOutProducer.java:103) ~[?:?] at org.apache.activemq.artemis.jms.client.JMSMessageListenerWrapper.onMessage(JMSMessageListenerWrapper.java:110) ~[254:org.apache.activemq.artemis-server-osgi:2.8.1] at org.apache.activemq.artemis.core.client.impl.ClientConsumerImpl.callOnMessage(ClientConsumerImpl.java:1031) ~[?:?] at org.apache.activemq.artemis.core.client.impl.ClientConsumerImpl.access$400(ClientConsumerImpl.java:50) ~[?:?] at org.apache.activemq.artemis.core.client.impl.ClientConsumerImpl$Runner.run(ClientConsumerImpl.java:1154) ~[?:?] at org.apache.activemq.artemis.utils.actors.OrderedExecutor.doTask(OrderedExecutor.java:42) ~[?:?] at org.apache.activemq.artemis.utils.actors.OrderedExecutor.doTask(OrderedExecutor.java:31) ~[?:?] at org.apache.activemq.artemis.utils.actors.ProcessorBase.executePendingTasks(ProcessorBase.java:66) ~[?:?] at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149) [?:?] at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624) [?:?]",davsclaus,Bug,Minor,Resolved,"multiple consumers for namedReplyTo results in a cryptic nullPointer Per [https://camel.apache.org/components/latest/sjms-component.html#_clustering] you should not have multiple inOut producerEndpoints using the same replyTo address but if you do it results in a cryptic null pointer exception it would be nice to have a better error message of some sort directing you to use a unique replyTo address or temporary queue. Additionally if the replyTo is a topic then I don't believe it should result in an error and it may be better to actually use a message selector for this case.

java.lang.NullPointerException: nulljava.lang.NullPointerException: null at org.apache.camel.component.sjms.producer.InOutProducer$MessageConsumerResourcesFactory$1.onMessage(InOutProducer.java:103) ~[?:?] at org.apache.activemq.artemis.jms.client.JMSMessageListenerWrapper.onMessage(JMSMessageListenerWrapper.java:110) ~[254:org.apache.activemq.artemis-server-osgi:2.8.1] at org.apache.activemq.artemis.core.client.impl.ClientConsumerImpl.callOnMessage(ClientConsumerImpl.java:1031) ~[?:?] at org.apache.activemq.artemis.core.client.impl.ClientConsumerImpl.access$400(ClientConsumerImpl.java:50) ~[?:?] at org.apache.activemq.artemis.core.client.impl.ClientConsumerImpl$Runner.run(ClientConsumerImpl.java:1154) ~[?:?] at org.apache.activemq.artemis.utils.actors.OrderedExecutor.doTask(OrderedExecutor.java:42) ~[?:?] at org.apache.activemq.artemis.utils.actors.OrderedExecutor.doTask(OrderedExecutor.java:31) ~[?:?] at org.apache.activemq.artemis.utils.actors.ProcessorBase.executePendingTasks(ProcessorBase.java:66) ~[?:?] at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149) [?:?] at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624) [?:?]"
CAMEL-14031,Move process control from Main to MainSupport,"org.apache.camel.main.MainSupport is now in charge to parse command line arguments, keep the process up according to some policies, intercepts shutdown events and so on.

To make it easier to re-use MainSupport in other projects such as camel-quarkus where as example there's no control over command line arguments, it would be nice to move the process control logic to org.apache.camel.main.Main.

[~davsclaus] does it make sense or there is something I haven't taken into account ?",davsclaus,Improvement,Major,Resolved,"Move process control from Main to MainSupport org.apache.camel.main.MainSupport is now in charge to parse command line arguments, keep the process up according to some policies, intercepts shutdown events and so on.

To make it easier to re-use MainSupport in other projects such as camel-quarkus where as example there's no control over command line arguments, it would be nice to move the process control logic to org.apache.camel.main.Main.

[~davsclaus] does it make sense or there is something I haven't taken into account ?"
CAMEL-14030,camel-ftp - streamDownload=true and move options dont work,"Reported on mailing list
https://camel.465427.n5.nabble.com/Bug-Camel-FTP-streamdownload-move-options-tp5843791.html",davsclaus,Bug,Major,Resolved,"camel-ftp - streamDownload=true and move options dont work Reported on mailing list
https://camel.465427.n5.nabble.com/Bug-Camel-FTP-streamdownload-move-options-tp5843791.html"
CAMEL-13999,Salesforce Component IDLE_TIMEOUT Blocks Async Request Responses for 2.x,"Bulk, Composite Batch, etc. all throw an exception when trying to return on more than a few records due to [static final IDLE_TIMEOUT|https://github.com/apache/camel/blob/master/components/camel-salesforce/camel-salesforce-component/src/main/java/org/apache/camel/component/salesforce/SalesforceComponent.java#L80] on the instantiated salesforce component httpClient:

 

Caused by: org.apache.camel.component.salesforce.api.SalesforceException: Unexpected error \{0:null} executing \{POST:https://genericSFDCInstance.salesforce.com/services/data/v38.0/composite/batch}
        at org.apache.camel.component.salesforce.internal.client.AbstractClientBase$1.onComplete(AbstractClientBase.java:199) ~[camel-salesforce-2.23.0.jar:2.23.0]
        at org.eclipse.jetty.client.ResponseNotifier.notifyComplete(ResponseNotifier.java:202) ~[jetty-client-9.4.12.v20180830.jar:9.4.12.v20180830]
        at org.eclipse.jetty.client.ResponseNotifier.notifyComplete(ResponseNotifier.java:194) ~[jetty-client-9.4.12.v20180830.jar:9.4.12.v20180830]
        at org.eclipse.jetty.client.HttpReceiver.terminateResponse(HttpReceiver.java:470) ~[jetty-client-9.4.12.v20180830.jar:9.4.12.v20180830]
        at org.eclipse.jetty.client.HttpReceiver.abort(HttpReceiver.java:552) ~[jetty-client-9.4.12.v20180830.jar:9.4.12.v20180830]
        at org.eclipse.jetty.client.HttpChannel.abortResponse(HttpChannel.java:156) ~[jetty-client-9.4.12.v20180830.jar:9.4.12.v20180830]
        at org.eclipse.jetty.client.HttpChannel.abort(HttpChannel.java:149) ~[jetty-client-9.4.12.v20180830.jar:9.4.12.v20180830]
        at org.eclipse.jetty.client.HttpExchange.abort(HttpExchange.java:257) ~[jetty-client-9.4.12.v20180830.jar:9.4.12.v20180830]
        at org.eclipse.jetty.client.HttpConversation.abort(HttpConversation.java:141) ~[jetty-client-9.4.12.v20180830.jar:9.4.12.v20180830]
        at org.eclipse.jetty.client.HttpRequest.abort(HttpRequest.java:767) ~[jetty-client-9.4.12.v20180830.jar:9.4.12.v20180830]
        at org.eclipse.jetty.client.http.HttpConnectionOverHTTP.abort(HttpConnectionOverHTTP.java:204) ~[jetty-client-9.4.12.v20180830.jar:9.4.12.v20180830]
        at org.eclipse.jetty.client.http.HttpConnectionOverHTTP.close(HttpConnectionOverHTTP.java:190) ~[jetty-client-9.4.12.v20180830.jar:9.4.12.v20180830]
        at org.eclipse.jetty.client.http.HttpConnectionOverHTTP.onIdleExpired(HttpConnectionOverHTTP.java:145) ~[jetty-client-9.4.12.v20180830.jar:9.4.12.v20180830]
        at org.eclipse.jetty.io.ssl.SslConnection.onIdleExpired(SslConnection.java:286) ~[jetty-io-9.4.12.v20180830.jar:9.4.12.v20180830]
        at org.eclipse.jetty.io.AbstractEndPoint.onIdleExpired(AbstractEndPoint.java:401) ~[jetty-io-9.4.12.v20180830.jar:9.4.12.v20180830]
        at org.eclipse.jetty.io.IdleTimeout.checkIdleTimeout(IdleTimeout.java:166) ~[jetty-io-9.4.12.v20180830.jar:9.4.12.v20180830]
        at org.eclipse.jetty.io.IdleTimeout$1.run(IdleTimeout.java:50) ~[jetty-io-9.4.12.v20180830.jar:9.4.12.v20180830]
        at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511) ~[?:1.8.0_201]
        at java.util.concurrent.FutureTask.run(FutureTask.java:266) ~[?:1.8.0_201]
        at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.access$201(ScheduledThreadPoolExecutor.java:180) ~[?:1.8.0_201]
        at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:293) ~[?:1.8.0_201]
        at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149) ~[?:1.8.0_201]
        at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624) ~[?:1.8.0_201]
        ... 1 more


*Caused by: java.util.concurrent.TimeoutException: Idle timeout 5000 ms*
        at org.eclipse.jetty.client.http.HttpConnectionOverHTTP.onIdleExpired(HttpConnectionOverHTTP.java:145) ~[jetty-client-9.4.12.v20180830.jar:9.4.12.v20180830]
        at org.eclipse.jetty.io.ssl.SslConnection.onIdleExpired(SslConnection.java:286) ~[jetty-io-9.4.12.v20180830.jar:9.4.12.v20180830]
        at org.eclipse.jetty.io.AbstractEndPoint.onIdleExpired(AbstractEndPoint.java:401) ~[jetty-io-9.4.12.v20180830.jar:9.4.12.v20180830]
        at org.eclipse.jetty.io.IdleTimeout.checkIdleTimeout(IdleTimeout.java:166) ~[jetty-io-9.4.12.v20180830.jar:9.4.12.v20180830]
        at org.eclipse.jetty.io.IdleTimeout$1.run(IdleTimeout.java:50) ~[jetty-io-9.4.12.v20180830.jar:9.4.12.v20180830]
        at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511) ~[?:1.8.0_201]
        at java.util.concurrent.FutureTask.run(FutureTask.java:266) ~[?:1.8.0_201]
        at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.access$201(ScheduledThreadPoolExecutor.java:180) ~[?:1.8.0_201]
        at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:293) ~[?:1.8.0_201]
        at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149) ~[?:1.8.0_201]
        at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624) ~[?:1.8.0_201]
        ... 1 more

 

Note that as IDLE_TIMEOUT is static, it cannot be set via Spring, and the httpClientProperties map is [never used to set any timeouts|https://github.com/apache/camel/blob/master/components/camel-salesforce/camel-salesforce-component/src/main/java/org/apache/camel/component/salesforce/SalesforceComponent.java#L714], instead opting to take the [hardcoded defaults|https://github.com/apache/camel/blob/master/components/camel-salesforce/camel-salesforce-component/src/main/java/org/apache/camel/component/salesforce/SalesforceComponent.java#L707].

 ",davsclaus,Bug,Minor,Resolved,"Salesforce Component IDLE_TIMEOUT Blocks Async Request Responses for 2.x Bulk, Composite Batch, etc. all throw an exception when trying to return on more than a few records due to [static final IDLE_TIMEOUT|https://github.com/apache/camel/blob/master/components/camel-salesforce/camel-salesforce-component/src/main/java/org/apache/camel/component/salesforce/SalesforceComponent.java#L80] on the instantiated salesforce component httpClient:

 

Caused by: org.apache.camel.component.salesforce.api.SalesforceException: Unexpected error \{0:null} executing \{POST:https://genericSFDCInstance.salesforce.com/services/data/v38.0/composite/batch}
        at org.apache.camel.component.salesforce.internal.client.AbstractClientBase$1.onComplete(AbstractClientBase.java:199) ~[camel-salesforce-2.23.0.jar:2.23.0]
        at org.eclipse.jetty.client.ResponseNotifier.notifyComplete(ResponseNotifier.java:202) ~[jetty-client-9.4.12.v20180830.jar:9.4.12.v20180830]
        at org.eclipse.jetty.client.ResponseNotifier.notifyComplete(ResponseNotifier.java:194) ~[jetty-client-9.4.12.v20180830.jar:9.4.12.v20180830]
        at org.eclipse.jetty.client.HttpReceiver.terminateResponse(HttpReceiver.java:470) ~[jetty-client-9.4.12.v20180830.jar:9.4.12.v20180830]
        at org.eclipse.jetty.client.HttpReceiver.abort(HttpReceiver.java:552) ~[jetty-client-9.4.12.v20180830.jar:9.4.12.v20180830]
        at org.eclipse.jetty.client.HttpChannel.abortResponse(HttpChannel.java:156) ~[jetty-client-9.4.12.v20180830.jar:9.4.12.v20180830]
        at org.eclipse.jetty.client.HttpChannel.abort(HttpChannel.java:149) ~[jetty-client-9.4.12.v20180830.jar:9.4.12.v20180830]
        at org.eclipse.jetty.client.HttpExchange.abort(HttpExchange.java:257) ~[jetty-client-9.4.12.v20180830.jar:9.4.12.v20180830]
        at org.eclipse.jetty.client.HttpConversation.abort(HttpConversation.java:141) ~[jetty-client-9.4.12.v20180830.jar:9.4.12.v20180830]
        at org.eclipse.jetty.client.HttpRequest.abort(HttpRequest.java:767) ~[jetty-client-9.4.12.v20180830.jar:9.4.12.v20180830]
        at org.eclipse.jetty.client.http.HttpConnectionOverHTTP.abort(HttpConnectionOverHTTP.java:204) ~[jetty-client-9.4.12.v20180830.jar:9.4.12.v20180830]
        at org.eclipse.jetty.client.http.HttpConnectionOverHTTP.close(HttpConnectionOverHTTP.java:190) ~[jetty-client-9.4.12.v20180830.jar:9.4.12.v20180830]
        at org.eclipse.jetty.client.http.HttpConnectionOverHTTP.onIdleExpired(HttpConnectionOverHTTP.java:145) ~[jetty-client-9.4.12.v20180830.jar:9.4.12.v20180830]
        at org.eclipse.jetty.io.ssl.SslConnection.onIdleExpired(SslConnection.java:286) ~[jetty-io-9.4.12.v20180830.jar:9.4.12.v20180830]
        at org.eclipse.jetty.io.AbstractEndPoint.onIdleExpired(AbstractEndPoint.java:401) ~[jetty-io-9.4.12.v20180830.jar:9.4.12.v20180830]
        at org.eclipse.jetty.io.IdleTimeout.checkIdleTimeout(IdleTimeout.java:166) ~[jetty-io-9.4.12.v20180830.jar:9.4.12.v20180830]
        at org.eclipse.jetty.io.IdleTimeout$1.run(IdleTimeout.java:50) ~[jetty-io-9.4.12.v20180830.jar:9.4.12.v20180830]
        at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511) ~[?:1.8.0_201]
        at java.util.concurrent.FutureTask.run(FutureTask.java:266) ~[?:1.8.0_201]
        at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.access$201(ScheduledThreadPoolExecutor.java:180) ~[?:1.8.0_201]
        at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:293) ~[?:1.8.0_201]
        at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149) ~[?:1.8.0_201]
        at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624) ~[?:1.8.0_201]
        ... 1 more


*Caused by: java.util.concurrent.TimeoutException: Idle timeout 5000 ms*
        at org.eclipse.jetty.client.http.HttpConnectionOverHTTP.onIdleExpired(HttpConnectionOverHTTP.java:145) ~[jetty-client-9.4.12.v20180830.jar:9.4.12.v20180830]
        at org.eclipse.jetty.io.ssl.SslConnection.onIdleExpired(SslConnection.java:286) ~[jetty-io-9.4.12.v20180830.jar:9.4.12.v20180830]
        at org.eclipse.jetty.io.AbstractEndPoint.onIdleExpired(AbstractEndPoint.java:401) ~[jetty-io-9.4.12.v20180830.jar:9.4.12.v20180830]
        at org.eclipse.jetty.io.IdleTimeout.checkIdleTimeout(IdleTimeout.java:166) ~[jetty-io-9.4.12.v20180830.jar:9.4.12.v20180830]
        at org.eclipse.jetty.io.IdleTimeout$1.run(IdleTimeout.java:50) ~[jetty-io-9.4.12.v20180830.jar:9.4.12.v20180830]
        at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511) ~[?:1.8.0_201]
        at java.util.concurrent.FutureTask.run(FutureTask.java:266) ~[?:1.8.0_201]
        at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.access$201(ScheduledThreadPoolExecutor.java:180) ~[?:1.8.0_201]
        at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:293) ~[?:1.8.0_201]
        at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149) ~[?:1.8.0_201]
        at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624) ~[?:1.8.0_201]
        ... 1 more

 

Note that as IDLE_TIMEOUT is static, it cannot be set via Spring, and the httpClientProperties map is [never used to set any timeouts|https://github.com/apache/camel/blob/master/components/camel-salesforce/camel-salesforce-component/src/main/java/org/apache/camel/component/salesforce/SalesforceComponent.java#L714], instead opting to take the [hardcoded defaults|https://github.com/apache/camel/blob/master/components/camel-salesforce/camel-salesforce-component/src/main/java/org/apache/camel/component/salesforce/SalesforceComponent.java#L707].

 "
CAMEL-13991,camel-main - Configuring component options with #class dont work,The fast component configurer is in use before we check whether the value is a #class etc which we need to do beforehand,davsclaus,Bug,Major,Resolved,camel-main - Configuring component options with #class dont work The fast component configurer is in use before we check whether the value is a #class etc which we need to do beforehand
CAMEL-13961,Reconsider default for xslt:allowStAX,"This is currently set to true. However, Xalan (which the default XSLT processor for most) cannot handle StAXSource

{code}
Caused by: javax.xml.transform.TransformerException: javax.xml.transform.TransformerException: org.apache.xml.dtm.DTMException: Not supported: javax.xml.transform.stax.StAXSource@6a35603
	at org.apache.xalan.xsltc.trax.TransformerImpl.transform(TransformerImpl.java:642)
	at org.apache.xalan.xsltc.trax.TransformerImpl.transform(TransformerImpl.java:303)
	at org.apache.camel.component.xslt.XsltBuilder.process(XsltBuilder.java:132)
	at org.apache.camel.support.ProcessorEndpoint.onExchange(ProcessorEndpoint.java:95)
	at org.apache.camel.component.xslt.XsltEndpoint.onExchange(XsltEndpoint.java:121)

{code}",davsclaus,Bug,Major,Resolved,"Reconsider default for xslt:allowStAX This is currently set to true. However, Xalan (which the default XSLT processor for most) cannot handle StAXSource

{code}
Caused by: javax.xml.transform.TransformerException: javax.xml.transform.TransformerException: org.apache.xml.dtm.DTMException: Not supported: javax.xml.transform.stax.StAXSource@6a35603
	at org.apache.xalan.xsltc.trax.TransformerImpl.transform(TransformerImpl.java:642)
	at org.apache.xalan.xsltc.trax.TransformerImpl.transform(TransformerImpl.java:303)
	at org.apache.camel.component.xslt.XsltBuilder.process(XsltBuilder.java:132)
	at org.apache.camel.support.ProcessorEndpoint.onExchange(ProcessorEndpoint.java:95)
	at org.apache.camel.component.xslt.XsltEndpoint.onExchange(XsltEndpoint.java:121)

{code}"
CAMEL-13955,SJMS-Batch does not support CompletionAware aggregators,"SJMS-Batch isn't aware of the CompletionAwareAggregationStrategy interface and so never calls the completion method.

This prevents SJMS-Batch from working as expected with built in aggregators such as org.apache.camel.processor.aggregate.GroupedBodyAggregationStrategy - the aggregated message remains as an exchange header instead of being the message body.

 ",davsclaus,Improvement,Minor,Resolved,"SJMS-Batch does not support CompletionAware aggregators SJMS-Batch isn't aware of the CompletionAwareAggregationStrategy interface and so never calls the completion method.

This prevents SJMS-Batch from working as expected with built in aggregators such as org.apache.camel.processor.aggregate.GroupedBodyAggregationStrategy - the aggregated message remains as an exchange header instead of being the message body.

 "
CAMEL-13949,camel-core vs camel-core-engine,"The camel-core-engine trims camel-core using maven exclusions which may lead to unexpected result as if both are present in the dependencies tree, then one may win over the other depending of the maven resolution.
",davsclaus,Improvement,Major,Resolved,"camel-core vs camel-core-engine The camel-core-engine trims camel-core using maven exclusions which may lead to unexpected result as if both are present in the dependencies tree, then one may win over the other depending of the maven resolution.
"
CAMEL-13947,Create a configuration service instead of leveraging the properties component,"As today the way camel resolves properties/configuration is trough the Properties Component which leads to a chicken and egg problem as:

- camel core depends on properties component
- the properties component depends on camel core

We should probably have a proper configuration service part of camel core that can eventually be leveraged by the Properties Component.

",davsclaus,Improvement,Major,Resolved,"Create a configuration service instead of leveraging the properties component As today the way camel resolves properties/configuration is trough the Properties Component which leads to a chicken and egg problem as:

- camel core depends on properties component
- the properties component depends on camel core

We should probably have a proper configuration service part of camel core that can eventually be leveraged by the Properties Component.

"
CAMEL-13941,NullPointerException when Conduit is null,"Hello,

the CxfProducer.doStart() retrieves a Conduit.

If this Conduit is null, should we still throw a NullPointerException or, should we check nullity before condition?
{code:java}
Conduit conduit = client.getConduit();

        if (conduit.getClass().getName().endsWith(""JMSConduit"")) {
...
}{code}

https://github.com/apache/camel/blob/camel-2.21.2/components/camel-cxf/src/main/java/org/apache/camel/component/cxf/CxfProducer.java#L87
https://github.com/apache/camel/blob/camel-2.23.1/components/camel-cxf/src/main/java/org/apache/camel/component/cxf/CxfProducer.java#L87
https://github.com/apache/camel/blob/camel-2.24.1/components/camel-cxf/src/main/java/org/apache/camel/component/cxf/CxfProducer.java#L87

Thanks for your point of view.",davsclaus,Bug,Minor,Resolved,"NullPointerException when Conduit is null Hello,

the CxfProducer.doStart() retrieves a Conduit.

If this Conduit is null, should we still throw a NullPointerException or, should we check nullity before condition?
{code:java}
Conduit conduit = client.getConduit();

        if (conduit.getClass().getName().endsWith(""JMSConduit"")) {
...
}{code}

https://github.com/apache/camel/blob/camel-2.21.2/components/camel-cxf/src/main/java/org/apache/camel/component/cxf/CxfProducer.java#L87
https://github.com/apache/camel/blob/camel-2.23.1/components/camel-cxf/src/main/java/org/apache/camel/component/cxf/CxfProducer.java#L87
https://github.com/apache/camel/blob/camel-2.24.1/components/camel-cxf/src/main/java/org/apache/camel/component/cxf/CxfProducer.java#L87

Thanks for your point of view."
CAMEL-13939,camel3 - Rename camel-management-impl to camel-management,"Lets avoid the -impl in the name as its the only Camel artifact that has this ending.


",davsclaus,Task,Major,Resolved,"camel3 - Rename camel-management-impl to camel-management Lets avoid the -impl in the name as its the only Camel artifact that has this ending.


"
CAMEL-13936,SNMP Component support ‘snmp walk’,"The current version, the SNMP Component can not support 'snmp walk'.

Although the source code has appear 'GET_NEXT' in SnmpActionType.java, but no found in processor.

Now, i add the 'snmp walk' and in my application it run successfully.

So, if it need add to the next camel version, please check.

Thanks!",davsclaus,New Feature,Minor,Resolved,"SNMP Component support 'snmp walk' The current version, the SNMP Component can not support 'snmp walk'.

Although the source code has appear 'GET_NEXT' in SnmpActionType.java, but no found in processor.

Now, i add the 'snmp walk' and in my application it run successfully.

So, if it need add to the next camel version, please check.

Thanks!"
CAMEL-13935,camel-properties: Properties with types different from string are not taken into account,"
The properties component spi has a setOverrideProperties that allow to use an arbitrary Properties object so it is possible that the properties it holds are not of type string. 

In case the properties component is asked to resolve a non string property, then it will fail as DefaultPropertiesLookup uses Properties::getProperty [¹] which returns null in case of the requested property is not of type string.

The error is a little bit misleading as it states: 

{code}
because of PropertiesComponent with name properties must be defined in CamelContext to support property placeholders. Property with key [the.body] not found in properties from text: in.body == {{the.body}}
{code}

[1] https://github.com/apache/camel/blob/master/components/camel-properties/src/main/java/org/apache/camel/component/properties/DefaultPropertiesLookup.java#L40",davsclaus,Bug,Minor,Resolved,"camel-properties: Properties with types different from string are not taken into account 
The properties component spi has a setOverrideProperties that allow to use an arbitrary Properties object so it is possible that the properties it holds are not of type string. 

In case the properties component is asked to resolve a non string property, then it will fail as DefaultPropertiesLookup uses Properties::getProperty [1] which returns null in case of the requested property is not of type string.

The error is a little bit misleading as it states: 

{code}
because of PropertiesComponent with name properties must be defined in CamelContext to support property placeholders. Property with key [the.body] not found in properties from text: in.body == {{the.body}}
{code}

[1] https://github.com/apache/camel/blob/master/components/camel-properties/src/main/java/org/apache/camel/component/properties/DefaultPropertiesLookup.java#L40"
CAMEL-13931,camel-file - tempFileName directory is not auto-created if it is relative before the endpoint path,"Hi,

I face a requirement to place temp files in a folder at the same hierarchy as the output folder like this:
 * {{target/data/output/claus.txt}}
 * {{target/data/temp/claus.tmp}}

Using a simple route definition like:
{code:java}
from(""direct:a"").to(""file://target/data/output/?tempFileName=../temp/${file:name.noext}.tmp""){code}
 

If the temp folder does not exist, the GenericFileProducer should auto-create it. However, it only does so correctly for the tempFileName path, if it is *relativ ""after"" the endpoint path*. If it is above/before the endpoint path the tempFileName path will be created as a child of the endpoint path instead:
 * {{target/data/output/target/data/temp}}

This results in a NoSuchFileException when camel tries to write the temp file into the ""correct"" temp directory target/data/temp afterwards.

 

 

A very easy way to reproduce this is to use the 'parentFileUrl' instead of the 'fileUrl' in the createRouteBuilder method of FileProduceTempFileNameTest.java ([https://github.com/apache/camel/blob/master/core/camel-core/src/test/java/org/apache/camel/component/file/FileProduceTempFileNameTest.java]).",davsclaus,Bug,Minor,Resolved,"camel-file - tempFileName directory is not auto-created if it is relative before the endpoint path Hi,

I face a requirement to place temp files in a folder at the same hierarchy as the output folder like this:
 * {{target/data/output/claus.txt}}
 * {{target/data/temp/claus.tmp}}

Using a simple route definition like:
{code:java}
from(""direct:a"").to(""file://target/data/output/?tempFileName=../temp/${file:name.noext}.tmp""){code}
 

If the temp folder does not exist, the GenericFileProducer should auto-create it. However, it only does so correctly for the tempFileName path, if it is *relativ ""after"" the endpoint path*. If it is above/before the endpoint path the tempFileName path will be created as a child of the endpoint path instead:
 * {{target/data/output/target/data/temp}}

This results in a NoSuchFileException when camel tries to write the temp file into the ""correct"" temp directory target/data/temp afterwards.

 

 

A very easy way to reproduce this is to use the 'parentFileUrl' instead of the 'fileUrl' in the createRouteBuilder method of FileProduceTempFileNameTest.java ([https://github.com/apache/camel/blob/master/core/camel-core/src/test/java/org/apache/camel/component/file/FileProduceTempFileNameTest.java])."
CAMEL-13929,camel3 - ApiEndpoint should extend ScheduledPollEndpoint,"As the ApiConsumer is scheduled poll based, but the endpoint was not its base class. Then options get out of sync and not documented either.",davsclaus,Improvement,Major,Resolved,"camel3 - ApiEndpoint should extend ScheduledPollEndpoint As the ApiConsumer is scheduled poll based, but the endpoint was not its base class. Then options get out of sync and not documented either."
CAMEL-13925,camel-seda - SedaConsumer should extend DefaultConsumer,So its like the other components where we extend default classes,davsclaus,Improvement,Major,Resolved,camel-seda - SedaConsumer should extend DefaultConsumer So its like the other components where we extend default classes
CAMEL-13919,"""camel-package:update-readme"" throws ArrayIndexOutOfBoundsException when there is an empty ""adoc"" file","Steps to produce: 
 * Create an empty {{adoc}} file in any component.
 * Run {{camel-package:update-readme}}.
 * It will fail with the following error: 
{code}
Caused by: java.lang.ArrayIndexOutOfBoundsException: Index 1 out of bounds for length 1
    at org.apache.camel.maven.packaging.UpdateReadmeMojo.updateAvailableFrom (UpdateReadmeMojo.java:510)
    at org.apache.camel.maven.packaging.UpdateReadmeMojo.executeComponent (UpdateReadmeMojo.java:151)
    at org.apache.camel.maven.packaging.UpdateReadmeMojo.execute (UpdateReadmeMojo.java:105)
{code}

* As I can see [here|https://github.com/apache/camel/blob/master/tooling/maven/camel-package-maven-plugin/src/main/java/org/apache/camel/maven/packaging/UpdateReadmeMojo.java#L510], it looks it will try to retrieve index although there are empty lines",davsclaus,Bug,Minor,Resolved,"""camel-package:update-readme"" throws ArrayIndexOutOfBoundsException when there is an empty ""adoc"" file Steps to produce: 
 * Create an empty {{adoc}} file in any component.
 * Run {{camel-package:update-readme}}.
 * It will fail with the following error: 
{code}
Caused by: java.lang.ArrayIndexOutOfBoundsException: Index 1 out of bounds for length 1
    at org.apache.camel.maven.packaging.UpdateReadmeMojo.updateAvailableFrom (UpdateReadmeMojo.java:510)
    at org.apache.camel.maven.packaging.UpdateReadmeMojo.executeComponent (UpdateReadmeMojo.java:151)
    at org.apache.camel.maven.packaging.UpdateReadmeMojo.execute (UpdateReadmeMojo.java:105)
{code}

* As I can see [here|https://github.com/apache/camel/blob/master/tooling/maven/camel-package-maven-plugin/src/main/java/org/apache/camel/maven/packaging/UpdateReadmeMojo.java#L510], it looks it will try to retrieve index although there are empty lines"
CAMEL-13918,camel3 - camel-http - Remove deprecate url rewrite,"UrlRewrite has been deprecated on 2.x, and should be removed for 3",davsclaus,Task,Major,Resolved,"camel3 - camel-http - Remove deprecate url rewrite UrlRewrite has been deprecated on 2.x, and should be removed for 3"
CAMEL-13917,camel3 - Deprecate and remove consumer.xxx syntax for delay options,"You can configure them on the endpoint directly, so consumer.delay=5000 should just be delay=5000 and so on.",davsclaus,Task,Major,Resolved,"camel3 - Deprecate and remove consumer.xxx syntax for delay options You can configure them on the endpoint directly, so consumer.delay=5000 should just be delay=5000 and so on."
CAMEL-13913,camel3 - components - Use BeanIntrospection instead of IntrospectionSupport,They should use BeanIntrosepction which you can get from camel context,davsclaus,Task,Major,Resolved,camel3 - components - Use BeanIntrospection instead of IntrospectionSupport They should use BeanIntrosepction which you can get from camel context
CAMEL-13907,camel3 - JMX can clear its bean introspection cache after all MBeans have been registered,"Those are no longer needed and it can free up a bit of memory hold by the cache. Mind the cache is weak anyway, but this makes it more explicit",davsclaus,Task,Major,Resolved,"camel3 - JMX can clear its bean introspection cache after all MBeans have been registered Those are no longer needed and it can free up a bit of memory hold by the cache. Mind the cache is weak anyway, but this makes it more explicit"
CAMEL-13906,Component options - Only include if they have @Metadata,"Properties component include some options which should not be there, as we should only take the getter/setter pairs that have @Metadata annotation",davsclaus,Task,Major,Resolved,"Component options - Only include if they have @Metadata Properties component include some options which should not be there, as we should only take the getter/setter pairs that have @Metadata annotation"
CAMEL-13904,JMX - Early registered services may not be enlisted in XML DSL,In some use-cases depending on how you run Camel then some early services for JMX may not get registered,davsclaus,Bug,Major,Resolved,JMX - Early registered services may not be enlisted in XML DSL In some use-cases depending on how you run Camel then some early services for JMX may not get registered
CAMEL-13901,camel-main-plugin - Dont run it automatic on compile,"Lets just add instructions in the readme and avoid running it on each build. Its used for setting up the project for tooling support, and if you want to have it to do auto-detection of certain JMS clients - eg ActiveMQ vs Artemis and adapt the project accordingly.",davsclaus,Improvement,Major,Resolved,"camel-main-plugin - Dont run it automatic on compile Lets just add instructions in the readme and avoid running it on each build. Its used for setting up the project for tooling support, and if you want to have it to do auto-detection of certain JMS clients - eg ActiveMQ vs Artemis and adapt the project accordingly."
CAMEL-13895,camel3 - TypeConverter(loader = true) rename to generateLoader,"We are using generateConfigurer for fast endpoint configurer, so lets rename this for type converter loader to generateLoader on these annotations",davsclaus,Improvement,Major,Resolved,"camel3 - TypeConverter(loader = true) rename to generateLoader We are using generateConfigurer for fast endpoint configurer, so lets rename this for type converter loader to generateLoader on these annotations"
CAMEL-13878,Message is forwarded to the wrong Kafka Topic,"I have 3 Apache Spring Boot applications and 3 topics.

Let's call them Topic A, B and C and the Spring Boot applications FirstApp, SecondApp and ThridApp. I use Java DSL for the Kafka configuration.

The FirstApp creates a message to Kafka Topic A.

The SecondApp reads from Topic A makes transformations and passes each value to Topic B.

The ThirdApp reads from Topic B and after transformations tries to pass it to Topic C.

At this point through the debugger I saw that at the class  org.apache.camel.component.kafka.KafkaProducer and at the method 

protected Iterator<ProducerRecord> createRecorder(Exchange exchange) something strange is happening.
The headerTopic (line 140) from the following line:

String headerTopic = exchange.getIn().getHeader(KafkaConstants.TOPIC, String.class);

contains the topic A! The correct topic that I have clearly set through the Java DSL can be found under the line 137: 

String topic = endpoint.getConfiguration().getTopic();

As a workaround I have entered the following line inside a processor at the SecondProgram:

exchange.getIn().setHeader(KafkaConstants.TOPIC, null);

This has the side-effect that the headerTopic at line 140 is empty and thus the correct topic from line 137 is used.

I believe that since I have clearly set the destination topic at the ThirdProgram to Topic C then Apache Camel should not override this with Topic A.

It looks like a bug since from the method description I understand that we try to avoid circular loops.

 ",davsclaus,Bug,Major,Resolved,"Message is forwarded to the wrong Kafka Topic I have 3 Apache Spring Boot applications and 3 topics.

Let's call them Topic A, B and C and the Spring Boot applications FirstApp, SecondApp and ThridApp. I use Java DSL for the Kafka configuration.

The FirstApp creates a message to Kafka Topic A.

The SecondApp reads from Topic A makes transformations and passes each value to Topic B.

The ThirdApp reads from Topic B and after transformations tries to pass it to Topic C.

At this point through the debugger I saw that at the class  org.apache.camel.component.kafka.KafkaProducer and at the method 

protected Iterator<ProducerRecord> createRecorder(Exchange exchange) something strange is happening.
The headerTopic (line 140) from the following line:

String headerTopic = exchange.getIn().getHeader(KafkaConstants.TOPIC, String.class);

contains the topic A! The correct topic that I have clearly set through the Java DSL can be found under the line 137: 

String topic = endpoint.getConfiguration().getTopic();

As a workaround I have entered the following line inside a processor at the SecondProgram:

exchange.getIn().setHeader(KafkaConstants.TOPIC, null);

This has the side-effect that the headerTopic at line 140 is empty and thus the correct topic from line 137 is used.

I believe that since I have clearly set the destination topic at the ThirdProgram to Topic C then Apache Camel should not override this with Topic A.

It looks like a bug since from the method description I understand that we try to avoid circular loops.

 "
CAMEL-13870,camel3 - Fast configuring of endpoint options,"Like we did for fast property placeholders on EIPs we can optimize endpoints as well, by using the apt compiler plugin to generate a configurer classes that uses direct java method invocations and then the property builder support class can detect that we have such a configurer and use it, when it looks for the setter. 

",davsclaus,Improvement,Major,Resolved,"camel3 - Fast configuring of endpoint options Like we did for fast property placeholders on EIPs we can optimize endpoints as well, by using the apt compiler plugin to generate a configurer classes that uses direct java method invocations and then the property builder support class can detect that we have such a configurer and use it, when it looks for the setter. 

"
CAMEL-13863,camel3 - Optimize XmlConverterLoader,"I wonder if we can optimize XmlConverterLoader this to init the getXmlConverter once only and avoid synchronized.

It does take a bit time to load according to the yourkit profiler",davsclaus,Improvement,Major,Resolved,"camel3 - Optimize XmlConverterLoader I wonder if we can optimize XmlConverterLoader this to init the getXmlConverter once only and avoid synchronized.

It does take a bit time to load according to the yourkit profiler"
CAMEL-13850,camel3 - Property placeholders on EIP models can be optimized,"We do a bit of introspection on each model class to fin its getter/setter properties, which we can then use for property placeholders.

org.apache.camel.model.ProcessorDefinitionHelper#resolvePropertyPlaceholders

We should look at optimising this",davsclaus,Improvement,Major,Resolved,"camel3 - Property placeholders on EIP models can be optimized We do a bit of introspection on each model class to fin its getter/setter properties, which we can then use for property placeholders.

org.apache.camel.model.ProcessorDefinitionHelper#resolvePropertyPlaceholders

We should look at optimising this"
CAMEL-13848,Support room password in camel-xmpp,Camel-xmpp does not support room passwords at the moment. With small patch it could. Patch file included.,davsclaus,Improvement,Minor,Resolved,Support room password in camel-xmpp Camel-xmpp does not support room passwords at the moment. With small patch it could. Patch file included.
CAMEL-13847,camel-webhook - Should be lenient properties,"So you can pass in uri parameters to the target endpoint, as today it will validate its own configuration only.",davsclaus,Bug,Major,Resolved,"camel-webhook - Should be lenient properties So you can pass in uri parameters to the target endpoint, as today it will validate its own configuration only."
CAMEL-13846,Make PropertyBindingSupport a fluent builder only,PropertyBindingSupport provides a number of flag to customize how properties should be bound to a target object and it is likely possible that in the future more flags are required so instead of adding yet another overloaded method for each flag we should turn PropertyBindingSupport intop a fluent builder,davsclaus,Improvement,Major,Resolved,Make PropertyBindingSupport a fluent builder only PropertyBindingSupport provides a number of flag to customize how properties should be bound to a target object and it is likely possible that in the future more flags are required so instead of adding yet another overloaded method for each flag we should turn PropertyBindingSupport intop a fluent builder
CAMEL-13845,camel-telegram - Do not show authorizationToken in uri,"We should hide this sensitive information, this requires to migrate it from uri path to uri parameter instead. ",davsclaus,Improvement,Major,Resolved,"camel-telegram - Do not show authorizationToken in uri We should hide this sensitive information, this requires to migrate it from uri path to uri parameter instead. "
CAMEL-13837,camel3 - FactoryFinder - Return null if not found instead of exception,"When starting Camel we attempt to find custom factories for SPI. But this means we end up throwing 40+ exceptions just for a basic Camel route. We can optimize this to use null as response for ""no factory exists"".",davsclaus,Improvement,Major,Resolved,"camel3 - FactoryFinder - Return null if not found instead of exception When starting Camel we attempt to find custom factories for SPI. But this means we end up throwing 40+ exceptions just for a basic Camel route. We can optimize this to use null as response for ""no factory exists""."
CAMEL-13832,Properties component - Check ENV before JVM System property,"We should favour using OS ENV properties over JVM system properties out of the box, for the same keys. This works the best with containers and cloud platforms.",davsclaus,Improvement,Major,Resolved,"Properties component - Check ENV before JVM System property We should favour using OS ENV properties over JVM system properties out of the box, for the same keys. This works the best with containers and cloud platforms."
CAMEL-13829,Deprecate transferExchange option,"Its a bad design to transfer Camel Exchange Java objects over the wire. Lets deprecate it in 2.x and remove in 3.0.

The camel-jms component has this option, and some of the http too, and others maybe.",davsclaus,Improvement,Major,Resolved,"Deprecate transferExchange option Its a bad design to transfer Camel Exchange Java objects over the wire. Lets deprecate it in 2.x and remove in 3.0.

The camel-jms component has this option, and some of the http too, and others maybe."
CAMEL-13828,DefaultExchangeHolder - Do not propgate exchange id,The exchange id should not be preserved as it should not mutate the existing ids,davsclaus,Improvement,Major,Resolved,DefaultExchangeHolder - Do not propgate exchange id The exchange id should not be preserved as it should not mutate the existing ids
CAMEL-13820,ResolveEndpointFailedException should mask sensitive information in uri,"Misconfiguration of routes throws ResolveEndpointFailedException.

This exception prints sensitive information like passwords which should be masked.",davsclaus,Improvement,Major,Resolved,"ResolveEndpointFailedException should mask sensitive information in uri Misconfiguration of routes throws ResolveEndpointFailedException.

This exception prints sensitive information like passwords which should be masked."
CAMEL-13810,camel3 - Always log ERROR if failed to start CamelContext,"As starting Camel mail fail then lets ensure we always get the exception logged as we rethrow it out of start of camel context, and it may be that some runtimes may not log this, so you can have harder time find out why it failed.

",davsclaus,Improvement,Major,Resolved,"camel3 - Always log ERROR if failed to start CamelContext As starting Camel mail fail then lets ensure we always get the exception logged as we rethrow it out of start of camel context, and it may be that some runtimes may not log this, so you can have harder time find out why it failed.

"
CAMEL-13799,camel-cdi: Remove support for multiple context via @ContextName (was: NPE with recent camel-cdi changes),"{code}
Exception 0 :
javax.enterprise.inject.InjectionException: Error adding routes of type [org.wildfly.camel.test.cdi.subA.RouteBuilderB] to Camel context [contextB]
	at org.apache.camel.cdi.CdiCamelExtension.addRouteToContext(CdiCamelExtension.java:467)
	at org.apache.camel.cdi.CdiCamelExtension.afterDeploymentValidation(CdiCamelExtension.java:410)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:498)
	at org.jboss.weld.injection.StaticMethodInjectionPoint.invoke(StaticMethodInjectionPoint.java:95)
	at org.jboss.weld.injection.MethodInvocationStrategy$SpecialParamPlusBeanManagerStrategy.invoke(MethodInvocationStrategy.java:187)
	at org.jboss.weld.event.ObserverMethodImpl.sendEvent(ObserverMethodImpl.java:330)
	at org.jboss.weld.event.ExtensionObserverMethodImpl.sendEvent(ExtensionObserverMethodImpl.java:123)
	at org.jboss.weld.event.ObserverMethodImpl.sendEvent(ObserverMethodImpl.java:308)
	at org.jboss.weld.event.ObserverMethodImpl.notify(ObserverMethodImpl.java:286)
	at javax.enterprise.inject.spi.ObserverMethod.notify(ObserverMethod.java:124)
	at org.jboss.weld.util.Observers.notify(Observers.java:166)
	at org.jboss.weld.event.ObserverNotifier.notifySyncObservers(ObserverNotifier.java:285)
	at org.jboss.weld.event.ObserverNotifier.notify(ObserverNotifier.java:273)
	at org.jboss.weld.event.ObserverNotifier.fireEvent(ObserverNotifier.java:177)
	at org.jboss.weld.event.ObserverNotifier.fireEvent(ObserverNotifier.java:171)
	at org.jboss.weld.bootstrap.events.AbstractContainerEvent.fire(AbstractContainerEvent.java:53)
	at org.jboss.weld.bootstrap.events.AbstractDeploymentContainerEvent.fire(AbstractDeploymentContainerEvent.java:35)
	at org.jboss.weld.bootstrap.events.AfterDeploymentValidationImpl.fire(AfterDeploymentValidationImpl.java:28)
	at org.jboss.weld.bootstrap.WeldStartup.validateBeans(WeldStartup.java:505)
	at org.jboss.weld.bootstrap.WeldBootstrap.validateBeans(WeldBootstrap.java:93)
	at org.jboss.as.weld.WeldStartService.start(WeldStartService.java:98)
	at org.jboss.msc.service.ServiceControllerImpl$StartTask.startService(ServiceControllerImpl.java:1737)
	at org.jboss.msc.service.ServiceControllerImpl$StartTask.execute(ServiceControllerImpl.java:1699)
	at org.jboss.msc.service.ServiceControllerImpl$ControllerTask.run(ServiceControllerImpl.java:1557)
	at org.jboss.threads.ContextClassLoaderSavingRunnable.run(ContextClassLoaderSavingRunnable.java:35)
	at org.jboss.threads.EnhancedQueueExecutor.safeRun(EnhancedQueueExecutor.java:1982)
	at org.jboss.threads.EnhancedQueueExecutor$ThreadBody.doRunTask(EnhancedQueueExecutor.java:1486)
	at org.jboss.threads.EnhancedQueueExecutor$ThreadBody.run(EnhancedQueueExecutor.java:1377)
	at java.lang.Thread.run(Thread.java:748)
Caused by: javax.enterprise.inject.InjectionException: Camel annotations post processing of [InjectionTarget for Managed Bean [class org.wildfly.camel.test.cdi.subA.RouteBuilderB] with qualifiers [@Any @ContextName]] failed!
	at org.apache.camel.cdi.CamelBeanInjectionTarget.inject(CamelBeanInjectionTarget.java:44)
	at org.jboss.weld.bean.ManagedBean.create(ManagedBean.java:161)
	at org.jboss.weld.contexts.unbound.DependentContextImpl.get(DependentContextImpl.java:70)
	at org.jboss.weld.bean.ContextualInstanceStrategy$DefaultContextualInstanceStrategy.get(ContextualInstanceStrategy.java:100)
	at org.jboss.weld.bean.ContextualInstance.get(ContextualInstance.java:50)
	at org.jboss.weld.manager.BeanManagerImpl.getReference(BeanManagerImpl.java:694)
	at org.jboss.weld.manager.BeanManagerImpl.getReference(BeanManagerImpl.java:717)
	at org.jboss.weld.util.ForwardingBeanManager.getReference(ForwardingBeanManager.java:64)
	at org.jboss.weld.bean.builtin.BeanManagerProxy.getReference(BeanManagerProxy.java:87)
	at org.apache.camel.cdi.BeanManagerHelper.getReference(BeanManagerHelper.java:53)
	at org.apache.camel.cdi.CdiCamelExtension.addRouteToContext(CdiCamelExtension.java:452)
	... 31 more
Caused by: java.lang.NullPointerException
	at org.apache.camel.support.CamelContextHelper.getEndpointInjection(CamelContextHelper.java:187)
	at org.apache.camel.impl.engine.CamelPostProcessorHelper.doGetEndpointInjection(CamelPostProcessorHelper.java:160)
	at org.apache.camel.impl.engine.CamelPostProcessorHelper.getEndpointInjection(CamelPostProcessorHelper.java:150)
	at org.apache.camel.impl.engine.CamelPostProcessorHelper.getInjectionValue(CamelPostProcessorHelper.java:228)
	at org.apache.camel.impl.engine.DefaultCamelBeanPostProcessor.injectField(DefaultCamelBeanPostProcessor.java:210)
	at org.apache.camel.impl.engine.DefaultCamelBeanPostProcessor.injectField(DefaultCamelBeanPostProcessor.java:204)
	at org.apache.camel.impl.engine.DefaultCamelBeanPostProcessor.lambda$injectFields$0(DefaultCamelBeanPostProcessor.java:181)
	at org.apache.camel.util.ReflectionHelper.doWithFields(ReflectionHelper.java:108)
	at org.apache.camel.impl.engine.DefaultCamelBeanPostProcessor.injectFields(DefaultCamelBeanPostProcessor.java:166)
	at org.apache.camel.impl.engine.DefaultCamelBeanPostProcessor.postProcessBeforeInitialization(DefaultCamelBeanPostProcessor.java:91)
	at org.apache.camel.cdi.CamelBeanInjectionTarget.inject(CamelBeanInjectionTarget.java:41)
	... 41 more
Exception 1 :
javax.enterprise.inject.InjectionException: Error adding routes of type [org.wildfly.camel.test.cdi.subA.RouteBuilderA] to Camel context [contextA]
	at org.apache.camel.cdi.CdiCamelExtension.addRouteToContext(CdiCamelExtension.java:467)
	at org.apache.camel.cdi.CdiCamelExtension.afterDeploymentValidation(CdiCamelExtension.java:410)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:498)
	at org.jboss.weld.injection.StaticMethodInjectionPoint.invoke(StaticMethodInjectionPoint.java:95)
	at org.jboss.weld.injection.MethodInvocationStrategy$SpecialParamPlusBeanManagerStrategy.invoke(MethodInvocationStrategy.java:187)
	at org.jboss.weld.event.ObserverMethodImpl.sendEvent(ObserverMethodImpl.java:330)
	at org.jboss.weld.event.ExtensionObserverMethodImpl.sendEvent(ExtensionObserverMethodImpl.java:123)
	at org.jboss.weld.event.ObserverMethodImpl.sendEvent(ObserverMethodImpl.java:308)
	at org.jboss.weld.event.ObserverMethodImpl.notify(ObserverMethodImpl.java:286)
	at javax.enterprise.inject.spi.ObserverMethod.notify(ObserverMethod.java:124)
	at org.jboss.weld.util.Observers.notify(Observers.java:166)
	at org.jboss.weld.event.ObserverNotifier.notifySyncObservers(ObserverNotifier.java:285)
	at org.jboss.weld.event.ObserverNotifier.notify(ObserverNotifier.java:273)
	at org.jboss.weld.event.ObserverNotifier.fireEvent(ObserverNotifier.java:177)
	at org.jboss.weld.event.ObserverNotifier.fireEvent(ObserverNotifier.java:171)
	at org.jboss.weld.bootstrap.events.AbstractContainerEvent.fire(AbstractContainerEvent.java:53)
	at org.jboss.weld.bootstrap.events.AbstractDeploymentContainerEvent.fire(AbstractDeploymentContainerEvent.java:35)
	at org.jboss.weld.bootstrap.events.AfterDeploymentValidationImpl.fire(AfterDeploymentValidationImpl.java:28)
	at org.jboss.weld.bootstrap.WeldStartup.validateBeans(WeldStartup.java:505)
	at org.jboss.weld.bootstrap.WeldBootstrap.validateBeans(WeldBootstrap.java:93)
	at org.jboss.as.weld.WeldStartService.start(WeldStartService.java:98)
	at org.jboss.msc.service.ServiceControllerImpl$StartTask.startService(ServiceControllerImpl.java:1737)
	at org.jboss.msc.service.ServiceControllerImpl$StartTask.execute(ServiceControllerImpl.java:1699)
	at org.jboss.msc.service.ServiceControllerImpl$ControllerTask.run(ServiceControllerImpl.java:1557)
	at org.jboss.threads.ContextClassLoaderSavingRunnable.run(ContextClassLoaderSavingRunnable.java:35)
	at org.jboss.threads.EnhancedQueueExecutor.safeRun(EnhancedQueueExecutor.java:1982)
	at org.jboss.threads.EnhancedQueueExecutor$ThreadBody.doRunTask(EnhancedQueueExecutor.java:1486)
	at org.jboss.threads.EnhancedQueueExecutor$ThreadBody.run(EnhancedQueueExecutor.java:1377)
	at java.lang.Thread.run(Thread.java:748)
Caused by: javax.enterprise.inject.InjectionException: Camel annotations post processing of [InjectionTarget for Managed Bean [class org.wildfly.camel.test.cdi.subA.RouteBuilderA] with qualifiers [@Any @ContextName]] failed!
	at org.apache.camel.cdi.CamelBeanInjectionTarget.inject(CamelBeanInjectionTarget.java:44)
	at org.jboss.weld.bean.ManagedBean.create(ManagedBean.java:161)
	at org.jboss.weld.contexts.unbound.DependentContextImpl.get(DependentContextImpl.java:70)
	at org.jboss.weld.bean.ContextualInstanceStrategy$DefaultContextualInstanceStrategy.get(ContextualInstanceStrategy.java:100)
	at org.jboss.weld.bean.ContextualInstance.get(ContextualInstance.java:50)
	at org.jboss.weld.manager.BeanManagerImpl.getReference(BeanManagerImpl.java:694)
	at org.jboss.weld.manager.BeanManagerImpl.getReference(BeanManagerImpl.java:717)
	at org.jboss.weld.util.ForwardingBeanManager.getReference(ForwardingBeanManager.java:64)
	at org.jboss.weld.bean.builtin.BeanManagerProxy.getReference(BeanManagerProxy.java:87)
	at org.apache.camel.cdi.BeanManagerHelper.getReference(BeanManagerHelper.java:53)
	at org.apache.camel.cdi.CdiCamelExtension.addRouteToContext(CdiCamelExtension.java:452)
	... 31 more
Caused by: java.lang.NullPointerException
	at org.apache.camel.support.CamelContextHelper.getEndpointInjection(CamelContextHelper.java:187)
	at org.apache.camel.impl.engine.CamelPostProcessorHelper.doGetEndpointInjection(CamelPostProcessorHelper.java:160)
	at org.apache.camel.impl.engine.CamelPostProcessorHelper.getEndpointInjection(CamelPostProcessorHelper.java:150)
	at org.apache.camel.impl.engine.CamelPostProcessorHelper.getInjectionValue(CamelPostProcessorHelper.java:228)
	at org.apache.camel.impl.engine.DefaultCamelBeanPostProcessor.injectField(DefaultCamelBeanPostProcessor.java:210)
	at org.apache.camel.impl.engine.DefaultCamelBeanPostProcessor.injectField(DefaultCamelBeanPostProcessor.java:204)
	at org.apache.camel.impl.engine.DefaultCamelBeanPostProcessor.lambda$injectFields$0(DefaultCamelBeanPostProcessor.java:181)
	at org.apache.camel.util.ReflectionHelper.doWithFields(ReflectionHelper.java:108)
	at org.apache.camel.impl.engine.DefaultCamelBeanPostProcessor.injectFields(DefaultCamelBeanPostProcessor.java:166)
	at org.apache.camel.impl.engine.DefaultCamelBeanPostProcessor.postProcessBeforeInitialization(DefaultCamelBeanPostProcessor.java:91)
	at org.apache.camel.cdi.CamelBeanInjectionTarget.inject(CamelBeanInjectionTarget.java:41)
	... 41 more
""}}}}
{code}

CrossRef: https://github.com/wildfly-extras/wildfly-camel/issues/2859",davsclaus,Improvement,Major,Resolved,"camel-cdi: Remove support for multiple context via @ContextName (was: NPE with recent camel-cdi changes) {code}
Exception 0 :
javax.enterprise.inject.InjectionException: Error adding routes of type [org.wildfly.camel.test.cdi.subA.RouteBuilderB] to Camel context [contextB]
	at org.apache.camel.cdi.CdiCamelExtension.addRouteToContext(CdiCamelExtension.java:467)
	at org.apache.camel.cdi.CdiCamelExtension.afterDeploymentValidation(CdiCamelExtension.java:410)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:498)
	at org.jboss.weld.injection.StaticMethodInjectionPoint.invoke(StaticMethodInjectionPoint.java:95)
	at org.jboss.weld.injection.MethodInvocationStrategy$SpecialParamPlusBeanManagerStrategy.invoke(MethodInvocationStrategy.java:187)
	at org.jboss.weld.event.ObserverMethodImpl.sendEvent(ObserverMethodImpl.java:330)
	at org.jboss.weld.event.ExtensionObserverMethodImpl.sendEvent(ExtensionObserverMethodImpl.java:123)
	at org.jboss.weld.event.ObserverMethodImpl.sendEvent(ObserverMethodImpl.java:308)
	at org.jboss.weld.event.ObserverMethodImpl.notify(ObserverMethodImpl.java:286)
	at javax.enterprise.inject.spi.ObserverMethod.notify(ObserverMethod.java:124)
	at org.jboss.weld.util.Observers.notify(Observers.java:166)
	at org.jboss.weld.event.ObserverNotifier.notifySyncObservers(ObserverNotifier.java:285)
	at org.jboss.weld.event.ObserverNotifier.notify(ObserverNotifier.java:273)
	at org.jboss.weld.event.ObserverNotifier.fireEvent(ObserverNotifier.java:177)
	at org.jboss.weld.event.ObserverNotifier.fireEvent(ObserverNotifier.java:171)
	at org.jboss.weld.bootstrap.events.AbstractContainerEvent.fire(AbstractContainerEvent.java:53)
	at org.jboss.weld.bootstrap.events.AbstractDeploymentContainerEvent.fire(AbstractDeploymentContainerEvent.java:35)
	at org.jboss.weld.bootstrap.events.AfterDeploymentValidationImpl.fire(AfterDeploymentValidationImpl.java:28)
	at org.jboss.weld.bootstrap.WeldStartup.validateBeans(WeldStartup.java:505)
	at org.jboss.weld.bootstrap.WeldBootstrap.validateBeans(WeldBootstrap.java:93)
	at org.jboss.as.weld.WeldStartService.start(WeldStartService.java:98)
	at org.jboss.msc.service.ServiceControllerImpl$StartTask.startService(ServiceControllerImpl.java:1737)
	at org.jboss.msc.service.ServiceControllerImpl$StartTask.execute(ServiceControllerImpl.java:1699)
	at org.jboss.msc.service.ServiceControllerImpl$ControllerTask.run(ServiceControllerImpl.java:1557)
	at org.jboss.threads.ContextClassLoaderSavingRunnable.run(ContextClassLoaderSavingRunnable.java:35)
	at org.jboss.threads.EnhancedQueueExecutor.safeRun(EnhancedQueueExecutor.java:1982)
	at org.jboss.threads.EnhancedQueueExecutor$ThreadBody.doRunTask(EnhancedQueueExecutor.java:1486)
	at org.jboss.threads.EnhancedQueueExecutor$ThreadBody.run(EnhancedQueueExecutor.java:1377)
	at java.lang.Thread.run(Thread.java:748)
Caused by: javax.enterprise.inject.InjectionException: Camel annotations post processing of [InjectionTarget for Managed Bean [class org.wildfly.camel.test.cdi.subA.RouteBuilderB] with qualifiers [@Any @ContextName]] failed!
	at org.apache.camel.cdi.CamelBeanInjectionTarget.inject(CamelBeanInjectionTarget.java:44)
	at org.jboss.weld.bean.ManagedBean.create(ManagedBean.java:161)
	at org.jboss.weld.contexts.unbound.DependentContextImpl.get(DependentContextImpl.java:70)
	at org.jboss.weld.bean.ContextualInstanceStrategy$DefaultContextualInstanceStrategy.get(ContextualInstanceStrategy.java:100)
	at org.jboss.weld.bean.ContextualInstance.get(ContextualInstance.java:50)
	at org.jboss.weld.manager.BeanManagerImpl.getReference(BeanManagerImpl.java:694)
	at org.jboss.weld.manager.BeanManagerImpl.getReference(BeanManagerImpl.java:717)
	at org.jboss.weld.util.ForwardingBeanManager.getReference(ForwardingBeanManager.java:64)
	at org.jboss.weld.bean.builtin.BeanManagerProxy.getReference(BeanManagerProxy.java:87)
	at org.apache.camel.cdi.BeanManagerHelper.getReference(BeanManagerHelper.java:53)
	at org.apache.camel.cdi.CdiCamelExtension.addRouteToContext(CdiCamelExtension.java:452)
	... 31 more
Caused by: java.lang.NullPointerException
	at org.apache.camel.support.CamelContextHelper.getEndpointInjection(CamelContextHelper.java:187)
	at org.apache.camel.impl.engine.CamelPostProcessorHelper.doGetEndpointInjection(CamelPostProcessorHelper.java:160)
	at org.apache.camel.impl.engine.CamelPostProcessorHelper.getEndpointInjection(CamelPostProcessorHelper.java:150)
	at org.apache.camel.impl.engine.CamelPostProcessorHelper.getInjectionValue(CamelPostProcessorHelper.java:228)
	at org.apache.camel.impl.engine.DefaultCamelBeanPostProcessor.injectField(DefaultCamelBeanPostProcessor.java:210)
	at org.apache.camel.impl.engine.DefaultCamelBeanPostProcessor.injectField(DefaultCamelBeanPostProcessor.java:204)
	at org.apache.camel.impl.engine.DefaultCamelBeanPostProcessor.lambda$injectFields$0(DefaultCamelBeanPostProcessor.java:181)
	at org.apache.camel.util.ReflectionHelper.doWithFields(ReflectionHelper.java:108)
	at org.apache.camel.impl.engine.DefaultCamelBeanPostProcessor.injectFields(DefaultCamelBeanPostProcessor.java:166)
	at org.apache.camel.impl.engine.DefaultCamelBeanPostProcessor.postProcessBeforeInitialization(DefaultCamelBeanPostProcessor.java:91)
	at org.apache.camel.cdi.CamelBeanInjectionTarget.inject(CamelBeanInjectionTarget.java:41)
	... 41 more
Exception 1 :
javax.enterprise.inject.InjectionException: Error adding routes of type [org.wildfly.camel.test.cdi.subA.RouteBuilderA] to Camel context [contextA]
	at org.apache.camel.cdi.CdiCamelExtension.addRouteToContext(CdiCamelExtension.java:467)
	at org.apache.camel.cdi.CdiCamelExtension.afterDeploymentValidation(CdiCamelExtension.java:410)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:498)
	at org.jboss.weld.injection.StaticMethodInjectionPoint.invoke(StaticMethodInjectionPoint.java:95)
	at org.jboss.weld.injection.MethodInvocationStrategy$SpecialParamPlusBeanManagerStrategy.invoke(MethodInvocationStrategy.java:187)
	at org.jboss.weld.event.ObserverMethodImpl.sendEvent(ObserverMethodImpl.java:330)
	at org.jboss.weld.event.ExtensionObserverMethodImpl.sendEvent(ExtensionObserverMethodImpl.java:123)
	at org.jboss.weld.event.ObserverMethodImpl.sendEvent(ObserverMethodImpl.java:308)
	at org.jboss.weld.event.ObserverMethodImpl.notify(ObserverMethodImpl.java:286)
	at javax.enterprise.inject.spi.ObserverMethod.notify(ObserverMethod.java:124)
	at org.jboss.weld.util.Observers.notify(Observers.java:166)
	at org.jboss.weld.event.ObserverNotifier.notifySyncObservers(ObserverNotifier.java:285)
	at org.jboss.weld.event.ObserverNotifier.notify(ObserverNotifier.java:273)
	at org.jboss.weld.event.ObserverNotifier.fireEvent(ObserverNotifier.java:177)
	at org.jboss.weld.event.ObserverNotifier.fireEvent(ObserverNotifier.java:171)
	at org.jboss.weld.bootstrap.events.AbstractContainerEvent.fire(AbstractContainerEvent.java:53)
	at org.jboss.weld.bootstrap.events.AbstractDeploymentContainerEvent.fire(AbstractDeploymentContainerEvent.java:35)
	at org.jboss.weld.bootstrap.events.AfterDeploymentValidationImpl.fire(AfterDeploymentValidationImpl.java:28)
	at org.jboss.weld.bootstrap.WeldStartup.validateBeans(WeldStartup.java:505)
	at org.jboss.weld.bootstrap.WeldBootstrap.validateBeans(WeldBootstrap.java:93)
	at org.jboss.as.weld.WeldStartService.start(WeldStartService.java:98)
	at org.jboss.msc.service.ServiceControllerImpl$StartTask.startService(ServiceControllerImpl.java:1737)
	at org.jboss.msc.service.ServiceControllerImpl$StartTask.execute(ServiceControllerImpl.java:1699)
	at org.jboss.msc.service.ServiceControllerImpl$ControllerTask.run(ServiceControllerImpl.java:1557)
	at org.jboss.threads.ContextClassLoaderSavingRunnable.run(ContextClassLoaderSavingRunnable.java:35)
	at org.jboss.threads.EnhancedQueueExecutor.safeRun(EnhancedQueueExecutor.java:1982)
	at org.jboss.threads.EnhancedQueueExecutor$ThreadBody.doRunTask(EnhancedQueueExecutor.java:1486)
	at org.jboss.threads.EnhancedQueueExecutor$ThreadBody.run(EnhancedQueueExecutor.java:1377)
	at java.lang.Thread.run(Thread.java:748)
Caused by: javax.enterprise.inject.InjectionException: Camel annotations post processing of [InjectionTarget for Managed Bean [class org.wildfly.camel.test.cdi.subA.RouteBuilderA] with qualifiers [@Any @ContextName]] failed!
	at org.apache.camel.cdi.CamelBeanInjectionTarget.inject(CamelBeanInjectionTarget.java:44)
	at org.jboss.weld.bean.ManagedBean.create(ManagedBean.java:161)
	at org.jboss.weld.contexts.unbound.DependentContextImpl.get(DependentContextImpl.java:70)
	at org.jboss.weld.bean.ContextualInstanceStrategy$DefaultContextualInstanceStrategy.get(ContextualInstanceStrategy.java:100)
	at org.jboss.weld.bean.ContextualInstance.get(ContextualInstance.java:50)
	at org.jboss.weld.manager.BeanManagerImpl.getReference(BeanManagerImpl.java:694)
	at org.jboss.weld.manager.BeanManagerImpl.getReference(BeanManagerImpl.java:717)
	at org.jboss.weld.util.ForwardingBeanManager.getReference(ForwardingBeanManager.java:64)
	at org.jboss.weld.bean.builtin.BeanManagerProxy.getReference(BeanManagerProxy.java:87)
	at org.apache.camel.cdi.BeanManagerHelper.getReference(BeanManagerHelper.java:53)
	at org.apache.camel.cdi.CdiCamelExtension.addRouteToContext(CdiCamelExtension.java:452)
	... 31 more
Caused by: java.lang.NullPointerException
	at org.apache.camel.support.CamelContextHelper.getEndpointInjection(CamelContextHelper.java:187)
	at org.apache.camel.impl.engine.CamelPostProcessorHelper.doGetEndpointInjection(CamelPostProcessorHelper.java:160)
	at org.apache.camel.impl.engine.CamelPostProcessorHelper.getEndpointInjection(CamelPostProcessorHelper.java:150)
	at org.apache.camel.impl.engine.CamelPostProcessorHelper.getInjectionValue(CamelPostProcessorHelper.java:228)
	at org.apache.camel.impl.engine.DefaultCamelBeanPostProcessor.injectField(DefaultCamelBeanPostProcessor.java:210)
	at org.apache.camel.impl.engine.DefaultCamelBeanPostProcessor.injectField(DefaultCamelBeanPostProcessor.java:204)
	at org.apache.camel.impl.engine.DefaultCamelBeanPostProcessor.lambda$injectFields$0(DefaultCamelBeanPostProcessor.java:181)
	at org.apache.camel.util.ReflectionHelper.doWithFields(ReflectionHelper.java:108)
	at org.apache.camel.impl.engine.DefaultCamelBeanPostProcessor.injectFields(DefaultCamelBeanPostProcessor.java:166)
	at org.apache.camel.impl.engine.DefaultCamelBeanPostProcessor.postProcessBeforeInitialization(DefaultCamelBeanPostProcessor.java:91)
	at org.apache.camel.cdi.CamelBeanInjectionTarget.inject(CamelBeanInjectionTarget.java:41)
	... 41 more
""}}}}
{code}

CrossRef: https://github.com/wildfly-extras/wildfly-camel/issues/2859"
CAMEL-13797,Move @InvokeOnHeader/@InvokeOnHeaders to org.apache.camel.spi package,"Contributions is welcome, there is a number of components that are using these annotations which needs to be updated too",davsclaus,Improvement,Major,Resolved,"Move @InvokeOnHeader/@InvokeOnHeaders to org.apache.camel.spi package Contributions is welcome, there is a number of components that are using these annotations which needs to be updated too"
CAMEL-13796,Salesforce Component IDLE_TIMEOUT Blocks Async Request Responses,"Bulk, Composite Batch, etc. all throw an exception when trying to return on more than a few records due to [static final IDLE_TIMEOUT|https://github.com/apache/camel/blob/master/components/camel-salesforce/camel-salesforce-component/src/main/java/org/apache/camel/component/salesforce/SalesforceComponent.java#L80] on the instantiated salesforce component httpClient:

 

Caused by: org.apache.camel.component.salesforce.api.SalesforceException: Unexpected error \{0:null} executing \{POST:https://genericSFDCInstance.salesforce.com/services/data/v38.0/composite/batch}
        at org.apache.camel.component.salesforce.internal.client.AbstractClientBase$1.onComplete(AbstractClientBase.java:199) ~[camel-salesforce-2.23.0.jar:2.23.0]
        at org.eclipse.jetty.client.ResponseNotifier.notifyComplete(ResponseNotifier.java:202) ~[jetty-client-9.4.12.v20180830.jar:9.4.12.v20180830]
        at org.eclipse.jetty.client.ResponseNotifier.notifyComplete(ResponseNotifier.java:194) ~[jetty-client-9.4.12.v20180830.jar:9.4.12.v20180830]
        at org.eclipse.jetty.client.HttpReceiver.terminateResponse(HttpReceiver.java:470) ~[jetty-client-9.4.12.v20180830.jar:9.4.12.v20180830]
        at org.eclipse.jetty.client.HttpReceiver.abort(HttpReceiver.java:552) ~[jetty-client-9.4.12.v20180830.jar:9.4.12.v20180830]
        at org.eclipse.jetty.client.HttpChannel.abortResponse(HttpChannel.java:156) ~[jetty-client-9.4.12.v20180830.jar:9.4.12.v20180830]
        at org.eclipse.jetty.client.HttpChannel.abort(HttpChannel.java:149) ~[jetty-client-9.4.12.v20180830.jar:9.4.12.v20180830]
        at org.eclipse.jetty.client.HttpExchange.abort(HttpExchange.java:257) ~[jetty-client-9.4.12.v20180830.jar:9.4.12.v20180830]
        at org.eclipse.jetty.client.HttpConversation.abort(HttpConversation.java:141) ~[jetty-client-9.4.12.v20180830.jar:9.4.12.v20180830]
        at org.eclipse.jetty.client.HttpRequest.abort(HttpRequest.java:767) ~[jetty-client-9.4.12.v20180830.jar:9.4.12.v20180830]
        at org.eclipse.jetty.client.http.HttpConnectionOverHTTP.abort(HttpConnectionOverHTTP.java:204) ~[jetty-client-9.4.12.v20180830.jar:9.4.12.v20180830]
        at org.eclipse.jetty.client.http.HttpConnectionOverHTTP.close(HttpConnectionOverHTTP.java:190) ~[jetty-client-9.4.12.v20180830.jar:9.4.12.v20180830]
        at org.eclipse.jetty.client.http.HttpConnectionOverHTTP.onIdleExpired(HttpConnectionOverHTTP.java:145) ~[jetty-client-9.4.12.v20180830.jar:9.4.12.v20180830]
        at org.eclipse.jetty.io.ssl.SslConnection.onIdleExpired(SslConnection.java:286) ~[jetty-io-9.4.12.v20180830.jar:9.4.12.v20180830]
        at org.eclipse.jetty.io.AbstractEndPoint.onIdleExpired(AbstractEndPoint.java:401) ~[jetty-io-9.4.12.v20180830.jar:9.4.12.v20180830]
        at org.eclipse.jetty.io.IdleTimeout.checkIdleTimeout(IdleTimeout.java:166) ~[jetty-io-9.4.12.v20180830.jar:9.4.12.v20180830]
        at org.eclipse.jetty.io.IdleTimeout$1.run(IdleTimeout.java:50) ~[jetty-io-9.4.12.v20180830.jar:9.4.12.v20180830]
        at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511) ~[?:1.8.0_201]
        at java.util.concurrent.FutureTask.run(FutureTask.java:266) ~[?:1.8.0_201]
        at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.access$201(ScheduledThreadPoolExecutor.java:180) ~[?:1.8.0_201]
        at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:293) ~[?:1.8.0_201]
        at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149) ~[?:1.8.0_201]
        at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624) ~[?:1.8.0_201]
        ... 1 more


*Caused by: java.util.concurrent.TimeoutException: Idle timeout 5000 ms*
        at org.eclipse.jetty.client.http.HttpConnectionOverHTTP.onIdleExpired(HttpConnectionOverHTTP.java:145) ~[jetty-client-9.4.12.v20180830.jar:9.4.12.v20180830]
        at org.eclipse.jetty.io.ssl.SslConnection.onIdleExpired(SslConnection.java:286) ~[jetty-io-9.4.12.v20180830.jar:9.4.12.v20180830]
        at org.eclipse.jetty.io.AbstractEndPoint.onIdleExpired(AbstractEndPoint.java:401) ~[jetty-io-9.4.12.v20180830.jar:9.4.12.v20180830]
        at org.eclipse.jetty.io.IdleTimeout.checkIdleTimeout(IdleTimeout.java:166) ~[jetty-io-9.4.12.v20180830.jar:9.4.12.v20180830]
        at org.eclipse.jetty.io.IdleTimeout$1.run(IdleTimeout.java:50) ~[jetty-io-9.4.12.v20180830.jar:9.4.12.v20180830]
        at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511) ~[?:1.8.0_201]
        at java.util.concurrent.FutureTask.run(FutureTask.java:266) ~[?:1.8.0_201]
        at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.access$201(ScheduledThreadPoolExecutor.java:180) ~[?:1.8.0_201]
        at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:293) ~[?:1.8.0_201]
        at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149) ~[?:1.8.0_201]
        at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624) ~[?:1.8.0_201]
        ... 1 more

 

Note that as IDLE_TIMEOUT is static, it cannot be set via Spring, and the httpClientProperties map is [never used to set any timeouts|https://github.com/apache/camel/blob/master/components/camel-salesforce/camel-salesforce-component/src/main/java/org/apache/camel/component/salesforce/SalesforceComponent.java#L714], instead opting to take the [hardcoded defaults|https://github.com/apache/camel/blob/master/components/camel-salesforce/camel-salesforce-component/src/main/java/org/apache/camel/component/salesforce/SalesforceComponent.java#L707].

 ",davsclaus,Bug,Minor,Closed,"Salesforce Component IDLE_TIMEOUT Blocks Async Request Responses Bulk, Composite Batch, etc. all throw an exception when trying to return on more than a few records due to [static final IDLE_TIMEOUT|https://github.com/apache/camel/blob/master/components/camel-salesforce/camel-salesforce-component/src/main/java/org/apache/camel/component/salesforce/SalesforceComponent.java#L80] on the instantiated salesforce component httpClient:

 

Caused by: org.apache.camel.component.salesforce.api.SalesforceException: Unexpected error \{0:null} executing \{POST:https://genericSFDCInstance.salesforce.com/services/data/v38.0/composite/batch}
        at org.apache.camel.component.salesforce.internal.client.AbstractClientBase$1.onComplete(AbstractClientBase.java:199) ~[camel-salesforce-2.23.0.jar:2.23.0]
        at org.eclipse.jetty.client.ResponseNotifier.notifyComplete(ResponseNotifier.java:202) ~[jetty-client-9.4.12.v20180830.jar:9.4.12.v20180830]
        at org.eclipse.jetty.client.ResponseNotifier.notifyComplete(ResponseNotifier.java:194) ~[jetty-client-9.4.12.v20180830.jar:9.4.12.v20180830]
        at org.eclipse.jetty.client.HttpReceiver.terminateResponse(HttpReceiver.java:470) ~[jetty-client-9.4.12.v20180830.jar:9.4.12.v20180830]
        at org.eclipse.jetty.client.HttpReceiver.abort(HttpReceiver.java:552) ~[jetty-client-9.4.12.v20180830.jar:9.4.12.v20180830]
        at org.eclipse.jetty.client.HttpChannel.abortResponse(HttpChannel.java:156) ~[jetty-client-9.4.12.v20180830.jar:9.4.12.v20180830]
        at org.eclipse.jetty.client.HttpChannel.abort(HttpChannel.java:149) ~[jetty-client-9.4.12.v20180830.jar:9.4.12.v20180830]
        at org.eclipse.jetty.client.HttpExchange.abort(HttpExchange.java:257) ~[jetty-client-9.4.12.v20180830.jar:9.4.12.v20180830]
        at org.eclipse.jetty.client.HttpConversation.abort(HttpConversation.java:141) ~[jetty-client-9.4.12.v20180830.jar:9.4.12.v20180830]
        at org.eclipse.jetty.client.HttpRequest.abort(HttpRequest.java:767) ~[jetty-client-9.4.12.v20180830.jar:9.4.12.v20180830]
        at org.eclipse.jetty.client.http.HttpConnectionOverHTTP.abort(HttpConnectionOverHTTP.java:204) ~[jetty-client-9.4.12.v20180830.jar:9.4.12.v20180830]
        at org.eclipse.jetty.client.http.HttpConnectionOverHTTP.close(HttpConnectionOverHTTP.java:190) ~[jetty-client-9.4.12.v20180830.jar:9.4.12.v20180830]
        at org.eclipse.jetty.client.http.HttpConnectionOverHTTP.onIdleExpired(HttpConnectionOverHTTP.java:145) ~[jetty-client-9.4.12.v20180830.jar:9.4.12.v20180830]
        at org.eclipse.jetty.io.ssl.SslConnection.onIdleExpired(SslConnection.java:286) ~[jetty-io-9.4.12.v20180830.jar:9.4.12.v20180830]
        at org.eclipse.jetty.io.AbstractEndPoint.onIdleExpired(AbstractEndPoint.java:401) ~[jetty-io-9.4.12.v20180830.jar:9.4.12.v20180830]
        at org.eclipse.jetty.io.IdleTimeout.checkIdleTimeout(IdleTimeout.java:166) ~[jetty-io-9.4.12.v20180830.jar:9.4.12.v20180830]
        at org.eclipse.jetty.io.IdleTimeout$1.run(IdleTimeout.java:50) ~[jetty-io-9.4.12.v20180830.jar:9.4.12.v20180830]
        at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511) ~[?:1.8.0_201]
        at java.util.concurrent.FutureTask.run(FutureTask.java:266) ~[?:1.8.0_201]
        at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.access$201(ScheduledThreadPoolExecutor.java:180) ~[?:1.8.0_201]
        at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:293) ~[?:1.8.0_201]
        at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149) ~[?:1.8.0_201]
        at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624) ~[?:1.8.0_201]
        ... 1 more


*Caused by: java.util.concurrent.TimeoutException: Idle timeout 5000 ms*
        at org.eclipse.jetty.client.http.HttpConnectionOverHTTP.onIdleExpired(HttpConnectionOverHTTP.java:145) ~[jetty-client-9.4.12.v20180830.jar:9.4.12.v20180830]
        at org.eclipse.jetty.io.ssl.SslConnection.onIdleExpired(SslConnection.java:286) ~[jetty-io-9.4.12.v20180830.jar:9.4.12.v20180830]
        at org.eclipse.jetty.io.AbstractEndPoint.onIdleExpired(AbstractEndPoint.java:401) ~[jetty-io-9.4.12.v20180830.jar:9.4.12.v20180830]
        at org.eclipse.jetty.io.IdleTimeout.checkIdleTimeout(IdleTimeout.java:166) ~[jetty-io-9.4.12.v20180830.jar:9.4.12.v20180830]
        at org.eclipse.jetty.io.IdleTimeout$1.run(IdleTimeout.java:50) ~[jetty-io-9.4.12.v20180830.jar:9.4.12.v20180830]
        at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511) ~[?:1.8.0_201]
        at java.util.concurrent.FutureTask.run(FutureTask.java:266) ~[?:1.8.0_201]
        at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.access$201(ScheduledThreadPoolExecutor.java:180) ~[?:1.8.0_201]
        at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:293) ~[?:1.8.0_201]
        at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149) ~[?:1.8.0_201]
        at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624) ~[?:1.8.0_201]
        ... 1 more

 

Note that as IDLE_TIMEOUT is static, it cannot be set via Spring, and the httpClientProperties map is [never used to set any timeouts|https://github.com/apache/camel/blob/master/components/camel-salesforce/camel-salesforce-component/src/main/java/org/apache/camel/component/salesforce/SalesforceComponent.java#L714], instead opting to take the [hardcoded defaults|https://github.com/apache/camel/blob/master/components/camel-salesforce/camel-salesforce-component/src/main/java/org/apache/camel/component/salesforce/SalesforceComponent.java#L707].

 "
CAMEL-13795,TokenXMLExpressionIterator with inheritNamespaceToken creates duplicate default namespace definition," If a sub-item also contains the default namespace definition the splitter will duplicate it.

 
{code:java|title=route definition}
from(""file:target/pair?initialDelay=0&delay=10"")
                    // split the order child tags, and inherit namespaces from the orders root tag
                    .split().tokenizeXML(""order"", ""orders"")
                        .to(""mock:split"");
{code}
 

 
{code:xml|title=input}
<orders xmlns=""http:acme.com""> 
 <order xmlns=""http:acme.com"" id=""1"">Camel in Action</order>
 <order id=""2"">ActiveMQ in Action</order>
 <order id=""3"">DSL in Action</order>
</orders>""
{code}
{code:xml|title=output[1]}
<order xmlns=""http:acme.com"" id=""1"" xmlns=""http:acme.com"">Camel in Action</order>
{code}
{code:xml|title=expected[1]}
 <order xmlns=""http:acme.com"" id=""1"">Camel in Action</order>
{code}",davsclaus,Bug,Minor,Resolved,"TokenXMLExpressionIterator with inheritNamespaceToken creates duplicate default namespace definition  If a sub-item also contains the default namespace definition the splitter will duplicate it.

 
{code:java|title=route definition}
from(""file:target/pair?initialDelay=0&delay=10"")
                    // split the order child tags, and inherit namespaces from the orders root tag
                    .split().tokenizeXML(""order"", ""orders"")
                        .to(""mock:split"");
{code}
 

 
{code:xml|title=input}
<orders xmlns=""http:acme.com""> 
 <order xmlns=""http:acme.com"" id=""1"">Camel in Action</order>
 <order id=""2"">ActiveMQ in Action</order>
 <order id=""3"">DSL in Action</order>
</orders>""
{code}
{code:xml|title=output[1]}
<order xmlns=""http:acme.com"" id=""1"" xmlns=""http:acme.com"">Camel in Action</order>
{code}
{code:xml|title=expected[1]}
 <order xmlns=""http:acme.com"" id=""1"">Camel in Action</order>
{code}"
CAMEL-13793,camel3 - Camel annotations with context ids should be deprecated,"We do not recommend having 2+ camel contexts per application / deployment unit. So we should deprecate these on these annotations as they should be for the current context only.

",davsclaus,Improvement,Major,Resolved,"camel3 - Camel annotations with context ids should be deprecated We do not recommend having 2+ camel contexts per application / deployment unit. So we should deprecate these on these annotations as they should be for the current context only.

"
CAMEL-13788,camel3 - Message API - Deprecate OUT,http://mail-archives.apache.org/mod_mbox/camel-dev/201907.mbox/%3CCAGB5yNkyx9LYk40UwGQdq_%2BiZH%3DOrqOifnqp%2BNL7vmv2TSJvnw%40mail.gmail.com%3E,davsclaus,Improvement,Major,Resolved,camel3 - Message API - Deprecate OUT http://mail-archives.apache.org/mod_mbox/camel-dev/201907.mbox/%3CCAGB5yNkyx9LYk40UwGQdq_%2BiZH%3DOrqOifnqp%2BNL7vmv2TSJvnw%40mail.gmail.com%3E
CAMEL-13783,Fix the camel-archetype-component to inherit from DefaultConsumer instead of ScheduledPollConsumer,"Currently the {{[camel-archetype-component|https://github.com/apache/camel/blob/master/archetypes/camel-archetype-component/src/main/resources/archetype-resources/src/main/java/__name__Consumer.java#L28]}} inherits from {{ScheduledPollConsumer}}, since this consumer is less used, it will make sense to change the consumer to {{DefaultConsumer}} instead. ",davsclaus,Bug,Minor,Resolved,"Fix the camel-archetype-component to inherit from DefaultConsumer instead of ScheduledPollConsumer Currently the {{[camel-archetype-component|https://github.com/apache/camel/blob/master/archetypes/camel-archetype-component/src/main/resources/archetype-resources/src/main/java/__name__Consumer.java#L28]}} inherits from {{ScheduledPollConsumer}}, since this consumer is less used, it will make sense to change the consumer to {{DefaultConsumer}} instead. "
CAMEL-13774,camel-zipfile - Accept an iterator as body for zip,"Accept iterator or Java 8 Stream as body to produce a zip file this will avoid to use the memory for big file (for some use case we can't get an inputStream)

For example it would be very nice to be able to do this:


{code:java}
from(""timer:foo?repeatCount=1"")
                .setBody(constant(Stream.of(""v1"", ""v2"")))
                .setHeader(Exchange.FILE_NAME, constant(""report.txt""))
                .marshal().zipFile()
                .to(""file:output/directory"");
{code}

(https://stackoverflow.com/questions/50295432/zip-and-unzip-a-large-file-without-loading-the-entire-file-in-memory-in-apache-c)
",davsclaus,Improvement,Major,Resolved,"camel-zipfile - Accept an iterator as body for zip Accept iterator or Java 8 Stream as body to produce a zip file this will avoid to use the memory for big file (for some use case we can't get an inputStream)

For example it would be very nice to be able to do this:


{code:java}
from(""timer:foo?repeatCount=1"")
                .setBody(constant(Stream.of(""v1"", ""v2"")))
                .setHeader(Exchange.FILE_NAME, constant(""report.txt""))
                .marshal().zipFile()
                .to(""file:output/directory"");
{code}

(https://stackoverflow.com/questions/50295432/zip-and-unzip-a-large-file-without-loading-the-entire-file-in-memory-in-apache-c)
"
CAMEL-13770,Properties of class Map does not work with Spring Boot 2.x,"From version 2.22.0 onwards spring-boot version is upgraded to 2.x
After that all Map properties are not working

For example in application.properties
camel.component.salesforce.http-client-properties is treated as string instead of Map and whatever value we provide to it, the Map is initialize as null

",davsclaus,Bug,Major,Resolved,"Properties of class Map does not work with Spring Boot 2.x From version 2.22.0 onwards spring-boot version is upgraded to 2.x
After that all Map properties are not working

For example in application.properties
camel.component.salesforce.http-client-properties is treated as string instead of Map and whatever value we provide to it, the Map is initialize as null

"
CAMEL-13763,elasticsearch-rest producer closes connection when route is reloaded from xml and stays closed,"When setting camel.springboot.xmlRoutesReloadDirectory, any route using the Elasticsearch rest producer will cause a shutdown of the http client. When reloading a route, the route will be stopped and client.close() is being called on RestClient. The shared http client will not be able to handle new requets because the reactor status is STOPPED.",davsclaus,Improvement,Critical,Resolved,"elasticsearch-rest producer closes connection when route is reloaded from xml and stays closed When setting camel.springboot.xmlRoutesReloadDirectory, any route using the Elasticsearch rest producer will cause a shutdown of the http client. When reloading a route, the route will be stopped and client.close() is being called on RestClient. The shared http client will not be able to handle new requets because the reactor status is STOPPED."
CAMEL-13761,"StartupListener runs before routes are started, contrary to Javadoc","The Javadoc ([https://static.javadoc.io/org.apache.camel/camel-core/2.23.3/org/apache/camel/StartupListener.html]) for StartupListener is misleading (italics for emphasis):
{quote}This can be used to perform any custom work when the entire [{{CamelContext}}|https://static.javadoc.io/org.apache.camel/camel-core/2.23.3/org/apache/camel/CamelContext.html] has been initialized and *almost* started. _For example this ensures that all Camel routes have been started and are up and running, before this callback is invoked._
{quote}
However, routes are not started within the callback. The following code, for example, 
{code:java}
DefaultCamelContext context = new DefaultCamelContext();

context.addStartupListener((c, alreadyStarted) -> {
    c.createProducerTemplate().sendBody(""direct:doesNotExistYet"", new Object());
});

context.addRoutes(new RouteBuilder() {
    @Override
    public void configure() {
        from(""direct:doesNotExistYet"").bean((Consumer<Object>) System.out::println);
    }
});
context.start();{code}

fails with
{code}
Caused by: org.apache.camel.component.direct.DirectConsumerNotAvailableException: No consumers available on endpoint: direct://doesNotExistYet. Exchange[ID-x-1563396556957-0-1]
	at org.apache.camel.component.direct.DirectProducer.process(DirectProducer.java:69)
	at org.apache.camel.processor.SharedCamelInternalProcessor.process(SharedCamelInternalProcessor.java:186)
	at org.apache.camel.processor.SharedCamelInternalProcessor.process(SharedCamelInternalProcessor.java:86)
	at org.apache.camel.impl.ProducerCache$1.doInProducer(ProducerCache.java:541)
	at org.apache.camel.impl.ProducerCache$1.doInProducer(ProducerCache.java:506)
	at org.apache.camel.impl.ProducerCache.doInProducer(ProducerCache.java:369)
	at org.apache.camel.impl.ProducerCache.sendExchange(ProducerCache.java:506)
	at org.apache.camel.impl.ProducerCache.send(ProducerCache.java:229)
	at org.apache.camel.impl.DefaultProducerTemplate.send(DefaultProducerTemplate.java:144)
	at org.apache.camel.impl.DefaultProducerTemplate.sendBody(DefaultProducerTemplate.java:161)
	... 12 more
{code}

I am aware that using ExtendedStartupListener or an EventNotifier makes this work, but it would be great if the Javadoc was updated (assuming this is intended behavior, I am not sure).",davsclaus,Improvement,Trivial,Resolved,"StartupListener runs before routes are started, contrary to Javadoc The Javadoc ([https://static.javadoc.io/org.apache.camel/camel-core/2.23.3/org/apache/camel/StartupListener.html]) for StartupListener is misleading (italics for emphasis):
{quote}This can be used to perform any custom work when the entire [{{CamelContext}}|https://static.javadoc.io/org.apache.camel/camel-core/2.23.3/org/apache/camel/CamelContext.html] has been initialized and *almost* started. _For example this ensures that all Camel routes have been started and are up and running, before this callback is invoked._
{quote}
However, routes are not started within the callback. The following code, for example, 
{code:java}
DefaultCamelContext context = new DefaultCamelContext();

context.addStartupListener((c, alreadyStarted) -> {
    c.createProducerTemplate().sendBody(""direct:doesNotExistYet"", new Object());
});

context.addRoutes(new RouteBuilder() {
    @Override
    public void configure() {
        from(""direct:doesNotExistYet"").bean((Consumer<Object>) System.out::println);
    }
});
context.start();{code}

fails with
{code}
Caused by: org.apache.camel.component.direct.DirectConsumerNotAvailableException: No consumers available on endpoint: direct://doesNotExistYet. Exchange[ID-x-1563396556957-0-1]
	at org.apache.camel.component.direct.DirectProducer.process(DirectProducer.java:69)
	at org.apache.camel.processor.SharedCamelInternalProcessor.process(SharedCamelInternalProcessor.java:186)
	at org.apache.camel.processor.SharedCamelInternalProcessor.process(SharedCamelInternalProcessor.java:86)
	at org.apache.camel.impl.ProducerCache$1.doInProducer(ProducerCache.java:541)
	at org.apache.camel.impl.ProducerCache$1.doInProducer(ProducerCache.java:506)
	at org.apache.camel.impl.ProducerCache.doInProducer(ProducerCache.java:369)
	at org.apache.camel.impl.ProducerCache.sendExchange(ProducerCache.java:506)
	at org.apache.camel.impl.ProducerCache.send(ProducerCache.java:229)
	at org.apache.camel.impl.DefaultProducerTemplate.send(DefaultProducerTemplate.java:144)
	at org.apache.camel.impl.DefaultProducerTemplate.sendBody(DefaultProducerTemplate.java:161)
	... 12 more
{code}

I am aware that using ExtendedStartupListener or an EventNotifier makes this work, but it would be great if the Javadoc was updated (assuming this is intended behavior, I am not sure)."
CAMEL-13760,camel3 - Property placeholder - Deprecate changing prefix/suffix tokens,This causes some issues and its better we stick to one model the default of using {{ }} which is the Camel style.,davsclaus,Improvement,Major,Resolved,camel3 - Property placeholder - Deprecate changing prefix/suffix tokens This causes some issues and its better we stick to one model the default of using {{ }} which is the Camel style.
CAMEL-13759,camel3 - Remove poor mans debugger,"We have an old debugger implementation that just have callbacks before|after a processor in the routes which you can then from camel-test override the before/after methods to have debugging in the editor.

We should remove this as its using the intercept strategy which is intended not to be so much in use. So lets cleanup a bit of cruft. There is already the newer backlog debugger that hawtio and other tools uses for debugging.",davsclaus,Improvement,Major,Resolved,"camel3 - Remove poor mans debugger We have an old debugger implementation that just have callbacks before|after a processor in the routes which you can then from camel-test override the before/after methods to have debugging in the editor.

We should remove this as its using the intercept strategy which is intended not to be so much in use. So lets cleanup a bit of cruft. There is already the newer backlog debugger that hawtio and other tools uses for debugging."
CAMEL-13758,"Unable to parse $simple{}, when you have prefixToken=""${"" suffixToken=""}"" in the propertyPlaceholder","Unable to parse $simple{}, when you have prefixToken={color:#14892c}""$\{""{color} suffixToken={color:#14892c}""}{color}"" in the propertyPlaceholder.

For example -

{{<camelContext xmlns=""http://camel.apache.org/schema/spring""> <propertyPlaceholder id=""ignoreId"" location=""classpath:props.properties"" prefixToken=""${"" suffixToken=""}""/> <route id=""sendNotification""> <from uri=""jms:queue:queue.sendNotification""/> <to uri=""file:${OnDemand.output.url}?fileName=L2W.$simple\{in.header.accountNum}-${date:now:yyyyMMddHHmmssSSS}.csv""/> </route> </camelContext>}}

 

In the above route ${OnDemand.output.url} {color:#333333}is a Spring property placeholders and $simple\{in.header.accountNum}{color} is a camel property placeholder.

{{{color:#205081}Note:- This route configuration used to work till Camel 2.12{color}}}

{{According to [https://github.com/apache/camel/blob/master/docs/user-manual/modules/ROOT/pages/using-propertyplaceholder.adoc]- one should be able to refer to Camel's properties using $simple\{...} like this:}}

 

{{<setHeader headerName=""Exchange.FILE_NAME""> <simple>{{file.rootdir}}{{/$simple\{in.header.CamelFileName}</simple </setHeader>}}

 

{{Replication - camel-test.zip attached. Main class - CamelHelloWorldSpringExample.java}}",davsclaus,Bug,Minor,Resolved,"Unable to parse $simple{}, when you have prefixToken=""${"" suffixToken=""}"" in the propertyPlaceholder Unable to parse $simple{}, when you have prefixToken={color:#14892c}""$\{""{color} suffixToken={color:#14892c}""}{color}"" in the propertyPlaceholder.

For example -

{{<camelContext xmlns=""http://camel.apache.org/schema/spring""> <propertyPlaceholder id=""ignoreId"" location=""classpath:props.properties"" prefixToken=""${"" suffixToken=""}""/> <route id=""sendNotification""> <from uri=""jms:queue:queue.sendNotification""/> <to uri=""file:${OnDemand.output.url}?fileName=L2W.$simple\{in.header.accountNum}-${date:now:yyyyMMddHHmmssSSS}.csv""/> </route> </camelContext>}}

 

In the above route ${OnDemand.output.url} {color:#333333}is a Spring property placeholders and $simple\{in.header.accountNum}{color} is a camel property placeholder.

{{{color:#205081}Note:- This route configuration used to work till Camel 2.12{color}}}

{{According to [https://github.com/apache/camel/blob/master/docs/user-manual/modules/ROOT/pages/using-propertyplaceholder.adoc]- one should be able to refer to Camel's properties using $simple\{...} like this:}}

 

{{<setHeader headerName=""Exchange.FILE_NAME""> <simple>{{file.rootdir}}{{/$simple\{in.header.CamelFileName}</simple </setHeader>}}

 

{{Replication - camel-test.zip attached. Main class - CamelHelloWorldSpringExample.java}}"
CAMEL-13740,Document for XStream JSON not proper,"The document of Json Xtream [https://github.com/apache/camel/blob/master/components/camel-xstream/src/main/docs/json-xstream-dataformat.adoc] is exactly identical to Xstream [https://github.com/apache/camel/blob/master/components/camel-xstream/src/main/docs/xstream-dataformat.adoc.]

 

Although both uses same component, but JSON xtream document should have document on how to convert JSON to object and vis versa. But it also talks about XML. This needs to be improved.",davsclaus,Improvement,Minor,Resolved,"Document for XStream JSON not proper The document of Json Xtream [https://github.com/apache/camel/blob/master/components/camel-xstream/src/main/docs/json-xstream-dataformat.adoc] is exactly identical to Xstream [https://github.com/apache/camel/blob/master/components/camel-xstream/src/main/docs/xstream-dataformat.adoc.]

 

Although both uses same component, but JSON xtream document should have document on how to convert JSON to object and vis versa. But it also talks about XML. This needs to be improved."
CAMEL-13738,parent/pom.xml - use dash in version properties,"We should only use dashes in the names, eg 

        <javax.el-api-version>2.2.5</javax.el-api-version>
        <javax.el-version>2.2.5</javax.el-version>
        <javax.el3-version>3.0.0</javax.el3-version>
        <javax.el-api-hibernate-validator-version>3.0.1-b04</javax.el-api-hibernate-validator-version>
        <javax.el-hibernate-validator-version>3.0.1-b10</javax.el-hibernate-validator-version>


Should be

javax-el-version and so forth. Also check if all of them are still in use?


Contributions is welcome",davsclaus,Task,Minor,Resolved,"parent/pom.xml - use dash in version properties We should only use dashes in the names, eg 

        <javax.el-api-version>2.2.5</javax.el-api-version>
        <javax.el-version>2.2.5</javax.el-version>
        <javax.el3-version>3.0.0</javax.el3-version>
        <javax.el-api-hibernate-validator-version>3.0.1-b04</javax.el-api-hibernate-validator-version>
        <javax.el-hibernate-validator-version>3.0.1-b10</javax.el-hibernate-validator-version>


Should be

javax-el-version and so forth. Also check if all of them are still in use?


Contributions is welcome"
CAMEL-13736,Camel main - Support bean post processing on @BindToRegistry,"When creating a new bean such as

@BindToRegistry
public MyBean myBean() {
  return new MyBean();
}

We can have a way to support bean post processing so we can do ioc injection on the created bean.

There can maybe be an option on camel main you can turn on | off. 

Also we can support this for fields only, if you dont need to do any customization

@BindToRegistry
private MyBean myBean
",davsclaus,Improvement,Major,Resolved,"Camel main - Support bean post processing on @BindToRegistry When creating a new bean such as

@BindToRegistry
public MyBean myBean() {
  return new MyBean();
}

We can have a way to support bean post processing so we can do ioc injection on the created bean.

There can maybe be an option on camel main you can turn on | off. 

Also we can support this for fields only, if you dont need to do any customization

@BindToRegistry
private MyBean myBean
"
CAMEL-13732,Converting to boolean should always be strict,When converting to boolean (primitive) we should be strict and only allow this for a set of known types and values.,davsclaus,Improvement,Major,Resolved,Converting to boolean should always be strict When converting to boolean (primitive) we should be strict and only allow this for a set of known types and values.
CAMEL-13730,NotifyBuilder MockComponent methods are deprecated and there is no replacement,"Several methods of the NotifyBuilder that receive MockComponent as a parameter are deprecated and are going to be removed from version 3+, but there is no viable replacement at the moment.

From related email conversation ([http://mail-archives.apache.org/mod_mbox/camel-users/201907.mbox/%3CMWHPR11MB138984E7FFB0DA82C043F4F395FA0%40MWHPR11MB1389.namprd11.prod.outlook.com%3E]):

Claus> Well we can take a look at adding some kind of SPI interface that advice with can use and then mock implement that.

And then potentially other components can be used too (in theory).",davsclaus,Task,Major,Resolved,"NotifyBuilder MockComponent methods are deprecated and there is no replacement Several methods of the NotifyBuilder that receive MockComponent as a parameter are deprecated and are going to be removed from version 3+, but there is no viable replacement at the moment.

From related email conversation ([http://mail-archives.apache.org/mod_mbox/camel-users/201907.mbox/%3CMWHPR11MB138984E7FFB0DA82C043F4F395FA0%40MWHPR11MB1389.namprd11.prod.outlook.com%3E]):

Claus> Well we can take a look at adding some kind of SPI interface that advice with can use and then mock implement that.

And then potentially other components can be used too (in theory)."
CAMEL-13727,Endpoint DSL - Do not generate path parameters as they cannot be set individually,"For example

bean("""").beanName(""myBean"")

is not working, you should do

bean(""myBean"");

For the former to work we need to allow to do

bean().beanName()...

And have the endpoint DSL know its a path parameter and built the uri correctly which is hard as this requires camel-catalog to build the uri as it knows all the complexity of building with path parameters. ",davsclaus,Improvement,Major,Resolved,"Endpoint DSL - Do not generate path parameters as they cannot be set individually For example

bean("""").beanName(""myBean"")

is not working, you should do

bean(""myBean"");

For the former to work we need to allow to do

bean().beanName()...

And have the endpoint DSL know its a path parameter and built the uri correctly which is hard as this requires camel-catalog to build the uri as it knows all the complexity of building with path parameters. "
CAMEL-13725,Endpoint DSL - Add to javadoc if an option is required,"When an option has required=true in the metadata we should add that to the endpoint DSL javadoc, eg

{code}
        /**
         * Whether the topic is persistent or non-persistent.
         * The option is a <code>java.lang.String</code> type.
         * @group common
         */
        default PulsarEndpointConsumerBuilder persistence(String persistence) {
            setProperty(""persistence"", persistence);
            return this;
        }
{code}

This option is required. Also not sure if @group is a valid javadoc syntax
",davsclaus,Improvement,Major,Resolved,"Endpoint DSL - Add to javadoc if an option is required When an option has required=true in the metadata we should add that to the endpoint DSL javadoc, eg

{code}
        /**
         * Whether the topic is persistent or non-persistent.
         * The option is a <code>java.lang.String</code> type.
         * @group common
         */
        default PulsarEndpointConsumerBuilder persistence(String persistence) {
            setProperty(""persistence"", persistence);
            return this;
        }
{code}

This option is required. Also not sure if @group is a valid javadoc syntax
"
CAMEL-13721,Properties component - Make it simpler by removing not often used stuff,"We can remove the properties component that is using uris, eg

properties:myKey

Which would create an endpoint with myKey as the url (eg delegate). But you can do that today with {{myKey}}.

Also we can remove the support for using location paths that has not been pre-configured, as that makes it more complex in terms of init logic. As we want to be able to optimize for property placeholders during build time and whatnot",davsclaus,Improvement,Major,Resolved,"Properties component - Make it simpler by removing not often used stuff We can remove the properties component that is using uris, eg

properties:myKey

Which would create an endpoint with myKey as the url (eg delegate). But you can do that today with {{myKey}}.

Also we can remove the support for using location paths that has not been pre-configured, as that makes it more complex in terms of init logic. As we want to be able to optimize for property placeholders during build time and whatnot"
CAMEL-13720,Properties component - Remove complexity of augemented properties parser,The need for CAMEL-4520 is not needed and makes the logic too complex. Lets remove this stuff and just use the simpler parser,davsclaus,Improvement,Major,Resolved,Properties component - Remove complexity of augemented properties parser The need for CAMEL-4520 is not needed and makes the logic too complex. Lets remove this stuff and just use the simpler parser
CAMEL-13718,Fix syntax for pulsar component,"Replace

 
{noformat}
pulsar:persistence://tenant/namespace/topic{noformat}
 

with
{noformat}
pulsar:configuration{noformat}
or
{noformat}
pulsar:uri{noformat}
 

There is currently only a single property of kind ""path"" for this component which is called ""topic"". The description of that parameter suggests that is should hold type, tenant and topic values for the endpoint which makes the name ""topic"" for this parameter a bad choice. I would rather suggest to rename it to something more fitting like ""configuration"" or ""uri"" instead.

 ",davsclaus,Bug,Major,Resolved,"Fix syntax for pulsar component Replace

 
{noformat}
pulsar:persistence://tenant/namespace/topic{noformat}
 

with
{noformat}
pulsar:configuration{noformat}
or
{noformat}
pulsar:uri{noformat}
 

There is currently only a single property of kind ""path"" for this component which is called ""topic"". The description of that parameter suggests that is should hold type, tenant and topic values for the endpoint which makes the name ""topic"" for this parameter a bad choice. I would rather suggest to rename it to something more fitting like ""configuration"" or ""uri"" instead.

 "
CAMEL-13712,"If a javax.mail.Session gets referred to using the ""session"" URL parameter, Apache Camel Mail ignored its hostnames.","{color:#658aba}A javax.mail.Session injected using JNDI can refer to one host per protocol. Referring to such a session using the URL query string parameter session=#jndiName seems to ignore the hosts the session is bound to:{color}

{color:#658aba}My first try was simply e.g. ""smtp://?session=#jndiName"". Now Apache Camel Mail complains about a missing hostname.{color}

{color:#658aba}So I tried ""smtp://localhost?session=#jndiName"" expecting that ""localhost"" would have been overridden using the SMTP host the session refers to, which is not the case. Camel complains that no SMTP server was listening on the host named ""localhost"".{color}

{color:#658aba}The workaround that works – but is somehow redundant in my opinion – is:{color}

{{{color:#3381ff}@Resource{color}(mappedName = {color:#658aba}""jndiName""{color})}}
 {{ {color:#000080}private {color}Session {color:#1948a6}mySession{color};}}

{{{color:#658aba}...to(""smtp://""+{color}{color:#1948a6}mySession{color}.getProperty({color:#658aba}""mail.smtp.host""{color})+""{color:#658aba}?session=#jndiName"")...{color}}}

{color:#658aba}The same also applies to the IMAP server (and likely to the other protocols supported by Java Mail as well).{color}

{color:#658aba}It would be nice iff referring to a JNDI injected session would take the session as-is to simplify the URL.{color}

{color:#658aba}I found an example for using the ""session"" parameter: ""MailUsingCustomSessionTest"". It would be helpful to have another example at hand that either takes the hostname from the session as my example above or that does not contain a hostname at all, given, Apache Camel Mail will support that in the future.{color}",davsclaus,Improvement,Minor,Resolved,"If a javax.mail.Session gets referred to using the ""session"" URL parameter, Apache Camel Mail ignored its hostnames. {color:#658aba}A javax.mail.Session injected using JNDI can refer to one host per protocol. Referring to such a session using the URL query string parameter session=#jndiName seems to ignore the hosts the session is bound to:{color}

{color:#658aba}My first try was simply e.g. ""smtp://?session=#jndiName"". Now Apache Camel Mail complains about a missing hostname.{color}

{color:#658aba}So I tried ""smtp://localhost?session=#jndiName"" expecting that ""localhost"" would have been overridden using the SMTP host the session refers to, which is not the case. Camel complains that no SMTP server was listening on the host named ""localhost"".{color}

{color:#658aba}The workaround that works - but is somehow redundant in my opinion - is:{color}

{{{color:#3381ff}@Resource{color}(mappedName = {color:#658aba}""jndiName""{color})}}
 {{ {color:#000080}private {color}Session {color:#1948a6}mySession{color};}}

{{{color:#658aba}...to(""smtp://""+{color}{color:#1948a6}mySession{color}.getProperty({color:#658aba}""mail.smtp.host""{color})+""{color:#658aba}?session=#jndiName"")...{color}}}

{color:#658aba}The same also applies to the IMAP server (and likely to the other protocols supported by Java Mail as well).{color}

{color:#658aba}It would be nice iff referring to a JNDI injected session would take the session as-is to simplify the URL.{color}

{color:#658aba}I found an example for using the ""session"" parameter: ""MailUsingCustomSessionTest"". It would be helpful to have another example at hand that either takes the hostname from the session as my example above or that does not contain a hostname at all, given, Apache Camel Mail will support that in the future.{color}"
CAMEL-13709,Properties component - Optimise to not call loadProperties to frequently,"The camel-properties calls loadProperties to load all the properties. But it tend to do this for each parseUri for custom PropertiesSource and other means which can be optimised.

The cache is based on properties location only.",davsclaus,Improvement,Major,Resolved,"Properties component - Optimise to not call loadProperties to frequently The camel-properties calls loadProperties to load all the properties. But it tend to do this for each parseUri for custom PropertiesSource and other means which can be optimised.

The cache is based on properties location only."
CAMEL-13708,PropertiesSource to resolve a single property,"CAMEL-13705 introduces support for property sources such as MP Config and others and at the moment it does require to load all the properties upfront on source initialization.

It would be nice to have an additional method to resolve a single property as some back-and may perform some I/O to resolve properties and get alll of them could be expensive.

So the properties component should:

- leverage PropertiesSource::loadPropertiers() when is is required to know all the properties (i.e. when auto configure components in camel main)
- leverage a new PropertiesSource::resolveProperty(String) when it just need to resolve a single property
",davsclaus,Improvement,Minor,Resolved,"PropertiesSource to resolve a single property CAMEL-13705 introduces support for property sources such as MP Config and others and at the moment it does require to load all the properties upfront on source initialization.

It would be nice to have an additional method to resolve a single property as some back-and may perform some I/O to resolve properties and get alll of them could be expensive.

So the properties component should:

- leverage PropertiesSource::loadPropertiers() when is is required to know all the properties (i.e. when auto configure components in camel main)
- leverage a new PropertiesSource::resolveProperty(String) when it just need to resolve a single property
"
CAMEL-13705,Properties component should work with Eclipse MicroProfile Config,"We should integrate with MP Config so you can build MP apps and have Camel's properties component use their properties.

We should allow to auto-detect this if eg a camel-microprofile-config is on the classpath and then setup this bridge automatic.

",davsclaus,New Feature,Major,Resolved,"Properties component should work with Eclipse MicroProfile Config We should integrate with MP Config so you can build MP apps and have Camel's properties component use their properties.

We should allow to auto-detect this if eg a camel-microprofile-config is on the classpath and then setup this bridge automatic.

"
CAMEL-13702,camel-main-maven-plugin - Only download sources JAR if really neesed,"We can improve the logic to detect if there are new components and then only if so, download sources jar if needed for options that need documentation.",davsclaus,Improvement,Major,Resolved,"camel-main-maven-plugin - Only download sources JAR if really neesed We can improve the logic to detect if there are new components and then only if so, download sources jar if needed for options that need documentation."
CAMEL-13697,URISupport - Mask accessToken and clientSecret in uri logging,We should also mask accessToken and clientSecret in uri outputs as they are sensitive data.,davsclaus,Improvement,Major,Resolved,URISupport - Mask accessToken and clientSecret in uri logging We should also mask accessToken and clientSecret in uri outputs as they are sensitive data.
CAMEL-13695,camel-core - Injector allow to create beans via static factory methods,"We should support creating beans via static factory methods that they sometime have instead of constructors, such as

camel.component.quartz2.scheduler-factory=#class:org.quartz.impl.DirectSchedulerFactory#getInstance

",davsclaus,Improvement,Major,Resolved,"camel-core - Injector allow to create beans via static factory methods We should support creating beans via static factory methods that they sometime have instead of constructors, such as

camel.component.quartz2.scheduler-factory=#class:org.quartz.impl.DirectSchedulerFactory#getInstance

"
CAMEL-13694,Easier way to extend PropertiesComponent,"The current implementation of the PropertiesComponent is very oriented to paths and location and it is not very easy to provide alternative back-ends i.e MP Config or HashiCorp Vault.

We may need to re-think the PropertiesComponent interface and reason in term of ordered ""property sources"", like:

{code}
ProertiesComponent cp = new ProertiesComponent()
cp.addSource(new ValutPropertiesSource())
cp.addSource(new PathPropertiesSource())
cp.addSource(PropertiesSource.wrap(properties))
...
{code}


",davsclaus,Improvement,Minor,Resolved,"Easier way to extend PropertiesComponent The current implementation of the PropertiesComponent is very oriented to paths and location and it is not very easy to provide alternative back-ends i.e MP Config or HashiCorp Vault.

We may need to re-think the PropertiesComponent interface and reason in term of ordered ""property sources"", like:

{code}
ProertiesComponent cp = new ProertiesComponent()
cp.addSource(new ValutPropertiesSource())
cp.addSource(new PathPropertiesSource())
cp.addSource(PropertiesSource.wrap(properties))
...
{code}


"
CAMEL-13690,camel-main - Add option to ignore unknown options,"For example if you have OS ENV variables set that will not be in use because a component is not being used or something. 
",davsclaus,Improvement,Major,Resolved,"camel-main - Add option to ignore unknown options For example if you have OS ENV variables set that will not be in use because a component is not being used or something. 
"
CAMEL-13688,Camel main - Setting boolean option should have strict conversition,"If you set an option like

camel.main.allow-use-original-message=123

Then its set as false, because we do a Boolean.valueOf convertion which just checks if its ""true"" or not. Instead we should only allow string values of ""true"" or ""false"" otherwise its a invalid value.",davsclaus,Improvement,Major,Resolved,"Camel main - Setting boolean option should have strict conversition If you set an option like

camel.main.allow-use-original-message=123

Then its set as false, because we do a Boolean.valueOf convertion which just checks if its ""true"" or not. Instead we should only allow string values of ""true"" or ""false"" otherwise its a invalid value."
CAMEL-13687,NotifyBuilder not working as expected,"am trying to test an error handling route. The {{NotificationBuilder}} does not work as expected (it always returns false).

Created a main route and a test route to test the main route. I used Spring Boot - all other tests work fine, so there is no problem with the setup I guess.

 

I have attached the sample project. Please uncomment the @Ignore method to test the method. Please read the README.md attached in the project",davsclaus,Bug,Major,Resolved,"NotifyBuilder not working as expected am trying to test an error handling route. The {{NotificationBuilder}} does not work as expected (it always returns false).

Created a main route and a test route to test the main route. I used Spring Boot - all other tests work fine, so there is no problem with the setup I guess.

 

I have attached the sample project. Please uncomment the @Ignore method to test the method. Please read the README.md attached in the project"
CAMEL-13686,camel-main - Add option for verbose logging of configuration,"So end users can just set an option

camel.main.configuration-logging=true

Or something like that to get verbose INFO logging of how all these configurations are computed so you can use that to track if something seems not correct.",davsclaus,Improvement,Major,Resolved,"camel-main - Add option for verbose logging of configuration So end users can just set an option

camel.main.configuration-logging=true

Or something like that to get verbose INFO logging of how all these configurations are computed so you can use that to track if something seems not correct."
CAMEL-13685,camel-rabbitmq  Thread name for route set to endpoint uri,"change thread name of rabbitmq routes from ""RabbitMQConsumer"" to  its endpoint uri",davsclaus,Improvement,Minor,Resolved,"camel-rabbitmq  Thread name for route set to endpoint uri change thread name of rabbitmq routes from ""RabbitMQConsumer"" to  its endpoint uri"
CAMEL-13683,camel-main - configuring properties report better error if missing JARs on classpath,Look into if we are not reporting a good error if you configure an option for a component that is not on the classpath etc.,davsclaus,Improvement,Major,Resolved,camel-main - configuring properties report better error if missing JARs on classpath Look into if we are not reporting a good error if you configure an option for a component that is not on the classpath etc.
CAMEL-13681,camel-main - Allow ENV variables to configure any option,"Any of the options you can configure via application.properties such as:
camel.main.name
camel.component.xxx=yyy

And so on should be configurable via ENV variables which will override any existing configuration. This is good practice in containers and also how SB can do etc.

",davsclaus,New Feature,Major,Resolved,"camel-main - Allow ENV variables to configure any option Any of the options you can configure via application.properties such as:
camel.main.name
camel.component.xxx=yyy

And so on should be configurable via ENV variables which will override any existing configuration. This is good practice in containers and also how SB can do etc.

"
CAMEL-13680,camel-file - From file to file with readLock=fileLock dont work on windows,"You can get errors like
{code}
Stacktrace
---------------------------------------------------------------------------------------------------------------------------------------
org.apache.camel.component.file.GenericFileOperationFailedException: Cannot store file: work\cbr\output\ID-WIN-JTA8KU4EF9D-1561426618994-0-2
	at org.apache.camel.component.file.FileOperations.storeFile(FileOperations.java:352)
	at org.apache.camel.component.file.GenericFileProducer.writeFile(GenericFileProducer.java:305)
	at org.apache.camel.component.file.GenericFileProducer.processExchange(GenericFileProducer.java:169)
	at org.apache.camel.component.file.GenericFileProducer.process(GenericFileProducer.java:80)
	at org.apache.camel.util.AsyncProcessorConverterHelper$ProcessorToAsyncProcessorBridge.process(AsyncProcessorConverterHelper.java:61)
	at org.apache.camel.processor.SendProcessor.process(SendProcessor.java:148)
	at org.apache.camel.processor.RedeliveryErrorHandler.process(RedeliveryErrorHandler.java:548)
	at org.apache.camel.processor.CamelInternalProcessor.process(CamelInternalProcessor.java:201)
	at org.apache.camel.processor.Pipeline.process(Pipeline.java:138)
	at org.apache.camel.processor.Pipeline.process(Pipeline.java:101)
	at org.apache.camel.processor.CamelInternalProcessor.process(CamelInternalProcessor.java:201)
	at org.apache.camel.component.file.GenericFileConsumer.processExchange(GenericFileConsumer.java:452)
	at org.apache.camel.component.file.GenericFileConsumer.processBatch(GenericFileConsumer.java:219)
	at org.apache.camel.component.file.GenericFileConsumer.poll(GenericFileConsumer.java:183)
	at org.apache.camel.impl.ScheduledPollConsumer.doRun(ScheduledPollConsumer.java:174)
	at org.apache.camel.impl.ScheduledPollConsumer.run(ScheduledPollConsumer.java:101)
	at java.util.concurrent.Executors$RunnableAdapter.call(Unknown Source)
	at java.util.concurrent.FutureTask.runAndReset(Unknown Source)
	at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.access$301(Unknown Source)
	at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(Unknown Source)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(Unknown Source)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(Unknown Source)
	at java.lang.Thread.run(Unknown Source)
Caused by: java.nio.file.FileSystemException: work\cbr\input\ID-WIN-JTA8KU4EF9D-1561426618994-0-2 -> work\cbr\output\ID-WIN-JTA8KU4EF9D-1561426618994-0-2: The process cannot access the file because it is being used by another process
	at sun.nio.fs.WindowsException.translateToIOException(Unknown Source)
	at sun.nio.fs.WindowsException.rethrowAsIOException(Unknown Source)
	at sun.nio.fs.WindowsFileCopy.copy(Unknown Source)
	at sun.nio.fs.WindowsFileSystemProvider.copy(Unknown Source)
	at java.nio.file.Files.copy(Unknown Source)
{code}",davsclaus,Bug,Minor,Resolved,"camel-file - From file to file with readLock=fileLock dont work on windows You can get errors like
{code}
Stacktrace
---------------------------------------------------------------------------------------------------------------------------------------
org.apache.camel.component.file.GenericFileOperationFailedException: Cannot store file: work\cbr\output\ID-WIN-JTA8KU4EF9D-1561426618994-0-2
	at org.apache.camel.component.file.FileOperations.storeFile(FileOperations.java:352)
	at org.apache.camel.component.file.GenericFileProducer.writeFile(GenericFileProducer.java:305)
	at org.apache.camel.component.file.GenericFileProducer.processExchange(GenericFileProducer.java:169)
	at org.apache.camel.component.file.GenericFileProducer.process(GenericFileProducer.java:80)
	at org.apache.camel.util.AsyncProcessorConverterHelper$ProcessorToAsyncProcessorBridge.process(AsyncProcessorConverterHelper.java:61)
	at org.apache.camel.processor.SendProcessor.process(SendProcessor.java:148)
	at org.apache.camel.processor.RedeliveryErrorHandler.process(RedeliveryErrorHandler.java:548)
	at org.apache.camel.processor.CamelInternalProcessor.process(CamelInternalProcessor.java:201)
	at org.apache.camel.processor.Pipeline.process(Pipeline.java:138)
	at org.apache.camel.processor.Pipeline.process(Pipeline.java:101)
	at org.apache.camel.processor.CamelInternalProcessor.process(CamelInternalProcessor.java:201)
	at org.apache.camel.component.file.GenericFileConsumer.processExchange(GenericFileConsumer.java:452)
	at org.apache.camel.component.file.GenericFileConsumer.processBatch(GenericFileConsumer.java:219)
	at org.apache.camel.component.file.GenericFileConsumer.poll(GenericFileConsumer.java:183)
	at org.apache.camel.impl.ScheduledPollConsumer.doRun(ScheduledPollConsumer.java:174)
	at org.apache.camel.impl.ScheduledPollConsumer.run(ScheduledPollConsumer.java:101)
	at java.util.concurrent.Executors$RunnableAdapter.call(Unknown Source)
	at java.util.concurrent.FutureTask.runAndReset(Unknown Source)
	at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.access$301(Unknown Source)
	at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(Unknown Source)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(Unknown Source)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(Unknown Source)
	at java.lang.Thread.run(Unknown Source)
Caused by: java.nio.file.FileSystemException: work\cbr\input\ID-WIN-JTA8KU4EF9D-1561426618994-0-2 -> work\cbr\output\ID-WIN-JTA8KU4EF9D-1561426618994-0-2: The process cannot access the file because it is being used by another process
	at sun.nio.fs.WindowsException.translateToIOException(Unknown Source)
	at sun.nio.fs.WindowsException.rethrowAsIOException(Unknown Source)
	at sun.nio.fs.WindowsFileCopy.copy(Unknown Source)
	at sun.nio.fs.WindowsFileSystemProvider.copy(Unknown Source)
	at java.nio.file.Files.copy(Unknown Source)
{code}"
CAMEL-13678,Attachments API on Message - Deprecate and remove,"We should consider making the Camel Message API more simpler and remove stuff that are seldom in use, or can be component specific.

The javax.attachment is removed from JDK11 onwards and its not really much in use in the future.

",davsclaus,Improvement,Major,Resolved,"Attachments API on Message - Deprecate and remove We should consider making the Camel Message API more simpler and remove stuff that are seldom in use, or can be component specific.

The javax.attachment is removed from JDK11 onwards and its not really much in use in the future.

"
CAMEL-13677,Move AttachmentConverterLoader out of camel-core,The javax.attachments API are not standard in Java 11. We should make this converter optional from camel-core and move to somewhere else.,davsclaus,Improvement,Major,Resolved,Move AttachmentConverterLoader out of camel-core The javax.attachments API are not standard in Java 11. We should make this converter optional from camel-core and move to somewhere else.
CAMEL-13675,camel-main - Optimise main configurer,"This method takes approx 60 millis on my laptop
org.apache.camel.main.DefaultConfigurationConfigurer#afterPropertiesSet

I suspects its all those lambda's that are loaded on classpath and only in use if there is a bean to lookup. The logic can be improved to use old fashioned code with some if != null

If I disable all of those then its down to 4 millis on my laptop",davsclaus,Improvement,Minor,Resolved,"camel-main - Optimise main configurer This method takes approx 60 millis on my laptop
org.apache.camel.main.DefaultConfigurationConfigurer#afterPropertiesSet

I suspects its all those lambda's that are loaded on classpath and only in use if there is a bean to lookup. The logic can be improved to use old fashioned code with some if != null

If I disable all of those then its down to 4 millis on my laptop"
CAMEL-13674,Simple language - Body as one line,Add function to return the message body as a one line string. This can be useful in some situations where you want to be able to do this from logging point of view via Log EIP,davsclaus,New Feature,Minor,Resolved,Simple language - Body as one line Add function to return the message body as a one line string. This can be useful in some situations where you want to be able to do this from logging point of view via Log EIP
CAMEL-13672,camel-main-maven-plugin - Add groups to tooling metadata,"We can add groups as documented in SB metamodel
https://docs.spring.io/spring-boot/docs/current/reference/html/configuration-metadata.html#configuration-metadata-format

Then we can have groups for
- main
- per component

With a description of each group, eg the component description etc. This gives a little bit more documentation for the end users.",davsclaus,Improvement,Major,Resolved,"camel-main-maven-plugin - Add groups to tooling metadata We can add groups as documented in SB metamodel
https://docs.spring.io/spring-boot/docs/current/reference/html/configuration-metadata.html#configuration-metadata-format

Then we can have groups for
- main
- per component

With a description of each group, eg the component description etc. This gives a little bit more documentation for the end users."
CAMEL-13665,camel3 - SPI classpath discovery - Combine into a single lookup,"We do a bunch of SPI classpath discover for 3rd party plugins and even for components like camel-bean and whatnot. (its those resolvers).

For a quicker startup we can group these standard lookups into a single classpath scan (notice Camel only does that if you have not set an explicit SPI vis its setter).",davsclaus,Improvement,Minor,Resolved,"camel3 - SPI classpath discovery - Combine into a single lookup We do a bunch of SPI classpath discover for 3rd party plugins and even for components like camel-bean and whatnot. (its those resolvers).

For a quicker startup we can group these standard lookups into a single classpath scan (notice Camel only does that if you have not set an explicit SPI vis its setter)."
CAMEL-13663,camel-main-maven-plugin - Generate tooling metadata,"To assist editing Camel Main and eg application.properties then we could ""fool"" tooling by generating Spring Boot metadata json files, so tools see these files and offer their code completions.

Then you can use ctrl + space for type completions when typing

camel.component.jms

",davsclaus,New Feature,Major,Resolved,"camel-main-maven-plugin - Generate tooling metadata To assist editing Camel Main and eg application.properties then we could ""fool"" tooling by generating Spring Boot metadata json files, so tools see these files and offer their code completions.

Then you can use ctrl + space for type completions when typing

camel.component.jms

"
CAMEL-13658,Refine ProcessorDefinition output handling,"The ProcessDefinition class is the base class for most of the DSL / Definitions and defines a  number of methods related to outputs such as:

{code:java}
public abstract List<ProcessorDefinition<?>> getOutputs();
public abstract boolean isOutputSupported();
{code}

The information about the ability to handle outputs is thus available at runtime only which complicates the creation of alternative DSLs (i.e https://github.com/apache/camel-k-runtime/issues/80)",davsclaus,Improvement,Minor,Resolved,"Refine ProcessorDefinition output handling The ProcessDefinition class is the base class for most of the DSL / Definitions and defines a  number of methods related to outputs such as:

{code:java}
public abstract List<ProcessorDefinition<?>> getOutputs();
public abstract boolean isOutputSupported();
{code}

The information about the ability to handle outputs is thus available at runtime only which complicates the creation of alternative DSLs (i.e https://github.com/apache/camel-k-runtime/issues/80)"
CAMEL-13657,Simpler attribute names in the XML DSL,"Some part of the DSL expose verbose properties as example, the set header definition, has ha setHeaderName property which leads to an XML like:

{code:xml}
<setHeader headerName=""Something""/>
{code}

This is not wrong but the context gives enough information so it can be rewritten as:

{code:xml}
<setHeader name=""Something""/>
{code}

Which makes it shorter and does not impact comprehension. 
",davsclaus,Improvement,Major,Resolved,"Simpler attribute names in the XML DSL Some part of the DSL expose verbose properties as example, the set header definition, has ha setHeaderName property which leads to an XML like:

{code:xml}
<setHeader headerName=""Something""/>
{code}

This is not wrong but the context gives enough information so it can be rewritten as:

{code:xml}
<setHeader name=""Something""/>
{code}

Which makes it shorter and does not impact comprehension. 
"
CAMEL-13656,reifiers classes should be public,Refiers classes are now package private that make it impossible to reuse them for example in a custom processor factory like what it is done by Hystrix: https://github.com/apache/camel/blob/master/components/camel-hystrix/src/main/java/org/apache/camel/component/hystrix/processor/HystrixProcessorFactory.java,davsclaus,Improvement,Minor,Resolved,reifiers classes should be public Refiers classes are now package private that make it impossible to reuse them for example in a custom processor factory like what it is done by Hystrix: https://github.com/apache/camel/blob/master/components/camel-hystrix/src/main/java/org/apache/camel/component/hystrix/processor/HystrixProcessorFactory.java
CAMEL-13650,Properties component - loadProperties to return properties in order,"The API

    Properties loadProperties();

    Properties loadProperties(String... locations);

But the Properties is a Hashtable that is unordered, but it would be better if we could get this as Map so we can use LinkedHashMap so they are in order. This would work better with the order the end users may define in their application.properties files etc

camel.component.jms.configuration.connectionFactory=#class:org.apache.activemq.artemis.jms.client.ActiveMQJMSConnectionFactory
camel.component.jms.configuration.connectionFactory.brokerUrl=localhost:61616

",davsclaus,Improvement,Major,Resolved,"Properties component - loadProperties to return properties in order The API

    Properties loadProperties();

    Properties loadProperties(String... locations);

But the Properties is a Hashtable that is unordered, but it would be better if we could get this as Map so we can use LinkedHashMap so they are in order. This would work better with the order the end users may define in their application.properties files etc

camel.component.jms.configuration.connectionFactory=#class:org.apache.activemq.artemis.jms.client.ActiveMQJMSConnectionFactory
camel.component.jms.configuration.connectionFactory.brokerUrl=localhost:61616

"
CAMEL-13647,camel-main - Add support for auto binding to components by interface type and discover impl class on classpath,"This can make convention over configuration nicer. For example some components requires a ConnectionFactory etc and if we can auto-discover that on the classpath there is only 1 implementation of such interface, we can try to auto create the instance and configure it on the component.

This should be an option you can turn on|off.",davsclaus,New Feature,Major,Resolved,"camel-main - Add support for auto binding to components by interface type and discover impl class on classpath This can make convention over configuration nicer. For example some components requires a ConnectionFactory etc and if we can auto-discover that on the classpath there is only 1 implementation of such interface, we can try to auto create the instance and configure it on the component.

This should be an option you can turn on|off."
CAMEL-13645,camel-spring - NPE in NotifyBuilder during testing,"Just noticed some NPEs while doing test of camel-spring

019-06-13 15:02:08,902 WARN  EventHelper - Error notifying event ID-davsclaus-pro-local-1560430811107-235-1 exchange created: Exchange[ID-davsclaus-pro-local-1560430811107-235-1]. This exception will be ignored.  
java.lang.NullPointerException: null
	at org.apache.camel.builder.NotifyBuilder$3.onExchange(NotifyBuilder.java:194) ~[camel-core-3.0.0-SNAPSHOT.jar:3.0.0-SNAPSHOT]
	at org.apache.camel.builder.NotifyBuilder$EventPredicateSupport.onExchangeCreated(NotifyBuilder.java:1293) ~[camel-core-3.0.0-SNAPSHOT.jar:3.0.0-SNAPSHOT]
	at org.apache.camel.builder.NotifyBuilder$CompoundEventPredicate.onExchangeCreated(NotifyBuilder.java:1381) ~[camel-core-3.0.0-SNAPSHOT.jar:3.0.0-SNAPSHOT]
	at org.apache.camel.builder.NotifyBuilder$ExchangeNotifier.onExchangeCreated(NotifyBuilder.java:1154) ~[camel-core-3.0.0-SNAPSHOT.jar:3.0.0-SNAPSHOT]
	at org.apache.camel.builder.NotifyBuilder$ExchangeNotifier.notify(NotifyBuilder.java:1135) ~[camel-core-3.0.0-SNAPSHOT.jar:3.0.0-SNAPSHOT]
	at org.apache.camel.support.EventHelper.doNotifyEvent(EventHelper.java:288) [camel-support-3.0.0-SNAPSHOT.jar:3.0.0-SNAPSHOT]
	at org.apache.camel.support.EventHelper.doNotify(EventHelper.java:27",davsclaus,Test,Major,Resolved,"camel-spring - NPE in NotifyBuilder during testing Just noticed some NPEs while doing test of camel-spring

019-06-13 15:02:08,902 WARN  EventHelper - Error notifying event ID-davsclaus-pro-local-1560430811107-235-1 exchange created: Exchange[ID-davsclaus-pro-local-1560430811107-235-1]. This exception will be ignored.  
java.lang.NullPointerException: null
	at org.apache.camel.builder.NotifyBuilder$3.onExchange(NotifyBuilder.java:194) ~[camel-core-3.0.0-SNAPSHOT.jar:3.0.0-SNAPSHOT]
	at org.apache.camel.builder.NotifyBuilder$EventPredicateSupport.onExchangeCreated(NotifyBuilder.java:1293) ~[camel-core-3.0.0-SNAPSHOT.jar:3.0.0-SNAPSHOT]
	at org.apache.camel.builder.NotifyBuilder$CompoundEventPredicate.onExchangeCreated(NotifyBuilder.java:1381) ~[camel-core-3.0.0-SNAPSHOT.jar:3.0.0-SNAPSHOT]
	at org.apache.camel.builder.NotifyBuilder$ExchangeNotifier.onExchangeCreated(NotifyBuilder.java:1154) ~[camel-core-3.0.0-SNAPSHOT.jar:3.0.0-SNAPSHOT]
	at org.apache.camel.builder.NotifyBuilder$ExchangeNotifier.notify(NotifyBuilder.java:1135) ~[camel-core-3.0.0-SNAPSHOT.jar:3.0.0-SNAPSHOT]
	at org.apache.camel.support.EventHelper.doNotifyEvent(EventHelper.java:288) [camel-support-3.0.0-SNAPSHOT.jar:3.0.0-SNAPSHOT]
	at org.apache.camel.support.EventHelper.doNotify(EventHelper.java:27"
CAMEL-13636,camel3 - SPI for ReactiveHelper so we can plugin different reactive engines,Today we use ReactiveHelper.callback(callback) to execute works in Camel routing engine. We should have a SPI so we can plugin 3rd party.,davsclaus,Improvement,Major,Resolved,camel3 - SPI for ReactiveHelper so we can plugin different reactive engines Today we use ReactiveHelper.callback(callback) to execute works in Camel routing engine. We should have a SPI so we can plugin 3rd party.
CAMEL-13634,Camel main - Allow to configure rest dsl configuration,"So you can configure in application.properties etc, some of the rest dsl configuration you would otherwise have to configure with restConfiguration() in the java dsl",davsclaus,Improvement,Major,Resolved,"Camel main - Allow to configure rest dsl configuration So you can configure in application.properties etc, some of the rest dsl configuration you would otherwise have to configure with restConfiguration() in the java dsl"
CAMEL-13632,Deprecate and remove ReloadStrategy,"This should be deprecated in camel 2.x and removed in 3.0.

This makes the modularization of camel 3 better, and its also only used as a developer/demo thing and not for production usage. And today there are better alternatives with camel k, and camel-quarkus etc, for hot re-load that can load the entire app and not only a xml route.",davsclaus,Improvement,Major,Resolved,"Deprecate and remove ReloadStrategy This should be deprecated in camel 2.x and removed in 3.0.

This makes the modularization of camel 3 better, and its also only used as a developer/demo thing and not for production usage. And today there are better alternatives with camel k, and camel-quarkus etc, for hot re-load that can load the entire app and not only a xml route."
CAMEL-13625,Quartz2 firenow doesn't work consistently,"Hi Colleagues,

We have an interesting bug in the camel-quartz2 where the firenow doesn't work consistently.

it works sometimes and sometimes it doesn't. On debug i found that the problem occurs when Scheduler starts it invokes *CamleJob,*  *CamleJob* starts executing and tries to read from *getProcessors()* method of *LoadBalancerSupport* class. sometimes *getProcessors()* method returns empty list as a result routes doesn't get executed.

*StartupListener* (QuartzComponent) gets notified much before the *QuartzConsumer* starts, as a result it is not able to get the List<Processor> from *getProcessors()* method of *LoadBalancerSupport* class.

 

Analysis of the problem

--------------------------------------------------------------------------------------------------
 # *DefaultCamelContext* method *safelyStartRouteServices()* notifies QuartzComponent's *onCamelContextStarted()* method.
 # The above step starts the scheduler which then calls *execute()* method in *CamelJob* class.
 # In the execute() method it invokes *getProcessors()* method of *LoadBalancerSupport* class to get the List<Processor>.
 # Sometimes *getProcessors()*  returns empty list.
 # The reason is  List<Processor> in *LoadBalancerSupport* class is populated by *QuartzConsumer* on start of consumer. but  it is started after QuartzComponent's *onCamelContextStarted()* method is called in *DefaultCamelContext*.
 # When i checked the older version of camel which we are using in our organization 2.17.0 i see the order is different.
 # Consumer starts first then the classes that implements *StartupListener*.

To Summarize

-------------------------------------------------------------------------------------------------------
 # The order in which *StartupListener* and *Consumer* is started in *DefaultCamelContext* is causing race condition.
 # The older version of camel 2.17.0 order is first *Consumer* starts followed by classes that implement *StartupListener*

 

I have attached the junit with quartz2, since it is intermittent issue, i made the junit to run 1000 times and it fails randomly which proves existence of the problem.

I have also attached by proposed solution in DefaultCamelContext in the attachment.

 

 ",davsclaus,Bug,Major,Resolved,"Quartz2 firenow doesn't work consistently Hi Colleagues,

We have an interesting bug in the camel-quartz2 where the firenow doesn't work consistently.

it works sometimes and sometimes it doesn't. On debug i found that the problem occurs when Scheduler starts it invokes *CamleJob,*  *CamleJob* starts executing and tries to read from *getProcessors()* method of *LoadBalancerSupport* class. sometimes *getProcessors()* method returns empty list as a result routes doesn't get executed.

*StartupListener* (QuartzComponent) gets notified much before the *QuartzConsumer* starts, as a result it is not able to get the List<Processor> from *getProcessors()* method of *LoadBalancerSupport* class.

 

Analysis of the problem

--------------------------------------------------------------------------------------------------
 # *DefaultCamelContext* method *safelyStartRouteServices()* notifies QuartzComponent's *onCamelContextStarted()* method.
 # The above step starts the scheduler which then calls *execute()* method in *CamelJob* class.
 # In the execute() method it invokes *getProcessors()* method of *LoadBalancerSupport* class to get the List<Processor>.
 # Sometimes *getProcessors()*  returns empty list.
 # The reason is  List<Processor> in *LoadBalancerSupport* class is populated by *QuartzConsumer* on start of consumer. but  it is started after QuartzComponent's *onCamelContextStarted()* method is called in *DefaultCamelContext*.
 # When i checked the older version of camel which we are using in our organization 2.17.0 i see the order is different.
 # Consumer starts first then the classes that implements *StartupListener*.

To Summarize

-------------------------------------------------------------------------------------------------------
 # The order in which *StartupListener* and *Consumer* is started in *DefaultCamelContext* is causing race condition.
 # The older version of camel 2.17.0 order is first *Consumer* starts followed by classes that implement *StartupListener*

 

I have attached the junit with quartz2, since it is intermittent issue, i made the junit to run 1000 times and it fails randomly which proves existence of the problem.

I have also attached by proposed solution in DefaultCamelContext in the attachment.

 

 "
CAMEL-13620,Camel Main - Move to camel-main ccomponent,"Lets see if we can move the main classes from camel-core to camel-main so they get more separated and become more reusable in other parts.

We have a common set of options to configure on camel context itself, and all the configuration of components etc. That logic can be more shared for camel main, camel k, camel spring boot, and others etc.",davsclaus,Improvement,Major,Resolved,"Camel Main - Move to camel-main ccomponent Lets see if we can move the main classes from camel-core to camel-main so they get more separated and become more reusable in other parts.

We have a common set of options to configure on camel context itself, and all the configuration of components etc. That logic can be more shared for camel main, camel k, camel spring boot, and others etc."
CAMEL-13618,camel3 - Move FileWatcherReloadStrategy out of camel-core,For example to camel-support etc,davsclaus,Improvement,Major,Resolved,camel3 - Move FileWatcherReloadStrategy out of camel-core For example to camel-support etc
CAMEL-13612,camel-rest - Should separate consumer and producer component names,"You may end up with using rest-dsl and rest component together, and have a rest endpoint that is shared among them. Then the endpoint will have a componentName option set to the consumer, such as jetty. And then when the same endpoint is used for creating the rest producer (eg to rest) then it would fail. We should separate these two options.",davsclaus,Improvement,Major,Resolved,"camel-rest - Should separate consumer and producer component names You may end up with using rest-dsl and rest component together, and have a rest endpoint that is shared among them. Then the endpoint will have a componentName option set to the consumer, such as jetty. And then when the same endpoint is used for creating the rest producer (eg to rest) then it would fail. We should separate these two options."
CAMEL-13608,camel-spring-boot - Add option to include/exclude routes based on their ids,"So you can for example do an unit test where you want to only test a specific route and then filter out everyone else. Currently you can filter on route builder and xml files level, but not on route ids.",davsclaus,New Feature,Major,Resolved,"camel-spring-boot - Add option to include/exclude routes based on their ids So you can for example do an unit test where you want to only test a specific route and then filter out everyone else. Currently you can filter on route builder and xml files level, but not on route ids."
CAMEL-13605,Support setup proxy host and port on Telegram,"As we may run the camel-telegram application behind a proxy, it could be handy if camel-telegram support setting http proxy. ",njiang,Improvement,Minor,Resolved,"Support setup proxy host and port on Telegram As we may run the camel-telegram application behind a proxy, it could be handy if camel-telegram support setting http proxy. "
CAMEL-13599,Claim check - Allow to use dynamic key via simple language,"Asked on user forum
http://camel.465427.n5.nabble.com/Using-dynamic-expression-as-claimCheck-key-tp5835356.html",davsclaus,Improvement,Major,Resolved,"Claim check - Allow to use dynamic key via simple language Asked on user forum
http://camel.465427.n5.nabble.com/Using-dynamic-expression-as-claimCheck-key-tp5835356.html"
CAMEL-13597,Splitter tokenize doesn't really accept every regex,"Hi, 

Neither
{code:java}
.split().tokenize(""\r?\n"", true, 2, true){code}
nor 
{code:java}
.split().tokenize(""\r\n|\n"", true, 2, true){code}
work.

 

The latter expression insert a ""|"" instead of correctly split rows on \r\n or \n.

 

 

 

 

 

 ",davsclaus,Improvement,Minor,Resolved,"Splitter tokenize doesn't really accept every regex Hi, 

Neither
{code:java}
.split().tokenize(""\r?\n"", true, 2, true){code}
nor 
{code:java}
.split().tokenize(""\r\n|\n"", true, 2, true){code}
work.

 

The latter expression insert a ""|"" instead of correctly split rows on \r\n or \n.

 

 

 

 

 

 "
CAMEL-13594,camel apt - Avoid generating TypeConverter META-INF file when we generate TypeConverterLoader,We can optimize this to only have the newer TypeConverterLoader file which has all the type converters that are optimized. And then in tooling/apt avoid generate both TypeConverter and TypeConverterLoaded meta files.,davsclaus,Improvement,Major,Resolved,camel apt - Avoid generating TypeConverter META-INF file when we generate TypeConverterLoader We can optimize this to only have the newer TypeConverterLoader file which has all the type converters that are optimized. And then in tooling/apt avoid generate both TypeConverter and TypeConverterLoaded meta files.
CAMEL-13592,camel-sql - Repeated parameters in URI are not treated correctly,"When constructing Camel SQL component with the following URI:
{code:java}
sql:INSERT INTO TABLE ....?batch=true&...&batch=true{code}
Resulting camel endpoint ends up with batch == false. The reason for this is found in 
{code:java}
private static void addParameter // this is in UriSupport.java{code}
This method adds values into a list and then setting the parameter does not work correctly. I believe that Camel should be more linient for such ""errors"" (which can occur if you construct URI programatically). 

I suggest parameter value detection. If
{code:java}
existing.equals(value) // to use actual names of variables from the code{code}
then just ignore. DO NOT do the following (list construction; current behavior):
{code:java}
if (existing instanceof List) {
    list = CastUtils.cast((List<?>) existing);
} else {
    // create a new list to hold the multiple values
    list = new ArrayList<String>();
    String s = existing != null ? existing.toString() : null;
    if (s != null) {
        list.add(s);
    }
}
list.add(value);
{code}
In the end the URI shown in the beginning will result in Component with batch equal to false. Which is really hard to determine why and what happened. 

 

I believe this is a generic problem tho",davsclaus,Bug,Minor,Resolved,"camel-sql - Repeated parameters in URI are not treated correctly When constructing Camel SQL component with the following URI:
{code:java}
sql:INSERT INTO TABLE ....?batch=true&...&batch=true{code}
Resulting camel endpoint ends up with batch == false. The reason for this is found in 
{code:java}
private static void addParameter // this is in UriSupport.java{code}
This method adds values into a list and then setting the parameter does not work correctly. I believe that Camel should be more linient for such ""errors"" (which can occur if you construct URI programatically). 

I suggest parameter value detection. If
{code:java}
existing.equals(value) // to use actual names of variables from the code{code}
then just ignore. DO NOT do the following (list construction; current behavior):
{code:java}
if (existing instanceof List) {
    list = CastUtils.cast((List<?>) existing);
} else {
    // create a new list to hold the multiple values
    list = new ArrayList<String>();
    String s = existing != null ? existing.toString() : null;
    if (s != null) {
        list.add(s);
    }
}
list.add(value);
{code}
In the end the URI shown in the beginning will result in Component with batch equal to false. Which is really hard to determine why and what happened. 

 

I believe this is a generic problem tho"
CAMEL-13587,"InflightRepository, InflightEntry getElapsed is 0","Hi,

I made a camel-route that checks about inflight messages on other server through JMX connection.
It was working fine in 2.17.x but now we upgrade to 2.22.1 and I always obtain a result of 0 millisecond for the elapsed field.

I use the browse() operation of JMX bean. You can use jconsole to run a simple test.

!image-2019-05-27-17-04-12-319.png!

This is a major bug for us, since we use the code to monitoring production routes. Is there any workaround like get the echange historymessage from the exchage id?

Thank you",davsclaus,Bug,Major,Resolved,"InflightRepository, InflightEntry getElapsed is 0 Hi,

I made a camel-route that checks about inflight messages on other server through JMX connection.
It was working fine in 2.17.x but now we upgrade to 2.22.1 and I always obtain a result of 0 millisecond for the elapsed field.

I use the browse() operation of JMX bean. You can use jconsole to run a simple test.

!image-2019-05-27-17-04-12-319.png!

This is a major bug for us, since we use the code to monitoring production routes. Is there any workaround like get the echange historymessage from the exchage id?

Thank you"
CAMEL-13584,Camel main - Calling init should initialize as much as possible,"So we can eager init as much as possible when running Camel Main, by calling main.init() method. This can be used to warmup Camel.",davsclaus,Improvement,Major,Resolved,"Camel main - Calling init should initialize as much as possible So we can eager init as much as possible when running Camel Main, by calling main.init() method. This can be used to warmup Camel."
CAMEL-13583,Camel Injector - Add method for creating a new instance without bean processing,"There are use-cases where we for example loads the type converter loaded that creates an instance of the class, but we use the injector which does bean post processing by scanning methods for injecting fields / and other autowriting via those Camel annotations. But these type converters are basic and dont need this. There can be some other factory classes too, so lets have a basic injector method so you can choose.",davsclaus,Improvement,Minor,Resolved,"Camel Injector - Add method for creating a new instance without bean processing There are use-cases where we for example loads the type converter loaded that creates an instance of the class, but we use the injector which does bean post processing by scanning methods for injecting fields / and other autowriting via those Camel annotations. But these type converters are basic and dont need this. There can be some other factory classes too, so lets have a basic injector method so you can choose."
CAMEL-13582,Camel main - Configuration class should support automatic autowire by type,"In such a configuration class
{code}
public class MyConfiguration {

    @BindToRegistry
    public ClientConfiguration myClientConfig() {
        ClientConfiguration cc = new ClientConfiguration();
        cc.setMaxConnections(5);
        return cc;
    }

    @BindToRegistry
    public MyBean myBean(@PropertyInject(""hi"") String hi, @PropertyInject(""bye"") String bye) {
        // this will create an instance of this bean with the name of the method (eg myBean)
        return new MyBean(hi, bye);
    }

    @BindToRegistry
    public AmazonS3 myAmazon(@BeanInject(""myClientConfig"") ClientConfiguration config) {
        return AmazonS3Client.builder().withRegion(""US-EAST-1"").withClientConfiguration(config).build();
    }

    public void configure() {
        // this method is optional and can be removed if no additional configuration is needed.
    }

}
{code}

We could detect that the myAmazon method has a parameter of type ClientConfiguration which we can attempt to lookup as singleton bean. Then you can do

{code}
    @BindToRegistry
    public AmazonS3 myAmazon(ClientConfiguration config) 
{code}",davsclaus,Improvement,Major,Resolved,"Camel main - Configuration class should support automatic autowire by type In such a configuration class
{code}
public class MyConfiguration {

    @BindToRegistry
    public ClientConfiguration myClientConfig() {
        ClientConfiguration cc = new ClientConfiguration();
        cc.setMaxConnections(5);
        return cc;
    }

    @BindToRegistry
    public MyBean myBean(@PropertyInject(""hi"") String hi, @PropertyInject(""bye"") String bye) {
        // this will create an instance of this bean with the name of the method (eg myBean)
        return new MyBean(hi, bye);
    }

    @BindToRegistry
    public AmazonS3 myAmazon(@BeanInject(""myClientConfig"") ClientConfiguration config) {
        return AmazonS3Client.builder().withRegion(""US-EAST-1"").withClientConfiguration(config).build();
    }

    public void configure() {
        // this method is optional and can be removed if no additional configuration is needed.
    }

}
{code}

We could detect that the myAmazon method has a parameter of type ClientConfiguration which we can attempt to lookup as singleton bean. Then you can do

{code}
    @BindToRegistry
    public AmazonS3 myAmazon(ClientConfiguration config) 
{code}"
CAMEL-13581,camel-blueprint - Many WARNs about overriding type converters,"Noticed these during testing CiA2 book

2019-05-27 06:47:06,045 [main           ] WARN  DefaultTypeConverter           - Overriding type converter from: org.apache.camel.support.SimpleTypeConverter@659f226a to: StaticMethodTypeConverter: public static org.restlet.data.Method org.apache.camel.component.restlet.converter.RestletConverter.toMethod(java.lang.String)
2019-05-27 06:47:06,045 [main           ] WARN  DefaultTypeConverter           - Overriding type converter from: org.apache.camel.support.SimpleTypeConverter@2e463f4 to: StaticMethodTypeConverter: public static org.restlet.data.Method[] org.apache.camel.component.restlet.converter.RestletConverter.toMethods(java.lang.String)
2019-05-27 06:47:06,045 [main           ] WARN  DefaultTypeConverter           - Overriding type converter from: org.apache.camel.support.SimpleTypeConverter@32ec9c90 to: StaticMethodTypeConverter: public static org.restlet.data.MediaType[] org.apache.camel.component.restlet.converter.RestletConverter.toMediaTypes(java.lang.String)
2019-05-27 06:47:06,046 [main           ] WARN  DefaultTypeConverter           - Overriding type converter from: org.apache.camel.support.SimpleTypeConverter@36ab3814 to: StaticMethodTypeConverter: public static org.restlet.data.MediaType org.apache.camel.component.restlet.converter.RestletConverter.toMediaType(java.lang.String)
2019-05-27 06:47:06,046 [main           ] WARN  DefaultTypeConverter           - Overriding type converter from: org.apache.camel.support.SimpleTypeConverter@467233e4 to: StaticMethodTypeConverter: public static java.io.InputStream org.apache.camel.http.common.HttpConverter.toInputStream(org.apache.camel.http.common.HttpMessage,org.apache.camel.Exchange) throws java.lang.Exception
2019-05-27 06:47:06,046 [main           ] WARN  DefaultTypeConverter           - Overriding type converter from: org.apache.camel.support.SimpleTypeConverter@427a12b6 to: StaticMethodTypeConverter: public static java.io.InputStream org.apache.camel.http.common.HttpConverter.toInputStream(javax.servlet.http.HttpServletRequest,org.apache.camel.Exchange) throws java.io.IOException
2019-05-27 06:47:06,046 [main           ] WARN  DefaultTypeConverter           - Overriding type converter from: org.apache.camel.support.SimpleTypeConverter@6025d790 to: StaticMethodTypeConverter: public static java.io.BufferedReader org.apache.camel.http.common.HttpConverter.toReader(org.apache.camel.http.common.HttpMessage) throws java.io.IOException
2019-05-27 06:47:06,046 [main           ] WARN  DefaultTypeConverter           - Overriding type converter from: org.apache.camel.support.SimpleTypeConverter@af7e376 to: StaticMethodTypeConverter: public static javax.servlet.http.HttpServletResponse org.apache.camel.http.common.HttpConverter.toServletResponse(org.apache.camel.Message)
2019-05-27 06:47:06,046 [main           ] WARN  DefaultTypeConverter           - Overriding type converter from: org.apache.camel.support.SimpleTypeConverter@5dcd0cdf to: StaticMethodTypeConverter: public static javax.servlet.http.HttpServletRequest org.apache.camel.http.common.HttpConverter.toServletRequest(org.apache.camel.Message)
2019-05-27 06:47:06,047 [main           ] WARN  DefaultTypeConverter           - Overriding type converter from: org.apache.camel.support.SimpleTypeConverter@4fb04a72 to: StaticMethodTypeConverter: public static javax.servlet.ServletInputStream org.apache.camel.http.common.HttpConverter.toServletInputStream(org.apache.camel.http.common.HttpMessage) throws java.io.IOException
2019-05-27 06:47:06,047 [main           ] WARN  DefaultTypeConverter           - Overriding type converter from: org.apache.camel.support.SimpleTypeConverter@1a07bf6 to: StaticMethodTypeConverter: public static java.io.InputStream org.apache.camel.spring.converter.ResourceConverter.convertToInputStream(org.springframework.core.io.Resource) throws java.io.IOException
2019-05-27 06:47:06,047 [main           ] WARN  DefaultTypeConverter           - Overriding type converter from: org.apache.camel.support.SimpleTypeConverter@34d713a2 to: StaticMethodTypeConverter: public static java.lang.Object[] org.apache.camel.component.cxf.converter.CxfConverter.toArray(java.lang.Object)
2019-05-27 06:47:06,047 [main           ] WARN  DefaultTypeConverter           - Overriding type converter from: org.apache.camel.support.SimpleTypeConverter@36aab105 to: StaticMethodTypeConverter: public static java.io.InputStream org.apache.camel.component.cxf.converter.CxfConverter.toInputStream(javax.ws.rs.core.Response,org.apache.camel.Exchange)
2019-05-27 06:47:06,047 [main           ] WARN  DefaultTypeConverter           - Overriding type converter from: org.apache.camel.support.SimpleTypeConverter@889a8a8 to: StaticMethodTypeConverter: public static javax.xml.namespace.QName org.apache.camel.component.cxf.converter.CxfConverter.toQName(java.lang.String)
2019-05-27 06:47:06,047 [main           ] WARN  DefaultTypeConverter           - Overriding type converter from: org.apache.camel.support.SimpleTypeConverter@f29353f to: StaticMethodTypeConverter: public static org.apache.cxf.message.MessageContentsList org.apache.camel.component.cxf.converter.CxfConverter.toMessageContentsList(java.lang.Object[])
2019-05-27 06:47:06,047 [main           ] WARN  DefaultTypeConverter           - Overriding type converter from: org.apache.camel.support.SimpleTypeConverter@36f7d7b to: StaticMethodTypeConverter: public static org.apache.camel.component.cxf.DataFormat org.apache.camel.component.cxf.converter.CxfConverter.toDataFormat(java.lang.String)
2019-05-27 06:47:06,047 [main           ] WARN  DefaultTypeConverter           - Overriding type converter from: org.apache.camel.support.SimpleTypeConverter@60aec68a to: StaticMethodTypeConverter: public static java.lang.String org.apache.camel.component.cxf.converter.CxfConverter.soapMessageToString(javax.xml.soap.SOAPMessage,org.apache.camel.Exchange) throws javax.xml.soap.SOAPException,java.io.IOException
2019-05-27 06:47:06,047 [main           ] WARN  DefaultTypeConverter           - Overriding type converter from: org.apache.camel.support.SimpleTypeConverter@25a7fedf to: StaticMethodTypeConverter: public static java.io.InputStream org.apache.camel.component.cxf.converter.CxfConverter.soapMessageToInputStream(javax.xml.soap.SOAPMessage,org.apache.camel.Exchange) throws javax.xml.soap.SOAPException,java.io.IOException
2019-05-27 06:47:06,047 [main           ] WARN  DefaultTypeConverter           - Overriding type converter from: org.apache.camel.support.SimpleTypeConverter@6361b799 to: StaticMethodTypeConverter: public static org.w3c.dom.NodeList org.apache.camel.component.cxf.converter.CxfPayloadConverter.cxfPayloadToNodeList(org.apache.camel.component.cxf.CxfPayload,org.apache.camel.Exchange)
2019-05-27 06:47:06,047 [main           ] WARN  DefaultTypeConverter           - Overriding type converter from: org.apache.camel.support.SimpleTypeConverter@1b9d9a2b to: StaticMethodTypeConverter: public static org.w3c.dom.Node org.apache.camel.component.cxf.converter.CxfPayloadConverter.cxfPayLoadToNode(org.apache.camel.component.cxf.CxfPayload,org.apache.camel.Exchange)
2019-05-27 06:47:06,047 [main           ] WARN  DefaultTypeConverter           - Overriding type converter from: org.apache.camel.support.SimpleTypeConverter@d919544 to: StaticMethodTypeConverter: public static org.apache.camel.component.cxf.CxfPayload org.apache.camel.component.cxf.converter.CxfPayloadConverter.nodeListToCxfPayload(org.w3c.dom.NodeList,org.apache.camel.Exchange)
2019-05-27 06:47:06,047 [main           ] WARN  DefaultTypeConverter           - Overriding type converter from: org.apache.camel.support.SimpleTypeConverter@17dad32f to: StaticMethodTypeConverter: public static org.apache.camel.component.cxf.CxfPayload org.apache.camel.component.cxf.converter.CxfPayloadConverter.elementToCxfPayload(org.w3c.dom.Element,org.apache.camel.Exchange)
2019-05-27 06:47:06,047 [main           ] WARN  DefaultTypeConverter           - Overriding type converter from: org.apache.camel.support.SimpleTypeConverter@79696332 to: StaticMethodTypeConverter: public static org.apache.camel.component.cxf.CxfPayload org.apache.camel.component.cxf.converter.CxfPayloadConverter.documentToCxfPayload(org.w3c.dom.Document,org.apache.camel.Exchange)
2019-05-27 06:47:06,048 [main           ] WARN  DefaultTypeConverter           - Overriding type converter from: org.apache.camel.support.SimpleTypeConverter@ed2f2f6 to: StaticMethodTypeConverter: public static org.apache.camel.component.cxf.CxfPayload org.apache.camel.component.cxf.converter.CxfPayloadConverter.sourceToCxfPayload(javax.xml.transform.Source,org.apache.camel.Exchange)
2019-05-27 06:47:06,048 [main           ] WARN  DefaultTypeConverter           - Overriding type converter from: org.apache.camel.support.SimpleTypeConverter@fe87ddd to: StaticMethodTypeConverter: public static org.apache.camel.StreamCache org.apache.camel.component.cxf.converter.CxfPayloadConverter.cxfPayLoadToStreamCache(org.apache.camel.component.cxf.CxfPayload,org.apache.camel.Exchange)
2019-05-27 06:47:06,048 [main           ] WARN  DefaultTypeConverter           - Overriding type converter from: org.apache.camel.support.SimpleTypeConverter@4eea94a4 to: StaticMethodTypeConverter: public static javax.xml.transform.Source org.apache.camel.component.cxf.converter.CxfPayloadConverter.cxfPayLoadToSource(org.apache.camel.component.cxf.CxfPayload,org.apache.camel.Exchange)
2019-05-27 06:47:06,048 [main           ] WARN  DefaultTypeConverter           - Overriding type converter from: org.apache.camel.support.SimpleTypeConverter@29be997f to: StaticMethodTypeConverter: public static java.io.InputStream org.apache.camel.component.file.GenericFileConverter.genericFileToInputStream(org.apache.camel.component.file.GenericFile,org.apache.camel.Exchange) throws java.io.IOException
2019-05-27 06:47:06,048 [main           ] WARN  DefaultTypeConverter           - Overriding type converter from: org.apache.camel.support.SimpleTypeConverter@33eb6758 to: StaticMethodTypeConverter: public static java.lang.String org.apache.camel.component.file.GenericFileConverter.genericFileToString(org.apache.camel.component.file.GenericFile,org.apache.camel.Exchange) throws java.io.IOException,org.apache.camel.NoTypeConversionAvailableException
2019-05-27 06:47:06,048 [main           ] WARN  DefaultTypeConverter           - Overriding type converter from: org.apache.camel.support.SimpleTypeConverter@f8a6243 to: StaticMethodTypeConverter: public static java.io.Serializable org.apache.camel.component.file.GenericFileConverter.genericFileToSerializable(org.apache.camel.component.file.GenericFile,org.apache.camel.Exchange) throws java.io.IOException
2019-05-27 06:47:06,048 [main           ] WARN  DefaultTypeConverter           - Overriding type converter from: org.apache.camel.support.SimpleTypeConverter@7f9e8421 to: StaticMethodTypeConverter: public static org.apache.camel.StreamCache org.apache.camel.converter.stream.StreamCacheConverter.convertToStreamCache(java.io.ByteArrayInputStream,org.apache.camel.Exchange) throws java.io.IOException
2019-05-27 06:47:06,048 [main           ] WARN  DefaultTypeConverter           - Overriding type converter from: org.apache.camel.support.SimpleTypeConverter@23da79eb to: StaticMethodTypeConverter: public static org.apache.camel.StreamCache org.apache.camel.converter.stream.StreamCacheConverter.convertToStreamCache(java.io.InputStream,org.apache.camel.Exchange) throws java.io.IOException
2019-05-27 06:47:06,048 [main           ] WARN  DefaultTypeConverter           - Overriding type converter from: org.apache.camel.support.SimpleTypeConverter@168b4cb0 to: StaticMethodTypeConverter: public static org.apache.camel.StreamCache org.apache.camel.converter.stream.StreamCacheConverter.convertToStreamCache(org.apache.camel.converter.stream.CachedOutputStream,org.apache.camel.Exchange) throws java.io.IOException
2019-05-27 06:47:06,048 [main           ] WARN  DefaultTypeConverter           - Overriding type converter from: org.apache.camel.support.SimpleTypeConverter@3e05586b to: StaticMethodTypeConverter: public static org.apache.camel.StreamCache org.apache.camel.converter.stream.StreamCacheConverter.convertToStreamCache(java.io.Reader,org.apache.camel.Exchange) throws java.io.IOException
2019-05-27 06:47:06,048 [main           ] WARN  DefaultTypeConverter           - Overriding type converter from: org.apache.camel.support.SimpleTypeConverter@35b17c06 to: StaticMethodTypeConverter: public static org.apache.camel.StreamCache org.apache.camel.converter.stream.StreamCacheConverter.convertToStreamCache(javax.xml.transform.stream.StreamSource,org.apache.camel.Exchange) throws java.io.IOException
2019-05-27 06:47:06,048 [main           ] WARN  DefaultTypeConverter           - Overriding type converter from: org.apache.camel.support.SimpleTypeConverter@45545e7a to: StaticMethodTypeConverter: public static org.apache.camel.StreamCache org.apache.camel.converter.stream.StreamCacheConverter.convertToStreamCache(org.apache.camel.StringSource)
2019-05-27 06:47:06,048 [main           ] WARN  DefaultTypeConverter           - Overriding type converter from: org.apache.camel.support.SimpleTypeConverter@9f674ac to: StaticMethodTypeConverter: public static org.apache.camel.StreamCache org.apache.camel.converter.stream.StreamCacheConverter.convertToStreamCache(org.apache.camel.BytesSource)
2019-05-27 06:47:06,048 [main           ] WARN  DefaultTypeConverter           - Overriding type converter from: org.apache.camel.support.SimpleTypeConverter@1da4b3f9 to: StaticMethodTypeConverter: public static org.apache.camel.StreamCache org.apache.camel.converter.stream.StreamCacheConverter.convertToStreamCache(javax.xml.transform.sax.SAXSource,org.apache.camel.Exchange) throws javax.xml.transform.TransformerException
2019-05-27 06:47:06,048 [main           ] WARN  DefaultTypeConverter           - Overriding type converter from: org.apache.camel.support.SimpleTypeConverter@23cbbd07 to: StaticMethodTypeConverter: public static java.nio.ByteBuffer org.apache.camel.converter.stream.StreamCacheConverter.convertToByteBuffer(org.apache.camel.StreamCache,org.apache.camel.Exchange) throws java.io.IOException
2019-05-27 06:47:06,048 [main           ] WARN  DefaultTypeConverter           - Overriding type converter from: org.apache.camel.support.SimpleTypeConverter@448b808a to: StaticMethodTypeConverter: public static java.io.Serializable org.apache.camel.converter.stream.StreamCacheConverter.convertToSerializable(org.apache.camel.StreamCache,org.apache.camel.Exchange) throws java.io.IOException
2019-05-27 06:47:06,048 [main           ] WARN  DefaultTypeConverter           - Overriding type converter from: org.apache.camel.support.SimpleTypeConverter@7e62cfa3 to: StaticMethodTypeConverter: public static byte[] org.apache.camel.converter.stream.StreamCacheConverter.convertToByteArray(org.apache.camel.StreamCache,org.apache.camel.Exchange) throws java.io.IOException
2019-05-27 06:47:06,049 [main           ] WARN  DefaultTypeConverter           - Overriding type converter from: StaticMethodTypeConverter: public static org.apache.camel.StreamCache org.apache.camel.converter.stream.StreamCacheConverter.convertToStreamCache(java.io.ByteArrayInputStream,org.apache.camel.Exchange) throws java.io.IOException to: StaticMethodTypeConverter: public static org.apache.camel.StreamCache org.apache.camel.converter.stream.StreamCacheConverter.convertToStreamCache(java.io.ByteArrayInputStream,org.apache.camel.Exchange) throws java.io.IOException
2019-05-27 06:47:06,049 [main           ] WARN  DefaultTypeConverter           - Overriding type converter from: StaticMethodTypeConverter: public static org.apache.camel.StreamCache org.apache.camel.converter.stream.StreamCacheConverter.convertToStreamCache(java.io.InputStream,org.apache.camel.Exchange) throws java.io.IOException to: StaticMethodTypeConverter: public static org.apache.camel.StreamCache org.apache.camel.converter.stream.StreamCacheConverter.convertToStreamCache(java.io.InputStream,org.apache.camel.Exchange) throws java.io.IOException
2019-05-27 06:47:06,049 [main           ] WARN  DefaultTypeConverter           - Overriding type converter from: StaticMethodTypeConverter: public static org.apache.camel.StreamCache org.apache.camel.converter.stream.StreamCacheConverter.convertToStreamCache(org.apache.camel.converter.stream.CachedOutputStream,org.apache.camel.Exchange) throws java.io.IOException to: StaticMethodTypeConverter: public static org.apache.camel.StreamCache org.apache.camel.converter.stream.StreamCacheConverter.convertToStreamCache(org.apache.camel.converter.stream.CachedOutputStream,org.apache.camel.Exchange) throws java.io.IOException
2019-05-27 06:47:06,049 [main           ] WARN  DefaultTypeConverter           - Overriding type converter from: StaticMethodTypeConverter: public static org.apache.camel.StreamCache org.apache.camel.converter.stream.StreamCacheConverter.convertToStreamCache(java.io.Reader,org.apache.camel.Exchange) throws java.io.IOException to: StaticMethodTypeConverter: public static org.apache.camel.StreamCache org.apache.camel.converter.stream.StreamCacheConverter.convertToStreamCache(java.io.Reader,org.apache.camel.Exchange) throws java.io.IOException
2019-05-27 06:47:06,049 [main           ] WARN  DefaultTypeConverter           - Overriding type converter from: StaticMethodTypeConverter: public static org.apache.camel.StreamCache org.apache.camel.converter.stream.StreamCacheConverter.convertToStreamCache(javax.xml.transform.stream.StreamSource,org.apache.camel.Exchange) throws java.io.IOException to: StaticMethodTypeConverter: public static org.apache.camel.StreamCache org.apache.camel.converter.stream.StreamCacheConverter.convertToStreamCache(javax.xml.transform.stream.StreamSource,org.apache.camel.Exchange) throws java.io.IOException
2019-05-27 06:47:06,049 [main           ] WARN  DefaultTypeConverter           - Overriding type converter from: StaticMethodTypeConverter: public static org.apache.camel.StreamCache org.apache.camel.converter.stream.StreamCacheConverter.convertToStreamCache(org.apache.camel.StringSource) to: StaticMethodTypeConverter: public static org.apache.camel.StreamCache org.apache.camel.converter.stream.StreamCacheConverter.convertToStreamCache(org.apache.camel.StringSource)
2019-05-27 06:47:06,049 [main           ] WARN  DefaultTypeConverter           - Overriding type converter from: StaticMethodTypeConverter: public static org.apache.camel.StreamCache org.apache.camel.converter.stream.StreamCacheConverter.convertToStreamCache(org.apache.camel.BytesSource) to: StaticMethodTypeConverter: public static org.apache.camel.StreamCache org.apache.camel.converter.stream.StreamCacheConverter.convertToStreamCache(org.apache.camel.BytesSource)
2019-05-27 06:47:06,050 [main           ] WARN  DefaultTypeConverter           - Overriding type converter from: StaticMethodTypeConverter: public static org.apache.camel.StreamCache org.apache.camel.converter.stream.StreamCacheConverter.convertToStreamCache(javax.xml.transform.sax.SAXSource,org.apache.camel.Exchange) throws javax.xml.transform.TransformerException to: StaticMethodTypeConverter: public static org.apache.camel.StreamCache org.apache.camel.converter.stream.StreamCacheConverter.convertToStreamCache(javax.xml.transform.sax.SAXSource,org.apache.camel.Exchange) throws javax.xml.transform.TransformerException
2019-05-27 06:47:06,050 [main           ] WARN  DefaultTypeConverter           - Overriding type converter from: StaticMethodTypeConverter: public static java.nio.ByteBuffer org.apache.camel.converter.stream.StreamCacheConverter.convertToByteBuffer(org.apache.camel.StreamCache,org.apache.camel.Exchange) throws java.io.IOException to: StaticMethodTypeConverter: public static java.nio.ByteBuffer org.apache.camel.converter.stream.StreamCacheConverter.convertToByteBuffer(org.apache.camel.StreamCache,org.apache.camel.Exchange) throws java.io.IOException
2019-05-27 06:47:06,050 [main           ] WARN  DefaultTypeConverter           - Overriding type converter from: StaticMethodTypeConverter: public static java.io.Serializable org.apache.camel.converter.stream.StreamCacheConverter.convertToSerializable(org.apache.camel.StreamCache,org.apache.camel.Exchange) throws java.io.IOException to: StaticMethodTypeConverter: public static java.io.Serializable org.apache.camel.converter.stream.StreamCacheConverter.convertToSerializable(org.apache.camel.StreamCache,org.apache.camel.Exchange) throws java.io.IOException
2019-05-27 06:47:06,050 [main           ] WARN  DefaultTypeConverter           - Overriding type converter from: StaticMethodTypeConverter: public static byte[] org.apache.camel.converter.stream.StreamCacheConverter.convertToByteArray(org.apache.camel.StreamCache,org.apache.camel.Exchange) throws java.io.IOException to: StaticMethodTypeConverter: public static byte[] org.apache.camel.converter.stream.StreamCacheConverter.convertToByteArray(org.apache.camel.StreamCache,org.apache.camel.Exchange) throws java.io.IOException",davsclaus,Task,Minor,Resolved,"camel-blueprint - Many WARNs about overriding type converters Noticed these during testing CiA2 book

2019-05-27 06:47:06,045 [main           ] WARN  DefaultTypeConverter           - Overriding type converter from: org.apache.camel.support.SimpleTypeConverter@659f226a to: StaticMethodTypeConverter: public static org.restlet.data.Method org.apache.camel.component.restlet.converter.RestletConverter.toMethod(java.lang.String)
2019-05-27 06:47:06,045 [main           ] WARN  DefaultTypeConverter           - Overriding type converter from: org.apache.camel.support.SimpleTypeConverter@2e463f4 to: StaticMethodTypeConverter: public static org.restlet.data.Method[] org.apache.camel.component.restlet.converter.RestletConverter.toMethods(java.lang.String)
2019-05-27 06:47:06,045 [main           ] WARN  DefaultTypeConverter           - Overriding type converter from: org.apache.camel.support.SimpleTypeConverter@32ec9c90 to: StaticMethodTypeConverter: public static org.restlet.data.MediaType[] org.apache.camel.component.restlet.converter.RestletConverter.toMediaTypes(java.lang.String)
2019-05-27 06:47:06,046 [main           ] WARN  DefaultTypeConverter           - Overriding type converter from: org.apache.camel.support.SimpleTypeConverter@36ab3814 to: StaticMethodTypeConverter: public static org.restlet.data.MediaType org.apache.camel.component.restlet.converter.RestletConverter.toMediaType(java.lang.String)
2019-05-27 06:47:06,046 [main           ] WARN  DefaultTypeConverter           - Overriding type converter from: org.apache.camel.support.SimpleTypeConverter@467233e4 to: StaticMethodTypeConverter: public static java.io.InputStream org.apache.camel.http.common.HttpConverter.toInputStream(org.apache.camel.http.common.HttpMessage,org.apache.camel.Exchange) throws java.lang.Exception
2019-05-27 06:47:06,046 [main           ] WARN  DefaultTypeConverter           - Overriding type converter from: org.apache.camel.support.SimpleTypeConverter@427a12b6 to: StaticMethodTypeConverter: public static java.io.InputStream org.apache.camel.http.common.HttpConverter.toInputStream(javax.servlet.http.HttpServletRequest,org.apache.camel.Exchange) throws java.io.IOException
2019-05-27 06:47:06,046 [main           ] WARN  DefaultTypeConverter           - Overriding type converter from: org.apache.camel.support.SimpleTypeConverter@6025d790 to: StaticMethodTypeConverter: public static java.io.BufferedReader org.apache.camel.http.common.HttpConverter.toReader(org.apache.camel.http.common.HttpMessage) throws java.io.IOException
2019-05-27 06:47:06,046 [main           ] WARN  DefaultTypeConverter           - Overriding type converter from: org.apache.camel.support.SimpleTypeConverter@af7e376 to: StaticMethodTypeConverter: public static javax.servlet.http.HttpServletResponse org.apache.camel.http.common.HttpConverter.toServletResponse(org.apache.camel.Message)
2019-05-27 06:47:06,046 [main           ] WARN  DefaultTypeConverter           - Overriding type converter from: org.apache.camel.support.SimpleTypeConverter@5dcd0cdf to: StaticMethodTypeConverter: public static javax.servlet.http.HttpServletRequest org.apache.camel.http.common.HttpConverter.toServletRequest(org.apache.camel.Message)
2019-05-27 06:47:06,047 [main           ] WARN  DefaultTypeConverter           - Overriding type converter from: org.apache.camel.support.SimpleTypeConverter@4fb04a72 to: StaticMethodTypeConverter: public static javax.servlet.ServletInputStream org.apache.camel.http.common.HttpConverter.toServletInputStream(org.apache.camel.http.common.HttpMessage) throws java.io.IOException
2019-05-27 06:47:06,047 [main           ] WARN  DefaultTypeConverter           - Overriding type converter from: org.apache.camel.support.SimpleTypeConverter@1a07bf6 to: StaticMethodTypeConverter: public static java.io.InputStream org.apache.camel.spring.converter.ResourceConverter.convertToInputStream(org.springframework.core.io.Resource) throws java.io.IOException
2019-05-27 06:47:06,047 [main           ] WARN  DefaultTypeConverter           - Overriding type converter from: org.apache.camel.support.SimpleTypeConverter@34d713a2 to: StaticMethodTypeConverter: public static java.lang.Object[] org.apache.camel.component.cxf.converter.CxfConverter.toArray(java.lang.Object)
2019-05-27 06:47:06,047 [main           ] WARN  DefaultTypeConverter           - Overriding type converter from: org.apache.camel.support.SimpleTypeConverter@36aab105 to: StaticMethodTypeConverter: public static java.io.InputStream org.apache.camel.component.cxf.converter.CxfConverter.toInputStream(javax.ws.rs.core.Response,org.apache.camel.Exchange)
2019-05-27 06:47:06,047 [main           ] WARN  DefaultTypeConverter           - Overriding type converter from: org.apache.camel.support.SimpleTypeConverter@889a8a8 to: StaticMethodTypeConverter: public static javax.xml.namespace.QName org.apache.camel.component.cxf.converter.CxfConverter.toQName(java.lang.String)
2019-05-27 06:47:06,047 [main           ] WARN  DefaultTypeConverter           - Overriding type converter from: org.apache.camel.support.SimpleTypeConverter@f29353f to: StaticMethodTypeConverter: public static org.apache.cxf.message.MessageContentsList org.apache.camel.component.cxf.converter.CxfConverter.toMessageContentsList(java.lang.Object[])
2019-05-27 06:47:06,047 [main           ] WARN  DefaultTypeConverter           - Overriding type converter from: org.apache.camel.support.SimpleTypeConverter@36f7d7b to: StaticMethodTypeConverter: public static org.apache.camel.component.cxf.DataFormat org.apache.camel.component.cxf.converter.CxfConverter.toDataFormat(java.lang.String)
2019-05-27 06:47:06,047 [main           ] WARN  DefaultTypeConverter           - Overriding type converter from: org.apache.camel.support.SimpleTypeConverter@60aec68a to: StaticMethodTypeConverter: public static java.lang.String org.apache.camel.component.cxf.converter.CxfConverter.soapMessageToString(javax.xml.soap.SOAPMessage,org.apache.camel.Exchange) throws javax.xml.soap.SOAPException,java.io.IOException
2019-05-27 06:47:06,047 [main           ] WARN  DefaultTypeConverter           - Overriding type converter from: org.apache.camel.support.SimpleTypeConverter@25a7fedf to: StaticMethodTypeConverter: public static java.io.InputStream org.apache.camel.component.cxf.converter.CxfConverter.soapMessageToInputStream(javax.xml.soap.SOAPMessage,org.apache.camel.Exchange) throws javax.xml.soap.SOAPException,java.io.IOException
2019-05-27 06:47:06,047 [main           ] WARN  DefaultTypeConverter           - Overriding type converter from: org.apache.camel.support.SimpleTypeConverter@6361b799 to: StaticMethodTypeConverter: public static org.w3c.dom.NodeList org.apache.camel.component.cxf.converter.CxfPayloadConverter.cxfPayloadToNodeList(org.apache.camel.component.cxf.CxfPayload,org.apache.camel.Exchange)
2019-05-27 06:47:06,047 [main           ] WARN  DefaultTypeConverter           - Overriding type converter from: org.apache.camel.support.SimpleTypeConverter@1b9d9a2b to: StaticMethodTypeConverter: public static org.w3c.dom.Node org.apache.camel.component.cxf.converter.CxfPayloadConverter.cxfPayLoadToNode(org.apache.camel.component.cxf.CxfPayload,org.apache.camel.Exchange)
2019-05-27 06:47:06,047 [main           ] WARN  DefaultTypeConverter           - Overriding type converter from: org.apache.camel.support.SimpleTypeConverter@d919544 to: StaticMethodTypeConverter: public static org.apache.camel.component.cxf.CxfPayload org.apache.camel.component.cxf.converter.CxfPayloadConverter.nodeListToCxfPayload(org.w3c.dom.NodeList,org.apache.camel.Exchange)
2019-05-27 06:47:06,047 [main           ] WARN  DefaultTypeConverter           - Overriding type converter from: org.apache.camel.support.SimpleTypeConverter@17dad32f to: StaticMethodTypeConverter: public static org.apache.camel.component.cxf.CxfPayload org.apache.camel.component.cxf.converter.CxfPayloadConverter.elementToCxfPayload(org.w3c.dom.Element,org.apache.camel.Exchange)
2019-05-27 06:47:06,047 [main           ] WARN  DefaultTypeConverter           - Overriding type converter from: org.apache.camel.support.SimpleTypeConverter@79696332 to: StaticMethodTypeConverter: public static org.apache.camel.component.cxf.CxfPayload org.apache.camel.component.cxf.converter.CxfPayloadConverter.documentToCxfPayload(org.w3c.dom.Document,org.apache.camel.Exchange)
2019-05-27 06:47:06,048 [main           ] WARN  DefaultTypeConverter           - Overriding type converter from: org.apache.camel.support.SimpleTypeConverter@ed2f2f6 to: StaticMethodTypeConverter: public static org.apache.camel.component.cxf.CxfPayload org.apache.camel.component.cxf.converter.CxfPayloadConverter.sourceToCxfPayload(javax.xml.transform.Source,org.apache.camel.Exchange)
2019-05-27 06:47:06,048 [main           ] WARN  DefaultTypeConverter           - Overriding type converter from: org.apache.camel.support.SimpleTypeConverter@fe87ddd to: StaticMethodTypeConverter: public static org.apache.camel.StreamCache org.apache.camel.component.cxf.converter.CxfPayloadConverter.cxfPayLoadToStreamCache(org.apache.camel.component.cxf.CxfPayload,org.apache.camel.Exchange)
2019-05-27 06:47:06,048 [main           ] WARN  DefaultTypeConverter           - Overriding type converter from: org.apache.camel.support.SimpleTypeConverter@4eea94a4 to: StaticMethodTypeConverter: public static javax.xml.transform.Source org.apache.camel.component.cxf.converter.CxfPayloadConverter.cxfPayLoadToSource(org.apache.camel.component.cxf.CxfPayload,org.apache.camel.Exchange)
2019-05-27 06:47:06,048 [main           ] WARN  DefaultTypeConverter           - Overriding type converter from: org.apache.camel.support.SimpleTypeConverter@29be997f to: StaticMethodTypeConverter: public static java.io.InputStream org.apache.camel.component.file.GenericFileConverter.genericFileToInputStream(org.apache.camel.component.file.GenericFile,org.apache.camel.Exchange) throws java.io.IOException
2019-05-27 06:47:06,048 [main           ] WARN  DefaultTypeConverter           - Overriding type converter from: org.apache.camel.support.SimpleTypeConverter@33eb6758 to: StaticMethodTypeConverter: public static java.lang.String org.apache.camel.component.file.GenericFileConverter.genericFileToString(org.apache.camel.component.file.GenericFile,org.apache.camel.Exchange) throws java.io.IOException,org.apache.camel.NoTypeConversionAvailableException
2019-05-27 06:47:06,048 [main           ] WARN  DefaultTypeConverter           - Overriding type converter from: org.apache.camel.support.SimpleTypeConverter@f8a6243 to: StaticMethodTypeConverter: public static java.io.Serializable org.apache.camel.component.file.GenericFileConverter.genericFileToSerializable(org.apache.camel.component.file.GenericFile,org.apache.camel.Exchange) throws java.io.IOException
2019-05-27 06:47:06,048 [main           ] WARN  DefaultTypeConverter           - Overriding type converter from: org.apache.camel.support.SimpleTypeConverter@7f9e8421 to: StaticMethodTypeConverter: public static org.apache.camel.StreamCache org.apache.camel.converter.stream.StreamCacheConverter.convertToStreamCache(java.io.ByteArrayInputStream,org.apache.camel.Exchange) throws java.io.IOException
2019-05-27 06:47:06,048 [main           ] WARN  DefaultTypeConverter           - Overriding type converter from: org.apache.camel.support.SimpleTypeConverter@23da79eb to: StaticMethodTypeConverter: public static org.apache.camel.StreamCache org.apache.camel.converter.stream.StreamCacheConverter.convertToStreamCache(java.io.InputStream,org.apache.camel.Exchange) throws java.io.IOException
2019-05-27 06:47:06,048 [main           ] WARN  DefaultTypeConverter           - Overriding type converter from: org.apache.camel.support.SimpleTypeConverter@168b4cb0 to: StaticMethodTypeConverter: public static org.apache.camel.StreamCache org.apache.camel.converter.stream.StreamCacheConverter.convertToStreamCache(org.apache.camel.converter.stream.CachedOutputStream,org.apache.camel.Exchange) throws java.io.IOException
2019-05-27 06:47:06,048 [main           ] WARN  DefaultTypeConverter           - Overriding type converter from: org.apache.camel.support.SimpleTypeConverter@3e05586b to: StaticMethodTypeConverter: public static org.apache.camel.StreamCache org.apache.camel.converter.stream.StreamCacheConverter.convertToStreamCache(java.io.Reader,org.apache.camel.Exchange) throws java.io.IOException
2019-05-27 06:47:06,048 [main           ] WARN  DefaultTypeConverter           - Overriding type converter from: org.apache.camel.support.SimpleTypeConverter@35b17c06 to: StaticMethodTypeConverter: public static org.apache.camel.StreamCache org.apache.camel.converter.stream.StreamCacheConverter.convertToStreamCache(javax.xml.transform.stream.StreamSource,org.apache.camel.Exchange) throws java.io.IOException
2019-05-27 06:47:06,048 [main           ] WARN  DefaultTypeConverter           - Overriding type converter from: org.apache.camel.support.SimpleTypeConverter@45545e7a to: StaticMethodTypeConverter: public static org.apache.camel.StreamCache org.apache.camel.converter.stream.StreamCacheConverter.convertToStreamCache(org.apache.camel.StringSource)
2019-05-27 06:47:06,048 [main           ] WARN  DefaultTypeConverter           - Overriding type converter from: org.apache.camel.support.SimpleTypeConverter@9f674ac to: StaticMethodTypeConverter: public static org.apache.camel.StreamCache org.apache.camel.converter.stream.StreamCacheConverter.convertToStreamCache(org.apache.camel.BytesSource)
2019-05-27 06:47:06,048 [main           ] WARN  DefaultTypeConverter           - Overriding type converter from: org.apache.camel.support.SimpleTypeConverter@1da4b3f9 to: StaticMethodTypeConverter: public static org.apache.camel.StreamCache org.apache.camel.converter.stream.StreamCacheConverter.convertToStreamCache(javax.xml.transform.sax.SAXSource,org.apache.camel.Exchange) throws javax.xml.transform.TransformerException
2019-05-27 06:47:06,048 [main           ] WARN  DefaultTypeConverter           - Overriding type converter from: org.apache.camel.support.SimpleTypeConverter@23cbbd07 to: StaticMethodTypeConverter: public static java.nio.ByteBuffer org.apache.camel.converter.stream.StreamCacheConverter.convertToByteBuffer(org.apache.camel.StreamCache,org.apache.camel.Exchange) throws java.io.IOException
2019-05-27 06:47:06,048 [main           ] WARN  DefaultTypeConverter           - Overriding type converter from: org.apache.camel.support.SimpleTypeConverter@448b808a to: StaticMethodTypeConverter: public static java.io.Serializable org.apache.camel.converter.stream.StreamCacheConverter.convertToSerializable(org.apache.camel.StreamCache,org.apache.camel.Exchange) throws java.io.IOException
2019-05-27 06:47:06,048 [main           ] WARN  DefaultTypeConverter           - Overriding type converter from: org.apache.camel.support.SimpleTypeConverter@7e62cfa3 to: StaticMethodTypeConverter: public static byte[] org.apache.camel.converter.stream.StreamCacheConverter.convertToByteArray(org.apache.camel.StreamCache,org.apache.camel.Exchange) throws java.io.IOException
2019-05-27 06:47:06,049 [main           ] WARN  DefaultTypeConverter           - Overriding type converter from: StaticMethodTypeConverter: public static org.apache.camel.StreamCache org.apache.camel.converter.stream.StreamCacheConverter.convertToStreamCache(java.io.ByteArrayInputStream,org.apache.camel.Exchange) throws java.io.IOException to: StaticMethodTypeConverter: public static org.apache.camel.StreamCache org.apache.camel.converter.stream.StreamCacheConverter.convertToStreamCache(java.io.ByteArrayInputStream,org.apache.camel.Exchange) throws java.io.IOException
2019-05-27 06:47:06,049 [main           ] WARN  DefaultTypeConverter           - Overriding type converter from: StaticMethodTypeConverter: public static org.apache.camel.StreamCache org.apache.camel.converter.stream.StreamCacheConverter.convertToStreamCache(java.io.InputStream,org.apache.camel.Exchange) throws java.io.IOException to: StaticMethodTypeConverter: public static org.apache.camel.StreamCache org.apache.camel.converter.stream.StreamCacheConverter.convertToStreamCache(java.io.InputStream,org.apache.camel.Exchange) throws java.io.IOException
2019-05-27 06:47:06,049 [main           ] WARN  DefaultTypeConverter           - Overriding type converter from: StaticMethodTypeConverter: public static org.apache.camel.StreamCache org.apache.camel.converter.stream.StreamCacheConverter.convertToStreamCache(org.apache.camel.converter.stream.CachedOutputStream,org.apache.camel.Exchange) throws java.io.IOException to: StaticMethodTypeConverter: public static org.apache.camel.StreamCache org.apache.camel.converter.stream.StreamCacheConverter.convertToStreamCache(org.apache.camel.converter.stream.CachedOutputStream,org.apache.camel.Exchange) throws java.io.IOException
2019-05-27 06:47:06,049 [main           ] WARN  DefaultTypeConverter           - Overriding type converter from: StaticMethodTypeConverter: public static org.apache.camel.StreamCache org.apache.camel.converter.stream.StreamCacheConverter.convertToStreamCache(java.io.Reader,org.apache.camel.Exchange) throws java.io.IOException to: StaticMethodTypeConverter: public static org.apache.camel.StreamCache org.apache.camel.converter.stream.StreamCacheConverter.convertToStreamCache(java.io.Reader,org.apache.camel.Exchange) throws java.io.IOException
2019-05-27 06:47:06,049 [main           ] WARN  DefaultTypeConverter           - Overriding type converter from: StaticMethodTypeConverter: public static org.apache.camel.StreamCache org.apache.camel.converter.stream.StreamCacheConverter.convertToStreamCache(javax.xml.transform.stream.StreamSource,org.apache.camel.Exchange) throws java.io.IOException to: StaticMethodTypeConverter: public static org.apache.camel.StreamCache org.apache.camel.converter.stream.StreamCacheConverter.convertToStreamCache(javax.xml.transform.stream.StreamSource,org.apache.camel.Exchange) throws java.io.IOException
2019-05-27 06:47:06,049 [main           ] WARN  DefaultTypeConverter           - Overriding type converter from: StaticMethodTypeConverter: public static org.apache.camel.StreamCache org.apache.camel.converter.stream.StreamCacheConverter.convertToStreamCache(org.apache.camel.StringSource) to: StaticMethodTypeConverter: public static org.apache.camel.StreamCache org.apache.camel.converter.stream.StreamCacheConverter.convertToStreamCache(org.apache.camel.StringSource)
2019-05-27 06:47:06,049 [main           ] WARN  DefaultTypeConverter           - Overriding type converter from: StaticMethodTypeConverter: public static org.apache.camel.StreamCache org.apache.camel.converter.stream.StreamCacheConverter.convertToStreamCache(org.apache.camel.BytesSource) to: StaticMethodTypeConverter: public static org.apache.camel.StreamCache org.apache.camel.converter.stream.StreamCacheConverter.convertToStreamCache(org.apache.camel.BytesSource)
2019-05-27 06:47:06,050 [main           ] WARN  DefaultTypeConverter           - Overriding type converter from: StaticMethodTypeConverter: public static org.apache.camel.StreamCache org.apache.camel.converter.stream.StreamCacheConverter.convertToStreamCache(javax.xml.transform.sax.SAXSource,org.apache.camel.Exchange) throws javax.xml.transform.TransformerException to: StaticMethodTypeConverter: public static org.apache.camel.StreamCache org.apache.camel.converter.stream.StreamCacheConverter.convertToStreamCache(javax.xml.transform.sax.SAXSource,org.apache.camel.Exchange) throws javax.xml.transform.TransformerException
2019-05-27 06:47:06,050 [main           ] WARN  DefaultTypeConverter           - Overriding type converter from: StaticMethodTypeConverter: public static java.nio.ByteBuffer org.apache.camel.converter.stream.StreamCacheConverter.convertToByteBuffer(org.apache.camel.StreamCache,org.apache.camel.Exchange) throws java.io.IOException to: StaticMethodTypeConverter: public static java.nio.ByteBuffer org.apache.camel.converter.stream.StreamCacheConverter.convertToByteBuffer(org.apache.camel.StreamCache,org.apache.camel.Exchange) throws java.io.IOException
2019-05-27 06:47:06,050 [main           ] WARN  DefaultTypeConverter           - Overriding type converter from: StaticMethodTypeConverter: public static java.io.Serializable org.apache.camel.converter.stream.StreamCacheConverter.convertToSerializable(org.apache.camel.StreamCache,org.apache.camel.Exchange) throws java.io.IOException to: StaticMethodTypeConverter: public static java.io.Serializable org.apache.camel.converter.stream.StreamCacheConverter.convertToSerializable(org.apache.camel.StreamCache,org.apache.camel.Exchange) throws java.io.IOException
2019-05-27 06:47:06,050 [main           ] WARN  DefaultTypeConverter           - Overriding type converter from: StaticMethodTypeConverter: public static byte[] org.apache.camel.converter.stream.StreamCacheConverter.convertToByteArray(org.apache.camel.StreamCache,org.apache.camel.Exchange) throws java.io.IOException to: StaticMethodTypeConverter: public static byte[] org.apache.camel.converter.stream.StreamCacheConverter.convertToByteArray(org.apache.camel.StreamCache,org.apache.camel.Exchange) throws java.io.IOException"
CAMEL-13580,camel-zookeeper - Deprecate route master/slave policy,"As the camel-zookeeper-master component is better at handling this. So lets deprecate this in Camel 2.x, and remove in 3.0",davsclaus,Improvement,Major,Resolved,"camel-zookeeper - Deprecate route master/slave policy As the camel-zookeeper-master component is better at handling this. So lets deprecate this in Camel 2.x, and remove in 3.0"
CAMEL-13569,JndiContext - Remove old bean binding,"There is some old code that allows to define in jndi.properties beans with .class etc to create these beans via basic class loading that was from Camel 1.x time and nobody uses.

This should be removed",davsclaus,Improvement,Major,Resolved,"JndiContext - Remove old bean binding There is some old code that allows to define in jndi.properties beans with .class etc to create these beans via basic class loading that was from Camel 1.x time and nobody uses.

This should be removed"
CAMEL-13566,IntrospectionSupport - Remove old legacy JDK PropertyEditor,"There is some old code using JDK

PropertyEditor editor = PropertyEditorManager.findEditor(type);

But this is no longer in use as we really use camel's type converter. That above is also slow and not thread safe and was intended for java swing/beans stuff and some cruft from very old times. Lets try to get rid of it.",davsclaus,Improvement,Major,Resolved,"IntrospectionSupport - Remove old legacy JDK PropertyEditor There is some old code using JDK

PropertyEditor editor = PropertyEditorManager.findEditor(type);

But this is no longer in use as we really use camel's type converter. That above is also slow and not thread safe and was intended for java swing/beans stuff and some cruft from very old times. Lets try to get rid of it."
CAMEL-13561,camel-hystrix - HystrixBadRequestException is swallowed,"CAMEL-13066 fixed a problem that HystrixBadRequestExceptions caused the fallback processor being executed.

However, it seems that due to this fix the exception is simply thrown away and the route proceeds as if no error has occurred. This is certainly not the intended behavior.

As I understand it, the HystrixBadRequestExceptions should simply be thrown out of the HystrixProcessor, but without any fallback processor being triggered or circuit being opened",davsclaus,Bug,Major,Resolved,"camel-hystrix - HystrixBadRequestException is swallowed CAMEL-13066 fixed a problem that HystrixBadRequestExceptions caused the fallback processor being executed.

However, it seems that due to this fix the exception is simply thrown away and the route proceeds as if no error has occurred. This is certainly not the intended behavior.

As I understand it, the HystrixBadRequestExceptions should simply be thrown out of the HystrixProcessor, but without any fallback processor being triggered or circuit being opened"
CAMEL-13557,Support for nested properties binding,"As today properties binding does not work for nested objects so assuming I have a class like:

{code:java}
class MyComponent {
    
    public void setFoo(String foo) {
        this.foo = foo;
    }

    public String getFoo() {
        return foo;
    }

    public void setConfiguration(Configuration conf) {
        this.conf = conf;
    }

    public Configuration getConfiguration() {
        return conf;
    }

    static class Configuration {
    
        public void setBar(String bar) {
            this.bar = bar
        }

        public String getBar() {
            return bar
        }
    }
}
{code}

And a set of properties like:

{code}
myComponent.foo = ""foo""
myComponent.conf.bar = ""bar""
{code}

Then only MyComponent.foo will be set but it would be nice if the binding framework could navigate the property using dot notation and set any dependent object.
",davsclaus,New Feature,Major,Resolved,"Support for nested properties binding As today properties binding does not work for nested objects so assuming I have a class like:

{code:java}
class MyComponent {
    
    public void setFoo(String foo) {
        this.foo = foo;
    }

    public String getFoo() {
        return foo;
    }

    public void setConfiguration(Configuration conf) {
        this.conf = conf;
    }

    public Configuration getConfiguration() {
        return conf;
    }

    static class Configuration {
    
        public void setBar(String bar) {
            this.bar = bar
        }

        public String getBar() {
            return bar
        }
    }
}
{code}

And a set of properties like:

{code}
myComponent.foo = ""foo""
myComponent.conf.bar = ""bar""
{code}

Then only MyComponent.foo will be set but it would be nice if the binding framework could navigate the property using dot notation and set any dependent object.
"
CAMEL-13556,Camel main - Duration max messages may not work,Looks like max duration = 1 will not shutdown the jvm. Also the idle checker background thread is stopping camel from the same thread as itself so its own thread pool cannot shutdown nicely.,davsclaus,Bug,Major,Resolved,Camel main - Duration max messages may not work Looks like max duration = 1 will not shutdown the jvm. Also the idle checker background thread is stopping camel from the same thread as itself so its own thread pool cannot shutdown nicely.
CAMEL-13555,Producer and consumer template/cache should check if camel is started when being used,"When sending via producer template etc then you can send to endpoints even if camel is stopped / not started etc. We should add a check for this as camel would ideally need to be started first to ensure the sending works correctly.

",davsclaus,Improvement,Major,Resolved,"Producer and consumer template/cache should check if camel is started when being used When sending via producer template etc then you can send to endpoints even if camel is stopped / not started etc. We should add a check for this as camel would ideally need to be started first to ensure the sending works correctly.

"
CAMEL-13554,"Using ""route1"" as a route id produces infinite loop","Steps:
# Start a Camel context.
# Add a route through RouteBuilder with id *""route1""* (reserved id).
# Attempt to add a second route with no id. The method enters an infinite loop. 

Example code that reproduces the problem:
{code:java}
package com.paytrue.swakka;

import org.apache.camel.builder.RouteBuilder;
import org.apache.camel.impl.DefaultCamelContext;

public class InfLoopMain {

    public static void main(final String[] args) throws Exception {
        final DefaultCamelContext camelContext = new DefaultCamelContext();
        camelContext.start();

        final RouteBuilder route1 = new RouteBuilder() {
            @Override
            public void configure() {
                from(""direct:in1"")
                    .id(""route1"") // Note the name
                    .to(""mock:test1"");
            }
        };
        camelContext.addRoutes(route1);

        final RouteBuilder route2 = new RouteBuilder() {
            @Override
            public void configure() {
                from(""direct:in2"")
                    .to(""mock:test2"");
            }
        };
        // Infinite loop
        camelContext.addRoutes(route2);
    }
}
{code}
 ",davsclaus,Bug,Minor,Resolved,"Using ""route1"" as a route id produces infinite loop Steps:
# Start a Camel context.
# Add a route through RouteBuilder with id *""route1""* (reserved id).
# Attempt to add a second route with no id. The method enters an infinite loop. 

Example code that reproduces the problem:
{code:java}
package com.paytrue.swakka;

import org.apache.camel.builder.RouteBuilder;
import org.apache.camel.impl.DefaultCamelContext;

public class InfLoopMain {

    public static void main(final String[] args) throws Exception {
        final DefaultCamelContext camelContext = new DefaultCamelContext();
        camelContext.start();

        final RouteBuilder route1 = new RouteBuilder() {
            @Override
            public void configure() {
                from(""direct:in1"")
                    .id(""route1"") // Note the name
                    .to(""mock:test1"");
            }
        };
        camelContext.addRoutes(route1);

        final RouteBuilder route2 = new RouteBuilder() {
            @Override
            public void configure() {
                from(""direct:in2"")
                    .to(""mock:test2"");
            }
        };
        // Infinite loop
        camelContext.addRoutes(route2);
    }
}
{code}
 "
CAMEL-13551,camel3 - Some of the SPI can be static services when there can only be one configured,"A number of configurations for packagescan class resolver and node id factory and whatnot are essentially a single instance that can be configured, so we can leverage this fact and make them StaticService if they are just defined as a Service today.",davsclaus,Improvement,Major,Resolved,"camel3 - Some of the SPI can be static services when there can only be one configured A number of configurations for packagescan class resolver and node id factory and whatnot are essentially a single instance that can be configured, so we can leverage this fact and make them StaticService if they are just defined as a Service today."
CAMEL-13549,expectedHeaderReceived should failed when no message is received,"This test should fail:
{code:java}
import org.apache.camel.RoutesBuilder;
import org.apache.camel.builder.RouteBuilder;
import org.apache.camel.component.mock.MockEndpoint;
import org.apache.camel.test.junit4.CamelTestSupport;
import org.assertj.core.api.Assertions;
import org.junit.Test;

public class MyRouteTest extends CamelTestSupport {

  private static final String ROUTE_ID = ""mytest"";

  @Override
  public RoutesBuilder createRouteBuilder() throws Exception {
    return new RouteBuilder() {

      @Override
      public void configure() throws Exception {
        from(""direct:foo"")
          .id(ROUTE_ID)
          .to(""mock:extract"");
      }
    };
  }

  @Test
  public void shouldFail() throws InterruptedException {
    // given
    final MockEndpoint mock = getMockEndpoint(""mock:extract"");

    // declare
    mock.expectedHeaderReceived(""foo"", ""bar"");

    // when
//template.sendBody(""direct:foo"", ""test"");

    // then
    mock.assertIsSatisfied();
  }
}
{code}

Because we were expecting some headers, but none headers were received",davsclaus,Bug,Minor,Resolved,"expectedHeaderReceived should failed when no message is received This test should fail:
{code:java}
import org.apache.camel.RoutesBuilder;
import org.apache.camel.builder.RouteBuilder;
import org.apache.camel.component.mock.MockEndpoint;
import org.apache.camel.test.junit4.CamelTestSupport;
import org.assertj.core.api.Assertions;
import org.junit.Test;

public class MyRouteTest extends CamelTestSupport {

  private static final String ROUTE_ID = ""mytest"";

  @Override
  public RoutesBuilder createRouteBuilder() throws Exception {
    return new RouteBuilder() {

      @Override
      public void configure() throws Exception {
        from(""direct:foo"")
          .id(ROUTE_ID)
          .to(""mock:extract"");
      }
    };
  }

  @Test
  public void shouldFail() throws InterruptedException {
    // given
    final MockEndpoint mock = getMockEndpoint(""mock:extract"");

    // declare
    mock.expectedHeaderReceived(""foo"", ""bar"");

    // when
//template.sendBody(""direct:foo"", ""test"");

    // then
    mock.assertIsSatisfied();
  }
}
{code}

Because we were expecting some headers, but none headers were received"
CAMEL-13544,adviceWith in test should be fired before routes are started,"This test should pass:
{code:java}
import java.util.concurrent.atomic.AtomicInteger;

import org.apache.camel.CamelContext;
import org.apache.camel.RoutesBuilder;
import org.apache.camel.builder.AdviceWithRouteBuilder;
import org.apache.camel.builder.RouteBuilder;
import org.apache.camel.component.mock.MockEndpoint;
import org.apache.camel.test.junit4.CamelTestSupport;
import org.assertj.core.api.Assertions;
import org.junit.Test;

public class MyRouteTest extends CamelTestSupport {

  private static final String ROUTE_ID = ""mytest"";

  private final AtomicInteger counter = new AtomicInteger(0);

  @Override
  public RoutesBuilder createRouteBuilder() throws Exception {
    return new RouteBuilder() {

      @Override
      public void configure() throws Exception {
        from(""quartz2://test?cron=0/1+*+*+*+*+?"")
          .id(ROUTE_ID)
          .bean(counter, ""incrementAndGet"", false)
          .to(""stream:out"");
      }
    };
  }

  @Override
  public void setUp() throws Exception {
      super.setUp();
      final CamelContext camelContext = context();
      camelContext.getRouteDefinition(ROUTE_ID)
        .adviceWith(camelContext, new AdviceWithRouteBuilder() {
          @Override
          public void configure() throws Exception {
            replaceFromWith(""direct:quartz"");
            weaveAddLast().to(""mock:extract"");
          }
        });
  }

  @Test
  public void shouldReceive2Messages() throws InterruptedException {
    // given
    final MockEndpoint quartzMock = getMockEndpoint(""mock:extract"");

    // declare
    quartzMock.expectedMessageCount(2);

    // when
    template.sendBody(""direct:quartz"", ""tick"");
    template.sendBody(""direct:quartz"", ""tick"");

    // then
    quartzMock.assertIsSatisfied();
    Assertions.assertThat(counter).hasValue(2);
  }
}
{code}

Unfortunatelly, before adviceWith is invoked, quartz sends already two messages",davsclaus,Bug,Major,Resolved,"adviceWith in test should be fired before routes are started This test should pass:
{code:java}
import java.util.concurrent.atomic.AtomicInteger;

import org.apache.camel.CamelContext;
import org.apache.camel.RoutesBuilder;
import org.apache.camel.builder.AdviceWithRouteBuilder;
import org.apache.camel.builder.RouteBuilder;
import org.apache.camel.component.mock.MockEndpoint;
import org.apache.camel.test.junit4.CamelTestSupport;
import org.assertj.core.api.Assertions;
import org.junit.Test;

public class MyRouteTest extends CamelTestSupport {

  private static final String ROUTE_ID = ""mytest"";

  private final AtomicInteger counter = new AtomicInteger(0);

  @Override
  public RoutesBuilder createRouteBuilder() throws Exception {
    return new RouteBuilder() {

      @Override
      public void configure() throws Exception {
        from(""quartz2://test?cron=0/1+*+*+*+*+?"")
          .id(ROUTE_ID)
          .bean(counter, ""incrementAndGet"", false)
          .to(""stream:out"");
      }
    };
  }

  @Override
  public void setUp() throws Exception {
      super.setUp();
      final CamelContext camelContext = context();
      camelContext.getRouteDefinition(ROUTE_ID)
        .adviceWith(camelContext, new AdviceWithRouteBuilder() {
          @Override
          public void configure() throws Exception {
            replaceFromWith(""direct:quartz"");
            weaveAddLast().to(""mock:extract"");
          }
        });
  }

  @Test
  public void shouldReceive2Messages() throws InterruptedException {
    // given
    final MockEndpoint quartzMock = getMockEndpoint(""mock:extract"");

    // declare
    quartzMock.expectedMessageCount(2);

    // when
    template.sendBody(""direct:quartz"", ""tick"");
    template.sendBody(""direct:quartz"", ""tick"");

    // then
    quartzMock.assertIsSatisfied();
    Assertions.assertThat(counter).hasValue(2);
  }
}
{code}

Unfortunatelly, before adviceWith is invoked, quartz sends already two messages"
CAMEL-13540,isUseAdviceWith causes test to hang,"Having this test:
{code:java}
import org.apache.camel.CamelContext;
import org.apache.camel.RoutesBuilder;
import org.apache.camel.builder.AdviceWithRouteBuilder;
import org.apache.camel.builder.RouteBuilder;
import org.apache.camel.component.mock.MockEndpoint;
import org.apache.camel.test.junit4.CamelTestSupport;
import org.junit.Test;

public class MyRouteTest extends CamelTestSupport {

  private static final String ROUTE_ID = ""mytest"";

  @Override
  public RoutesBuilder createRouteBuilder() throws Exception {
    return new RouteBuilder() {

      @Override
      public void configure() throws Exception {
        from(""direct:mytest"")
          .id(ROUTE_ID)
          .to(""stream:out"");
      }
    };
  }

  @Override
  public void setUp() throws Exception {
      super.setUp();
      final CamelContext camelContext = context();
      camelContext.getRouteDefinition(ROUTE_ID)
        .adviceWith(camelContext, new AdviceWithRouteBuilder() {
          @Override
          public void configure() throws Exception {
            weaveAddLast().to(""mock:extract"");
          }
        });
  }

  @Override
  public boolean isUseAdviceWith() {
      return true; // <- here is the problem
  }

  @Test
  public void shouldFire() throws InterruptedException {
    // given
    final MockEndpoint myMock = getMockEndpoint(""mock:extract"");

    myMock.expectedMessageCount(1);
    myMock.expectedBodiesReceived(""test"");

    // when
    template.sendBody(""direct:mytest"", ""test"");

    // then
    myMock.assertIsSatisfied();
  }
}
{code}
 Causes Camel to hang",davsclaus,Improvement,Minor,Resolved,"isUseAdviceWith causes test to hang Having this test:
{code:java}
import org.apache.camel.CamelContext;
import org.apache.camel.RoutesBuilder;
import org.apache.camel.builder.AdviceWithRouteBuilder;
import org.apache.camel.builder.RouteBuilder;
import org.apache.camel.component.mock.MockEndpoint;
import org.apache.camel.test.junit4.CamelTestSupport;
import org.junit.Test;

public class MyRouteTest extends CamelTestSupport {

  private static final String ROUTE_ID = ""mytest"";

  @Override
  public RoutesBuilder createRouteBuilder() throws Exception {
    return new RouteBuilder() {

      @Override
      public void configure() throws Exception {
        from(""direct:mytest"")
          .id(ROUTE_ID)
          .to(""stream:out"");
      }
    };
  }

  @Override
  public void setUp() throws Exception {
      super.setUp();
      final CamelContext camelContext = context();
      camelContext.getRouteDefinition(ROUTE_ID)
        .adviceWith(camelContext, new AdviceWithRouteBuilder() {
          @Override
          public void configure() throws Exception {
            weaveAddLast().to(""mock:extract"");
          }
        });
  }

  @Override
  public boolean isUseAdviceWith() {
      return true; // <- here is the problem
  }

  @Test
  public void shouldFire() throws InterruptedException {
    // given
    final MockEndpoint myMock = getMockEndpoint(""mock:extract"");

    myMock.expectedMessageCount(1);
    myMock.expectedBodiesReceived(""test"");

    // when
    template.sendBody(""direct:mytest"", ""test"");

    // then
    myMock.assertIsSatisfied();
  }
}
{code}
 Causes Camel to hang"
CAMEL-13536,StackOverflow when using bean(this),"This testcase
{code:java}
import org.apache.camel.CamelContext;
import org.apache.camel.Exchange;
import org.apache.camel.RoutesBuilder;
import org.apache.camel.builder.AdviceWithRouteBuilder;
import org.apache.camel.builder.RouteBuilder;
import org.apache.camel.component.mock.MockEndpoint;
import org.apache.camel.test.junit4.CamelTestSupport;
import org.junit.Test;

public class MyRouteTest extends CamelTestSupport {

private static final String ROUTE_ID = ""mytest"";

@Override
protected RoutesBuilder createRouteBuilder() throws Exception {
  return new RouteBuilder() {

    @Override
    public void configure() throws Exception {
      from(""direct:mytest"")
      .id(ROUTE_ID)
      .bean(this, ""hello"", false) // <- here is the problem
      .to(""stream:out"");
    }

    public void hello(final Exchange exchange) {
    }
  };
}

@Override
public void setUp() throws Exception {
  super.setUp();
  final CamelContext camelContext = context();
  camelContext.getRouteDefinition(ROUTE_ID)
    .adviceWith(camelContext, new AdviceWithRouteBuilder() {
    @Override
    public void configure() throws Exception {
      weaveAddLast().to(""mock:extract"");
    }
  });
}

@Override
public boolean isUseAdviceWith() {
  return true;
}

@Test
public void shouldFire() throws InterruptedException {
  // given
  final MockEndpoint myMock = getMockEndpoint(""mock:extract"");

  myMock.expectedMessageCount(1);

  // when
  template.sendBody(""direct:mytest"", ""test"");

  // then
  myMock.assertIsSatisfied();
}
}
{code}
Throws
{code:java}
java.lang.StackOverflowError
at java.util.AbstractCollection.toString(Unknown Source)
at java.lang.String.valueOf(Unknown Source)
at java.lang.StringBuilder.append(Unknown Source)
at org.apache.camel.model.RoutesDefinition.toString(RoutesDefinition.java:64)
at org.apache.camel.builder.RouteBuilder.toString(RouteBuilder.java:74)
at org.apache.camel.model.BeanDefinition.description(BeanDefinition.java:89)
at org.apache.camel.model.BeanDefinition.toString(BeanDefinition.java:78)
at java.lang.String.valueOf(Unknown Source)
{code}
 ",davsclaus,Bug,Minor,Resolved,"StackOverflow when using bean(this) This testcase
{code:java}
import org.apache.camel.CamelContext;
import org.apache.camel.Exchange;
import org.apache.camel.RoutesBuilder;
import org.apache.camel.builder.AdviceWithRouteBuilder;
import org.apache.camel.builder.RouteBuilder;
import org.apache.camel.component.mock.MockEndpoint;
import org.apache.camel.test.junit4.CamelTestSupport;
import org.junit.Test;

public class MyRouteTest extends CamelTestSupport {

private static final String ROUTE_ID = ""mytest"";

@Override
protected RoutesBuilder createRouteBuilder() throws Exception {
  return new RouteBuilder() {

    @Override
    public void configure() throws Exception {
      from(""direct:mytest"")
      .id(ROUTE_ID)
      .bean(this, ""hello"", false) // <- here is the problem
      .to(""stream:out"");
    }

    public void hello(final Exchange exchange) {
    }
  };
}

@Override
public void setUp() throws Exception {
  super.setUp();
  final CamelContext camelContext = context();
  camelContext.getRouteDefinition(ROUTE_ID)
    .adviceWith(camelContext, new AdviceWithRouteBuilder() {
    @Override
    public void configure() throws Exception {
      weaveAddLast().to(""mock:extract"");
    }
  });
}

@Override
public boolean isUseAdviceWith() {
  return true;
}

@Test
public void shouldFire() throws InterruptedException {
  // given
  final MockEndpoint myMock = getMockEndpoint(""mock:extract"");

  myMock.expectedMessageCount(1);

  // when
  template.sendBody(""direct:mytest"", ""test"");

  // then
  myMock.assertIsSatisfied();
}
}
{code}
Throws
{code:java}
java.lang.StackOverflowError
at java.util.AbstractCollection.toString(Unknown Source)
at java.lang.String.valueOf(Unknown Source)
at java.lang.StringBuilder.append(Unknown Source)
at org.apache.camel.model.RoutesDefinition.toString(RoutesDefinition.java:64)
at org.apache.camel.builder.RouteBuilder.toString(RouteBuilder.java:74)
at org.apache.camel.model.BeanDefinition.description(BeanDefinition.java:89)
at org.apache.camel.model.BeanDefinition.toString(BeanDefinition.java:78)
at java.lang.String.valueOf(Unknown Source)
{code}
 "
CAMEL-13535,Camel main - Allow to configure supervising route controller,Like you can do in SB to setup advanced route startup where Camel can retry starting routes etc.,davsclaus,Improvement,Major,Resolved,Camel main - Allow to configure supervising route controller Like you can do in SB to setup advanced route startup where Camel can retry starting routes etc.
CAMEL-13534,Simple language - Add colon as alternative syntax style,"The simple syntax can maybe be improved a bit when its a function such as env or sysenv or other functions vs OGNL method calls on body, headers etc that uses dot style.

Eg 
{code}
${sysenv.FOO}
{code}
vs
{code}
${env:FOO}
{code}

It may feel a bit more natural to use colon in these situations, and dot when using

{code}
${body.someGetter}
{code}

And to refer to a header you can use both
{code}
${header.foo}
{code}

{code}
${header:foo}
{code}

https://github.com/apache/camel/blob/master/core/camel-core/src/main/docs/simple-language.adoc",davsclaus,Improvement,Major,Resolved,"Simple language - Add colon as alternative syntax style The simple syntax can maybe be improved a bit when its a function such as env or sysenv or other functions vs OGNL method calls on body, headers etc that uses dot style.

Eg 
{code}
${sysenv.FOO}
{code}
vs
{code}
${env:FOO}
{code}

It may feel a bit more natural to use colon in these situations, and dot when using

{code}
${body.someGetter}
{code}

And to refer to a header you can use both
{code}
${header.foo}
{code}

{code}
${header:foo}
{code}

https://github.com/apache/camel/blob/master/core/camel-core/src/main/docs/simple-language.adoc"
CAMEL-13532,file2: pollEnrich with sendEmptyMessageWhenIdle does not send correct Exchanges,"I use the file component in pollEnrich with sendEmptyMessageWhenIdle=true and readLock=changed

In 2.20.4 and before the attached test case worked, from 2.21.0 on it fails.

My test writes several characters delayed into a file so that the component runs into a timeout after 10000ms on the first call. This is correct.

On the second call the writing of the file is finished within the 10000ms, my expectation is the correct processing of the file in my route, but it fails because the Exchange has an empty body.

I debugged the thing an saw that in the variable GenericFilePollingConsumer.queue there are two exchanges instead of one. The first one sems to be the ""empty"" message from the first call without a GenericFile in the In-Body, and the second Exchange in the queue is the correct one with the GenericFile from the second call.

Because it's a FiFo, only the first, empty one is returned (in EventDrivenPollingConsumer.receive()) so that the route states that there is nothing to do.

I suspect an error in the processing of the empty message, so that it is not cleared or taken properly from the queue so that it remains there and conflicts with later calls.",davsclaus,Bug,Major,Resolved,"file2: pollEnrich with sendEmptyMessageWhenIdle does not send correct Exchanges I use the file component in pollEnrich with sendEmptyMessageWhenIdle=true and readLock=changed

In 2.20.4 and before the attached test case worked, from 2.21.0 on it fails.

My test writes several characters delayed into a file so that the component runs into a timeout after 10000ms on the first call. This is correct.

On the second call the writing of the file is finished within the 10000ms, my expectation is the correct processing of the file in my route, but it fails because the Exchange has an empty body.

I debugged the thing an saw that in the variable GenericFilePollingConsumer.queue there are two exchanges instead of one. The first one sems to be the ""empty"" message from the first call without a GenericFile in the In-Body, and the second Exchange in the queue is the correct one with the GenericFile from the second call.

Because it's a FiFo, only the first, empty one is returned (in EventDrivenPollingConsumer.receive()) so that the route states that there is nothing to do.

I suspect an error in the processing of the empty message, so that it is not cleared or taken properly from the queue so that it remains there and conflicts with later calls."
CAMEL-13531,Simple language - Add env as function to lookup system env variable,"You have to use sysenv to lookup OS env variable. But most people would know it as env, so lets add that as an alias so you can use both of them.",davsclaus,Improvement,Major,Resolved,"Simple language - Add env as function to lookup system env variable You have to use sysenv to lookup OS env variable. But most people would know it as env, so lets add that as an alias so you can use both of them."
CAMEL-13528,Rename chiper to cipher,Fix the typo in the API in camel-core,davsclaus,Task,Major,Resolved,Rename chiper to cipher Fix the typo in the API in camel-core
CAMEL-13527,Implement missing optimisation for DelimiterBasedFrameDecoder,"See pretty nice analysis on SO [https://stackoverflow.com/questions/56110408/memory-leak-in-camel-netty-tcp-client-when-consuming-lines-with-windows-line-bre]

*io.netty.handler.codec.DelimiterBasedFrameDecoder* internally delegates decoding to *io.netty.handler.codec.LineBasedFrameDecoder*. This delegation is not working with Camel, because Netty internally checks for condition
{code:java}
this.getClass() != DelimiterBasedFrameDecoder.class // io.netty.handler.codec.DelimiterBasedFrameDecoder line 174 - !isSubclass()
{code}
We can recreate similar optimisation inside *org.apache.camel.component.netty4.codec.DelimiterBasedFrameDecoder* and get (according to SO post) significant performance improvement.",davsclaus,Improvement,Minor,Resolved,"Implement missing optimisation for DelimiterBasedFrameDecoder See pretty nice analysis on SO [https://stackoverflow.com/questions/56110408/memory-leak-in-camel-netty-tcp-client-when-consuming-lines-with-windows-line-bre]

*io.netty.handler.codec.DelimiterBasedFrameDecoder* internally delegates decoding to *io.netty.handler.codec.LineBasedFrameDecoder*. This delegation is not working with Camel, because Netty internally checks for condition
{code:java}
this.getClass() != DelimiterBasedFrameDecoder.class // io.netty.handler.codec.DelimiterBasedFrameDecoder line 174 - !isSubclass()
{code}
We can recreate similar optimisation inside *org.apache.camel.component.netty4.codec.DelimiterBasedFrameDecoder* and get (according to SO post) significant performance improvement."
CAMEL-13525,camel - Only allow setting routeId once per route in Java DSL,"1 route = 1 route id, what you did in that unit test / JIRA ticket was wrong and not intended to be supported, eg .routeId will override each other, a route has 1 route id. So do only set .routeId once per route!

From gitter chat",davsclaus,Improvement,Minor,Resolved,"camel - Only allow setting routeId once per route in Java DSL 1 route = 1 route id, what you did in that unit test / JIRA ticket was wrong and not intended to be supported, eg .routeId will override each other, a route has 1 route id. So do only set .routeId once per route!

From gitter chat"
CAMEL-13524,RuntimeCamelCatalog#asEndpointUri strips dash from url with toD and netty4-http,"[https://stackoverflow.com/questions/56136857/how-to-use-camel-tod-and-netty4-http-component-problem-with-optimization-of-din]

This is very similar to CAMEL-12705, but in this case it affects url with dashes. Tested with current master.

*{{url}}*
{code:java}
netty4-http:http://a-b-c.hostname.tld:8080/anything{code}
*results in* 
{code:java}
netty4-http:http:a-b:8080/path{code}
Unit test in attachment.

 

-Maybe-

-_AbstractCamelCatalog#SYNTAX_PATTERN_ should be changed to- 
{code:java}
([\w.-]+)
{code}
-Or is there reason, why is dash excluded from regexp?-

I have tried to edit regexp and it broke test too, it results in resolved = ""netty4-http:http:a-b-c.hostname.tld-8080""",davsclaus,Bug,Major,Resolved,"RuntimeCamelCatalog#asEndpointUri strips dash from url with toD and netty4-http [https://stackoverflow.com/questions/56136857/how-to-use-camel-tod-and-netty4-http-component-problem-with-optimization-of-din]

This is very similar to CAMEL-12705, but in this case it affects url with dashes. Tested with current master.

*{{url}}*
{code:java}
netty4-http:http://a-b-c.hostname.tld:8080/anything{code}
*results in* 
{code:java}
netty4-http:http:a-b:8080/path{code}
Unit test in attachment.

 

-Maybe-

-_AbstractCamelCatalog#SYNTAX_PATTERN_ should be changed to- 
{code:java}
([\w.-]+)
{code}
-Or is there reason, why is dash excluded from regexp?-

I have tried to edit regexp and it broke test too, it results in resolved = ""netty4-http:http:a-b-c.hostname.tld-8080"""
CAMEL-13522,camel3 - The various Camel exceptions should favour extending runtime exception,"This makes using the APIs in Camel easier, and most of them are runtime based anyway. So lets align to be more non checked exceptions",davsclaus,Improvement,Major,Resolved,"camel3 - The various Camel exceptions should favour extending runtime exception This makes using the APIs in Camel easier, and most of them are runtime based anyway. So lets align to be more non checked exceptions"
CAMEL-13516,camel-webhook - Consumer polish,Should extend ServiceSupport and do its startup stop in doStart/doStop etc.,davsclaus,Improvement,Major,Resolved,camel-webhook - Consumer polish Should extend ServiceSupport and do its startup stop in doStart/doStop etc.
CAMEL-13515,Allow producer to lazy start until first message,"We could add option to DefaultProducer so any producer allows to defer its startup (doStart) to when the first message is being processed. The danger is that the startup logic has to be thread-safe and if there are concurrent messages then they would need to hold back until the startup is done. This is a trade-off that the user would need to accept if enabled.

But this can make it easier to let Camel startup routes even if some remote server is not available when a producer startup as part of route startup.",davsclaus,Improvement,Major,Resolved,"Allow producer to lazy start until first message We could add option to DefaultProducer so any producer allows to defer its startup (doStart) to when the first message is being processed. The danger is that the startup logic has to be thread-safe and if there are concurrent messages then they would need to hold back until the startup is done. This is a trade-off that the user would need to accept if enabled.

But this can make it easier to let Camel startup routes even if some remote server is not available when a producer startup as part of route startup."
CAMEL-13514,camel3 - Service start/stop should use unchecked exceptions,"The API for org.apache.camel.Service has throws Exception for its start/stop methods. It would be great to remove those, as they throw runtime exceptions when failing, and this makes using these APIs easier for end users, so they dont have the burden of checked exceptions.",davsclaus,Improvement,Major,Resolved,"camel3 - Service start/stop should use unchecked exceptions The API for org.apache.camel.Service has throws Exception for its start/stop methods. It would be great to remove those, as they throw runtime exceptions when failing, and this makes using these APIs easier for end users, so they dont have the burden of checked exceptions."
CAMEL-13505,Camel-Tracer: New implementation,"We deprecated the 2.x one and removed it, hence we need a new implementation in Camel 3.",davsclaus,Task,Major,Resolved,"Camel-Tracer: New implementation We deprecated the 2.x one and removed it, hence we need a new implementation in Camel 3."
CAMEL-13503,Camel main - Allow to configure global and common options ala camel-spring-boot have,"So you can set context name, shutdown timeout, and other options etc.",davsclaus,Improvement,Major,Resolved,"Camel main - Allow to configure global and common options ala camel-spring-boot have So you can set context name, shutdown timeout, and other options etc."
CAMEL-13502,Properties component - Let OS environment variable take precedence by having it in override mode by default,"See SO
https://stackoverflow.com/questions/56081583/camel-standalone-configuration-of-propertiescomponent-does-not-work-on-beanin

It makes sense to let OS env variables by default to let them override any existing property values. This is natural in cloud platforms and also how Spring Boot would work etc.

",davsclaus,Improvement,Major,Resolved,"Properties component - Let OS environment variable take precedence by having it in override mode by default See SO
https://stackoverflow.com/questions/56081583/camel-standalone-configuration-of-propertiescomponent-does-not-work-on-beanin

It makes sense to let OS env variables by default to let them override any existing property values. This is natural in cloud platforms and also how Spring Boot would work etc.

"
CAMEL-13500,Component configuration - Allow to use dot to refer to nested options,"For example some Camel components has nested options like camel-netty4 which has a NettyConfiguration class. 

So when you want to set some of its options you cannot easily do this via component configuration. We have some special support for spring boot that generated these nested options, but its also needed for other use-cases such as the Camel Main and just in general.

For example with SB we can do
camel.component.netty4-http.configuration.max-header-size

We should add support for doing this via Camel Main and in general also",davsclaus,Task,Major,Resolved,"Component configuration - Allow to use dot to refer to nested options For example some Camel components has nested options like camel-netty4 which has a NettyConfiguration class. 

So when you want to set some of its options you cannot easily do this via component configuration. We have some special support for spring boot that generated these nested options, but its also needed for other use-cases such as the Camel Main and just in general.

For example with SB we can do
camel.component.netty4-http.configuration.max-header-size

We should add support for doing this via Camel Main and in general also"
CAMEL-13491,CamelTestSupport.isCreateCamelContextPerClass no longer works for junit4 tests,"With the changes in 

org.apache.camel.test.junit4.CamelTestSupport done during the work on https://issues.apache.org/jira/browse/CAMEL-12534 the camel context is now recreated for every test regardless of the return value from

isCreateCamelContextPerClass()

. Since junit4 creates a new instance of the class for every test the variable tests will be recreated and initialized to 0 for every test.

This condition in tearDown will always be true
{code:java}
// code placeholder
if (tests.compareAndSet(v, v - 1)) {
    if (v == 1) {
{code}
which stops the camel context after every test.",davsclaus,Bug,Major,Resolved,"CamelTestSupport.isCreateCamelContextPerClass no longer works for junit4 tests With the changes in 

org.apache.camel.test.junit4.CamelTestSupport done during the work on https://issues.apache.org/jira/browse/CAMEL-12534 the camel context is now recreated for every test regardless of the return value from

isCreateCamelContextPerClass()

. Since junit4 creates a new instance of the class for every test the variable tests will be recreated and initialized to 0 for every test.

This condition in tearDown will always be true
{code:java}
// code placeholder
if (tests.compareAndSet(v, v - 1)) {
    if (v == 1) {
{code}
which stops the camel context after every test."
CAMEL-13483,File Component: Add option to fail startup when not having read permission on folder,"When starting a file consumer you configure a folder to poll.
When the camel context does not have read access on the folder, there is no error (or even warning), that route just starts.
But when saving files into the folder, they are not picked up and there is no further message.

This issue was raised on stackoverflow: [https://stackoverflow.com/questions/55920217/camel-file-consumer-when-folder-is-not-accessible]

 

Ideally, the file consumer would check at startup if it has access to the folder (we should propably check for write access here, but read access could also be enough?)

If the component (/context) does not have the required access to the folder, it should throw the error and exit the context (so it isn't started in a failure state).

This option should be disabled by default.

Also we should think about a way to configure the behavior:
1. For what permission should the consumer check (read / read-write)
2. What should happen when the permission is not given? (just an error / error + stop route / error + stop context)
As always, we should make this configurable via a custom bean.",davsclaus,New Feature,Major,Resolved,"File Component: Add option to fail startup when not having read permission on folder When starting a file consumer you configure a folder to poll.
When the camel context does not have read access on the folder, there is no error (or even warning), that route just starts.
But when saving files into the folder, they are not picked up and there is no further message.

This issue was raised on stackoverflow: [https://stackoverflow.com/questions/55920217/camel-file-consumer-when-folder-is-not-accessible]

 

Ideally, the file consumer would check at startup if it has access to the folder (we should propably check for write access here, but read access could also be enough?)

If the component (/context) does not have the required access to the folder, it should throw the error and exit the context (so it isn't started in a failure state).

This option should be disabled by default.

Also we should think about a way to configure the behavior:
1. For what permission should the consumer check (read / read-write)
2. What should happen when the permission is not given? (just an error / error + stop route / error + stop context)
As always, we should make this configurable via a custom bean."
CAMEL-13477,KafkaConfiguration puts truststore password into keystore password property,"If you create a component-level KafkaConfiguration, and set SslContextParameters on it that includes a truststore password, then when creating consumer or producer properties, the KafkaConfiguration puts the truststore password into the keystore password field, resulting in errors such as:

{{Caused by: org.apache.kafka.common.KafkaException: SSL key store is not specified, but key store password is specified.}}
{{ at org.apache.kafka.common.security.ssl.SslFactory.createKeystore(SslFactory.java:283)}}
{{ at org.apache.kafka.common.security.ssl.SslFactory.configure(SslFactory.java:126)}}
{{ at org.apache.kafka.common.network.SaslChannelBuilder.configure(SaslChannelBuilder.java:149)}}

 

PR available here:

[https://github.com/apache/camel/pull/2899]",davsclaus,Bug,Major,Resolved,"KafkaConfiguration puts truststore password into keystore password property If you create a component-level KafkaConfiguration, and set SslContextParameters on it that includes a truststore password, then when creating consumer or producer properties, the KafkaConfiguration puts the truststore password into the keystore password field, resulting in errors such as:

{{Caused by: org.apache.kafka.common.KafkaException: SSL key store is not specified, but key store password is specified.}}
{{ at org.apache.kafka.common.security.ssl.SslFactory.createKeystore(SslFactory.java:283)}}
{{ at org.apache.kafka.common.security.ssl.SslFactory.configure(SslFactory.java:126)}}
{{ at org.apache.kafka.common.network.SaslChannelBuilder.configure(SaslChannelBuilder.java:149)}}

 

PR available here:

[https://github.com/apache/camel/pull/2899]"
CAMEL-13476,QuartzScheduledPollConsumerScheduler should not remove trigger when quartz is clustered,"When using ftp component with quartz scheduler, like following sample

""ftp:""+sftpUsername+""@""+sftpHost+"":""+sftpPort+""/3G?password=""+sftpPw+""&binary=true&delay=5s&delete=true&scheduler=quartz2&scheduler.cron=\{{cron.3G.processing}}&scheduler.triggerId=3G_Trigger""

 

During shutdown, camel will remove all triggers without check quartz is running in cluster mode or not. Since we config quartz is cluster means there can be other instances running, so does it make sense we should check quartz cluster state to decide triggers should remove or keep?

 

!QuartzScheduledPollConsumerScheduler.java — camel-quartz2 2019-05-02 15-46-49.jpg!

 ",davsclaus,Improvement,Major,Resolved,"QuartzScheduledPollConsumerScheduler should not remove trigger when quartz is clustered When using ftp component with quartz scheduler, like following sample

""ftp:""+sftpUsername+""@""+sftpHost+"":""+sftpPort+""/3G?password=""+sftpPw+""&binary=true&delay=5s&delete=true&scheduler=quartz2&scheduler.cron=\{{cron.3G.processing}}&scheduler.triggerId=3G_Trigger""

 

During shutdown, camel will remove all triggers without check quartz is running in cluster mode or not. Since we config quartz is cluster means there can be other instances running, so does it make sense we should check quartz cluster state to decide triggers should remove or keep?

 

!QuartzScheduledPollConsumerScheduler.java -- camel-quartz2 2019-05-02 15-46-49.jpg!

 "
CAMEL-13475,Camel with Olingo4 not shutting down,"I'm using the Olingo4 component and I want my Camel to run as a cron job. After my exchange is completed I stop the camel context, but the jvm doesn’t close and keeps running. I found out that there still was a thread running with a httpAsyncClient.

I checked the code for the component and found in the class Olingo4AppImpl that there by default a CloseableHttpAsyncClient is started, but not closed when camel is being shut down.

I added this to close method and now the jvm process is stopping:

@Override
public void close() {
   if (client instanceof CloseableHttpAsyncClient) {
       try {
           client.close();
       }
       catch (IOException e) {
           throw new RuntimeException(e);
       }
   }
}

Not sure what should happen when somebody uses their own httpAsyncClientBuilder.",davsclaus,Bug,Minor,Resolved,"Camel with Olingo4 not shutting down I'm using the Olingo4 component and I want my Camel to run as a cron job. After my exchange is completed I stop the camel context, but the jvm doesn't close and keeps running. I found out that there still was a thread running with a httpAsyncClient.

I checked the code for the component and found in the class Olingo4AppImpl that there by default a CloseableHttpAsyncClient is started, but not closed when camel is being shut down.

I added this to close method and now the jvm process is stopping:

@Override
public void close() {
   if (client instanceof CloseableHttpAsyncClient) {
       try {
           client.close();
       }
       catch (IOException e) {
           throw new RuntimeException(e);
       }
   }
}

Not sure what should happen when somebody uses their own httpAsyncClientBuilder."
CAMEL-13474,Move dataformats out of camel-core,"We should deprecate string/seriazliation dataformats as they dont bring value, and java object serialization is a bad design and also often a security vulnerability (many issues reported against this functionality in java).

And then we can move zip/gzip into camel-deflater. ",davsclaus,Task,Major,Resolved,"Move dataformats out of camel-core We should deprecate string/seriazliation dataformats as they dont bring value, and java object serialization is a bad design and also often a security vulnerability (many issues reported against this functionality in java).

And then we can move zip/gzip into camel-deflater. "
CAMEL-13473,camel3 - build system - dataformats from camel-core no longer generated in readme files,Likely because they were moved from camel-core to camel-base etc.,davsclaus,Task,Major,Resolved,camel3 - build system - dataformats from camel-core no longer generated in readme files Likely because they were moved from camel-core to camel-base etc.
CAMEL-13468,Exception tag is missing when Camel Java DSL is converted into XML using dumpRouteAsXml() operation,"Exception tag is missing when Camel Java DSL is converted into XML using dumpRouteAsXml() operation

#Java DSL route
{code:java}
public void configure() {
	onException(Exception.class).log(""${exception.stacktrace}"").logStackTrace(true)
			.handled(true);

	from(""timer://foo?fixedRate=true&period=10000&repeatCount=101"").routeId(""test"")
			.log(""Hello World"");
}
{code}
#XML converted by dumpRouteAsXml() operation(*<exception>java.lang.Exception</exception>* tag is missing)
{code:java}
<?xml version=""1.0"" encoding=""UTF-8"" standalone=""yes""?>
<route xmlns=""http://camel.apache.org/schema/spring"" customId=""true"" id=""test"">
    <from uri=""timer://foo?fixedRate=true&amp;period=10000&amp;repeatCount=101""/>
    <onException id=""onException1"">
        <redeliveryPolicy logStackTrace=""true""/>
        <log id=""log1"" message=""${exception.stacktrace}""/>
    </onException>
    <log id=""log2"" message=""Hello World""/>
</route>
{code}",davsclaus,Bug,Minor,Resolved,"Exception tag is missing when Camel Java DSL is converted into XML using dumpRouteAsXml() operation Exception tag is missing when Camel Java DSL is converted into XML using dumpRouteAsXml() operation

#Java DSL route
{code:java}
public void configure() {
	onException(Exception.class).log(""${exception.stacktrace}"").logStackTrace(true)
			.handled(true);

	from(""timer://foo?fixedRate=true&period=10000&repeatCount=101"").routeId(""test"")
			.log(""Hello World"");
}
{code}
#XML converted by dumpRouteAsXml() operation(*<exception>java.lang.Exception</exception>* tag is missing)
{code:java}
<?xml version=""1.0"" encoding=""UTF-8"" standalone=""yes""?>
<route xmlns=""http://camel.apache.org/schema/spring"" customId=""true"" id=""test"">
    <from uri=""timer://foo?fixedRate=true&amp;period=10000&amp;repeatCount=101""/>
    <onException id=""onException1"">
        <redeliveryPolicy logStackTrace=""true""/>
        <log id=""log1"" message=""${exception.stacktrace}""/>
    </onException>
    <log id=""log2"" message=""Hello World""/>
</route>
{code}"
CAMEL-13460,camel3 - DefaultEndpoint - Should be singleton by default,"We should
{code}
    @Override
    public boolean isSingleton() {
        // lets be singleton by default as otherwise end-users may mistakenly write components
        // which are not singleton. Only in very rare situations would you need to be non-singletons.
        return true;
    }
{code}

in DefaultEndpoint, and then remove it from all the components that are also singleton. I think its possible only camel-ftp that may not be.",davsclaus,Improvement,Major,Resolved,"camel3 - DefaultEndpoint - Should be singleton by default We should
{code}
    @Override
    public boolean isSingleton() {
        // lets be singleton by default as otherwise end-users may mistakenly write components
        // which are not singleton. Only in very rare situations would you need to be non-singletons.
        return true;
    }
{code}

in DefaultEndpoint, and then remove it from all the components that are also singleton. I think its possible only camel-ftp that may not be."
CAMEL-13459,camel3 - Move language annotations for bean parameter bindings into their own package,"We have @Simple @Constant and @SpEL that are in the root package of language. They should be moved to their sub package, and @SpEL moved to camel-spring",davsclaus,Improvement,Minor,Resolved,"camel3 - Move language annotations for bean parameter bindings into their own package We have @Simple @Constant and @SpEL that are in the root package of language. They should be moved to their sub package, and @SpEL moved to camel-spring"
CAMEL-13457,ProxyHelper - Remove binding option,binding is always default true and setting it to false is no longer supported on Camel 3,davsclaus,Improvement,Major,Resolved,ProxyHelper - Remove binding option binding is always default true and setting it to false is no longer supported on Camel 3
CAMEL-13456,CamelContext - Move API that are not related to end users to an ExtendedCamelContext,"Lets cleanup a bit more on CamelContext and move APIs that are more useable for component developers and internally to Camel itself to an ExtendedCamelContext, so the API the end user see on CamelContext is more limited and mostly relevant to what he/she needs to use.

We already have some for model CamelContext and JMX etc today. ",davsclaus,Improvement,Major,Resolved,"CamelContext - Move API that are not related to end users to an ExtendedCamelContext Lets cleanup a bit more on CamelContext and move APIs that are more useable for component developers and internally to Camel itself to an ExtendedCamelContext, so the API the end user see on CamelContext is more limited and mostly relevant to what he/she needs to use.

We already have some for model CamelContext and JMX etc today. "
CAMEL-13449,camel3 - Move bean component out of camel-core,It seems there are only a few tangles left to make it possible to move bean component and language out of camel-core,davsclaus,Improvement,Major,Resolved,camel3 - Move bean component out of camel-core It seems there are only a few tangles left to make it possible to move bean component and language out of camel-core
CAMEL-13446,camel-xpath does not build,"I think due to CAMEL-13442 refactoring, there's a generated sources path that's looking in the wrong place when camel-xpath tries to build.  Here's the stacktrace:


{code:java}
[INFO] Scanning for projects...
[INFO] 
[INFO] ------------------------------------------------------------------------
[INFO] Building Camel :: XPath 3.0.0-SNAPSHOT
[INFO] ------------------------------------------------------------------------
[INFO] 
[INFO] --- maven-bundle-plugin:4.1.0:cleanVersions (versions) @ camel-xpath ---
[INFO] 
[INFO] --- maven-resources-plugin:3.1.0:resources (default-resources) @ camel-xpath ---
[INFO] Using 'UTF-8' encoding to copy filtered resources.
[INFO] skip non existing resourceDirectory /home/tdalbo/Programming/upstream/apache/camel/components/camel-xpath/src/main/resources
[INFO] 
[INFO] --- flatten-maven-plugin:1.1.0:flatten (default-cli) @ camel-xpath ---
[INFO] Generating flattened POM of project org.apache.camel:camel-xpath:jar:3.0.0-SNAPSHOT...
[INFO] 
[INFO] --- maven-compiler-plugin:3.8.0:compile (default-compile) @ camel-xpath ---
[INFO] Changes detected - recompiling the module!
[INFO] Compiling 8 source files to /home/tdalbo/Programming/upstream/apache/camel/components/camel-xpath/target/classes
[INFO] 
[INFO] --- camel-package-maven-plugin:3.0.0-SNAPSHOT:prepare-components (generate) @ camel-xpath ---
[INFO] ------------------------------------------------------------------------
[INFO] BUILD FAILURE
[INFO] ------------------------------------------------------------------------
[INFO] Total time: 3.298 s
[INFO] Finished at: 2019-04-23T07:42:30-06:00
[INFO] Final Memory: 24M/78M
[INFO] ------------------------------------------------------------------------
[ERROR] Failed to execute goal org.apache.camel:camel-package-maven-plugin:3.0.0-SNAPSHOT:prepare-components (generate) on project camel-xpath: Error loading language model from camel-core. Reason: java.io.FileNotFoundException: /home/tdalbo/Programming/upstream/apache/camel/core/camel-core/target/classes/org/apache/camel/model/language/xpath.json (No such file or directory) -> [Help 1]
[ERROR] 
[ERROR] To see the full stack trace of the errors, re-run Maven with the -e switch.
[ERROR] Re-run Maven using the -X switch to enable full debug logging.
[ERROR] 
[ERROR] For more information about the errors and possible solutions, please read the following articles:
[ERROR] [Help 1] http://cwiki.apache.org/confluence/display/MAVEN/MojoExecutionException
{code}
",davsclaus,Task,Major,Resolved,"camel-xpath does not build I think due to CAMEL-13442 refactoring, there's a generated sources path that's looking in the wrong place when camel-xpath tries to build.  Here's the stacktrace:


{code:java}
[INFO] Scanning for projects...
[INFO] 
[INFO] ------------------------------------------------------------------------
[INFO] Building Camel :: XPath 3.0.0-SNAPSHOT
[INFO] ------------------------------------------------------------------------
[INFO] 
[INFO] --- maven-bundle-plugin:4.1.0:cleanVersions (versions) @ camel-xpath ---
[INFO] 
[INFO] --- maven-resources-plugin:3.1.0:resources (default-resources) @ camel-xpath ---
[INFO] Using 'UTF-8' encoding to copy filtered resources.
[INFO] skip non existing resourceDirectory /home/tdalbo/Programming/upstream/apache/camel/components/camel-xpath/src/main/resources
[INFO] 
[INFO] --- flatten-maven-plugin:1.1.0:flatten (default-cli) @ camel-xpath ---
[INFO] Generating flattened POM of project org.apache.camel:camel-xpath:jar:3.0.0-SNAPSHOT...
[INFO] 
[INFO] --- maven-compiler-plugin:3.8.0:compile (default-compile) @ camel-xpath ---
[INFO] Changes detected - recompiling the module!
[INFO] Compiling 8 source files to /home/tdalbo/Programming/upstream/apache/camel/components/camel-xpath/target/classes
[INFO] 
[INFO] --- camel-package-maven-plugin:3.0.0-SNAPSHOT:prepare-components (generate) @ camel-xpath ---
[INFO] ------------------------------------------------------------------------
[INFO] BUILD FAILURE
[INFO] ------------------------------------------------------------------------
[INFO] Total time: 3.298 s
[INFO] Finished at: 2019-04-23T07:42:30-06:00
[INFO] Final Memory: 24M/78M
[INFO] ------------------------------------------------------------------------
[ERROR] Failed to execute goal org.apache.camel:camel-package-maven-plugin:3.0.0-SNAPSHOT:prepare-components (generate) on project camel-xpath: Error loading language model from camel-core. Reason: java.io.FileNotFoundException: /home/tdalbo/Programming/upstream/apache/camel/core/camel-core/target/classes/org/apache/camel/model/language/xpath.json (No such file or directory) -> [Help 1]
[ERROR] 
[ERROR] To see the full stack trace of the errors, re-run Maven with the -e switch.
[ERROR] Re-run Maven using the -X switch to enable full debug logging.
[ERROR] 
[ERROR] For more information about the errors and possible solutions, please read the following articles:
[ERROR] [Help 1] http://cwiki.apache.org/confluence/display/MAVEN/MojoExecutionException
{code}
"
CAMEL-13442,camel3 - Move xpath out of camel-core,We can move more xml stuff out of camel-core such as the xpath language,davsclaus,Improvement,Major,Resolved,camel3 - Move xpath out of camel-core We can move more xml stuff out of camel-core such as the xpath language
CAMEL-13439,camel3 - DataFormatResolver should be able to lookup from model,"When you have data formats defined via ids, such as
{code}
    <dataFormats>
        <json library=""Jackson"" id=""myjson""/>
        <jaxb contextPath=""org.apache.camel.component.dozer.example.abc"" id=""myjaxb""/>
    </dataFormats>
{code}

",davsclaus,Improvement,Major,Resolved,"camel3 - DataFormatResolver should be able to lookup from model When you have data formats defined via ids, such as
{code}
    <dataFormats>
        <json library=""Jackson"" id=""myjson""/>
        <jaxb contextPath=""org.apache.camel.component.dozer.example.abc"" id=""myjaxb""/>
    </dataFormats>
{code}

"
CAMEL-13432,Simple language - Deprecate and remove change its start/end token,We should rely on simple tokens being ${ } or $simple{ } for its functions. There is some code that would allow to change those but its not really in use and may not actually work in 100% situations. So lets cleanup this for camel 3. So deprecate in camel 2.x and remove in 3.,davsclaus,Improvement,Major,Resolved,Simple language - Deprecate and remove change its start/end token We should rely on simple tokens being ${ } or $simple{ } for its functions. There is some code that would allow to change those but its not really in use and may not actually work in 100% situations. So lets cleanup this for camel 3. So deprecate in camel 2.x and remove in 3.
CAMEL-13430,Simple language - Functions with space should use camelCase style,"Lets avoid having functions such as

starts with
not contains

where there are space as that makes it a bit less obvious its a function name, and can also lead to: https://stackoverflow.com/questions/55705150/camel-simple-expression-inside-jsonpath-language

So instead if we use

startsWith
notContains

",davsclaus,Improvement,Major,Resolved,"Simple language - Functions with space should use camelCase style Lets avoid having functions such as

starts with
not contains

where there are space as that makes it a bit less obvious its a function name, and can also lead to: https://stackoverflow.com/questions/55705150/camel-simple-expression-inside-jsonpath-language

So instead if we use

startsWith
notContains

"
CAMEL-13425,Add possibility to invalidate cache for PropertiesComponent,"Currently I can only enable/disable cache for PropertiesComponent.

I'd like to be able to enable caching, but programmatically invalidate cache on demand.

This should be rather simeple to implemet, something like:
{code:java}
public void invalidateCache() {
  this.cacheMap.clear();
}
{code}",davsclaus,Improvement,Major,Resolved,"Add possibility to invalidate cache for PropertiesComponent Currently I can only enable/disable cache for PropertiesComponent.

I'd like to be able to enable caching, but programmatically invalidate cache on demand.

This should be rather simeple to implemet, something like:
{code:java}
public void invalidateCache() {
  this.cacheMap.clear();
}
{code}"
CAMEL-13422,Remove camel-rmi,"Its bad design to use Java RMI and the work on CAMEL-13421 makes it better to remove this component as well, and deprecate it in 2.x",davsclaus,Improvement,Major,Resolved,"Remove camel-rmi Its bad design to use Java RMI and the work on CAMEL-13421 makes it better to remove this component as well, and deprecate it in 2.x"
CAMEL-13421,Remove BeanInvocation from camel-bean,Doing remote RPC calls via java bean serialization is a bad design and its not really much in use. Lets use the chance to get this removed for 3.x and deprecated in 2.x.,davsclaus,Improvement,Major,Resolved,Remove BeanInvocation from camel-bean Doing remote RPC calls via java bean serialization is a bad design and its not really much in use. Lets use the chance to get this removed for 3.x and deprecated in 2.x.
CAMEL-13417,Move mock component out of camel-core,"Now that we got a bit more moved out, its maybe a bit easier to move out the mock.",davsclaus,Improvement,Major,Resolved,"Move mock component out of camel-core Now that we got a bit more moved out, its maybe a bit easier to move out the mock."
CAMEL-13416,Please add camel-core-osgi to Camel Karaf feature repo,"I was following this documentation [http://camel.apache.org/karaf.html] in order to make Camel work in Karaf.

Many tutorials point to this configuration:
{code:java}
@Override
public void start(final BundleContext bundleContext) throws Exception {
  camelContext = new OsgiDefaultCamelContext(bundleContext);
  registrationCamelContext = bundleContext.registerService(CamelContext.class, camelContext, null);
  camelContext.start();
}
{code}
Unfortunately, when I install Camel in karaf:
{code:java}
karaf@root> feature:repo-add camel 2.23.1
{code}
only camel-core can be installed, while camel-core-osgi is missing.

Unfortunately camel-core contains only 
{code:java}
DefaultCamelContext{code}
which causes classpath problems in Karaf. For example I import camel-http4, but I get:
{code:java}
Caused by: org.apache.camel.ResolveEndpointFailedException: Failed to resolve endpoint: http4://my.site due to: No component found with scheme: http4
{code}
or I import camel-jackson, but I get:
{code:java}
Caused by: java.lang.IllegalArgumentException: Data format 'json-jackson' could not be created. Ensure that the data format is valid and the associated Camel component is present on the classpath
{code}
The solution is to use:
{code:java}
OsgiDefaultCamelContext{code}
which is located in camel-core-osgi, which is unavailable in Camel Karaf repo.

 ",davsclaus,Improvement,Major,Resolved,"Please add camel-core-osgi to Camel Karaf feature repo I was following this documentation [http://camel.apache.org/karaf.html] in order to make Camel work in Karaf.

Many tutorials point to this configuration:
{code:java}
@Override
public void start(final BundleContext bundleContext) throws Exception {
  camelContext = new OsgiDefaultCamelContext(bundleContext);
  registrationCamelContext = bundleContext.registerService(CamelContext.class, camelContext, null);
  camelContext.start();
}
{code}
Unfortunately, when I install Camel in karaf:
{code:java}
karaf@root> feature:repo-add camel 2.23.1
{code}
only camel-core can be installed, while camel-core-osgi is missing.

Unfortunately camel-core contains only 
{code:java}
DefaultCamelContext{code}
which causes classpath problems in Karaf. For example I import camel-http4, but I get:
{code:java}
Caused by: org.apache.camel.ResolveEndpointFailedException: Failed to resolve endpoint: http4://my.site due to: No component found with scheme: http4
{code}
or I import camel-jackson, but I get:
{code:java}
Caused by: java.lang.IllegalArgumentException: Data format 'json-jackson' could not be created. Ensure that the data format is valid and the associated Camel component is present on the classpath
{code}
The solution is to use:
{code:java}
OsgiDefaultCamelContext{code}
which is located in camel-core-osgi, which is unavailable in Camel Karaf repo.

 "
CAMEL-13414,Date.getTime() can be changed to System.currentTimeMillis(),"Hello,
I found that System.currentTimeMillis() can be used here instead of new Date.getTime().
Since new Date() is a thin wrapper of light method System.currentTimeMillis(). The performance will be greatly damaged if it is invoked too much times.
According to my local testing at the same environment, System.currentTimeMillis() can achieve a speedup to 5 times (435 ms vs 2073 ms), when these two methods are invoked 5,000,000 times.",davsclaus,Improvement,Minor,Resolved,"Date.getTime() can be changed to System.currentTimeMillis() Hello,
I found that System.currentTimeMillis() can be used here instead of new Date.getTime().
Since new Date() is a thin wrapper of light method System.currentTimeMillis(). The performance will be greatly damaged if it is invoked too much times.
According to my local testing at the same environment, System.currentTimeMillis() can achieve a speedup to 5 times (435 ms vs 2073 ms), when these two methods are invoked 5,000,000 times."
CAMEL-13403,"Default allowUseOriginalMessage=""false"" prevent clearing inflightRepository using jms with transferExchange=""true""","When using transferExchange=""true"" in a JMS consumer (assuming producer also did), camel is breaking the match between key and exchange in inflightRepository if allowUseOriginalMessage=""true"" is not set in camel context.

This can lead to java heap space out of memory because camel is not able to clear the inflightRepository from old Exchange.

Identified behaviour :
 # Camel receive the JMS message
 ## If allowUseOriginalMessage=true : parse JMS message to build Exchange instance
 ## If not : generate a new Instance
 # Camel add the Exchange to inflightRepository
 # On accessing the ExchangeBody, if it was not parsed  yet camel rebuild the Exchange but do not change the key(exchangeId) in the inflightRepository
 # When the route process is over the message is not disposed if the key has been changed in the Exchange but not inflightRepository
 # Sooner or later the heap space if full and application crash.

The problem appeared in 2.18.0 and is present up until 2.23.1 (tested with attached test case). Release note of 2.18.0 says :

""Optimize Camel to only enable AllowUseOriginalMessage if in use by error handler or OnCompletion<[http://camel.apache.org/oncompletion.html]>. End user who manually access the original message using the Java API must configure AllowUseOriginalMessage=true.""

Problem is transferExchange=""true"" case also needs allowUseOriginalMessage=""true"" even if the not accessing original message by Java API an other way.

Easy work around : set allowUseOriginalMessage=""true"" in camel context configuration",davsclaus,Bug,Minor,Resolved,"Default allowUseOriginalMessage=""false"" prevent clearing inflightRepository using jms with transferExchange=""true"" When using transferExchange=""true"" in a JMS consumer (assuming producer also did), camel is breaking the match between key and exchange in inflightRepository if allowUseOriginalMessage=""true"" is not set in camel context.

This can lead to java heap space out of memory because camel is not able to clear the inflightRepository from old Exchange.

Identified behaviour :
 # Camel receive the JMS message
 ## If allowUseOriginalMessage=true : parse JMS message to build Exchange instance
 ## If not : generate a new Instance
 # Camel add the Exchange to inflightRepository
 # On accessing the ExchangeBody, if it was not parsed  yet camel rebuild the Exchange but do not change the key(exchangeId) in the inflightRepository
 # When the route process is over the message is not disposed if the key has been changed in the Exchange but not inflightRepository
 # Sooner or later the heap space if full and application crash.

The problem appeared in 2.18.0 and is present up until 2.23.1 (tested with attached test case). Release note of 2.18.0 says :

""Optimize Camel to only enable AllowUseOriginalMessage if in use by error handler or OnCompletion<[http://camel.apache.org/oncompletion.html]>. End user who manually access the original message using the Java API must configure AllowUseOriginalMessage=true.""

Problem is transferExchange=""true"" case also needs allowUseOriginalMessage=""true"" even if the not accessing original message by Java API an other way.

Easy work around : set allowUseOriginalMessage=""true"" in camel context configuration"
CAMEL-13400,Camel FTP Cannot list directory with 'File not found' prepending additional '/' in front of directory automatically,"I need to poll files form a dynamic folder based on a specific date, so I have provided the parent directory in endpoint URI, enabled recursive flag and add filterDirectory accordingly. But It is not able to poll from the directory, it says file not found for that directory. It is trying with an addition '/' while listing {{listFor(/XXXX)}}

*Endpoint URI*

{{sftp://XXXX:22051?connectTimeout=90000&disconnect=true&filterDirectory=%24%7Bfile%3Aname%7D+starts+with+%27%24%7Bbean%3AdateofExchange%3Fmethod%3DforLoc%28%22MY%22%29%7D%27&flatten=true&include=.*IMG&knownHostsFile=C%3A%5Cprogram+files%5Cascertain%5CI2R-MystiQ-Engine%5Cknown_hosts&noop=true&password=xxxxxx&preferredAuthentications=password&reconnectDelay=30000&recursive=true&scheduler=quartz2&scheduler.cron=0+0%2F5+*+*+*+%3F&stepwise=false&username=XXXX_ftpuser }}

*TRACE LOG*

{{TRACE 2019-04-05T15:25:03,389 [org.apache.camel.component.file.remote.SftpConsumer] - Polling directory: TRACE 2019-04-05T15:25:03,389 [org.apache.camel.component.file.remote.SftpOperations] - listFiles() TRACE 2019-04-05T15:25:03,712 [org.apache.camel.component.file.remote.SftpConsumer] - Found 12 in directory: TRACE 2019-04-05T15:25:03,712 [org.apache.camel.component.file.remote.SftpConsumer] - SftpFile[fileName=., longName=dr-x------ 2 ftpadmin ftpadmin 0 Mar 12 05:27 ., dir=true] TRACE 2019-04-05T15:25:03,712 [org.apache.camel.component.file.remote.SftpConsumer] - File did not match. Will skip this file: RemoteFile[.] TRACE 2019-04-05T15:25:03,712 [org.apache.camel.component.file.remote.SftpConsumer] - SftpFile[fileName=.., longName=dr-x------ 2 ftpadmin ftpadmin 0 Mar 12 03:04 .., dir=true] TRACE 2019-04-05T15:25:03,712 [org.apache.camel.component.file.remote.SftpConsumer] - File did not match. Will skip this file: RemoteFile[..] TRACE 2019-04-05T15:25:03,728 [org.apache.camel.component.file.remote.SftpConsumer] - SftpFile[fileName=20170526, longName=dr-x------ 2 ftpadmin ftpadmin 0 Mar 12 02:16 20170526, dir=true] TRACE 2019-04-05T15:25:04,413 [org.apache.camel.component.file.remote.SftpConsumer] - File did not match. Will skip this file: RemoteFile[20170526] TRACE 2019-04-05T15:25:04,413 [org.apache.camel.component.file.remote.SftpConsumer] - SftpFile[fileName=20181119, longName=dr-x------ 2 ftpadmin ftpadmin 0 Mar 12 05:24 20181119, dir=true] TRACE 2019-04-05T15:25:05,117 [org.apache.camel.component.file.remote.SftpConsumer] - File did not match. Will skip this file: RemoteFile[20181119] TRACE 2019-04-05T15:25:05,117 [org.apache.camel.component.file.remote.SftpConsumer] - SftpFile[fileName=20181121, longName=dr-x------ 2 ftpadmin ftpadmin 0 Mar 12 05:25 20181121, dir=true] TRACE 2019-04-05T15:25:05,837 [org.apache.camel.component.file.remote.SftpConsumer] - File did not match. Will skip this file: RemoteFile[20181121] TRACE 2019-04-05T15:25:05,840 [org.apache.camel.component.file.remote.SftpConsumer] - SftpFile[fileName=20181122, longName=dr-x------ 2 ftpadmin ftpadmin 0 Mar 12 05:26 20181122, dir=true] TRACE 2019-04-05T15:25:06,561 [org.apache.camel.component.file.remote.SftpConsumer] - File did not match. Will skip this file: RemoteFile[20181122] TRACE 2019-04-05T15:25:06,563 [org.apache.camel.component.file.remote.SftpConsumer] - SftpFile[fileName=20181123, longName=dr-x------ 2 ftpadmin ftpadmin 0 Mar 12 05:27 20181123, dir=true] TRACE 2019-04-05T15:25:07,258 [org.apache.camel.component.file.remote.SftpConsumer] - Polling sub directory: /20181123 from: sftp://XXXX:22051?connectTimeout=90000&disconnect=true&filterDirectory=%24%7Bfile%3Aname%7D+starts+with+%27%24%7Bbean%3AdateofExchange%3Fmethod%3DforLoc%28%22MY%22%29%7D%27&flatten=true&include=.*IMG&knownHostsFile=C%3A%5Cprogram+files%5Cascertain%5CI2R-MystiQ-Engine%5Cknown_hosts&noop=true&password=xxxxxx&preferredAuthentications=password&reconnectDelay=30000&recursive=true&scheduler=quartz2&scheduler.cron=0+0%2F5+*+*+*+%3F&stepwise=false&username=XXXX_ftpuser TRACE 2019-04-05T15:25:07,260 [org.apache.camel.component.file.remote.SftpConsumer] - doPollDirectory from absolutePath: /20181123, dirName: 20181123 TRACE 2019-04-05T15:25:07,263 [org.apache.camel.component.file.remote.SftpConsumer] - Polling directory: /20181123 TRACE 2019-04-05T15:25:07,265 [org.apache.camel.component.file.remote.SftpOperations] - listFiles(/20181123) DEBUG 2019-04-05T15:25:07,281 [org.apache.camel.component.file.remote.SftpConsumer] - Caught exception Cannot list directory: /20181123 TRACE 2019-04-05T15:25:07,297 [org.apache.camel.component.file.remote.SftpConsumer] - Not ignoring file error Cannot list directory: /20181123 for /20181123 DEBUG 2019-04-05T15:25:07,297 [org.apache.camel.component.file.remote.SftpConsumer] - Error occurred during poll directory: due Cannot list directory: /20181123. Removing 0 files marked as in-progress. WARN 2019-04-05T15:25:07,297 [org.apache.camel.component.file.remote.RemoteFilePollingConsumerPollStrategy] - Trying to recover by force disconnecting from remote server and re-connecting at next poll: sftp://XXX@1XXXX:22051 DEBUG 2019-04-05T15:25:07,297 [org.apache.camel.component.file.remote.SftpConsumer] - Force disconnecting from: sftp://XXX@XXXX:22051 WARN 2019-04-05T15:25:07,297 [org.apache.camel.component.file.remote.SftpConsumer] - Consumer SftpConsumer[sftp://XXXX:22051?connectTimeout=90000&disconnect=true&filterDirectory=%24%7Bfile%3Aname%7D+starts+with+%27%24%7Bbean%3AdateofExchange%3Fmethod%3DforLoc%28%22MY%22%29%7D%27&flatten=true&include=.*IMG&knownHostsFile=C%3A%5Cprogram+files%5Cascertain%5CI2R-MystiQ-Engine%5Cknown_hosts&noop=true&password=xxxxxx&preferredAuthentications=password&reconnectDelay=30000&recursive=true&scheduler=quartz2&scheduler.cron=0+0%2F5+*+*+*+%3F&stepwise=false&username=XXXX_ftpuser] failed polling endpoint: sftp://XXXX:22051?connectTimeout=90000&disconnect=true&filterDirectory=%24%7Bfile%3Aname%7D+starts+with+%27%24%7Bbean%3AdateofExchange%3Fmethod%3DforLoc%28%22MY%22%29%7D%27&flatten=true&include=.*IMG&knownHostsFile=C%3A%5Cprogram+files%5Cascertain%5CI2R-MystiQ-Engine%5Cknown_hosts&noop=true&password=xxxxxx&preferredAuthentications=password&reconnectDelay=30000&recursive=true&scheduler=quartz2&scheduler.cron=0+0%2F5+*+*+*+%3F&stepwise=false&username=XXXX_ftpuser. Will try again at next poll. Caused by: [org.apache.camel.component.file.GenericFileOperationFailedException - Cannot list directory: /20181123] org.apache.camel.component.file.GenericFileOperationFailedException: Cannot list directory: /20181123 at org.apache.camel.component.file.remote.SftpOperations.listFiles(SftpOperations.java:660) ~[camel-ftp-2.21.1.jar!/:2.21.1] at org.apache.camel.component.file.remote.SftpConsumer.doPollDirectory(SftpConsumer.java:128) ~[camel-ftp-2.21.1.jar!/:2.21.1] at org.apache.camel.component.file.remote.RemoteFileConsumer.doSafePollSubDirectory(RemoteFileConsumer.java:260) ~[camel-ftp-2.21.1.jar!/:2.21.1] at org.apache.camel.component.file.remote.SftpConsumer.pollSubDirectory(SftpConsumer.java:96) ~[camel-ftp-2.21.1.jar!/:2.21.1] at org.apache.camel.component.file.remote.SftpConsumer.doPollDirectory(SftpConsumer.java:178) ~[camel-ftp-2.21.1.jar!/:2.21.1] at org.apache.camel.component.file.remote.SftpConsumer.pollDirectory(SftpConsumer.java:87) ~[camel-ftp-2.21.1.jar!/:2.21.1] at org.apache.camel.component.file.GenericFileConsumer.poll(GenericFileConsumer.java:124) ~[camel-core-2.21.1.jar!/:2.21.1] at org.apache.camel.impl.ScheduledPollConsumer.doRun(ScheduledPollConsumer.java:174) [camel-core-2.21.1.jar!/:2.21.1] at org.apache.camel.impl.ScheduledPollConsumer.run(ScheduledPollConsumer.java:101) [camel-core-2.21.1.jar!/:2.21.1] at org.apache.camel.pollconsumer.quartz2.QuartzScheduledPollConsumerJob.execute(QuartzScheduledPollConsumerJob.java:61) [camel-quartz2-2.21.1.jar!/:2.21.1] at org.quartz.core.JobRunShell.run(JobRunShell.java:202) [quartz-2.3.0.jar!/:?] at org.quartz.simpl.SimpleThreadPool$WorkerThread.run(SimpleThreadPool.java:573) [quartz-2.3.0.jar!/:?] Caused by: com.jcraft.jsch.SftpException: File not found: /20181123 at com.jcraft.jsch.ChannelSftp.throwStatusError(ChannelSftp.java:2873) ~[jsch-0.1.54.jar!/:?] at com.jcraft.jsch.ChannelSftp._stat(ChannelSftp.java:2225) ~[jsch-0.1.54.jar!/:?] at com.jcraft.jsch.ChannelSftp._stat(ChannelSftp.java:2242) ~[jsch-0.1.54.jar!/:?] at com.jcraft.jsch.ChannelSftp.ls(ChannelSftp.java:1592) ~[jsch-0.1.54.jar!/:?] at com.jcraft.jsch.ChannelSftp.ls(ChannelSftp.java:1553) ~[jsch-0.1.54.jar!/:?] at org.apache.camel.component.file.remote.SftpOperations.listFiles(SftpOperations.java:651) ~[camel-ftp-2.21.1.jar!/:2.21.1] ... 11 more }}

When I try to hardcode that folder along with endpint URI, it simply can list that directory and poll files. This time there is no '/' before the directory while listing {{listFor(XXXX)}}

*Endpoint URI*

{{sftp://XXXX:22051/20181123?connectTimeout=90000&disconnect=true&flatten=true&include=.*IMG&knownHostsFile=C%3A%5Cprogram+files%5Cascertain%5CI2R-MystiQ-Engine%5Cknown_hosts&noop=true&password=xxxxxx&preferredAuthentications=password&reconnectDelay=30000&recursive=true&scheduler=quartz2&scheduler.cron=0+0%2F5+*+*+*+%3F&separator=Auto&stepwise=false&username=XXXX_ftpuser }}

*TRACE LOG*

{{TRACE 2019-04-05T18:40:00,009 [org.apache.camel.component.file.remote.SftpConsumer] - prePollCheck on sftp://XXX@XXXX:22051 DEBUG 2019-04-05T18:40:00,009 [org.apache.camel.component.file.remote.SftpConsumer] - Not connected/logged in, connecting to: sftp://XXX@XXXX:22051 TRACE 2019-04-05T18:40:00,009 [org.apache.camel.component.file.remote.SftpOperations] - Session isn't connected, trying to recreate and connect. DEBUG 2019-04-05T18:40:00,009 [org.apache.camel.component.file.remote.SftpOperations] - Using knownhosts file: C:\program files\ascertain\I2R-MystiQ-Engine\known_hosts DEBUG 2019-04-05T18:40:00,009 [org.apache.camel.component.file.remote.SftpOperations] - Using known hosts information from file: C:\program files\ascertain\I2R-MystiQ-Engine\known_hosts DEBUG 2019-04-05T18:40:00,025 [org.apache.camel.component.file.remote.SftpOperations] - Using StrickHostKeyChecking: no DEBUG 2019-04-05T18:40:00,025 [org.apache.camel.component.file.remote.SftpOperations] - Using PreferredAuthentications: password TRACE 2019-04-05T18:40:00,025 [org.apache.camel.component.file.remote.SftpOperations] - Connecting use connectTimeout: 90000 ... TRACE 2019-04-05T18:40:00,465 [org.apache.camel.component.file.remote.SftpOperations] - Channel isn't connected, trying to recreate and connect. TRACE 2019-04-05T18:40:00,465 [org.apache.camel.component.file.remote.SftpOperations] - Connecting use connectTimeout: 90000 ... DEBUG 2019-04-05T18:40:01,215 [org.apache.camel.component.file.remote.SftpOperations] - Connected to sftp://XXX@XXXX:22051 DEBUG 2019-04-05T18:40:01,215 [org.apache.camel.component.file.remote.SftpConsumer] - Connected and logged in to: sftp://XXX@XXXX:22051 TRACE 2019-04-05T18:40:01,215 [org.apache.camel.component.file.remote.SftpConsumer] - doPollDirectory from absolutePath: 20181123, dirName: null TRACE 2019-04-05T18:40:01,215 [org.apache.camel.component.file.remote.SftpConsumer] - Polling directory: 20181123 TRACE 2019-04-05T18:40:01,215 [org.apache.camel.component.file.remote.SftpOperations] - listFiles(20181123) TRACE 2019-04-05T18:40:02,621 [org.apache.camel.component.file.remote.SftpConsumer] - Found 6 in directory: 20181123 TRACE 2019-04-05T18:40:02,621 [org.apache.camel.component.file.remote.SftpConsumer] - SftpFile[fileName=., longName=dr-x------ 2 ftpadmin ftpadmin 0 Mar 12 05:27 ., dir=true] TRACE 2019-04-05T18:40:02,621 [org.apache.camel.component.file.remote.SftpConsumer] - File did not match. Will skip this file: RemoteFile[.] TRACE 2019-04-05T18:40:02,637 [org.apache.camel.component.file.remote.SftpConsumer] - SftpFile[fileName=.., longName=dr-x------ 2 ftpadmin ftpadmin 0 Mar 12 05:27 .., dir=true] TRACE 2019-04-05T18:40:02,637 [org.apache.camel.component.file.remote.SftpConsumer] - File did not match. Will skip this file: RemoteFile[..] TRACE 2019-04-05T18:40:02,637 [org.apache.camel.component.file.remote.SftpConsumer] - SftpFile[fileName=Consolidated, longName=dr-x------ 2 ftpadmin ftpadmin 0 Mar 12 05:26 Consolidated, dir=true] TRACE 2019-04-05T18:40:02,637 [org.apache.camel.component.file.remote.SftpConsumer] - Polling sub directory: 20181123/Consolidated from: sftp://XXXX:22051/20181123?connectTimeout=90000&disconnect=true&flatten=true&include=.*IMG&knownHostsFile=C%3A%5Cprogram+files%5Cascertain%5CI2R-MystiQ-Engine%5Cknown_hosts&noop=true&password=xxxxxx&preferredAuthentications=password&reconnectDelay=30000&recursive=true&scheduler=quartz2&scheduler.cron=0+0%2F5+*+*+*+%3F&separator=Auto&stepwise=false&username=XXXX_ftpuser TRACE 2019-04-05T18:40:02,637 [org.apache.camel.component.file.remote.SftpConsumer] - doPollDirectory from absolutePath: 20181123/Consolidated, dirName: Consolidated TRACE 2019-04-05T18:40:02,637 [org.apache.camel.component.file.remote.SftpConsumer] - Polling directory: 20181123/Consolidated TRACE 2019-04-05T18:40:02,637 [org.apache.camel.component.file.remote.SftpOperations] - listFiles(20181123/Consolidated) TRACE 2019-04-05T18:40:02,715 [org.apache.camel.component.file.remote.SftpConsumer] - Found 5 in directory: 20181123/Consolidated TRACE 2019-04-05T18:40:02,715 [org.apache.camel.component.file.remote.SftpConsumer] - SftpFile[fileName=., longName=dr-x------ 2 ftpadmin ftpadmin 0 Mar 12 05:26 ., dir=true] TRACE 2019-04-05T18:40:02,715 [org.apache.camel.component.file.remote.SftpConsumer] - File did not match. Will skip this file: RemoteFile[Consolidated/.] TRACE 2019-04-05T18:40:02,715 [org.apache.camel.component.file.remote.SftpConsumer] - SftpFile[fileName=.., longName=dr-x------ 2 ftpadmin ftpadmin 0 Mar 12 05:27 .., dir=true] TRACE 2019-04-05T18:40:02,715 [org.apache.camel.component.file.remote.SftpConsumer] - File did not match. Will skip this file: RemoteFile[Consolidated/..] TRACE 2019-04-05T18:40:02,715 [org.apache.camel.component.file.remote.SftpConsumer] - SftpFile[fileName=20181124020438943_021420181123INW.MYR, longName=-r-x------ 1 ftpadmin ftpadmin 408097 Nov 23 2018 20181124020438943_021420181123INW.MYR, dir=false] TRACE 2019-04-05T18:40:02,731 [org.apache.camel.component.file.remote.SftpConsumer] - File did not match. Will skip this file: RemoteFile[Consolidated/20181124020438943_021420181123INW.MYR] TRACE 2019-04-05T18:40:02,731 [org.apache.camel.component.file.remote.SftpConsumer] - SftpFile[fileName=20181124020439099_035820181123INW.MYR, longName=-r-x------ 1 ftpadmin ftpadmin 21689 Nov 23 2018 20181124020439099_035820181123INW.MYR, dir=false] TRACE 2019-04-05T18:40:02,731 [org.apache.camel.component.file.remote.SftpConsumer] - File did not match. Will skip this file: RemoteFile[Consolidated/20181124020439099_035820181123INW.MYR] TRACE 2019-04-05T18:40:02,731 [org.apache.camel.component.file.remote.SftpConsumer] - SftpFile[fileName=ToPPay, longName=dr-x------ 2 ftpadmin ftpadmin 0 Mar 12 06:41 ToPPay, dir=true] TRACE 2019-04-05T18:40:02,731 [org.apache.camel.component.file.remote.SftpConsumer] - Polling sub directory: 20181123/Consolidated/ToPPay from: sftp://XXXX:22051/20181123?connectTimeout=90000&disconnect=true&flatten=true&include=.*IMG&knownHostsFile=C%3A%5Cprogram+files%5Cascertain%5CI2R-MystiQ-Engine%5Cknown_hosts&noop=true&password=xxxxxx&preferredAuthentications=password&reconnectDelay=30000&recursive=true&scheduler=quartz2&scheduler.cron=0+0%2F5+*+*+*+%3F&separator=Auto&stepwise=false&username=XXXX_ftpuser TRACE 2019-04-05T18:40:02,731 [org.apache.camel.component.file.remote.SftpConsumer] - doPollDirectory from absolutePath: 20181123/Consolidated/ToPPay, dirName: ToPPay TRACE 2019-04-05T18:40:02,731 [org.apache.camel.component.file.remote.SftpConsumer] - Polling directory: 20181123/Consolidated/ToPPay TRACE 2019-04-05T18:40:02,731 [org.apache.camel.component.file.remote.SftpOperations] - listFiles(20181123/Consolidated/ToPPay) TRACE 2019-04-05T18:40:02,777 [org.apache.camel.component.file.remote.SftpConsumer] - Found 8 in directory: 20181123/Consolidated/ToPPay TRACE 2019-04-05T18:40:02,777 [org.apache.camel.component.file.remote.SftpConsumer] - SftpFile[fileName=., longName=dr-x------ 2 ftpadmin ftpadmin 0 Mar 12 06:41 ., dir=true] TRACE 2019-04-05T18:40:02,777 [org.apache.camel.component.file.remote.SftpConsumer] - File did not match. Will skip this file: RemoteFile[Consolidated/ToPPay/.] TRACE 2019-04-05T18:40:02,777 [org.apache.camel.component.file.remote.SftpConsumer] - SftpFile[fileName=.., longName=dr-x------ 2 ftpadmin ftpadmin 0 Mar 12 05:26 .., dir=true] TRACE 2019-04-05T18:40:02,777 [org.apache.camel.component.file.remote.SftpConsumer] - File did not match. Will skip this file: RemoteFile[Consolidated/ToPPay/..] TRACE 2019-04-05T18:40:02,793 [org.apache.camel.component.file.remote.SftpConsumer] - SftpFile[fileName=021420181123INW.MYR, longName=-r-x------ 1 ftpadmin ftpadmin 408097 Nov 23 2018 021420181123INW.MYR, dir=false] TRACE 2019-04-05T18:40:02,793 [org.apache.camel.component.file.remote.SftpConsumer] - File did not match. Will skip this file: RemoteFile[Consolidated/ToPPay/021420181123INW.MYR] TRACE 2019-04-05T18:40:02,793 [org.apache.camel.component.file.remote.SftpConsumer] - SftpFile[fileName=021420181123INW1.MYR, longName=-r-x------ 1 ftpadmin ftpadmin 579829 Nov 23 2018 021420181123INW1.MYR, dir=false] TRACE 2019-04-05T18:40:02,793 [org.apache.camel.component.file.remote.SftpConsumer] - File did not match. Will skip this file: RemoteFile[Consolidated/ToPPay/021420181123INW1.MYR] TRACE 2019-04-05T18:40:02,793 [org.apache.camel.component.file.remote.SftpConsumer] - SftpFile[fileName=035820181123INW.MYR, longName=-r-x------ 1 ftpadmin ftpadmin 21689 Nov 23 2018 035820181123INW.MYR, dir=false] TRACE 2019-04-05T18:40:02,793 [org.apache.camel.component.file.remote.SftpConsumer] - File did not match. Will skip this file: RemoteFile[Consolidated/ToPPay/035820181123INW.MYR] TRACE 2019-04-05T18:40:02,793 [org.apache.camel.component.file.remote.SftpConsumer] - SftpFile[fileName=035820181123INW1.MYR, longName=-r-x------ 1 ftpadmin ftpadmin 30954 Nov 23 2018 035820181123INW1.MYR, dir=false] TRACE 2019-04-05T18:40:02,793 [org.apache.camel.component.file.remote.SftpConsumer] - File did not match. Will skip this file: RemoteFile[Consolidated/ToPPay/035820181123INW1.MYR] TRACE 2019-04-05T18:40:02,809 [org.apache.camel.component.file.remote.SftpConsumer] - SftpFile[fileName=20181124020438943_021420181123INW.MYR, longName=-r-x------ 1 ftpadmin ftpadmin 408097 Nov 23 2018 20181124020438943_021420181123INW.MYR, dir=false] TRACE 2019-04-05T18:40:02,809 [org.apache.camel.component.file.remote.SftpConsumer] - File did not match. Will skip this file: RemoteFile[Consolidated/ToPPay/20181124020438943_021420181123INW.MYR] TRACE 2019-04-05T18:40:02,809 [org.apache.camel.component.file.remote.SftpConsumer] - SftpFile[fileName=20181124020439099_035820181123INW.MYR, longName=-r-x------ 1 ftpadmin ftpadmin 21689 Nov 23 2018 20181124020439099_035820181123INW.MYR, dir=false] TRACE 2019-04-05T18:40:02,809 [org.apache.camel.component.file.remote.SftpConsumer] - File did not match. Will skip this file: RemoteFile[Consolidated/ToPPay/20181124020439099_035820181123INW.MYR] TRACE 2019-04-05T18:40:02,809 [org.apache.camel.component.file.remote.SftpConsumer] - SftpFile[fileName=Data, longName=dr-x------ 2 ftpadmin ftpadmin 0 Mar 12 05:26 Data, dir=true] TRACE 2019-04-05T18:40:02,809 [org.apache.camel.component.file.remote.SftpConsumer] - Polling sub directory: 20181123/Data from: sftp://XXXX:22051/20181123?connectTimeout=90000&disconnect=true&flatten=true&include=.*IMG&knownHostsFile=C%3A%5Cprogram+files%5Cascertain%5CI2R-MystiQ-Engine%5Cknown_hosts&noop=true&password=xxxxxx&preferredAuthentications=password&reconnectDelay=30000&recursive=true&scheduler=quartz2&scheduler.cron=0+0%2F5+*+*+*+%3F&separator=Auto&stepwise=false&username=XXXX_ftpuser TRACE 2019-04-05T18:40:02,809 [org.apache.camel.component.file.remote.SftpConsumer] - doPollDirectory from absolutePath: 20181123/Data, dirName: Data TRACE 2019-04-05T18:40:02,809 [org.apache.camel.component.file.remote.SftpConsumer] - Polling directory: 20181123/Data TRACE 2019-04-05T18:40:02,809 [org.apache.camel.component.file.remote.SftpOperations] - listFiles(20181123/Data) TRACE 2019-04-05T18:40:02,871 [org.apache.camel.component.file.remote.SftpConsumer] - Found 501 in directory: 20181123/Data TRACE 2019-04-05T18:40:02,871 [org.apache.camel.component.file.remote.SftpConsumer] - SftpFile[fileName=., longName=dr-x------ 2 ftpadmin ftpadmin 0 Mar 12 05:26 ., dir=true] TRACE 2019-04-05T18:40:02,871 [org.apache.camel.component.file.remote.SftpConsumer] - File did not match. Will skip this file: RemoteFile[Data/.] TRACE 2019-04-05T18:40:02,871 [org.apache.camel.component.file.remote.SftpConsumer] - SftpFile[fileName=.., longName=dr-x------ 2 ftpadmin ftpadmin 0 Mar 12 05:27 .., dir=true] TRACE 2019-04-05T18:40:02,871 [org.apache.camel.component.file.remote.SftpConsumer] - File did not match. Will skip this file: RemoteFile[Data/..] TRACE 2019-04-05T18:40:02,871 [org.apache.camel.component.file.remote.SftpConsumer] - SftpFile[fileName=20181123021401015101004323IWNM.MMYR, longName=-r-x------ 1 ftpadmin ftpadmin 14846 Nov 23 2018 20181123021401015101004323IWNM.MMYR, dir=false] TRACE 2019-04-05T18:40:02,871 [org.apache.camel.component.file.remote.SftpConsumer] - File did not match. Will skip this file: RemoteFile[Data/20181123021401015101004323IWNM.MMYR] }}

I am sure that the cause of the issue has to be the addition '/' prepending with directory name while listing {{listFor(/XXXX)}}. How can I avoid it ! .. using {{seperator}} parameter didn't effect i suppose it is only for producing files and not for consuming. I need to resolve this issue as soon as possible. Please suggest me some solution :(

*EDITED :*

I can reproduce the issue in latest version as well,I suppose the issue is when there is no base path only the '/' gets prepended which should not actually happen

Code Snippet from SftpConsumer.java Camel 3.0.0.M1

{{if (file.isDirectory()) \{ RemoteFile<SftpRemoteFile> remote = asRemoteFile(absolutePath, file, getEndpoint().getCharset()); if (endpoint.isRecursive() && depth < endpoint.getMaxDepth() && isValidFile(remote, true, files)) { // recursive scan and add the sub files and folders String subDirectory = file.getFilename(); String path = absolutePath + ""/"" + subDirectory; boolean canPollMore = pollSubDirectory(path, subDirectory, fileList, depth); if (!canPollMore) { return false; } } // we cannot use file.getAttrs().isLink on Windows, so we dont invoke the method // just assuming its a file we should poll } }}
{quote}String path = absolutePath + ""/"" + subDirectory;
{quote}",davsclaus,Bug,Major,Resolved,"Camel FTP Cannot list directory with 'File not found' prepending additional '/' in front of directory automatically I need to poll files form a dynamic folder based on a specific date, so I have provided the parent directory in endpoint URI, enabled recursive flag and add filterDirectory accordingly. But It is not able to poll from the directory, it says file not found for that directory. It is trying with an addition '/' while listing {{listFor(/XXXX)}}

*Endpoint URI*

{{sftp://XXXX:22051?connectTimeout=90000&disconnect=true&filterDirectory=%24%7Bfile%3Aname%7D+starts+with+%27%24%7Bbean%3AdateofExchange%3Fmethod%3DforLoc%28%22MY%22%29%7D%27&flatten=true&include=.*IMG&knownHostsFile=C%3A%5Cprogram+files%5Cascertain%5CI2R-MystiQ-Engine%5Cknown_hosts&noop=true&password=xxxxxx&preferredAuthentications=password&reconnectDelay=30000&recursive=true&scheduler=quartz2&scheduler.cron=0+0%2F5+*+*+*+%3F&stepwise=false&username=XXXX_ftpuser }}

*TRACE LOG*

{{TRACE 2019-04-05T15:25:03,389 [org.apache.camel.component.file.remote.SftpConsumer] - Polling directory: TRACE 2019-04-05T15:25:03,389 [org.apache.camel.component.file.remote.SftpOperations] - listFiles() TRACE 2019-04-05T15:25:03,712 [org.apache.camel.component.file.remote.SftpConsumer] - Found 12 in directory: TRACE 2019-04-05T15:25:03,712 [org.apache.camel.component.file.remote.SftpConsumer] - SftpFile[fileName=., longName=dr-x------ 2 ftpadmin ftpadmin 0 Mar 12 05:27 ., dir=true] TRACE 2019-04-05T15:25:03,712 [org.apache.camel.component.file.remote.SftpConsumer] - File did not match. Will skip this file: RemoteFile[.] TRACE 2019-04-05T15:25:03,712 [org.apache.camel.component.file.remote.SftpConsumer] - SftpFile[fileName=.., longName=dr-x------ 2 ftpadmin ftpadmin 0 Mar 12 03:04 .., dir=true] TRACE 2019-04-05T15:25:03,712 [org.apache.camel.component.file.remote.SftpConsumer] - File did not match. Will skip this file: RemoteFile[..] TRACE 2019-04-05T15:25:03,728 [org.apache.camel.component.file.remote.SftpConsumer] - SftpFile[fileName=20170526, longName=dr-x------ 2 ftpadmin ftpadmin 0 Mar 12 02:16 20170526, dir=true] TRACE 2019-04-05T15:25:04,413 [org.apache.camel.component.file.remote.SftpConsumer] - File did not match. Will skip this file: RemoteFile[20170526] TRACE 2019-04-05T15:25:04,413 [org.apache.camel.component.file.remote.SftpConsumer] - SftpFile[fileName=20181119, longName=dr-x------ 2 ftpadmin ftpadmin 0 Mar 12 05:24 20181119, dir=true] TRACE 2019-04-05T15:25:05,117 [org.apache.camel.component.file.remote.SftpConsumer] - File did not match. Will skip this file: RemoteFile[20181119] TRACE 2019-04-05T15:25:05,117 [org.apache.camel.component.file.remote.SftpConsumer] - SftpFile[fileName=20181121, longName=dr-x------ 2 ftpadmin ftpadmin 0 Mar 12 05:25 20181121, dir=true] TRACE 2019-04-05T15:25:05,837 [org.apache.camel.component.file.remote.SftpConsumer] - File did not match. Will skip this file: RemoteFile[20181121] TRACE 2019-04-05T15:25:05,840 [org.apache.camel.component.file.remote.SftpConsumer] - SftpFile[fileName=20181122, longName=dr-x------ 2 ftpadmin ftpadmin 0 Mar 12 05:26 20181122, dir=true] TRACE 2019-04-05T15:25:06,561 [org.apache.camel.component.file.remote.SftpConsumer] - File did not match. Will skip this file: RemoteFile[20181122] TRACE 2019-04-05T15:25:06,563 [org.apache.camel.component.file.remote.SftpConsumer] - SftpFile[fileName=20181123, longName=dr-x------ 2 ftpadmin ftpadmin 0 Mar 12 05:27 20181123, dir=true] TRACE 2019-04-05T15:25:07,258 [org.apache.camel.component.file.remote.SftpConsumer] - Polling sub directory: /20181123 from: sftp://XXXX:22051?connectTimeout=90000&disconnect=true&filterDirectory=%24%7Bfile%3Aname%7D+starts+with+%27%24%7Bbean%3AdateofExchange%3Fmethod%3DforLoc%28%22MY%22%29%7D%27&flatten=true&include=.*IMG&knownHostsFile=C%3A%5Cprogram+files%5Cascertain%5CI2R-MystiQ-Engine%5Cknown_hosts&noop=true&password=xxxxxx&preferredAuthentications=password&reconnectDelay=30000&recursive=true&scheduler=quartz2&scheduler.cron=0+0%2F5+*+*+*+%3F&stepwise=false&username=XXXX_ftpuser TRACE 2019-04-05T15:25:07,260 [org.apache.camel.component.file.remote.SftpConsumer] - doPollDirectory from absolutePath: /20181123, dirName: 20181123 TRACE 2019-04-05T15:25:07,263 [org.apache.camel.component.file.remote.SftpConsumer] - Polling directory: /20181123 TRACE 2019-04-05T15:25:07,265 [org.apache.camel.component.file.remote.SftpOperations] - listFiles(/20181123) DEBUG 2019-04-05T15:25:07,281 [org.apache.camel.component.file.remote.SftpConsumer] - Caught exception Cannot list directory: /20181123 TRACE 2019-04-05T15:25:07,297 [org.apache.camel.component.file.remote.SftpConsumer] - Not ignoring file error Cannot list directory: /20181123 for /20181123 DEBUG 2019-04-05T15:25:07,297 [org.apache.camel.component.file.remote.SftpConsumer] - Error occurred during poll directory: due Cannot list directory: /20181123. Removing 0 files marked as in-progress. WARN 2019-04-05T15:25:07,297 [org.apache.camel.component.file.remote.RemoteFilePollingConsumerPollStrategy] - Trying to recover by force disconnecting from remote server and re-connecting at next poll: sftp://XXX@1XXXX:22051 DEBUG 2019-04-05T15:25:07,297 [org.apache.camel.component.file.remote.SftpConsumer] - Force disconnecting from: sftp://XXX@XXXX:22051 WARN 2019-04-05T15:25:07,297 [org.apache.camel.component.file.remote.SftpConsumer] - Consumer SftpConsumer[sftp://XXXX:22051?connectTimeout=90000&disconnect=true&filterDirectory=%24%7Bfile%3Aname%7D+starts+with+%27%24%7Bbean%3AdateofExchange%3Fmethod%3DforLoc%28%22MY%22%29%7D%27&flatten=true&include=.*IMG&knownHostsFile=C%3A%5Cprogram+files%5Cascertain%5CI2R-MystiQ-Engine%5Cknown_hosts&noop=true&password=xxxxxx&preferredAuthentications=password&reconnectDelay=30000&recursive=true&scheduler=quartz2&scheduler.cron=0+0%2F5+*+*+*+%3F&stepwise=false&username=XXXX_ftpuser] failed polling endpoint: sftp://XXXX:22051?connectTimeout=90000&disconnect=true&filterDirectory=%24%7Bfile%3Aname%7D+starts+with+%27%24%7Bbean%3AdateofExchange%3Fmethod%3DforLoc%28%22MY%22%29%7D%27&flatten=true&include=.*IMG&knownHostsFile=C%3A%5Cprogram+files%5Cascertain%5CI2R-MystiQ-Engine%5Cknown_hosts&noop=true&password=xxxxxx&preferredAuthentications=password&reconnectDelay=30000&recursive=true&scheduler=quartz2&scheduler.cron=0+0%2F5+*+*+*+%3F&stepwise=false&username=XXXX_ftpuser. Will try again at next poll. Caused by: [org.apache.camel.component.file.GenericFileOperationFailedException - Cannot list directory: /20181123] org.apache.camel.component.file.GenericFileOperationFailedException: Cannot list directory: /20181123 at org.apache.camel.component.file.remote.SftpOperations.listFiles(SftpOperations.java:660) ~[camel-ftp-2.21.1.jar!/:2.21.1] at org.apache.camel.component.file.remote.SftpConsumer.doPollDirectory(SftpConsumer.java:128) ~[camel-ftp-2.21.1.jar!/:2.21.1] at org.apache.camel.component.file.remote.RemoteFileConsumer.doSafePollSubDirectory(RemoteFileConsumer.java:260) ~[camel-ftp-2.21.1.jar!/:2.21.1] at org.apache.camel.component.file.remote.SftpConsumer.pollSubDirectory(SftpConsumer.java:96) ~[camel-ftp-2.21.1.jar!/:2.21.1] at org.apache.camel.component.file.remote.SftpConsumer.doPollDirectory(SftpConsumer.java:178) ~[camel-ftp-2.21.1.jar!/:2.21.1] at org.apache.camel.component.file.remote.SftpConsumer.pollDirectory(SftpConsumer.java:87) ~[camel-ftp-2.21.1.jar!/:2.21.1] at org.apache.camel.component.file.GenericFileConsumer.poll(GenericFileConsumer.java:124) ~[camel-core-2.21.1.jar!/:2.21.1] at org.apache.camel.impl.ScheduledPollConsumer.doRun(ScheduledPollConsumer.java:174) [camel-core-2.21.1.jar!/:2.21.1] at org.apache.camel.impl.ScheduledPollConsumer.run(ScheduledPollConsumer.java:101) [camel-core-2.21.1.jar!/:2.21.1] at org.apache.camel.pollconsumer.quartz2.QuartzScheduledPollConsumerJob.execute(QuartzScheduledPollConsumerJob.java:61) [camel-quartz2-2.21.1.jar!/:2.21.1] at org.quartz.core.JobRunShell.run(JobRunShell.java:202) [quartz-2.3.0.jar!/:?] at org.quartz.simpl.SimpleThreadPool$WorkerThread.run(SimpleThreadPool.java:573) [quartz-2.3.0.jar!/:?] Caused by: com.jcraft.jsch.SftpException: File not found: /20181123 at com.jcraft.jsch.ChannelSftp.throwStatusError(ChannelSftp.java:2873) ~[jsch-0.1.54.jar!/:?] at com.jcraft.jsch.ChannelSftp._stat(ChannelSftp.java:2225) ~[jsch-0.1.54.jar!/:?] at com.jcraft.jsch.ChannelSftp._stat(ChannelSftp.java:2242) ~[jsch-0.1.54.jar!/:?] at com.jcraft.jsch.ChannelSftp.ls(ChannelSftp.java:1592) ~[jsch-0.1.54.jar!/:?] at com.jcraft.jsch.ChannelSftp.ls(ChannelSftp.java:1553) ~[jsch-0.1.54.jar!/:?] at org.apache.camel.component.file.remote.SftpOperations.listFiles(SftpOperations.java:651) ~[camel-ftp-2.21.1.jar!/:2.21.1] ... 11 more }}

When I try to hardcode that folder along with endpint URI, it simply can list that directory and poll files. This time there is no '/' before the directory while listing {{listFor(XXXX)}}

*Endpoint URI*

{{sftp://XXXX:22051/20181123?connectTimeout=90000&disconnect=true&flatten=true&include=.*IMG&knownHostsFile=C%3A%5Cprogram+files%5Cascertain%5CI2R-MystiQ-Engine%5Cknown_hosts&noop=true&password=xxxxxx&preferredAuthentications=password&reconnectDelay=30000&recursive=true&scheduler=quartz2&scheduler.cron=0+0%2F5+*+*+*+%3F&separator=Auto&stepwise=false&username=XXXX_ftpuser }}

*TRACE LOG*

{{TRACE 2019-04-05T18:40:00,009 [org.apache.camel.component.file.remote.SftpConsumer] - prePollCheck on sftp://XXX@XXXX:22051 DEBUG 2019-04-05T18:40:00,009 [org.apache.camel.component.file.remote.SftpConsumer] - Not connected/logged in, connecting to: sftp://XXX@XXXX:22051 TRACE 2019-04-05T18:40:00,009 [org.apache.camel.component.file.remote.SftpOperations] - Session isn't connected, trying to recreate and connect. DEBUG 2019-04-05T18:40:00,009 [org.apache.camel.component.file.remote.SftpOperations] - Using knownhosts file: C:\program files\ascertain\I2R-MystiQ-Engine\known_hosts DEBUG 2019-04-05T18:40:00,009 [org.apache.camel.component.file.remote.SftpOperations] - Using known hosts information from file: C:\program files\ascertain\I2R-MystiQ-Engine\known_hosts DEBUG 2019-04-05T18:40:00,025 [org.apache.camel.component.file.remote.SftpOperations] - Using StrickHostKeyChecking: no DEBUG 2019-04-05T18:40:00,025 [org.apache.camel.component.file.remote.SftpOperations] - Using PreferredAuthentications: password TRACE 2019-04-05T18:40:00,025 [org.apache.camel.component.file.remote.SftpOperations] - Connecting use connectTimeout: 90000 ... TRACE 2019-04-05T18:40:00,465 [org.apache.camel.component.file.remote.SftpOperations] - Channel isn't connected, trying to recreate and connect. TRACE 2019-04-05T18:40:00,465 [org.apache.camel.component.file.remote.SftpOperations] - Connecting use connectTimeout: 90000 ... DEBUG 2019-04-05T18:40:01,215 [org.apache.camel.component.file.remote.SftpOperations] - Connected to sftp://XXX@XXXX:22051 DEBUG 2019-04-05T18:40:01,215 [org.apache.camel.component.file.remote.SftpConsumer] - Connected and logged in to: sftp://XXX@XXXX:22051 TRACE 2019-04-05T18:40:01,215 [org.apache.camel.component.file.remote.SftpConsumer] - doPollDirectory from absolutePath: 20181123, dirName: null TRACE 2019-04-05T18:40:01,215 [org.apache.camel.component.file.remote.SftpConsumer] - Polling directory: 20181123 TRACE 2019-04-05T18:40:01,215 [org.apache.camel.component.file.remote.SftpOperations] - listFiles(20181123) TRACE 2019-04-05T18:40:02,621 [org.apache.camel.component.file.remote.SftpConsumer] - Found 6 in directory: 20181123 TRACE 2019-04-05T18:40:02,621 [org.apache.camel.component.file.remote.SftpConsumer] - SftpFile[fileName=., longName=dr-x------ 2 ftpadmin ftpadmin 0 Mar 12 05:27 ., dir=true] TRACE 2019-04-05T18:40:02,621 [org.apache.camel.component.file.remote.SftpConsumer] - File did not match. Will skip this file: RemoteFile[.] TRACE 2019-04-05T18:40:02,637 [org.apache.camel.component.file.remote.SftpConsumer] - SftpFile[fileName=.., longName=dr-x------ 2 ftpadmin ftpadmin 0 Mar 12 05:27 .., dir=true] TRACE 2019-04-05T18:40:02,637 [org.apache.camel.component.file.remote.SftpConsumer] - File did not match. Will skip this file: RemoteFile[..] TRACE 2019-04-05T18:40:02,637 [org.apache.camel.component.file.remote.SftpConsumer] - SftpFile[fileName=Consolidated, longName=dr-x------ 2 ftpadmin ftpadmin 0 Mar 12 05:26 Consolidated, dir=true] TRACE 2019-04-05T18:40:02,637 [org.apache.camel.component.file.remote.SftpConsumer] - Polling sub directory: 20181123/Consolidated from: sftp://XXXX:22051/20181123?connectTimeout=90000&disconnect=true&flatten=true&include=.*IMG&knownHostsFile=C%3A%5Cprogram+files%5Cascertain%5CI2R-MystiQ-Engine%5Cknown_hosts&noop=true&password=xxxxxx&preferredAuthentications=password&reconnectDelay=30000&recursive=true&scheduler=quartz2&scheduler.cron=0+0%2F5+*+*+*+%3F&separator=Auto&stepwise=false&username=XXXX_ftpuser TRACE 2019-04-05T18:40:02,637 [org.apache.camel.component.file.remote.SftpConsumer] - doPollDirectory from absolutePath: 20181123/Consolidated, dirName: Consolidated TRACE 2019-04-05T18:40:02,637 [org.apache.camel.component.file.remote.SftpConsumer] - Polling directory: 20181123/Consolidated TRACE 2019-04-05T18:40:02,637 [org.apache.camel.component.file.remote.SftpOperations] - listFiles(20181123/Consolidated) TRACE 2019-04-05T18:40:02,715 [org.apache.camel.component.file.remote.SftpConsumer] - Found 5 in directory: 20181123/Consolidated TRACE 2019-04-05T18:40:02,715 [org.apache.camel.component.file.remote.SftpConsumer] - SftpFile[fileName=., longName=dr-x------ 2 ftpadmin ftpadmin 0 Mar 12 05:26 ., dir=true] TRACE 2019-04-05T18:40:02,715 [org.apache.camel.component.file.remote.SftpConsumer] - File did not match. Will skip this file: RemoteFile[Consolidated/.] TRACE 2019-04-05T18:40:02,715 [org.apache.camel.component.file.remote.SftpConsumer] - SftpFile[fileName=.., longName=dr-x------ 2 ftpadmin ftpadmin 0 Mar 12 05:27 .., dir=true] TRACE 2019-04-05T18:40:02,715 [org.apache.camel.component.file.remote.SftpConsumer] - File did not match. Will skip this file: RemoteFile[Consolidated/..] TRACE 2019-04-05T18:40:02,715 [org.apache.camel.component.file.remote.SftpConsumer] - SftpFile[fileName=20181124020438943_021420181123INW.MYR, longName=-r-x------ 1 ftpadmin ftpadmin 408097 Nov 23 2018 20181124020438943_021420181123INW.MYR, dir=false] TRACE 2019-04-05T18:40:02,731 [org.apache.camel.component.file.remote.SftpConsumer] - File did not match. Will skip this file: RemoteFile[Consolidated/20181124020438943_021420181123INW.MYR] TRACE 2019-04-05T18:40:02,731 [org.apache.camel.component.file.remote.SftpConsumer] - SftpFile[fileName=20181124020439099_035820181123INW.MYR, longName=-r-x------ 1 ftpadmin ftpadmin 21689 Nov 23 2018 20181124020439099_035820181123INW.MYR, dir=false] TRACE 2019-04-05T18:40:02,731 [org.apache.camel.component.file.remote.SftpConsumer] - File did not match. Will skip this file: RemoteFile[Consolidated/20181124020439099_035820181123INW.MYR] TRACE 2019-04-05T18:40:02,731 [org.apache.camel.component.file.remote.SftpConsumer] - SftpFile[fileName=ToPPay, longName=dr-x------ 2 ftpadmin ftpadmin 0 Mar 12 06:41 ToPPay, dir=true] TRACE 2019-04-05T18:40:02,731 [org.apache.camel.component.file.remote.SftpConsumer] - Polling sub directory: 20181123/Consolidated/ToPPay from: sftp://XXXX:22051/20181123?connectTimeout=90000&disconnect=true&flatten=true&include=.*IMG&knownHostsFile=C%3A%5Cprogram+files%5Cascertain%5CI2R-MystiQ-Engine%5Cknown_hosts&noop=true&password=xxxxxx&preferredAuthentications=password&reconnectDelay=30000&recursive=true&scheduler=quartz2&scheduler.cron=0+0%2F5+*+*+*+%3F&separator=Auto&stepwise=false&username=XXXX_ftpuser TRACE 2019-04-05T18:40:02,731 [org.apache.camel.component.file.remote.SftpConsumer] - doPollDirectory from absolutePath: 20181123/Consolidated/ToPPay, dirName: ToPPay TRACE 2019-04-05T18:40:02,731 [org.apache.camel.component.file.remote.SftpConsumer] - Polling directory: 20181123/Consolidated/ToPPay TRACE 2019-04-05T18:40:02,731 [org.apache.camel.component.file.remote.SftpOperations] - listFiles(20181123/Consolidated/ToPPay) TRACE 2019-04-05T18:40:02,777 [org.apache.camel.component.file.remote.SftpConsumer] - Found 8 in directory: 20181123/Consolidated/ToPPay TRACE 2019-04-05T18:40:02,777 [org.apache.camel.component.file.remote.SftpConsumer] - SftpFile[fileName=., longName=dr-x------ 2 ftpadmin ftpadmin 0 Mar 12 06:41 ., dir=true] TRACE 2019-04-05T18:40:02,777 [org.apache.camel.component.file.remote.SftpConsumer] - File did not match. Will skip this file: RemoteFile[Consolidated/ToPPay/.] TRACE 2019-04-05T18:40:02,777 [org.apache.camel.component.file.remote.SftpConsumer] - SftpFile[fileName=.., longName=dr-x------ 2 ftpadmin ftpadmin 0 Mar 12 05:26 .., dir=true] TRACE 2019-04-05T18:40:02,777 [org.apache.camel.component.file.remote.SftpConsumer] - File did not match. Will skip this file: RemoteFile[Consolidated/ToPPay/..] TRACE 2019-04-05T18:40:02,793 [org.apache.camel.component.file.remote.SftpConsumer] - SftpFile[fileName=021420181123INW.MYR, longName=-r-x------ 1 ftpadmin ftpadmin 408097 Nov 23 2018 021420181123INW.MYR, dir=false] TRACE 2019-04-05T18:40:02,793 [org.apache.camel.component.file.remote.SftpConsumer] - File did not match. Will skip this file: RemoteFile[Consolidated/ToPPay/021420181123INW.MYR] TRACE 2019-04-05T18:40:02,793 [org.apache.camel.component.file.remote.SftpConsumer] - SftpFile[fileName=021420181123INW1.MYR, longName=-r-x------ 1 ftpadmin ftpadmin 579829 Nov 23 2018 021420181123INW1.MYR, dir=false] TRACE 2019-04-05T18:40:02,793 [org.apache.camel.component.file.remote.SftpConsumer] - File did not match. Will skip this file: RemoteFile[Consolidated/ToPPay/021420181123INW1.MYR] TRACE 2019-04-05T18:40:02,793 [org.apache.camel.component.file.remote.SftpConsumer] - SftpFile[fileName=035820181123INW.MYR, longName=-r-x------ 1 ftpadmin ftpadmin 21689 Nov 23 2018 035820181123INW.MYR, dir=false] TRACE 2019-04-05T18:40:02,793 [org.apache.camel.component.file.remote.SftpConsumer] - File did not match. Will skip this file: RemoteFile[Consolidated/ToPPay/035820181123INW.MYR] TRACE 2019-04-05T18:40:02,793 [org.apache.camel.component.file.remote.SftpConsumer] - SftpFile[fileName=035820181123INW1.MYR, longName=-r-x------ 1 ftpadmin ftpadmin 30954 Nov 23 2018 035820181123INW1.MYR, dir=false] TRACE 2019-04-05T18:40:02,793 [org.apache.camel.component.file.remote.SftpConsumer] - File did not match. Will skip this file: RemoteFile[Consolidated/ToPPay/035820181123INW1.MYR] TRACE 2019-04-05T18:40:02,809 [org.apache.camel.component.file.remote.SftpConsumer] - SftpFile[fileName=20181124020438943_021420181123INW.MYR, longName=-r-x------ 1 ftpadmin ftpadmin 408097 Nov 23 2018 20181124020438943_021420181123INW.MYR, dir=false] TRACE 2019-04-05T18:40:02,809 [org.apache.camel.component.file.remote.SftpConsumer] - File did not match. Will skip this file: RemoteFile[Consolidated/ToPPay/20181124020438943_021420181123INW.MYR] TRACE 2019-04-05T18:40:02,809 [org.apache.camel.component.file.remote.SftpConsumer] - SftpFile[fileName=20181124020439099_035820181123INW.MYR, longName=-r-x------ 1 ftpadmin ftpadmin 21689 Nov 23 2018 20181124020439099_035820181123INW.MYR, dir=false] TRACE 2019-04-05T18:40:02,809 [org.apache.camel.component.file.remote.SftpConsumer] - File did not match. Will skip this file: RemoteFile[Consolidated/ToPPay/20181124020439099_035820181123INW.MYR] TRACE 2019-04-05T18:40:02,809 [org.apache.camel.component.file.remote.SftpConsumer] - SftpFile[fileName=Data, longName=dr-x------ 2 ftpadmin ftpadmin 0 Mar 12 05:26 Data, dir=true] TRACE 2019-04-05T18:40:02,809 [org.apache.camel.component.file.remote.SftpConsumer] - Polling sub directory: 20181123/Data from: sftp://XXXX:22051/20181123?connectTimeout=90000&disconnect=true&flatten=true&include=.*IMG&knownHostsFile=C%3A%5Cprogram+files%5Cascertain%5CI2R-MystiQ-Engine%5Cknown_hosts&noop=true&password=xxxxxx&preferredAuthentications=password&reconnectDelay=30000&recursive=true&scheduler=quartz2&scheduler.cron=0+0%2F5+*+*+*+%3F&separator=Auto&stepwise=false&username=XXXX_ftpuser TRACE 2019-04-05T18:40:02,809 [org.apache.camel.component.file.remote.SftpConsumer] - doPollDirectory from absolutePath: 20181123/Data, dirName: Data TRACE 2019-04-05T18:40:02,809 [org.apache.camel.component.file.remote.SftpConsumer] - Polling directory: 20181123/Data TRACE 2019-04-05T18:40:02,809 [org.apache.camel.component.file.remote.SftpOperations] - listFiles(20181123/Data) TRACE 2019-04-05T18:40:02,871 [org.apache.camel.component.file.remote.SftpConsumer] - Found 501 in directory: 20181123/Data TRACE 2019-04-05T18:40:02,871 [org.apache.camel.component.file.remote.SftpConsumer] - SftpFile[fileName=., longName=dr-x------ 2 ftpadmin ftpadmin 0 Mar 12 05:26 ., dir=true] TRACE 2019-04-05T18:40:02,871 [org.apache.camel.component.file.remote.SftpConsumer] - File did not match. Will skip this file: RemoteFile[Data/.] TRACE 2019-04-05T18:40:02,871 [org.apache.camel.component.file.remote.SftpConsumer] - SftpFile[fileName=.., longName=dr-x------ 2 ftpadmin ftpadmin 0 Mar 12 05:27 .., dir=true] TRACE 2019-04-05T18:40:02,871 [org.apache.camel.component.file.remote.SftpConsumer] - File did not match. Will skip this file: RemoteFile[Data/..] TRACE 2019-04-05T18:40:02,871 [org.apache.camel.component.file.remote.SftpConsumer] - SftpFile[fileName=20181123021401015101004323IWNM.MMYR, longName=-r-x------ 1 ftpadmin ftpadmin 14846 Nov 23 2018 20181123021401015101004323IWNM.MMYR, dir=false] TRACE 2019-04-05T18:40:02,871 [org.apache.camel.component.file.remote.SftpConsumer] - File did not match. Will skip this file: RemoteFile[Data/20181123021401015101004323IWNM.MMYR] }}

I am sure that the cause of the issue has to be the addition '/' prepending with directory name while listing {{listFor(/XXXX)}}. How can I avoid it ! .. using {{seperator}} parameter didn't effect i suppose it is only for producing files and not for consuming. I need to resolve this issue as soon as possible. Please suggest me some solution :(

*EDITED :*

I can reproduce the issue in latest version as well,I suppose the issue is when there is no base path only the '/' gets prepended which should not actually happen

Code Snippet from SftpConsumer.java Camel 3.0.0.M1

{{if (file.isDirectory()) \{ RemoteFile<SftpRemoteFile> remote = asRemoteFile(absolutePath, file, getEndpoint().getCharset()); if (endpoint.isRecursive() && depth < endpoint.getMaxDepth() && isValidFile(remote, true, files)) { // recursive scan and add the sub files and folders String subDirectory = file.getFilename(); String path = absolutePath + ""/"" + subDirectory; boolean canPollMore = pollSubDirectory(path, subDirectory, fileList, depth); if (!canPollMore) { return false; } } // we cannot use file.getAttrs().isLink on Windows, so we dont invoke the method // just assuming its a file we should poll } }}
{quote}String path = absolutePath + ""/"" + subDirectory;
{quote}"
CAMEL-13393,NullPointerException on opentracing example,"When running service1 from of the opentracing example an NullPointerException is logged to the standard out:

{code}
2019-04-05 10:33:54.620  INFO 23268 --- [           main] o.a.camel.spring.boot.RoutesCollector    : Starting CamelMainRunController to ensure the main thread keeps running
[WARNING] 
java.lang.RuntimeException: java.lang.NullPointerException
    at org.apache.camel.spring.boot.CamelSpringBootApplicationController.run (CamelSpringBootApplicationController.java:83)
    at org.apache.camel.spring.boot.CamelMainRunController$DaemonTask.run (1m2Cam20melM1ainRunController.java:53)9
    -04-05 10:33:54.622  INFO at5m23268 java.lang.Thread.run --- [           main] o.a.c.impl.DefaultStreamCachingStrategy  : StreamCaching in use with spool directory: /tmp/camel/camel-tmp-4e01e06f-baf2-4a4c-abce-89e2a14f7516 and rules: [Sp (Thread.java:748)
ool > 128K body size]
Caused by: java.lang.NullPointerException
    at org.apache.camel.main.MainSupport.postProcessCamelContext (MainSupport.java:745)
    at org.apache.camel.main.MainSupport.initCamelContext (MainSupport.java:676)
    at org.apache.camel.main.Main.doStart (Main.java:107)
    at org.apache.camel.support.service.ServiceSupport.start (ServiceSupport.java:86)
    at org.apache.camel.main.MainSupport.run (MainSupport.java:203)
    at org.apache.camel.spring.boot.CamelSpringBootApplicationController.run (CamelSpringBootApplicationController.java:78)
    at org.apache.camel.spring.boot.CamelMainRunController$DaemonTask.run (CamelMainRunController.java:53)
    at java.lang.Thread.run (Thread.java:748)
{code}

Take a look at CAMEL-13386 on how to reproduce.",davsclaus,Bug,Major,Resolved,"NullPointerException on opentracing example When running service1 from of the opentracing example an NullPointerException is logged to the standard out:

{code}
2019-04-05 10:33:54.620  INFO 23268 --- [           main] o.a.camel.spring.boot.RoutesCollector    : Starting CamelMainRunController to ensure the main thread keeps running
[WARNING] 
java.lang.RuntimeException: java.lang.NullPointerException
    at org.apache.camel.spring.boot.CamelSpringBootApplicationController.run (CamelSpringBootApplicationController.java:83)
    at org.apache.camel.spring.boot.CamelMainRunController$DaemonTask.run (1m2Cam20melM1ainRunController.java:53)9
    -04-05 10:33:54.622  INFO at5m23268 java.lang.Thread.run --- [           main] o.a.c.impl.DefaultStreamCachingStrategy  : StreamCaching in use with spool directory: /tmp/camel/camel-tmp-4e01e06f-baf2-4a4c-abce-89e2a14f7516 and rules: [Sp (Thread.java:748)
ool > 128K body size]
Caused by: java.lang.NullPointerException
    at org.apache.camel.main.MainSupport.postProcessCamelContext (MainSupport.java:745)
    at org.apache.camel.main.MainSupport.initCamelContext (MainSupport.java:676)
    at org.apache.camel.main.Main.doStart (Main.java:107)
    at org.apache.camel.support.service.ServiceSupport.start (ServiceSupport.java:86)
    at org.apache.camel.main.MainSupport.run (MainSupport.java:203)
    at org.apache.camel.spring.boot.CamelSpringBootApplicationController.run (CamelSpringBootApplicationController.java:78)
    at org.apache.camel.spring.boot.CamelMainRunController$DaemonTask.run (CamelMainRunController.java:53)
    at java.lang.Thread.run (Thread.java:748)
{code}

Take a look at CAMEL-13386 on how to reproduce."
CAMEL-13388,Wrong removing parameters logic in ServiceComponent.,"Component: camel-service

Mistake in class : org.apache.camel.component.service.ServiceComponent.java:83

This error prevents the delegating component from receiving URI parameters.

*Have:*
{code:java}
parameters.keySet().removeAll(parameters.keySet());
{code}
*Must be:*
{code:java}
parameters.keySet().removeAll(params.keySet());
{code}
 ",davsclaus,Bug,Major,Resolved,"Wrong removing parameters logic in ServiceComponent. Component: camel-service

Mistake in class : org.apache.camel.component.service.ServiceComponent.java:83

This error prevents the delegating component from receiving URI parameters.

*Have:*
{code:java}
parameters.keySet().removeAll(parameters.keySet());
{code}
*Must be:*
{code:java}
parameters.keySet().removeAll(params.keySet());
{code}
 "
CAMEL-13387,camel-twitter-direct-message doesn't filter by filterOld parameter,DirectMessageConsumerHandler doesn't filter old messages when parameter filterOld=true,davsclaus,Bug,Minor,Resolved,camel-twitter-direct-message doesn't filter by filterOld parameter DirectMessageConsumerHandler doesn't filter old messages when parameter filterOld=true
CAMEL-13383,maven plugi validation fails with 3.0.0m1/m2,"The camel plugin fails validation which passed fine in v2.latest.
Also from the error-message it is not easy to understand what is really the problem?

{noformat}
INFO] [jenkins-event-spy] Generated /data/jenkins/workspace/c-jfr-server_feature_camel3-Y6VPXEFM3D7D7C2V3GQRGLFL7QLPEWEFUJY6V6RFK46FIDVYQ7SQ@tmp/withMavenca46cdd5/maven-spy-20190401-102256-4351026941413226375350.log

[ERROR] Failed to execute goal org.apache.camel:camel-report-maven-plugin:3.0.0-M2:validate (default) on project jfr-srv-batch: Endpoint validation success: (1 = passed, 0 = invalid, 1 = incapable, 0 = unknown components, 0 = deprecated options)

[ERROR] Simple validation error: (0 = passed, 1 = invalid)

[ERROR] Duplicate route id validation success (0 = ids)

[ERROR] Endpoint pair (seda/direct) validation success (0 = pairs)

[ERROR] -> [Help 1]

org.apache.maven.lifecycle.LifecycleExecutionException: Failed to execute goal org.apache.camel:camel-report-maven-plugin:3.0.0-M2:validate (default) on project jfr-srv-batch: Endpoint validation success: (1 = passed, 0 = invalid, 1 = incapable, 0 = unknown components, 0 = deprecated options)

Simple validation error: (0 = passed, 1 = invalid)

Duplicate route id validation success (0 = ids)

Endpoint pair (seda/direct) validation success (0 = pairs)

    at org.apache.maven.lifecycle.internal.MojoExecutor.execute (MojoExecutor.java:215)

    at org.apache.maven.lifecycle.internal.MojoExecutor.execute (MojoExecutor.java:156)

    at org.apache.maven.lifecycle.internal.MojoExecutor.execute (MojoExecutor.java:148)

    at org.apache.maven.lifecycle.internal.LifecycleModuleBuilder.buildProject (LifecycleModuleBuilder.java:117)

    at org.apache.maven.lifecycle.internal.builder.multithreaded.MultiThreadedBuilder$1.call (MultiThreadedBuilder.java:200)

    at org.apache.maven.lifecycle.internal.builder.multithreaded.MultiThreadedBuilder$1.call (MultiThreadedBuilder.java:196)

    at java.util.concurrent.FutureTask.run (FutureTask.java:264)

    at java.util.concurrent.Executors$RunnableAdapter.call (Executors.java:515)

    at java.util.concurrent.FutureTask.run (FutureTask.java:264)

    at java.util.concurrent.ThreadPoolExecutor.runWorker (ThreadPoolExecutor.java:1128)

    at java.util.concurrent.ThreadPoolExecutor$Worker.run (ThreadPoolExecutor.java:628)

    at java.lang.Thread.run (Thread.java:835)

Caused by: org.apache.maven.plugin.MojoExecutionException: Endpoint validation success: (1 = passed, 0 = invalid, 1 = incapable, 0 = unknown components, 0 = deprecated options)

Simple validation error: (0 = passed, 1 = invalid)

Duplicate route id validation success (0 = ids)

Endpoint pair (seda/direct) validation success (0 = pairs)

    at org.apache.camel.maven.ValidateMojo.execute (ValidateMojo.java:484)

    at org.apache.maven.plugin.DefaultBuildPluginManager.executeMojo (DefaultBuildPluginManager.java:137)

    at org.apache.maven.lifecycle.internal.MojoExecutor.execute (MojoExecutor.java:210)

    at org.apache.maven.lifecycle.internal.MojoExecutor.execute (MojoExecutor.java:156)

    at org.apache.maven.lifecycle.internal.MojoExecutor.execute (MojoExecutor.java:148)

    at org.apache.maven.lifecycle.internal.LifecycleModuleBuilder.buildProject (LifecycleModuleBuilder.java:117)

    at org.apache.maven.lifecycle.internal.builder.multithreaded.MultiThreadedBuilder$1.call (MultiThreadedBuilder.java:200)

    at org.apache.maven.lifecycle.internal.builder.multithreaded.MultiThreadedBuilder$1.call (MultiThreadedBuilder.java:196)

    at java.util.concurrent.FutureTask.run (FutureTask.java:264)

    at java.util.concurrent.Executors$RunnableAdapter.call (Executors.java:515)

    at java.util.concurrent.FutureTask.run (FutureTask.java:264)

    at java.util.concurrent.ThreadPoolExecutor.runWorker (ThreadPoolExecutor.java:1128)

    at java.util.concurrent.ThreadPoolExecutor$Worker.run (ThreadPoolExecutor.java:628)

    at java.lang.Thread.run (Thread.java:835)
{noformat}",davsclaus,Bug,Major,Resolved,"maven plugi validation fails with 3.0.0m1/m2 The camel plugin fails validation which passed fine in v2.latest.
Also from the error-message it is not easy to understand what is really the problem?

{noformat}
INFO] [jenkins-event-spy] Generated /data/jenkins/workspace/c-jfr-server_feature_camel3-Y6VPXEFM3D7D7C2V3GQRGLFL7QLPEWEFUJY6V6RFK46FIDVYQ7SQ@tmp/withMavenca46cdd5/maven-spy-20190401-102256-4351026941413226375350.log

[ERROR] Failed to execute goal org.apache.camel:camel-report-maven-plugin:3.0.0-M2:validate (default) on project jfr-srv-batch: Endpoint validation success: (1 = passed, 0 = invalid, 1 = incapable, 0 = unknown components, 0 = deprecated options)

[ERROR] Simple validation error: (0 = passed, 1 = invalid)

[ERROR] Duplicate route id validation success (0 = ids)

[ERROR] Endpoint pair (seda/direct) validation success (0 = pairs)

[ERROR] -> [Help 1]

org.apache.maven.lifecycle.LifecycleExecutionException: Failed to execute goal org.apache.camel:camel-report-maven-plugin:3.0.0-M2:validate (default) on project jfr-srv-batch: Endpoint validation success: (1 = passed, 0 = invalid, 1 = incapable, 0 = unknown components, 0 = deprecated options)

Simple validation error: (0 = passed, 1 = invalid)

Duplicate route id validation success (0 = ids)

Endpoint pair (seda/direct) validation success (0 = pairs)

    at org.apache.maven.lifecycle.internal.MojoExecutor.execute (MojoExecutor.java:215)

    at org.apache.maven.lifecycle.internal.MojoExecutor.execute (MojoExecutor.java:156)

    at org.apache.maven.lifecycle.internal.MojoExecutor.execute (MojoExecutor.java:148)

    at org.apache.maven.lifecycle.internal.LifecycleModuleBuilder.buildProject (LifecycleModuleBuilder.java:117)

    at org.apache.maven.lifecycle.internal.builder.multithreaded.MultiThreadedBuilder$1.call (MultiThreadedBuilder.java:200)

    at org.apache.maven.lifecycle.internal.builder.multithreaded.MultiThreadedBuilder$1.call (MultiThreadedBuilder.java:196)

    at java.util.concurrent.FutureTask.run (FutureTask.java:264)

    at java.util.concurrent.Executors$RunnableAdapter.call (Executors.java:515)

    at java.util.concurrent.FutureTask.run (FutureTask.java:264)

    at java.util.concurrent.ThreadPoolExecutor.runWorker (ThreadPoolExecutor.java:1128)

    at java.util.concurrent.ThreadPoolExecutor$Worker.run (ThreadPoolExecutor.java:628)

    at java.lang.Thread.run (Thread.java:835)

Caused by: org.apache.maven.plugin.MojoExecutionException: Endpoint validation success: (1 = passed, 0 = invalid, 1 = incapable, 0 = unknown components, 0 = deprecated options)

Simple validation error: (0 = passed, 1 = invalid)

Duplicate route id validation success (0 = ids)

Endpoint pair (seda/direct) validation success (0 = pairs)

    at org.apache.camel.maven.ValidateMojo.execute (ValidateMojo.java:484)

    at org.apache.maven.plugin.DefaultBuildPluginManager.executeMojo (DefaultBuildPluginManager.java:137)

    at org.apache.maven.lifecycle.internal.MojoExecutor.execute (MojoExecutor.java:210)

    at org.apache.maven.lifecycle.internal.MojoExecutor.execute (MojoExecutor.java:156)

    at org.apache.maven.lifecycle.internal.MojoExecutor.execute (MojoExecutor.java:148)

    at org.apache.maven.lifecycle.internal.LifecycleModuleBuilder.buildProject (LifecycleModuleBuilder.java:117)

    at org.apache.maven.lifecycle.internal.builder.multithreaded.MultiThreadedBuilder$1.call (MultiThreadedBuilder.java:200)

    at org.apache.maven.lifecycle.internal.builder.multithreaded.MultiThreadedBuilder$1.call (MultiThreadedBuilder.java:196)

    at java.util.concurrent.FutureTask.run (FutureTask.java:264)

    at java.util.concurrent.Executors$RunnableAdapter.call (Executors.java:515)

    at java.util.concurrent.FutureTask.run (FutureTask.java:264)

    at java.util.concurrent.ThreadPoolExecutor.runWorker (ThreadPoolExecutor.java:1128)

    at java.util.concurrent.ThreadPoolExecutor$Worker.run (ThreadPoolExecutor.java:628)

    at java.lang.Thread.run (Thread.java:835)
{noformat}"
CAMEL-13380,camel-core - Move cloud out into camel-cloud component,"Lets see if we can move the cloud parts out of camel-core into a new camel-cloud that some components uses, like camel-service, camel-ribbon etc.",davsclaus,Task,Major,Resolved,"camel-core - Move cloud out into camel-cloud component Lets see if we can move the cloud parts out of camel-core into a new camel-cloud that some components uses, like camel-service, camel-ribbon etc."
CAMEL-13375,Remove the JMX explain APis and related,"We have a set of explain APIs on JMX that can output ""catalog"" like information. However we dont really use it, and this can help remove functionality and complexity of camel-core.

You can get details via the camel-catalog and at runtime the runtime camel-catalog.",davsclaus,Task,Major,Resolved,"Remove the JMX explain APis and related We have a set of explain APIs on JMX that can output ""catalog"" like information. However we dont really use it, and this can help remove functionality and complexity of camel-core.

You can get details via the camel-catalog and at runtime the runtime camel-catalog."
CAMEL-13373,camel-stax - FileInputStream not closed,"The StAXProcessor.java class does not close the stream it opens.

I had to modify it like this: 

public void process(Exchange exchange) throws Exception {
 InputSource is = exchange.getIn().getMandatoryBody(InputSource.class);
 XMLStreamReader stream = exchange.getIn().getMandatoryBody(XMLStreamReader.class);
 // Fermeture de la inputstream ici, car dans la version originale de la classe la stream reste ouverte.
 *try(InputStream inputStreamToClose = is.getByteStream()) {*
 XMLReader reader = new StaxStreamXMLReader(stream);
 ContentHandler handler;
 if (this.contentHandlerClass != null)

{ handler = (ContentHandler) this.contentHandlerClass.newInstance(); }

else

{ handler = this.contentHandler; }

reader.setContentHandler(handler);
 reader.parse(is);
 if (ExchangeHelper.isOutCapable(exchange))

{ exchange.getOut().setHeaders(exchange.getIn().getHeaders()); exchange.getOut().setBody(handler); }

else

{ exchange.getIn().setBody(handler); }

} *finally*

*{ // Fermeture de la strem ValidatingStreamReader validatingStreamReader = (ValidatingStreamReader)stream; validatingStreamReader.closeCompletely(); }*

*}*",davsclaus,Bug,Minor,Resolved,"camel-stax - FileInputStream not closed The StAXProcessor.java class does not close the stream it opens.

I had to modify it like this: 

public void process(Exchange exchange) throws Exception {
 InputSource is = exchange.getIn().getMandatoryBody(InputSource.class);
 XMLStreamReader stream = exchange.getIn().getMandatoryBody(XMLStreamReader.class);
 // Fermeture de la inputstream ici, car dans la version originale de la classe la stream reste ouverte.
 *try(InputStream inputStreamToClose = is.getByteStream()) {*
 XMLReader reader = new StaxStreamXMLReader(stream);
 ContentHandler handler;
 if (this.contentHandlerClass != null)

{ handler = (ContentHandler) this.contentHandlerClass.newInstance(); }

else

{ handler = this.contentHandler; }

reader.setContentHandler(handler);
 reader.parse(is);
 if (ExchangeHelper.isOutCapable(exchange))

{ exchange.getOut().setHeaders(exchange.getIn().getHeaders()); exchange.getOut().setBody(handler); }

else

{ exchange.getIn().setBody(handler); }

} *finally*

*{ // Fermeture de la strem ValidatingStreamReader validatingStreamReader = (ValidatingStreamReader)stream; validatingStreamReader.closeCompletely(); }*

*}*"
CAMEL-13370,resolve delegating endpoint when routes are dumped,"As today the ModelHelper.dumpModelAsXml(..., ...) does not resolve delegating endpoint so in case an endpoint delegates to an additional endpoint, this delegated endpoint is not shown in the routes dump.

It would be nice to have an option to configure if the delegating endpoint should be replaced by the delegated one on dumpModelAsXml",davsclaus,Improvement,Minor,Resolved,"resolve delegating endpoint when routes are dumped As today the ModelHelper.dumpModelAsXml(..., ...) does not resolve delegating endpoint so in case an endpoint delegates to an additional endpoint, this delegated endpoint is not shown in the routes dump.

It would be nice to have an option to configure if the delegating endpoint should be replaced by the delegated one on dumpModelAsXml"
CAMEL-13369,enhance message history eip ,"The current message history eip is somehow limited as we cannot choose which nodes we want to take into account, as example if one creates routes using the new Step EIP, he may want to get the history to track step related activities only.

Another additional feature would be to have the message history pattern to keep a copy of the message being produced by the processor under monitor.",davsclaus,New Feature,Minor,Resolved,"enhance message history eip  The current message history eip is somehow limited as we cannot choose which nodes we want to take into account, as example if one creates routes using the new Step EIP, he may want to get the history to track step related activities only.

Another additional feature would be to have the message history pattern to keep a copy of the message being produced by the processor under monitor."
CAMEL-13367,camel-jaxb - Error loading fallback type converter in Karaf,To reproduce then unit test cia2 source code chapter10-camel-cxf-rest-karaf,davsclaus,Bug,Major,Resolved,camel-jaxb - Error loading fallback type converter in Karaf To reproduce then unit test cia2 source code chapter10-camel-cxf-rest-karaf
CAMEL-13366,MLLP Endpoint 'maxConcurrentConsumers' configuration support,"If you provide 'maxConcurrentConsumers' query parameter on the endpoint URI, then, the route fails with error message 

_""There are 1 parameters that couldn't be set on the endpoint. Check the uri
if the parameters are spelt correctly and that they are properties of the endpoint. Unknown parameters=[{maxConcurrentConsumers=xx}] ""_

As per docs, it should be supported as query parameter.",davsclaus,Bug,Minor,Resolved,"MLLP Endpoint 'maxConcurrentConsumers' configuration support If you provide 'maxConcurrentConsumers' query parameter on the endpoint URI, then, the route fails with error message 

_""There are 1 parameters that couldn't be set on the endpoint. Check the uri
if the parameters are spelt correctly and that they are properties of the endpoint. Unknown parameters=[{maxConcurrentConsumers=xx}] ""_

As per docs, it should be supported as query parameter."
CAMEL-13360,SEDA documentation does not track new bounded size value,"SEDA component has a bounded limit again thanks on work done for:
""seda - Have a default queue size limit (CAMEL-12542)""

 the documentation here :
https://cwiki.apache.org/confluence/display/CAMEL/SEDA
does not reflect the change
",davsclaus,Bug,Minor,Resolved,"SEDA documentation does not track new bounded size value SEDA component has a bounded limit again thanks on work done for:
""seda - Have a default queue size limit (CAMEL-12542)""

 the documentation here :
https://cwiki.apache.org/confluence/display/CAMEL/SEDA
does not reflect the change
"
CAMEL-13358,Sometimes SedaConsumer does not start and remains stuck,"Sometimes we notice that some of our routes get ""stuck"" and do not process anything.  Looking at the stacktrace for such a route we see something like this:
{code:java}
""Camel (SomeName) thread #648 - seda://someName"" #1287 daemon prio=5 os_prio=0 tid=0x00007f23880cf000 nid=0x25006 waiting on condition [0x00007f1f23530000]
   java.lang.Thread.State: WAITING (parking)
        at sun.misc.Unsafe.park(Native Method)
        - parking to wait for  <0x00000006e4beb8e0> (a java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject)
        at java.util.concurrent.locks.LockSupport.park(LockSupport.java:175)
        at java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject.await(AbstractQueuedSynchronizer.java:2039)
        at java.util.concurrent.LinkedBlockingQueue.take(LinkedBlockingQueue.java:442)
        at java.util.concurrent.ThreadPoolExecutor.getTask(ThreadPoolExecutor.java:1067)
        at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1127)
        at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617)
        at java.lang.Thread.run(Thread.java:748)
{code}
whereas we would instead normally expect to see something like this:
{code:java}
""Camel (SomeName) thread #840 - seda://someName"" #1577 daemon prio=5 os_prio=0 tid=0x00007f227c02b000 nid=0x256fe waiting on condition [0x00007f1f0ca20000]
   java.lang.Thread.State: TIMED_WAITING (parking)
        at sun.misc.Unsafe.park(Native Method)
        - parking to wait for  <0x00000006eb69c1f8> (a java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject)
        at java.util.concurrent.locks.LockSupport.parkNanos(LockSupport.java:215)
        at java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject.awaitNanos(AbstractQueuedSynchronizer.java:2078)
        at java.util.concurrent.LinkedBlockingQueue.poll(LinkedBlockingQueue.java:467)
        at org.apache.camel.component.seda.SedaConsumer.doRun(SedaConsumer.java:198)
        at org.apache.camel.component.seda.SedaConsumer.run(SedaConsumer.java:154)
        at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142)
        at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617)
        at java.lang.Thread.run(Thread.java:748)
{code}

Note that whereas this latter example has SedaConsumer in the stacktrace polling for an exchange, the former example has no such SedaConsumer in the stacktrace and is stuck waiting for a new ""task"" to be given to the ThreadPoolExecutor.

After adding debug logging, I see that the issue is as follows:

The code in ServiceSupport here writes to the starting and started flags using one thread (call it Thread W):
{code}
    public void start() throws Exception {
        if (isStarting() || isStarted()) {
            // only start service if not already started
            LOG.trace(""Service already started"");
            return;
        }
        if (starting.compareAndSet(false, true)) {
            LOG.trace(""Starting service"");
            try {
                doStart();
                started.set(true);
                starting.set(false);
{code}
and on a different thread (call it thread R) this code in ServiceSupport reads the starting and started flags:
{code}
    public boolean isRunAllowed() {
        // if we have not yet initialized, then all options is false
        boolean unused1 = !started.get() && !starting.get() && !stopping.get() && !stopped.get();
        boolean unused2 = !suspending.get() && !suspended.get() && !shutdown.get() && !shuttingdown.get();
        if (unused1 && unused2) {
            return false;
        }
        return !isStoppingOrStopped();
    }
{code}

So the order of events is:
# Thread W: calls ServiceSupport.start()
# Thread W: compareAndSet starting from false to true
# Thread W: calls ServiceSupport.doStart() which eventually creates and starts Thread R
# Thread R: calls SedaConsumer.doRun() which calls isRunAllowed()
# Thread R: in isRunAllowed() reads started as false
# Thread W: set started to true
# Thread W: set starting to false
# Thread R: in isRunAllowed() reads starting as false
# Thread R: concludes that isRunAllowed is false
# Thread R: the while loop in SedaConsumer.doRun is not executed and the thread will forever remain stuck waiting for a new ""task"" (on ThreadPoolExecutor.java:1067)

One fix would be to swap reading of starting and started so that starting is read first, then started.

Looking at the latest code in Camel 3.0.x, this code has been refactored to use a single ""status"" field instead of multiple different AtomicBoolean fields.  That should also fix this bug.  However, for completeness, I thought it best to log this bug anyway.",davsclaus,Bug,Major,Resolved,"Sometimes SedaConsumer does not start and remains stuck Sometimes we notice that some of our routes get ""stuck"" and do not process anything.  Looking at the stacktrace for such a route we see something like this:
{code:java}
""Camel (SomeName) thread #648 - seda://someName"" #1287 daemon prio=5 os_prio=0 tid=0x00007f23880cf000 nid=0x25006 waiting on condition [0x00007f1f23530000]
   java.lang.Thread.State: WAITING (parking)
        at sun.misc.Unsafe.park(Native Method)
        - parking to wait for  <0x00000006e4beb8e0> (a java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject)
        at java.util.concurrent.locks.LockSupport.park(LockSupport.java:175)
        at java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject.await(AbstractQueuedSynchronizer.java:2039)
        at java.util.concurrent.LinkedBlockingQueue.take(LinkedBlockingQueue.java:442)
        at java.util.concurrent.ThreadPoolExecutor.getTask(ThreadPoolExecutor.java:1067)
        at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1127)
        at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617)
        at java.lang.Thread.run(Thread.java:748)
{code}
whereas we would instead normally expect to see something like this:
{code:java}
""Camel (SomeName) thread #840 - seda://someName"" #1577 daemon prio=5 os_prio=0 tid=0x00007f227c02b000 nid=0x256fe waiting on condition [0x00007f1f0ca20000]
   java.lang.Thread.State: TIMED_WAITING (parking)
        at sun.misc.Unsafe.park(Native Method)
        - parking to wait for  <0x00000006eb69c1f8> (a java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject)
        at java.util.concurrent.locks.LockSupport.parkNanos(LockSupport.java:215)
        at java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject.awaitNanos(AbstractQueuedSynchronizer.java:2078)
        at java.util.concurrent.LinkedBlockingQueue.poll(LinkedBlockingQueue.java:467)
        at org.apache.camel.component.seda.SedaConsumer.doRun(SedaConsumer.java:198)
        at org.apache.camel.component.seda.SedaConsumer.run(SedaConsumer.java:154)
        at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142)
        at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617)
        at java.lang.Thread.run(Thread.java:748)
{code}

Note that whereas this latter example has SedaConsumer in the stacktrace polling for an exchange, the former example has no such SedaConsumer in the stacktrace and is stuck waiting for a new ""task"" to be given to the ThreadPoolExecutor.

After adding debug logging, I see that the issue is as follows:

The code in ServiceSupport here writes to the starting and started flags using one thread (call it Thread W):
{code}
    public void start() throws Exception {
        if (isStarting() || isStarted()) {
            // only start service if not already started
            LOG.trace(""Service already started"");
            return;
        }
        if (starting.compareAndSet(false, true)) {
            LOG.trace(""Starting service"");
            try {
                doStart();
                started.set(true);
                starting.set(false);
{code}
and on a different thread (call it thread R) this code in ServiceSupport reads the starting and started flags:
{code}
    public boolean isRunAllowed() {
        // if we have not yet initialized, then all options is false
        boolean unused1 = !started.get() && !starting.get() && !stopping.get() && !stopped.get();
        boolean unused2 = !suspending.get() && !suspended.get() && !shutdown.get() && !shuttingdown.get();
        if (unused1 && unused2) {
            return false;
        }
        return !isStoppingOrStopped();
    }
{code}

So the order of events is:
# Thread W: calls ServiceSupport.start()
# Thread W: compareAndSet starting from false to true
# Thread W: calls ServiceSupport.doStart() which eventually creates and starts Thread R
# Thread R: calls SedaConsumer.doRun() which calls isRunAllowed()
# Thread R: in isRunAllowed() reads started as false
# Thread W: set started to true
# Thread W: set starting to false
# Thread R: in isRunAllowed() reads starting as false
# Thread R: concludes that isRunAllowed is false
# Thread R: the while loop in SedaConsumer.doRun is not executed and the thread will forever remain stuck waiting for a new ""task"" (on ThreadPoolExecutor.java:1067)

One fix would be to swap reading of starting and started so that starting is read first, then started.

Looking at the latest code in Camel 3.0.x, this code has been refactored to use a single ""status"" field instead of multiple different AtomicBoolean fields.  That should also fix this bug.  However, for completeness, I thought it best to log this bug anyway."
CAMEL-13355,MLLP Component 'maxConcurrentConsumers' configuration is ignored,"If you set 'maxConcurrentConsumers' property in the MllpConfiguration object and assign that to MllpComponent, then, during creation of MllpEndpoint instance, that property is ignored and default value of 5 is used.",davsclaus,Bug,Minor,Resolved,"MLLP Component 'maxConcurrentConsumers' configuration is ignored If you set 'maxConcurrentConsumers' property in the MllpConfiguration object and assign that to MllpComponent, then, during creation of MllpEndpoint instance, that property is ignored and default value of 5 is used."
CAMEL-13354,Camel main - Allow to configure hystrix via application.properties,"So you can easily configure hystrix from property placeholders in application.properties etc, which you can do with spring boot etc.",davsclaus,Improvement,Major,Resolved,"Camel main - Allow to configure hystrix via application.properties So you can easily configure hystrix from property placeholders in application.properties etc, which you can do with spring boot etc."
CAMEL-13353,Re-enable the camel-lra integration tests,These camel-lra integration tests were ignored due to the JBTM issues which have been fixed in the Narayana 5.9.0.Final release. So I think it could be useful to re-enable to verify if it works.,davsclaus,Test,Major,Resolved,Re-enable the camel-lra integration tests These camel-lra integration tests were ignored due to the JBTM issues which have been fixed in the Narayana 5.9.0.Final release. So I think it could be useful to re-enable to verify if it works.
CAMEL-13352,Update document of HostAddresses ,"As the Host and Port options are removed, we need to update the HostAddresses document for it.",njiang,Improvement,Minor,Resolved,"Update document of HostAddresses  As the Host and Port options are removed, we need to update the HostAddresses document for it."
CAMEL-13348,Camel elasticsearch support search without specifying the indexName and indexType,"ElasticSearch support not to specify the indexName and indexType for search, so camel-elasticsearch search option don't need to specify the indexName and indexType",njiang,Task,Minor,Resolved,"Camel elasticsearch support search without specifying the indexName and indexType ElasticSearch support not to specify the indexName and indexType for search, so camel-elasticsearch search option don't need to specify the indexName and indexType"
CAMEL-13346,Camel main - Allow to add extra properties to property component,To make it easier to add custom properties from java api. Currently you can only configure properties locations (eg file locations),davsclaus,Improvement,Major,Resolved,Camel main - Allow to add extra properties to property component To make it easier to add custom properties from java api. Currently you can only configure properties locations (eg file locations)
CAMEL-13345,route-coverage : Add option to generate a jacoco XML report,"Would be good to have the route-coverage maven plugin to be able to generate a XML report using the jacoco XML report format, described in the jacoco documentation [https://www.jacoco.org/jacoco/trunk/doc/]

 

The benefit is that tools like SonarQube has support for handling these XML reports and they can then add this into the report.

 

 ",davsclaus,New Feature,Major,Resolved,"route-coverage : Add option to generate a jacoco XML report Would be good to have the route-coverage maven plugin to be able to generate a XML report using the jacoco XML report format, described in the jacoco documentation [https://www.jacoco.org/jacoco/trunk/doc/]

 

The benefit is that tools like SonarQube has support for handling these XML reports and they can then add this into the report.

 

 "
CAMEL-13344,camel-sql - stored procedure loaded from file/classpath should skip comment lines,"The template is loaded from a resource such a file on the classpath, then lines with comments (start with --) should be skipped.",davsclaus,Improvement,Major,Resolved,"camel-sql - stored procedure loaded from file/classpath should skip comment lines The template is loaded from a resource such a file on the classpath, then lines with comments (start with --) should be skipped."
CAMEL-13339,Partition revoke implemented to save offset state using KafkaConsumer.position API results in message loss,"Current implementation of org.apache.camel.component.kafka.KafkaConsumer.KafkaFetchRecords's onPartitionsRevoked, uses org.apache.kafka.clients.consumer.KafkaConsumer.position(partition). This approach causes message loss when multiple processes listening to same topic for point to point messaging (like a QUEUE) type implementation.

 

Issue is noticed when partition gets assigned and then gets revoked in quick succession. Upon partition assignment, say at the beginning of processing offset is set to 0, and say there was no poll for this partition (may be due to earlier poll brought in bunch of records and they are still being processed). Subsequently, say partition got revoked, before polling.

In this case, as onPartitionsRevoked looks at org.apache.kafka.clients.consumer.KafkaConsumer.position(partition) to save offset state and so 0 gets saved in this case in StateRepository implementation. When the same partition get assigned again, StateRepository.getState returns 0. Since Camel KafkaConsumer treats this as last processed offset, it adds 1 to it moving pointer to offset 1. Because of this, message at offset 0 never gets processed.

 

Two fixes might be needed
 # a) onPartitionsRevoked should look at last processed offset (possibly store 'last processed offset' for each topic/partition in a memory map) and use it to save offset
 # b) Currently onPartitionsRevoked just saves offset state when an implementation of StateRepository configured. Ideally it should call KafkaFetchRecords.commitOffset so commitSync call goes through when partition revoked and no StateRepository implementation configured",davsclaus,Bug,Major,Resolved,"Partition revoke implemented to save offset state using KafkaConsumer.position API results in message loss Current implementation of org.apache.camel.component.kafka.KafkaConsumer.KafkaFetchRecords's onPartitionsRevoked, uses org.apache.kafka.clients.consumer.KafkaConsumer.position(partition). This approach causes message loss when multiple processes listening to same topic for point to point messaging (like a QUEUE) type implementation.

 

Issue is noticed when partition gets assigned and then gets revoked in quick succession. Upon partition assignment, say at the beginning of processing offset is set to 0, and say there was no poll for this partition (may be due to earlier poll brought in bunch of records and they are still being processed). Subsequently, say partition got revoked, before polling.

In this case, as onPartitionsRevoked looks at org.apache.kafka.clients.consumer.KafkaConsumer.position(partition) to save offset state and so 0 gets saved in this case in StateRepository implementation. When the same partition get assigned again, StateRepository.getState returns 0. Since Camel KafkaConsumer treats this as last processed offset, it adds 1 to it moving pointer to offset 1. Because of this, message at offset 0 never gets processed.

 

Two fixes might be needed
 # a) onPartitionsRevoked should look at last processed offset (possibly store 'last processed offset' for each topic/partition in a memory map) and use it to save offset
 # b) Currently onPartitionsRevoked just saves offset state when an implementation of StateRepository configured. Ideally it should call KafkaFetchRecords.commitOffset so commitSync call goes through when partition revoked and no StateRepository implementation configured"
CAMEL-13338,ConsumerRebalanceListener is not registered when topicIsPattern is turned off. Causing message loss or too many duplicates,"Not registering ConsumerRebalanceListener when topicIsPattern turned off, causes either too many duplicate messages getting delivered to message processing layer or causes message loss depending on autoOffsetReset flag value.
 
Issue is noticed with below test scenario
Topic: e.g. TestMessage
Number of partitions: 25 (this is not completely relevant to issue)
ConsumerUri: kafka:<kafka-broker-uris>?topic=TestMessage&groupId=TestMessage_GROUP&consumersCount=5&autoCommitEnable=false&offsetRepository=#<DB-state-repository>
Number processes running consumers: 2 or more; e.g. two instances of Docker containers listening from same topic each with 5 consumer threads
 
Please note that offset management is done in DB with an implementation of Camel's StateRepository interface to eliminate too duplicate messages arriving at the message processor (at most one message processing needed for my use case)
 
When a second process instance (say second container) brought up, since ConsumerRebalanceListener is not registered, partitions start processing at earliest offsets if autoOffsetReset is set to earliest as expected. In this case, too many duplicate messages arrive at the message processing layer. If autoOffsetReset is set to latest, message loss occurs for certain partitions. If autoOffsetReset is set to none, no valid offset exception thrown by broker
 
Issue would be noticed consistently when simulating slow message processing for the above test scenario
 
 ",davsclaus,Bug,Major,Resolved,"ConsumerRebalanceListener is not registered when topicIsPattern is turned off. Causing message loss or too many duplicates Not registering ConsumerRebalanceListener when topicIsPattern turned off, causes either too many duplicate messages getting delivered to message processing layer or causes message loss depending on autoOffsetReset flag value.
 
Issue is noticed with below test scenario
Topic: e.g. TestMessage
Number of partitions: 25 (this is not completely relevant to issue)
ConsumerUri: kafka:<kafka-broker-uris>?topic=TestMessage&groupId=TestMessage_GROUP&consumersCount=5&autoCommitEnable=false&offsetRepository=#<DB-state-repository>
Number processes running consumers: 2 or more; e.g. two instances of Docker containers listening from same topic each with 5 consumer threads
 
Please note that offset management is done in DB with an implementation of Camel's StateRepository interface to eliminate too duplicate messages arriving at the message processor (at most one message processing needed for my use case)
 
When a second process instance (say second container) brought up, since ConsumerRebalanceListener is not registered, partitions start processing at earliest offsets if autoOffsetReset is set to earliest as expected. In this case, too many duplicate messages arrive at the message processing layer. If autoOffsetReset is set to latest, message loss occurs for certain partitions. If autoOffsetReset is set to none, no valid offset exception thrown by broker
 
Issue would be noticed consistently when simulating slow message processing for the above test scenario
 
 "
CAMEL-13335,create camel-cloudevents data type,We should create a camel-cloudevents data type based on https://github.com/cloudevents/sdk-java,njiang,New Feature,Minor,Open,create camel-cloudevents data type We should create a camel-cloudevents data type based on https://github.com/cloudevents/sdk-java
CAMEL-13334,Message parameter for log component,"There does not seem to be a good way to log a message describing what is logged.

Imagine I have a route, where I want to be able to trace all the content. I could use .log() processor but log component is better for tracing all the exchange details and also provides showStreams option.

 
{code:java}
from(direct:in)
.to(log:MyTestClass?level=TRACE)
.to(direct:step1)
.to(log:MyTestClass?level=TRACE)
.to(direct:step2)
.to(log:MyTestClass?level=TRACE)
.to(direct:step3)
.to(log:MyTestClass?level=TRACE)
.to(mock:result)
{code}
 

In the resulting log, it will be hard to see which line is produced by which log producer.

Something like 
{code:java}
.to(log:MyTestClass?level=TRACE&message=user before step1){code}
would be quite helpful. Wondering why it has not been implemented yet. I found only early requests from 2008. 

Beeing able to use simple language would be even better:  
{code:java}
.to(log:MyTestClass?level=TRACE&message=user before step1 - ${header.user.name}){code}
 ",davsclaus,Improvement,Minor,Resolved,"Message parameter for log component There does not seem to be a good way to log a message describing what is logged.

Imagine I have a route, where I want to be able to trace all the content. I could use .log() processor but log component is better for tracing all the exchange details and also provides showStreams option.

 
{code:java}
from(direct:in)
.to(log:MyTestClass?level=TRACE)
.to(direct:step1)
.to(log:MyTestClass?level=TRACE)
.to(direct:step2)
.to(log:MyTestClass?level=TRACE)
.to(direct:step3)
.to(log:MyTestClass?level=TRACE)
.to(mock:result)
{code}
 

In the resulting log, it will be hard to see which line is produced by which log producer.

Something like 
{code:java}
.to(log:MyTestClass?level=TRACE&message=user before step1){code}
would be quite helpful. Wondering why it has not been implemented yet. I found only early requests from 2008. 

Beeing able to use simple language would be even better:  
{code:java}
.to(log:MyTestClass?level=TRACE&message=user before step1 - ${header.user.name}){code}
 "
CAMEL-13329,camel-core - BeanConverter should be in core static converters,This component is still in camel-core and its not part of the core static converters. We should include it - until (if possible) we move the bean component out of camel-core.,davsclaus,Improvement,Major,Resolved,camel-core - BeanConverter should be in core static converters This component is still in camel-core and its not part of the core static converters. We should include it - until (if possible) we move the bean component out of camel-core.
CAMEL-13326,apt compiler - Separate core vs component processors,"We should make camel-core / camel-spring / camel-blueprint have their own set of apt compiler plugins. And then another set for the general components etc.

This avoids running some of these on modules they dont need to do.",davsclaus,New Feature,Major,Resolved,"apt compiler - Separate core vs component processors We should make camel-core / camel-spring / camel-blueprint have their own set of apt compiler plugins. And then another set for the general components etc.

This avoids running some of these on modules they dont need to do."
CAMEL-13313,camel-core - Add alternative way of loading type converters without classpath scanning,"We should make it possible to load and install all type converters without having to do
- classpath scanning
- loading TypeConverter file from META-INF

For example we do some apt compiler source code generation for the core type converter.
It would be good to have something similar or other means of loading and installing type converters that can be done fast and quick, which is needed for Camel K and graal like runtimes.",davsclaus,New Feature,Major,Resolved,"camel-core - Add alternative way of loading type converters without classpath scanning We should make it possible to load and install all type converters without having to do
- classpath scanning
- loading TypeConverter file from META-INF

For example we do some apt compiler source code generation for the core type converter.
It would be good to have something similar or other means of loading and installing type converters that can be done fast and quick, which is needed for Camel K and graal like runtimes."
CAMEL-13312,ModelCamelContext loadRoutesDefinition/loadRestsDefinition are misleading,"We do have method like loadRoutesDefinition and loadRestsDefinition in the ModelCamelContext interface but they are a little bit misleading as they do not load a definition in the camel context but they are an helper that invoke

{code}
ModelHelper.loadRoutesDefinition(this, is)
{code}

The only advantage is that you do not need to pass the camel context but other that that they appear as pure utility.

Toproperly load a route one need to do something something like

{code}
context.addRouteDefinitions(context.loadRoutesDefinition(is).getRoutes())
{code}

which is a little ugly
",davsclaus,Improvement,Minor,Resolved,"ModelCamelContext loadRoutesDefinition/loadRestsDefinition are misleading We do have method like loadRoutesDefinition and loadRestsDefinition in the ModelCamelContext interface but they are a little bit misleading as they do not load a definition in the camel context but they are an helper that invoke

{code}
ModelHelper.loadRoutesDefinition(this, is)
{code}

The only advantage is that you do not need to pass the camel context but other that that they appear as pure utility.

Toproperly load a route one need to do something something like

{code}
context.addRouteDefinitions(context.loadRoutesDefinition(is).getRoutes())
{code}

which is a little ugly
"
CAMEL-13311,camel-cdi and camel-blueprint - Cleanup bean post processor,Looks like they do some custom code that likely is not longer needed and can rely on the default out of the box.,davsclaus,Task,Major,Resolved,camel-cdi and camel-blueprint - Cleanup bean post processor Looks like they do some custom code that likely is not longer needed and can rely on the default out of the box.
CAMEL-13309,@EndpointInject - Use value as uri,"We should favour using value as attribute name so you can use shorthand syntax with @EndpointInject(""jms:cheese"") instead of having to use uri = ""xxx""

The same for @Produce and @Consume etc",davsclaus,Improvement,Major,Resolved,"@EndpointInject - Use value as uri We should favour using value as attribute name so you can use shorthand syntax with @EndpointInject(""jms:cheese"") instead of having to use uri = ""xxx""

The same for @Produce and @Consume etc"
CAMEL-13308,Remove ref on @Consume as you should use ref in the uri instead,"We removed this on <to ref=""xxx""> already in the DSL. We should remove this in other places like @Consume annotation",davsclaus,Improvement,Major,Resolved,"Remove ref on @Consume as you should use ref in the uri instead We removed this on <to ref=""xxx""> already in the DSL. We should remove this in other places like @Consume annotation"
CAMEL-13307,Camel registry - Allow to bind anonymously by type,"With the new bind api on registry we should also allow to bind with null id and by the type only, so you can bind anonymously.

For example for single resources in microservices / serverless, which Camel K uses.",davsclaus,New Feature,Major,Resolved,"Camel registry - Allow to bind anonymously by type With the new bind api on registry we should also allow to bind with null id and by the type only, so you can bind anonymously.

For example for single resources in microservices / serverless, which Camel K uses."
CAMEL-13303,Camel with OSGi blueprint on Karaf should detect JMX,"10:31:00.277 INFO [Blueprint Event Dispatcher: 1] Attempting to start CamelContext: camel-1
10:31:00.279 INFO [Blueprint Event Dispatcher: 1] Apache Camel 3.0.0-SNAPSHOT (CamelContext: camel-1) is starting
10:31:00.281 INFO [Blueprint Event Dispatcher: 1] JMX is disabled",davsclaus,Bug,Major,Resolved,"Camel with OSGi blueprint on Karaf should detect JMX 10:31:00.277 INFO [Blueprint Event Dispatcher: 1] Attempting to start CamelContext: camel-1
10:31:00.279 INFO [Blueprint Event Dispatcher: 1] Apache Camel 3.0.0-SNAPSHOT (CamelContext: camel-1) is starting
10:31:00.281 INFO [Blueprint Event Dispatcher: 1] JMX is disabled"
CAMEL-13301,Move catalog apis from CamelContext into CatalogCamelContext,"Lets move these catalog apis into a dedicated catalog camel context which you can then use the adapt api from camel context if you want to use it, like with model camel context",davsclaus,Improvement,Major,Resolved,"Move catalog apis from CamelContext into CatalogCamelContext Lets move these catalog apis into a dedicated catalog camel context which you can then use the adapt api from camel context if you want to use it, like with model camel context"
CAMEL-13298,Allow bean component to invoke methods with package modifier in the same class,"To make it easier to use methods from the same route builder class where you define the routes, then you may have helper methods, that are invoked via bean / method call language. And they can only see public methods as its via camel-core they are called. So we should look at opening up the visibility, like we do with field injection and other things.",davsclaus,Improvement,Major,Resolved,"Allow bean component to invoke methods with package modifier in the same class To make it easier to use methods from the same route builder class where you define the routes, then you may have helper methods, that are invoked via bean / method call language. And they can only see public methods as its via camel-core they are called. So we should look at opening up the visibility, like we do with field injection and other things."
CAMEL-13297,camel-core tests fail if JAVA_HOME is not set,"Test assumes that JAVA_HOME exists which is standard but not mandatory.
{noformat}
[ERROR] org.apache.camel.component.properties.PropertiesComponentDefaultFunctionsTest.testFunction(org.apache.camel.component.properties.PropertiesComponentDefaultFunctionsTest){noformat}",davsclaus,Test,Trivial,Resolved,"camel-core tests fail if JAVA_HOME is not set Test assumes that JAVA_HOME exists which is standard but not mandatory.
{noformat}
[ERROR] org.apache.camel.component.properties.PropertiesComponentDefaultFunctionsTest.testFunction(org.apache.camel.component.properties.PropertiesComponentDefaultFunctionsTest){noformat}"
CAMEL-13296,Dump JMX stats for null timestamps should not use 1970-1-1 as date,"Noticed this
lastExchangeFailureTimestamp=""1970-01-01T00:59:59.999+0100"" ",davsclaus,Bug,Minor,Resolved,"Dump JMX stats for null timestamps should not use 1970-1-1 as date Noticed this
lastExchangeFailureTimestamp=""1970-01-01T00:59:59.999+0100"" "
CAMEL-13294,Properties component - Add easy method to lookup via key,"Lets make this code a bit easier, and have a nicer API on the PropertiesComponent we have in camel-api now for Camel 3
{code}
                        // build key with default value included as this is supported during resolving
                        String key = pi.value();
                        if (!isEmpty(pi.defaultValue())) {
                            key = key + "":"" + pi.defaultValue();
                        }
                        // need to force property lookup by having key enclosed in tokens
                        key = camelContext.getPropertiesComponent().getPrefixToken() + key + camelContext.getPropertiesComponent().getSuffixToken();
                        try {
                            Object value = camelContext.resolvePropertyPlaceholders(key);
                            parameters[i] = camelContext.getTypeConverter().convertTo(type, value);
                        } catch (Exception e) {
                            throw RuntimeCamelException.wrapRuntimeCamelException(e);
                        }
{code}",davsclaus,Improvement,Major,Resolved,"Properties component - Add easy method to lookup via key Lets make this code a bit easier, and have a nicer API on the PropertiesComponent we have in camel-api now for Camel 3
{code}
                        // build key with default value included as this is supported during resolving
                        String key = pi.value();
                        if (!isEmpty(pi.defaultValue())) {
                            key = key + "":"" + pi.defaultValue();
                        }
                        // need to force property lookup by having key enclosed in tokens
                        key = camelContext.getPropertiesComponent().getPrefixToken() + key + camelContext.getPropertiesComponent().getSuffixToken();
                        try {
                            Object value = camelContext.resolvePropertyPlaceholders(key);
                            parameters[i] = camelContext.getTypeConverter().convertTo(type, value);
                        } catch (Exception e) {
                            throw RuntimeCamelException.wrapRuntimeCamelException(e);
                        }
{code}"
CAMEL-13293,"Camel-linkedin, switch HtmlUnit to JSoup to not rely on Jetty (and allow update to servlet api 4)","Component camel-linkedin depends on Jetty (see https://github.com/apache/camel/blob/master/platforms/karaf/features/src/main/resources/features.xml#L1578)

This dependency doesn't allow update servlet-api to 4.0

Solution is to refactor component to use JSoup instead.",davsclaus,Improvement,Major,Resolved,"Camel-linkedin, switch HtmlUnit to JSoup to not rely on Jetty (and allow update to servlet api 4) Component camel-linkedin depends on Jetty (see https://github.com/apache/camel/blob/master/platforms/karaf/features/src/main/resources/features.xml#L1578)

This dependency doesn't allow update servlet-api to 4.0

Solution is to refactor component to use JSoup instead."
CAMEL-13291,camel-quartz - Allow to configure cron parameter with spaces,"In the past we had to use + sign as separator in the cron
{code}
0/2+*+*+*+*+?
{code}

We should support also using spaces, so its like text-book cron
{code}
0/2 * * * * ?
{code}",davsclaus,Improvement,Minor,Resolved,"camel-quartz - Allow to configure cron parameter with spaces In the past we had to use + sign as separator in the cron
{code}
0/2+*+*+*+*+?
{code}

We should support also using spaces, so its like text-book cron
{code}
0/2 * * * * ?
{code}"
CAMEL-13289,Properties component - Keys with dashes should lookup with underscores as well,"On linux OS environment variables using dashes is not allowed, eg FOO-BAR, should be FOO_BAR. So we should automatic add support for looking up with underscores as fallback.",davsclaus,Improvement,Major,Resolved,"Properties component - Keys with dashes should lookup with underscores as well On linux OS environment variables using dashes is not allowed, eg FOO-BAR, should be FOO_BAR. So we should automatic add support for looking up with underscores as fallback."
CAMEL-13288,"Properties component - Add support for lookup exact by key, and mixed dashed vs camel case","So you can define property placeholders using a dashed style

https://github.com/apache/camel/blob/master/components/camel-jms/src/main/docs/jms-component.adoc

For example to set the JMS component option you can do:
camel.component.jms.acceptMessagesWhileStopping=true

But would be nice to support dashed style too (ala spring boot)
camel.component.jms.accept-messages-while-stopping=true

This is needed for Camel standalone to make this easier / similar to spring-boot



",davsclaus,New Feature,Major,Resolved,"Properties component - Add support for lookup exact by key, and mixed dashed vs camel case So you can define property placeholders using a dashed style

https://github.com/apache/camel/blob/master/components/camel-jms/src/main/docs/jms-component.adoc

For example to set the JMS component option you can do:
camel.component.jms.acceptMessagesWhileStopping=true

But would be nice to support dashed style too (ala spring boot)
camel.component.jms.accept-messages-while-stopping=true

This is needed for Camel standalone to make this easier / similar to spring-boot



"
CAMEL-13287, AggregationStrategy - Access original exchange in aggregate method,"For aggregation after multicast/splitter the original exchange should optionally be available in the aggregate method.
 There are several use cases when we would like to go-on processing the original exchange after multicast, but we'd like to enrich it with the outcome of the called routes. For example:
{code:java}
rest()
.get(""orders/{orderId}"")
.route()
  .to(""direct:getOrderDetails"") //get UserId, ItemId
  .setBody(method(this,""createResponsePojo""))
  .multicast(new MyAggregationStrategy())
    .to(""direct:getUserDetails"")
    .to(""direct:getDeliveryAddress"")
    .to(""direct:getItemDetails"")
  .end()
;
{code}
If any of the called routes fail, we still would like return a partial response in our service (this is a common requirement in case of microservices). The MyAggregationStrategy should simply enrich the ResponePojo object from the original exchange somehow with the new exchanges coming from the sub-routes. See this example:
{code:java}
public class MyAggregationStrategy implements AggregationStrategy {

public Exchange aggregateWithOriginal(Exchange oldExchange, Exchange newExchange, Exchange originalExchange) {
  Exchange exchange = oldExchange != null ? oldExchange : originalExchange;
  ResponsePojo response = exchange.getMessage().getBody(ResponsePojo.class);

  if (! newExchange.isFailed()) {
    // ... Add newExchange body somehow to ResponsePojo object...
  }
  return exchange;
}
...
}
{code}
Currently only the exchanges from the ""sub-routes"" are available during aggregation, so the exchange after the aggregate will be one (the first) of those. This comes with multiple problems:
 * Though the exchanges in the sub-routes are copies of the original exchange, sub routes make modifications: modify headers, modify properties, etc. Usually we don't want to see all these set by a sub-route on the final aggregated exchange. It's only noise. ""Whatever happens in the sub-route, should stay in the sub-route."" - We only want to see on the aggregated exchange what we ""took"" intentionally from the sub-route exchanges.
 * If we use stopOnException(true) our life is simple because we usually don't have to worry about exceptions in aggregate, we will stop anyway. The aggregation logic can become complicated if we want to go on with processing in case of errors. The first time aggregate() is called the oldExchange is null, so we usually take the newExchange as the return value. If this exchange has an Exception, we need to ""clean"" it first, otherwise the error handler will kick in after aggregation. This is non-trivial.

h3. Suggested approach

Let's extend the AggregationStrategy interface with a new method that takes three exchanges. This should be called after Multicast EIP (Enrich EIP is simple, it only has two exchanges).

With a default implementations we can keep the interface compatible:
{code:java}
public interface AggregationStrategy {

/**
* Aggregates an old, a new and the original exchange together to create a single combined exchange.
*
* @param oldExchange the oldest exchange, which is the returned value of the previous aggregation on null.
* @param newExchange the newest exchange
* @param originalExchange the original exchange before Multicast or Splitter EIP. Null in case of Enrich EIP.
* @return a combined exchange, favor returning the oldExchange
*/
default Exchange aggregateWithOriginal(Exchange oldExchange, Exchange newExchange, Exchange originalExchange) {
  return aggregate(oldExchange, newExchange);
};

//Maybe we should have a default implementation here too so one can only implement aggregateWithOriginal()
Exchange aggregate(Exchange oldExchange, Exchange newExchange); 
... 
}
{code}
{code:java}
 {code}",davsclaus,New Feature,Major,Resolved," AggregationStrategy - Access original exchange in aggregate method For aggregation after multicast/splitter the original exchange should optionally be available in the aggregate method.
 There are several use cases when we would like to go-on processing the original exchange after multicast, but we'd like to enrich it with the outcome of the called routes. For example:
{code:java}
rest()
.get(""orders/{orderId}"")
.route()
  .to(""direct:getOrderDetails"") //get UserId, ItemId
  .setBody(method(this,""createResponsePojo""))
  .multicast(new MyAggregationStrategy())
    .to(""direct:getUserDetails"")
    .to(""direct:getDeliveryAddress"")
    .to(""direct:getItemDetails"")
  .end()
;
{code}
If any of the called routes fail, we still would like return a partial response in our service (this is a common requirement in case of microservices). The MyAggregationStrategy should simply enrich the ResponePojo object from the original exchange somehow with the new exchanges coming from the sub-routes. See this example:
{code:java}
public class MyAggregationStrategy implements AggregationStrategy {

public Exchange aggregateWithOriginal(Exchange oldExchange, Exchange newExchange, Exchange originalExchange) {
  Exchange exchange = oldExchange != null ? oldExchange : originalExchange;
  ResponsePojo response = exchange.getMessage().getBody(ResponsePojo.class);

  if (! newExchange.isFailed()) {
    // ... Add newExchange body somehow to ResponsePojo object...
  }
  return exchange;
}
...
}
{code}
Currently only the exchanges from the ""sub-routes"" are available during aggregation, so the exchange after the aggregate will be one (the first) of those. This comes with multiple problems:
 * Though the exchanges in the sub-routes are copies of the original exchange, sub routes make modifications: modify headers, modify properties, etc. Usually we don't want to see all these set by a sub-route on the final aggregated exchange. It's only noise. ""Whatever happens in the sub-route, should stay in the sub-route."" - We only want to see on the aggregated exchange what we ""took"" intentionally from the sub-route exchanges.
 * If we use stopOnException(true) our life is simple because we usually don't have to worry about exceptions in aggregate, we will stop anyway. The aggregation logic can become complicated if we want to go on with processing in case of errors. The first time aggregate() is called the oldExchange is null, so we usually take the newExchange as the return value. If this exchange has an Exception, we need to ""clean"" it first, otherwise the error handler will kick in after aggregation. This is non-trivial.

h3. Suggested approach

Let's extend the AggregationStrategy interface with a new method that takes three exchanges. This should be called after Multicast EIP (Enrich EIP is simple, it only has two exchanges).

With a default implementations we can keep the interface compatible:
{code:java}
public interface AggregationStrategy {

/**
* Aggregates an old, a new and the original exchange together to create a single combined exchange.
*
* @param oldExchange the oldest exchange, which is the returned value of the previous aggregation on null.
* @param newExchange the newest exchange
* @param originalExchange the original exchange before Multicast or Splitter EIP. Null in case of Enrich EIP.
* @return a combined exchange, favor returning the oldExchange
*/
default Exchange aggregateWithOriginal(Exchange oldExchange, Exchange newExchange, Exchange originalExchange) {
  return aggregate(oldExchange, newExchange);
};

//Maybe we should have a default implementation here too so one can only implement aggregateWithOriginal()
Exchange aggregate(Exchange oldExchange, Exchange newExchange); 
... 
}
{code}
{code:java}
 {code}"
CAMEL-13283,Add @BindRegistry annotation to allow binding a field/class/bean to the Camel registry,"Now that we can bind to registry, lets add an annotation so users can define those as well, for example with Camel standalone.
",davsclaus,New Feature,Major,Resolved,"Add @BindRegistry annotation to allow binding a field/class/bean to the Camel registry Now that we can bind to registry, lets add an annotation so users can define those as well, for example with Camel standalone.
"
CAMEL-13281,spring boot starter - Generated auto configuration should support exclude properties on component level,"A few component inherit each other, and they may exclude some of the parent options, for example ftp/netty4-http etc. Currently they only do that on endpoint level. We need something similar on component level so the SB auto generation dont include them.

{code}
        excludeProperties = ""textline,delimiter,autoAppendDelimiter,decoderMaxLineLength,encoding,allowDefaultCodec,udpConnectionlessSending,networkInterface""
                + "",clientMode,reconnect,reconnectInterval,useByteBuf,udpByteArrayCodec,broadcast,correlationManager"")
{code}",davsclaus,Improvement,Major,Resolved,"spring boot starter - Generated auto configuration should support exclude properties on component level A few component inherit each other, and they may exclude some of the parent options, for example ftp/netty4-http etc. Currently they only do that on endpoint level. We need something similar on component level so the SB auto generation dont include them.

{code}
        excludeProperties = ""textline,delimiter,autoAppendDelimiter,decoderMaxLineLength,encoding,allowDefaultCodec,udpConnectionlessSending,networkInterface""
                + "",clientMode,reconnect,reconnectInterval,useByteBuf,udpByteArrayCodec,broadcast,correlationManager"")
{code}"
CAMEL-13280,Properties component - Allow to access loaded properties,We should expose API on properties component so users and tooling can access the loaded properties. This can help with detecting which properties are available in the project.,davsclaus,New Feature,Major,Resolved,Properties component - Allow to access loaded properties We should expose API on properties component so users and tooling can access the loaded properties. This can help with detecting which properties are available in the project.
CAMEL-13273,Link missing in JMX Documentation,"Reference: [https://github.com/apache/camel/blob/master/components/camel-jmx/src/main/docs/jmx-component.adoc#which-processors-are-registered]

{{It mentions ""See this FAQ"". But there is no link for it.}}",davsclaus,Task,Trivial,Resolved,"Link missing in JMX Documentation Reference: [https://github.com/apache/camel/blob/master/components/camel-jmx/src/main/docs/jmx-component.adoc#which-processors-are-registered]

{{It mentions ""See this FAQ"". But there is no link for it.}}"
CAMEL-13272,File producer - Issue with toD when using moveExisting,"See SO
https://stackoverflow.com/questions/54890566/camel-file-component-create-a-file-and-if-already-exist-move-it-and-renamed-i/54910417#54910417

And for the solution/workaround to use to instead of toD",davsclaus,Bug,Major,Resolved,"File producer - Issue with toD when using moveExisting See SO
https://stackoverflow.com/questions/54890566/camel-file-component-create-a-file-and-if-already-exist-move-it-and-renamed-i/54910417#54910417

And for the solution/workaround to use to instead of toD"
CAMEL-13270,camel-rabbitmq - x-death header gets lost because of incorrect header value validation,"In `RabbitMQMessageConverter.java`, some kind of header value validation is done:


{code:java}
    private Object getValidRabbitMQHeaderValue(Object headerValue) {
        if (headerValue instanceof String) {
            return headerValue;
        } else if (headerValue instanceof Number) {
            return headerValue;
        } else if (headerValue instanceof Boolean) {
            return headerValue;
        } else if (headerValue instanceof Date) {
            return headerValue;
        } else if (headerValue instanceof byte[]) {
            return headerValue;
        } else if (headerValue instanceof LongString) {
            return headerValue;
        }

        return null;
    }
{code}

While this is correct for the listed typed, this is incomplete. An example of this is the `x-death` header, as explained on https://www.rabbitmq.com/dlx.html#effects. This header is basically a `List<Map<String,Object>>`.

If a message with such header is consumed and then propagated to another queue, the header will be lost. An example use case is consuming a dead-letter queue and propagating the messages to another queue, possible after some delay, until the `count` field in the `x-death` header reached a certain threshold.

I am happy to provide a self-contained example if this would be helpful.",davsclaus,Bug,Minor,Resolved,"camel-rabbitmq - x-death header gets lost because of incorrect header value validation In `RabbitMQMessageConverter.java`, some kind of header value validation is done:


{code:java}
    private Object getValidRabbitMQHeaderValue(Object headerValue) {
        if (headerValue instanceof String) {
            return headerValue;
        } else if (headerValue instanceof Number) {
            return headerValue;
        } else if (headerValue instanceof Boolean) {
            return headerValue;
        } else if (headerValue instanceof Date) {
            return headerValue;
        } else if (headerValue instanceof byte[]) {
            return headerValue;
        } else if (headerValue instanceof LongString) {
            return headerValue;
        }

        return null;
    }
{code}

While this is correct for the listed typed, this is incomplete. An example of this is the `x-death` header, as explained on https://www.rabbitmq.com/dlx.html#effects. This header is basically a `List<Map<String,Object>>`.

If a message with such header is consumed and then propagated to another queue, the header will be lost. An example use case is consuming a dead-letter queue and propagating the messages to another queue, possible after some delay, until the `count` field in the `x-death` header reached a certain threshold.

I am happy to provide a self-contained example if this would be helpful."
CAMEL-13267,Camel stops consuming queue after restart of RabbitMQ broker,"I am consuming a RabbitMQ queue as following:

 
{code:java}
from(""rabbitmq://localhost:5672?username=test&password=test&declare=false&queue=q&autoAck=false&threadPoolSize=1&exclusiveConsumer=true"")
   .to(""log:receive"");{code}
 

When I restart the RabbitMQ broker, no messages are longer received in the log handler.

 

According the management interface, all pending messages are in UNACKED state. This means that they are transmitted to the consumer, but not acknowledged. In other words, Camel was able to restore the connection after the restart, but fails to deliver to the log handler and acknowledge them afterwards.

 

I did not test this, but I believe the consumer will eventually crash due to OOM.

 

+*example*+

 

Please find a self-contained example on [https://github.com/pbillen/playground-camel-13267|https://github.com/pbillen/playground-camel-13267].You need a (local) Docker daemon to run this. Use it as following:

 
 # Start with `mvn clean install -U`.
 # You notice in the logging that every 500ms, a message is sent and received. You can also log into the administrator interface on [http://localhost:15672|http://localhost:15672/] with login/password `test`. You will see the message pass through every 500ms. Great!
 # Now restart the RabbitMQ broker. Typically, find the container identifier with `docker ps` and then execute `docker restart <identifier>`.
 # After restart, you notice that every 500ms a message is sent, but not received. You can also log into the administrator interface and see that all messages are into the UNACKED state.",davsclaus,Bug,Minor,Resolved,"Camel stops consuming queue after restart of RabbitMQ broker I am consuming a RabbitMQ queue as following:

 
{code:java}
from(""rabbitmq://localhost:5672?username=test&password=test&declare=false&queue=q&autoAck=false&threadPoolSize=1&exclusiveConsumer=true"")
   .to(""log:receive"");{code}
 

When I restart the RabbitMQ broker, no messages are longer received in the log handler.

 

According the management interface, all pending messages are in UNACKED state. This means that they are transmitted to the consumer, but not acknowledged. In other words, Camel was able to restore the connection after the restart, but fails to deliver to the log handler and acknowledge them afterwards.

 

I did not test this, but I believe the consumer will eventually crash due to OOM.

 

+*example*+

 

Please find a self-contained example on [https://github.com/pbillen/playground-camel-13267|https://github.com/pbillen/playground-camel-13267].You need a (local) Docker daemon to run this. Use it as following:

 
 # Start with `mvn clean install -U`.
 # You notice in the logging that every 500ms, a message is sent and received. You can also log into the administrator interface on [http://localhost:15672|http://localhost:15672/] with login/password `test`. You will see the message pass through every 500ms. Great!
 # Now restart the RabbitMQ broker. Typically, find the container identifier with `docker ps` and then execute `docker restart <identifier>`.
 # After restart, you notice that every 500ms a message is sent, but not received. You can also log into the administrator interface and see that all messages are into the UNACKED state."
CAMEL-13266,camel-core-xml - Make JMX optional,"This module requires camel-management-impl. We should try to make this optional, so the JMX agent is not needed via compile time, but loaded via some factory way. Then end users can run camel XML with and without JMX more easily.",davsclaus,Improvement,Major,Resolved,"camel-core-xml - Make JMX optional This module requires camel-management-impl. We should try to make this optional, so the JMX agent is not needed via compile time, but loaded via some factory way. Then end users can run camel XML with and without JMX more easily."
CAMEL-13265,camel-core - Use camel-test for unit testing,"We can now build camel-test before camel-core, and then use camel-test for testing camel-core instead of having its own ContextTestSupport and other base classes.",davsclaus,Improvement,Major,Resolved,"camel-core - Use camel-test for unit testing We can now build camel-test before camel-core, and then use camel-test for testing camel-core instead of having its own ContextTestSupport and other base classes."
CAMEL-13264,Add release artifacts of camel-k-runtime project,We need to create the source release artifact for the camel-k-runtime project.,njiang,Task,Major,Resolved,Add release artifacts of camel-k-runtime project We need to create the source release artifact for the camel-k-runtime project.
CAMEL-13258,SimpleRegistry - Favour DefaultRegistry,"The DefaultRegistry should be favoured to be used. 
The simple registry is now more of an implementation detail as part of default registry.
And you can now do bind on default registry so you dont need to add custom registry to camel context to bind a bean etc.",davsclaus,Improvement,Major,Resolved,"SimpleRegistry - Favour DefaultRegistry The DefaultRegistry should be favoured to be used. 
The simple registry is now more of an implementation detail as part of default registry.
And you can now do bind on default registry so you dont need to add custom registry to camel context to bind a bean etc."
CAMEL-13252,camel-cdi - Remove OSGi support,OSGi with camel-cdi was hard to make stable and also not recommended to use. We only support OSGi blueprint on OSGi and for CDI then use plain CDI containers.,davsclaus,Task,Major,Resolved,camel-cdi - Remove OSGi support OSGi with camel-cdi was hard to make stable and also not recommended to use. We only support OSGi blueprint on OSGi and for CDI then use plain CDI containers.
CAMEL-13243,Camel Main - Make it have more functionality and convention out of the box,"For users that just want a plain Camel standalone, and also for Camel K where running low-footprint is important.

For example to make properties component automatic load from application.properties from root classpath. And also allow to have those properties fallback to lookup via ENV variables, so containers can customize them that way too.

And add other ideas here to this ticket",davsclaus,Improvement,Major,Resolved,"Camel Main - Make it have more functionality and convention out of the box For users that just want a plain Camel standalone, and also for Camel K where running low-footprint is important.

For example to make properties component automatic load from application.properties from root classpath. And also allow to have those properties fallback to lookup via ENV variables, so containers can customize them that way too.

And add other ideas here to this ticket"
CAMEL-13240,Don't ship the jars in the source artifacts,"In Camel 3.0.0 M1 source release kit, there are some jars for testing, we need to clean them out.
{code}
.//tests/camel-itest/lib/org/apache/camel/camel-validator-test-resources/1.0.0/camel-validator-test-resources-1.0.0.jar
.//components/camel-spring/src/test/resources/package_scan_test.jar
.//components/camel-spring/src/test/resources/package+scan+test.jar
{code}
",njiang,Task,Major,Resolved,"Don't ship the jars in the source artifacts In Camel 3.0.0 M1 source release kit, there are some jars for testing, we need to clean them out.
{code}
.//tests/camel-itest/lib/org/apache/camel/camel-validator-test-resources/1.0.0/camel-validator-test-resources-1.0.0.jar
.//components/camel-spring/src/test/resources/package_scan_test.jar
.//components/camel-spring/src/test/resources/package+scan+test.jar
{code}
"
CAMEL-13239,"camel-rabbitmq - Using the  ""new URl syntax"" doesn't seem to work correctly","When using the deprecated URL format
{noformat}
rabbitmq://hostname[:port]/exchange?[options]{noformat}
(also still on the main page) the camel route works as expected.  However, when listening to the warning and using the ""new syntax"" (only defined in the repo):
{noformat}
rabbitmq:exchange?[options]{noformat}
it does NOT work, and will fail to connect to rabbitmq at all, giving address errors

I have tried setting the hostname option (doesn't work, the component seems to ignore it), and tried setting springboot component parameters (doesn't seem to work, but I don't know of a way to test if they are even accessible.

I can supply loglines on demand if needed.

Also, in case it matters, in this case the hostname is an IP address.",davsclaus,Bug,Minor,Resolved,"camel-rabbitmq - Using the  ""new URl syntax"" doesn't seem to work correctly When using the deprecated URL format
{noformat}
rabbitmq://hostname[:port]/exchange?[options]{noformat}
(also still on the main page) the camel route works as expected.  However, when listening to the warning and using the ""new syntax"" (only defined in the repo):
{noformat}
rabbitmq:exchange?[options]{noformat}
it does NOT work, and will fail to connect to rabbitmq at all, giving address errors

I have tried setting the hostname option (doesn't work, the component seems to ignore it), and tried setting springboot component parameters (doesn't seem to work, but I don't know of a way to test if they are even accessible.

I can supply loglines on demand if needed.

Also, in case it matters, in this case the hostname is an IP address."
CAMEL-13236,mock endpoint - Small glitch in logging excepted failure,"We do
log.info(""Caught expected failure: {}"", e);

You cannot do {} with an exception.",davsclaus,Bug,Minor,Resolved,"mock endpoint - Small glitch in logging excepted failure We do
log.info(""Caught expected failure: {}"", e);

You cannot do {} with an exception."
CAMEL-13232,Simple language - Backwards compatible parser on 2.x should WARN,"We can make the old deprecated syntax of the simple language log a WARN when it has detected this style in Camel 2.24, so users can get more prepared for Camel 3.0 upgrade.",davsclaus,Task,Major,Resolved,"Simple language - Backwards compatible parser on 2.x should WARN We can make the old deprecated syntax of the simple language log a WARN when it has detected this style in Camel 2.24, so users can get more prepared for Camel 3.0 upgrade."
CAMEL-13221,Upgrade jetty to latest 9.4.x,"There is a newer release, but it may affect camel-cxf and others which tests with jetty. Jetty is always a bit problematic in their upgrades :(",davsclaus,Task,Major,Resolved,"Upgrade jetty to latest 9.4.x There is a newer release, but it may affect camel-cxf and others which tests with jetty. Jetty is always a bit problematic in their upgrades :("
CAMEL-13220,camel-jetty - Remove deprecated producer,"The producer of camel-jetty has been deprecated in Camel 2.x, and should be removed in 3.0.",davsclaus,Task,Major,Resolved,"camel-jetty - Remove deprecated producer The producer of camel-jetty has been deprecated in Camel 2.x, and should be removed in 3.0."
CAMEL-13217,Merge camel-jetty9 back into camel-jetty,"In the old days we had jetty 8 vs 9 problem, so we had to splitup it.
Now we camel 3 we can move back camel-jetty9 into camel-jetty and have this single JAR.
",davsclaus,Task,Major,Resolved,"Merge camel-jetty9 back into camel-jetty In the old days we had jetty 8 vs 9 problem, so we had to splitup it.
Now we camel 3 we can move back camel-jetty9 into camel-jetty and have this single JAR.
"
CAMEL-13214,camel-mail: Add headerFilterStrategy option to component level,"Currently it's not possible to change/customize the headerFilterStrategy for all camel-mail endpoints because it has to be configured on endpoint level.

In the cxf component it's possible to configure it on component level too, so it's possible to provide a global headerFilterStrategy:

Example:
{noformat}
		CxfComponent comp = camelContext.getComponent(""cxf"",
				CxfComponent.class);
		CxfHeaderFilterStrategy strategy = new CxfHeaderFilterStrategy();
		strategy.setOutFilterPattern(
				""<customized>"");
		comp.setHeaderFilterStrategy(strategy);{noformat}
It would be an improvement to add the headerFilterStrategy option also to component level.",davsclaus,Improvement,Minor,Resolved,"camel-mail: Add headerFilterStrategy option to component level Currently it's not possible to change/customize the headerFilterStrategy for all camel-mail endpoints because it has to be configured on endpoint level.

In the cxf component it's possible to configure it on component level too, so it's possible to provide a global headerFilterStrategy:

Example:
{noformat}
		CxfComponent comp = camelContext.getComponent(""cxf"",
				CxfComponent.class);
		CxfHeaderFilterStrategy strategy = new CxfHeaderFilterStrategy();
		strategy.setOutFilterPattern(
				""<customized>"");
		comp.setHeaderFilterStrategy(strategy);{noformat}
It would be an improvement to add the headerFilterStrategy option also to component level."
CAMEL-13210,camel-test-spring - Add support for @ExcludeRoutes annotation when testing spring boot,"Reported on user forum
http://camel.465427.n5.nabble.com/ExcludeRoutes-not-working-tp5830132.html",davsclaus,Improvement,Major,Resolved,"camel-test-spring - Add support for @ExcludeRoutes annotation when testing spring boot Reported on user forum
http://camel.465427.n5.nabble.com/ExcludeRoutes-not-working-tp5830132.html"
CAMEL-13208,camel3 - camel-core - Should have management-impl out of the box,"So its like in 2.x, where you have JMX out of the box.

We will for M2 work on a camel-core-tiny where you dont have that OOTB and other core components etc to have a minimal Camel.",davsclaus,Task,Major,Resolved,"camel3 - camel-core - Should have management-impl out of the box So its like in 2.x, where you have JMX out of the box.

We will for M2 work on a camel-core-tiny where you dont have that OOTB and other core components etc to have a minimal Camel."
CAMEL-13202,camel3 - spring-boot-start - Auto configuration too many,"we have still the ones that was in camel-core, but many has been moved out to its own component such as file, log, timer etc.",davsclaus,Task,Major,Resolved,"camel3 - spring-boot-start - Auto configuration too many we have still the ones that was in camel-core, but many has been moved out to its own component such as file, log, timer etc."
CAMEL-13201,camel3 - camel-core-minimal - To have core with as few dependencies as possible,"The camel-core includes all the core components from 2.x. However you may want to choose precisely only the core components you need.

So with a camel-core-minimal you can then add the ones afterwards, such as log,timer and file etc.",davsclaus,Task,Major,Resolved,"camel3 - camel-core-minimal - To have core with as few dependencies as possible The camel-core includes all the core components from 2.x. However you may want to choose precisely only the core components you need.

So with a camel-core-minimal you can then add the ones afterwards, such as log,timer and file etc."
CAMEL-13200,camel3 - Caffeine jar is not shaded,It should be shaded into camel-core which I dont think happens,davsclaus,Task,Major,Resolved,camel3 - Caffeine jar is not shaded It should be shaded into camel-core which I dont think happens
CAMEL-13199,Using @Produce as proxy for sending to endpoint does not emit sending/sent events,"Reported on user forum
http://camel.465427.n5.nabble.com/No-ExchangeSentEvent-in-Produce-but-is-in-ProducerTemplate-tp5830067.html",davsclaus,Improvement,Major,Resolved,"Using @Produce as proxy for sending to endpoint does not emit sending/sent events Reported on user forum
http://camel.465427.n5.nabble.com/No-ExchangeSentEvent-in-Produce-but-is-in-ProducerTemplate-tp5830067.html"
CAMEL-13194,camel3 - Karaf commands should use org.apache.camel as group id,"So everything we do in Apache Camel is always org.apache.camel

    <dependency>
      <groupId>org.apache.camel.karaf</groupId>
      <artifactId>camel-karaf-commands</artifactId>
    </dependency>

Should be

    <dependency>
      <groupId>org.apache.camel</groupId>
      <artifactId>camel-karaf-commands</artifactId>
    </dependency>",davsclaus,Task,Major,Resolved,"camel3 - Karaf commands should use org.apache.camel as group id So everything we do in Apache Camel is always org.apache.camel

    <dependency>
      <groupId>org.apache.camel.karaf</groupId>
      <artifactId>camel-karaf-commands</artifactId>
    </dependency>

Should be

    <dependency>
      <groupId>org.apache.camel</groupId>
      <artifactId>camel-karaf-commands</artifactId>
    </dependency>"
CAMEL-13193,camel3 - Remove deprecate jolokia commands,Just noticed it was there when I built locally.,davsclaus,Task,Major,Resolved,camel3 - Remove deprecate jolokia commands Just noticed it was there when I built locally.
CAMEL-13189,camel-catalog - Should be built after all Camel components,It should be built after all the camel components so it includes all the metadata of all components. Currently Maven builds it too early.,davsclaus,Task,Blocker,Resolved,camel-catalog - Should be built after all Camel components It should be built after all the camel components so it includes all the metadata of all components. Currently Maven builds it too early.
CAMEL-13178,Rename terser language to hl7terser,"The language terser is not well know, and its confusing what it does. I think we should rename it to hl7terser to indicate its about hl7.



",davsclaus,Improvement,Major,Resolved,"Rename terser language to hl7terser The language terser is not well know, and its confusing what it does. I think we should rename it to hl7terser to indicate its about hl7.



"
CAMEL-13176,camel yammer component is accessing non-existent page,When using camel-yammer component to receive relationships the component is (most likely) trying to access [non-existent page|https://www.yammer.com/api/v1/] and results in returning null.,davsclaus,Bug,Major,Resolved,camel yammer component is accessing non-existent page When using camel-yammer component to receive relationships the component is (most likely) trying to access [non-existent page|https://www.yammer.com/api/v1/] and results in returning null.
CAMEL-13175,Consider removing useOriginalMessage functionality,"This feature is a bit more complex and its intention/design was to in case of an error during routing, you could say, that the original incoming message should be restored as-is and used as ""result"", for example in case you want to move that message to some dead letter queue or log it etc.

However people may mis-understand this, and think you can mix the original message BODY only and enrich it with any existing headers at the time of error - but that was not how it was designed/intended.

However a few EIPs and if you turned on shared unit of work, you could end up with situations where it would mix the original message with the message of error.

If the user wants to mix both the original message with the message at the error, then they should use a bean/processor/aggregation strategy etc to ""merge"" the data together as they want. NOT rely on just saying useOriginalMessage and ""hope for the best"". 

Also the original message body, can when you transfer messages over Camel endpoints be stored at new endpoints such as JMS, direct-vm etc whom creates a new exchange. And if you use direct, and other internals it would not. So it can be a bit unclear where such original message would origin from.

Instead we should let the user use the Claim Check EIP pattern where you can explict set safe points with the original message, and easily merge data back agains, such as the message body only etc.

See for example
https://github.com/apache/camel/blob/camel-2.x/camel-core/src/test/java/org/apache/camel/issues/MulticastMixOriginalMessageBodyAndEnrichedHeadersTest.java

VS
https://github.com/apache/camel/blob/camel-2.x/camel-core/src/test/java/org/apache/camel/issues/MulticastMixOriginalMessageBodyAndEnrichedHeadersClaimCheckTest.java",davsclaus,Improvement,Major,Resolved,"Consider removing useOriginalMessage functionality This feature is a bit more complex and its intention/design was to in case of an error during routing, you could say, that the original incoming message should be restored as-is and used as ""result"", for example in case you want to move that message to some dead letter queue or log it etc.

However people may mis-understand this, and think you can mix the original message BODY only and enrich it with any existing headers at the time of error - but that was not how it was designed/intended.

However a few EIPs and if you turned on shared unit of work, you could end up with situations where it would mix the original message with the message of error.

If the user wants to mix both the original message with the message at the error, then they should use a bean/processor/aggregation strategy etc to ""merge"" the data together as they want. NOT rely on just saying useOriginalMessage and ""hope for the best"". 

Also the original message body, can when you transfer messages over Camel endpoints be stored at new endpoints such as JMS, direct-vm etc whom creates a new exchange. And if you use direct, and other internals it would not. So it can be a bit unclear where such original message would origin from.

Instead we should let the user use the Claim Check EIP pattern where you can explict set safe points with the original message, and easily merge data back agains, such as the message body only etc.

See for example
https://github.com/apache/camel/blob/camel-2.x/camel-core/src/test/java/org/apache/camel/issues/MulticastMixOriginalMessageBodyAndEnrichedHeadersTest.java

VS
https://github.com/apache/camel/blob/camel-2.x/camel-core/src/test/java/org/apache/camel/issues/MulticastMixOriginalMessageBodyAndEnrichedHeadersClaimCheckTest.java"
CAMEL-13174,[consumer.]bridgeErrorHandler doesn't handle exception thrown by startingDirectoryMustExist,"Following [StackOverflow: _File component's \[consumer.\]bridgeErrorHandler in conjunction with startingDirectoryMustExist_ |https://stackoverflow.com/questions/54513101/file-components-consumer-bridgeerrorhandler-in-conjunction-with-startingdirec] I created the following test class:
{code:java}
package test;

import org.apache.camel.LoggingLevel;
import org.apache.camel.builder.RouteBuilder;
import org.apache.camel.main.Main;
import org.junit.After;
import org.junit.Before;
import org.junit.Test;

public class CamelBridgeErrorHandlerTest {

  private Main main;

  @Before
  public void before() {
    main = new Main();
  }

  @Test
  public void bridgeErrorHandler() {
    main.addRouteBuilder(new RouteBuilder() {
      @Override
      public void configure() throws Exception {
        route(this, ""file:not.existing.dir?autoCreate=false&startingDirectoryMustExist=true&bridgeErrorHandler=true"");
      }
    });
  }

  @Test
  public void consumerBridgeErrorHandler() {
    main.addRouteBuilder(new RouteBuilder() {
      @Override
      public void configure() throws Exception {
        route(this, ""file:not.existing.dir?autoCreate=false&startingDirectoryMustExist=true&consumer.bridgeErrorHandler=true"");
      }
    });
  }

  private void route(final RouteBuilder builder, final String consumerURI) {
    builder
        .from(consumerURI)

        // this is never reached
        .onException(Exception.class)
        .handled(true)
        .log(LoggingLevel.ERROR, ""${exception}"")
        .end()

        .log("" ... processing ..."");
  }

  @After
  public void after() throws Exception {
    main.start();
  }
}
{code}
Both test methods throw:
{noformat}
org.apache.camel.FailedToCreateRouteException: Failed to create route routeN:
  Route(routeN)[[From[file:not.existing.dir?autoCreate=false&s...
    because of Starting directory does not exist: not.existing.dir
{noformat}
rather than the exception(s) being handled by the route(s)' {{onException()}}.
----
P.S.: When TRACEing through the log output both test methods show:
{quote}2019-02-08 11:29:36.209 TRACE camel.model.ProcessorDefinitionHelper – There are 6 properties on: From\[file:not.existing.dir?autoCreate=false&startingDirectoryMustExist=true&\{consumer.}bridgeErrorHandler=true\]
{quote}
while there are just 3 of them ({{autoCreate}}, {{startingDirectoryMustExist}}, {{[consumer.]bridgeErrorHandler}}), aren't there? Is this worth another issue?",davsclaus,Improvement,Minor,Resolved,"[consumer.]bridgeErrorHandler doesn't handle exception thrown by startingDirectoryMustExist Following [StackOverflow: _File component's \[consumer.\]bridgeErrorHandler in conjunction with startingDirectoryMustExist_ |https://stackoverflow.com/questions/54513101/file-components-consumer-bridgeerrorhandler-in-conjunction-with-startingdirec] I created the following test class:
{code:java}
package test;

import org.apache.camel.LoggingLevel;
import org.apache.camel.builder.RouteBuilder;
import org.apache.camel.main.Main;
import org.junit.After;
import org.junit.Before;
import org.junit.Test;

public class CamelBridgeErrorHandlerTest {

  private Main main;

  @Before
  public void before() {
    main = new Main();
  }

  @Test
  public void bridgeErrorHandler() {
    main.addRouteBuilder(new RouteBuilder() {
      @Override
      public void configure() throws Exception {
        route(this, ""file:not.existing.dir?autoCreate=false&startingDirectoryMustExist=true&bridgeErrorHandler=true"");
      }
    });
  }

  @Test
  public void consumerBridgeErrorHandler() {
    main.addRouteBuilder(new RouteBuilder() {
      @Override
      public void configure() throws Exception {
        route(this, ""file:not.existing.dir?autoCreate=false&startingDirectoryMustExist=true&consumer.bridgeErrorHandler=true"");
      }
    });
  }

  private void route(final RouteBuilder builder, final String consumerURI) {
    builder
        .from(consumerURI)

        // this is never reached
        .onException(Exception.class)
        .handled(true)
        .log(LoggingLevel.ERROR, ""${exception}"")
        .end()

        .log("" ... processing ..."");
  }

  @After
  public void after() throws Exception {
    main.start();
  }
}
{code}
Both test methods throw:
{noformat}
org.apache.camel.FailedToCreateRouteException: Failed to create route routeN:
  Route(routeN)[[From[file:not.existing.dir?autoCreate=false&s...
    because of Starting directory does not exist: not.existing.dir
{noformat}
rather than the exception(s) being handled by the route(s)' {{onException()}}.
----
P.S.: When TRACEing through the log output both test methods show:
{quote}2019-02-08 11:29:36.209 TRACE camel.model.ProcessorDefinitionHelper - There are 6 properties on: From\[file:not.existing.dir?autoCreate=false&startingDirectoryMustExist=true&\{consumer.}bridgeErrorHandler=true\]
{quote}
while there are just 3 of them ({{autoCreate}}, {{startingDirectoryMustExist}}, {{[consumer.]bridgeErrorHandler}}), aren't there? Is this worth another issue?"
CAMEL-13171,camel-restdsl-swagger xml generation can't find required method allowableValues(String),"Reported on SO
https://stackoverflow.com/questions/54405868/camel-restdsl-swagger-xml-generation-cant-find-required-method-allowablevalues?noredirect=1#comment95906957_54405868

Look at the provided sample project on github and see if we can reproduce the issue and find out whats the issue is",davsclaus,Bug,Minor,Resolved,"camel-restdsl-swagger xml generation can't find required method allowableValues(String) Reported on SO
https://stackoverflow.com/questions/54405868/camel-restdsl-swagger-xml-generation-cant-find-required-method-allowablevalues?noredirect=1#comment95906957_54405868

Look at the provided sample project on github and see if we can reproduce the issue and find out whats the issue is"
CAMEL-13164,camel3 - Remove includeRoutes on RouteBuilder,"This functionality was not really in use, and was not fully implemented. And there was no similar feature for using other DSLs such as XML.

Its deprecated in 2.x and removed in 3",davsclaus,Improvement,Major,Resolved,"camel3 - Remove includeRoutes on RouteBuilder This functionality was not really in use, and was not fully implemented. And there was no similar feature for using other DSLs such as XML.

Its deprecated in 2.x and removed in 3"
CAMEL-13160,Remove headers should be case in-sensitive by default,"The PatternHelper.matchPattern is case sensitive when matching with wildcard and regexp. For exact match then header keys are by default case insensitive so remove foo will remove FOO Foo and foo headers. But remove pattern=foo* will only remove lower-case foo headers. So we should make this case insensitive for all kinds of patterns (exact, wildcard and regexp).",davsclaus,Improvement,Major,Resolved,"Remove headers should be case in-sensitive by default The PatternHelper.matchPattern is case sensitive when matching with wildcard and regexp. For exact match then header keys are by default case insensitive so remove foo will remove FOO Foo and foo headers. But remove pattern=foo* will only remove lower-case foo headers. So we should make this case insensitive for all kinds of patterns (exact, wildcard and regexp)."
CAMEL-13158,"Unable to invoke beans starting with the string ""header"" using toD"," 

I found one strange behavior when I added below to my route:

 
{code:java}
from(...)
    .toD(""headerEnricher""){code}
 

After some debugging with below unit test, I was able to find the culprit as this line which is interpreting ""headerEnricher"" as if it is equivalent to ""header.Enricher"" or ""header[Enricher]""

[https://github.com/apache/camel/blob/camel-2.23.x/camel-core/src/main/java/org/apache/camel/language/simple/ast/SimpleFunctionExpression.java#L352] 

 
{code:java}

@Test
public void testSimpleHeaderString() {
final Language lan = new DefaultCamelContext().resolveLanguage(""simple"");
final Expression exp = lan.createExpression(""hederEnricher"");

//Pass
Assert.assertEquals(exp.toString(), ""hederEnricher"");

final Expression exp2 = lan.createExpression(""headerEnricher"");

//Fail
Assert.assertEquals(exp2.toString(), ""headerEnricher"");
}
{code}
 

My thought is that the legacy syntax should not try to parse the header expression unless it is followed by some kind of valid operator character like . or ? or [

 

 ",davsclaus,Improvement,Minor,Resolved,"Unable to invoke beans starting with the string ""header"" using toD  

I found one strange behavior when I added below to my route:

 
{code:java}
from(...)
    .toD(""headerEnricher""){code}
 

After some debugging with below unit test, I was able to find the culprit as this line which is interpreting ""headerEnricher"" as if it is equivalent to ""header.Enricher"" or ""header[Enricher]""

[https://github.com/apache/camel/blob/camel-2.23.x/camel-core/src/main/java/org/apache/camel/language/simple/ast/SimpleFunctionExpression.java#L352] 

 
{code:java}

@Test
public void testSimpleHeaderString() {
final Language lan = new DefaultCamelContext().resolveLanguage(""simple"");
final Expression exp = lan.createExpression(""hederEnricher"");

//Pass
Assert.assertEquals(exp.toString(), ""hederEnricher"");

final Expression exp2 = lan.createExpression(""headerEnricher"");

//Fail
Assert.assertEquals(exp2.toString(), ""headerEnricher"");
}
{code}
 

My thought is that the legacy syntax should not try to parse the header expression unless it is followed by some kind of valid operator character like . or ? or [

 

 "
CAMEL-13154,camel-example-spring-boot-master running error,"When running the spring-boot-master, as we use the spring-boot-web-starter by default,  I get the port is ready bound error when I start another instance.

As the example doesn't use the web server anymore, the fix could we just remove the spring-boot-web-starter. 
",njiang,Bug,Minor,Resolved,"camel-example-spring-boot-master running error When running the spring-boot-master, as we use the spring-boot-web-starter by default,  I get the port is ready bound error when I start another instance.

As the example doesn't use the web server anymore, the fix could we just remove the spring-boot-web-starter. 
"
CAMEL-13151,Removed deprecated stuff from simple language,"Related to CAMEL-13150. Where property on the date command is deprecated. We should remove that, and also look at other things that has been deprecated in the simple language in 2.x.",davsclaus,Task,Minor,Resolved,"Removed deprecated stuff from simple language Related to CAMEL-13150. Where property on the date command is deprecated. We should remove that, and also look at other things that has been deprecated in the simple language in 2.x."
CAMEL-13150,"Add command ""exchangeProperty"" for dateExpression in ExpressionBuilder","Method ""_dateExpression_"" in _ExpressionBuilder.java_ is not taking care about new accessor of ""_exchangeProperty_"". Command ""_property_"" is *deprecated* since 2.15

+working+ : simple(""_${date:property.CamelCreatedTimestamp:yyyy-MM-dd}_"") 

+not-working+ : simple(""_${date:exchangeProperty.CamelCreatedTimestamp:yyyy-MM-dd}_"") ",davsclaus,Improvement,Minor,Resolved,"Add command ""exchangeProperty"" for dateExpression in ExpressionBuilder Method ""_dateExpression_"" in _ExpressionBuilder.java_ is not taking care about new accessor of ""_exchangeProperty_"". Command ""_property_"" is *deprecated* since 2.15

+working+ : simple(""_${date:property.CamelCreatedTimestamp:yyyy-MM-dd}_"") 

+not-working+ : simple(""_${date:exchangeProperty.CamelCreatedTimestamp:yyyy-MM-dd}_"") "
CAMEL-13144,Move bean component out of camel-core,"This component is a bit more challenging as bean component is also used for method call language and has support for using language annotations. For example also for @XPath etc.
",davsclaus,Task,Major,Resolved,"Move bean component out of camel-core This component is a bit more challenging as bean component is also used for method call language and has support for using language annotations. For example also for @XPath etc.
"
CAMEL-13142,Camel may package artifacts from different version,"When switching from one branch to another there is a (likely) possibility that component directories that existed in a previous checkout branch are no longer available in the current checkout branch. However, `camel-foo/target` with all the previously generated artifacts is still on the file system and cannot be detected by `git status` either. Neither will these stale target directories be removed by `mvn clean`.

The camel packager plugin seems to be walking the camel directory structure and will package everything it finds. As a result the camel-2.23.2-SNAPSHOT catalog may contain a catalog entry that points to camel-browse-3.0.0-SNAPSHOT.

As a workaround, I suggest to do something like this 

{code}
find . -type d -name target | xargs rm -rf
{code}

before doing a clean mvn build.

As a possible solution, it may be necessary for the thing that walks the directory structure to require at least one file that is maintained in SCM (e.g. pom.xml)",davsclaus,Task,Minor,Resolved,"Camel may package artifacts from different version When switching from one branch to another there is a (likely) possibility that component directories that existed in a previous checkout branch are no longer available in the current checkout branch. However, `camel-foo/target` with all the previously generated artifacts is still on the file system and cannot be detected by `git status` either. Neither will these stale target directories be removed by `mvn clean`.

The camel packager plugin seems to be walking the camel directory structure and will package everything it finds. As a result the camel-2.23.2-SNAPSHOT catalog may contain a catalog entry that points to camel-browse-3.0.0-SNAPSHOT.

As a workaround, I suggest to do something like this 

{code}
find . -type d -name target | xargs rm -rf
{code}

before doing a clean mvn build.

As a possible solution, it may be necessary for the thing that walks the directory structure to require at least one file that is maintained in SCM (e.g. pom.xml)"
CAMEL-13141,camel-api - Add API for advising routes,"We should likely add a nicer API for testing camel routes with the adviceWith functionality. Today you have to use a RouteReifier from camel-core. We should make a new API in camel-api and make it with a nicer name so its easier to understand and use.

{code}
        RouteReifier.adviceWith(context.getRouteDefinitions().get(0), context, new RouteBuilder() {
            @Override
            public void configure() throws Exception {
                // intercept sending to mock:foo and do something else
                interceptSendToEndpoint(""mock:foo"")
                        .skipSendToOriginalEndpoint()
                        .to(""log:foo"")
                        .to(""mock:advised"");
            }
        });
{code}
",davsclaus,New Feature,Major,Resolved,"camel-api - Add API for advising routes We should likely add a nicer API for testing camel routes with the adviceWith functionality. Today you have to use a RouteReifier from camel-core. We should make a new API in camel-api and make it with a nicer name so its easier to understand and use.

{code}
        RouteReifier.adviceWith(context.getRouteDefinitions().get(0), context, new RouteBuilder() {
            @Override
            public void configure() throws Exception {
                // intercept sending to mock:foo and do something else
                interceptSendToEndpoint(""mock:foo"")
                        .skipSendToOriginalEndpoint()
                        .to(""log:foo"")
                        .to(""mock:advised"");
            }
        });
{code}
"
CAMEL-13140,camel-kafka - consumer does not respect auto.commit.interval.ms with AutoCommitEnabled=true,"This is probably a side effect of CAMEL-12454: when auto commit enabled is enabled kafka consumer commits offsets as soon as an exchange is complete with no regard to the auto.commit.interval.ms setting, which may cause additional non-balanced load on the kafka cluster (see attached screenshot depicting kafka brokers cpu load right after upgrade from 2.20.3 to 2.23.0).

Here is an example with debugging turned on for org.apache.camel.component.kafka.KafkaConsumer, as you can see Kafka consumer commits every 10-500 ms instead of once per 5 seconds:
{code:java}
2019-01-28 10:46:55.025  INFO 3324 --- [ontext_Worker-3] o.a.k.clients.consumer.ConsumerConfig    : ConsumerConfig values: 
	auto.commit.interval.ms = 5000
	auto.offset.reset = latest
	bootstrap.servers = [192.168.56.10:9093]
	check.crcs = true
	client.id = 
	connections.max.idle.ms = 540000
	enable.auto.commit = true
	exclude.internal.topics = true
	fetch.max.bytes = 52428800
	fetch.max.wait.ms = 500
	fetch.min.bytes = 1
	group.id = service_new
	heartbeat.interval.ms = 3000
	interceptor.classes = null
	internal.leave.group.on.close = true
	isolation.level = read_uncommitted
	key.deserializer = class org.apache.kafka.common.serialization.StringDeserializer
	max.partition.fetch.bytes = 1048576
	max.poll.interval.ms = 300000
	max.poll.records = 1000
	metadata.max.age.ms = 300000
	metric.reporters = []
	metrics.num.samples = 2
	metrics.recording.level = INFO
	metrics.sample.window.ms = 30000
	partition.assignment.strategy = [org.apache.kafka.clients.consumer.RangeAssignor]
	receive.buffer.bytes = 65536
	reconnect.backoff.max.ms = 1000
	reconnect.backoff.ms = 50
	request.timeout.ms = 40000
	retry.backoff.ms = 100
	sasl.jaas.config = null
	sasl.kerberos.kinit.cmd = /usr/bin/kinit
	sasl.kerberos.min.time.before.relogin = 60000
	sasl.kerberos.service.name = null
	sasl.kerberos.ticket.renew.jitter = 0.05
	sasl.kerberos.ticket.renew.window.factor = 0.8
	sasl.mechanism = GSSAPI
	security.protocol = SSL
	send.buffer.bytes = 131072
	session.timeout.ms = 30000
	ssl.cipher.suites = null
	ssl.enabled.protocols = [TLSv1.2]
	ssl.endpoint.identification.algorithm = null
	ssl.key.password = null
	ssl.keymanager.algorithm = SunX509
	ssl.keystore.location = /usr/files/server.jks
	ssl.keystore.password = [hidden]
	ssl.keystore.type = JCEKS
	ssl.protocol = TLS
	ssl.provider = null
	ssl.secure.random.implementation = null
	ssl.trustmanager.algorithm = PKIX
	ssl.truststore.location = /usr/files/truststore.jks
	ssl.truststore.password = [hidden]
	ssl.truststore.type = JCEKS
	value.deserializer = class org.apache.kafka.common.serialization.StringDeserializer

2019-01-28 10:46:55.160  INFO 3324 --- [ontext_Worker-3] o.a.kafka.common.utils.AppInfoParser     : Kafka version : 1.0.2
2019-01-28 10:46:55.160  INFO 3324 --- [ontext_Worker-3] o.a.kafka.common.utils.AppInfoParser     : Kafka commitId : 2a121f7b1d402825
2019-01-28 10:46:55.160  INFO 3324 --- [ontext_Worker-3] o.a.camel.spring.SpringCamelContext      : Route: route1 started and consuming from: kafka:topic1,topic2,topic3?brokers=192.168.56.10:9093
2019-01-28 10:46:55.161  INFO 3324 --- [uponassignment]] o.a.camel.component.kafka.KafkaConsumer  : Subscribing topic1,topic2,topic3-Thread 0 to topic topic1,topic2,topic3
2019-01-28 10:46:55.161  INFO 3324 --- [uponassignment]] o.a.camel.component.kafka.KafkaConsumer  : Subscribing topic1,topic2,topic3-Thread 0 to topic topic1,topic2,topic3
2019-01-28 10:46:55.313  INFO 3324 --- [uponassignment]] o.a.k.c.c.internals.AbstractCoordinator  : [Consumer clientId=consumer-1, groupId=service_new] Discovered group coordinator 192.168.56.10:9093 (id: 2147483646 rack: null)
2019-01-28 10:46:55.315  INFO 3324 --- [uponassignment]] o.a.k.c.c.internals.ConsumerCoordinator  : [Consumer clientId=consumer-1, groupId=service_new] Revoking previously assigned partitions []
2019-01-28 10:46:55.316  INFO 3324 --- [uponassignment]] o.a.k.c.c.internals.AbstractCoordinator  : [Consumer clientId=consumer-1, groupId=service_new] (Re-)joining group
2019-01-28 10:46:58.469  INFO 3324 --- [uponassignment]] o.a.k.c.c.internals.AbstractCoordinator  : [Consumer clientId=consumer-1, groupId=service_new] Successfully joined group with generation 3
2019-01-28 10:46:58.470  INFO 3324 --- [uponassignment]] o.a.k.c.c.internals.ConsumerCoordinator  : [Consumer clientId=consumer-1, groupId=service_new] Setting newly assigned partitions [topic3-1, topic3-0, topic2-1, topic1-0, topic2-0, topic1-1]
2019-01-28 10:47:24.953 DEBUG 3324 --- [uponassignment]] o.a.camel.component.kafka.KafkaConsumer  : Auto commitSync topic1,topic2,topic3-Thread 0 from topic topic1,topic2,topic3 with offset: 3221
2019-01-28 10:47:24.953 DEBUG 3324 --- [uponassignment]] o.a.camel.component.kafka.KafkaConsumer  : Auto commitSync topic1,topic2,topic3-Thread 0 from topic topic1,topic2,topic3 with offset: 3221
2019-01-28 10:47:24.957 DEBUG 3324 --- [uponassignment]] o.a.camel.component.kafka.KafkaConsumer  : Auto commitSync topic1,topic2,topic3-Thread 0 from topic topic1,topic2,topic3 with offset: 3222
2019-01-28 10:47:24.957 DEBUG 3324 --- [uponassignment]] o.a.camel.component.kafka.KafkaConsumer  : Auto commitSync topic1,topic2,topic3-Thread 0 from topic topic1,topic2,topic3 with offset: 3222
2019-01-28 10:47:24.964 DEBUG 3324 --- [uponassignment]] o.a.camel.component.kafka.KafkaConsumer  : Auto commitSync topic1,topic2,topic3-Thread 0 from topic topic1,topic2,topic3 with offset: 3325
2019-01-28 10:47:24.964 DEBUG 3324 --- [uponassignment]] o.a.camel.component.kafka.KafkaConsumer  : Auto commitSync topic1,topic2,topic3-Thread 0 from topic topic1,topic2,topic3 with offset: 3325
2019-01-28 10:47:25.005 DEBUG 3324 --- [uponassignment]] o.a.camel.component.kafka.KafkaConsumer  : Auto commitSync topic1,topic2,topic3-Thread 0 from topic topic1,topic2,topic3 with offset: 3223
2019-01-28 10:47:25.005 DEBUG 3324 --- [uponassignment]] o.a.camel.component.kafka.KafkaConsumer  : Auto commitSync topic1,topic2,topic3-Thread 0 from topic topic1,topic2,topic3 with offset: 3223
2019-01-28 10:47:25.515 DEBUG 3324 --- [uponassignment]] o.a.camel.component.kafka.KafkaConsumer  : Auto commitSync topic1,topic2,topic3-Thread 0 from topic topic1,topic2,topic3 with offset: 3326
2019-01-28 10:47:25.515 DEBUG 3324 --- [uponassignment]] o.a.camel.component.kafka.KafkaConsumer  : Auto commitSync topic1,topic2,topic3-Thread 0 from topic topic1,topic2,topic3 with offset: 3326
2019-01-28 10:47:26.005 DEBUG 3324 --- [uponassignment]] o.a.camel.component.kafka.KafkaConsumer  : Auto commitSync topic1,topic2,topic3-Thread 0 from topic topic1,topic2,topic3 with offset: 3224
2019-01-28 10:47:26.005 DEBUG 3324 --- [uponassignment]] o.a.camel.component.kafka.KafkaConsumer  : Auto commitSync topic1,topic2,topic3-Thread 0 from topic topic1,topic2,topic3 with offset: 3224
2019-01-28 10:47:26.528 DEBUG 3324 --- [uponassignment]] o.a.camel.component.kafka.KafkaConsumer  : Auto commitSync topic1,topic2,topic3-Thread 0 from topic topic1,topic2,topic3 with offset: 3327
2019-01-28 10:47:26.528 DEBUG 3324 --- [uponassignment]] o.a.camel.component.kafka.KafkaConsumer  : Auto commitSync topic1,topic2,topic3-Thread 0 from topic topic1,topic2,topic3 with offset: 3327
2019-01-28 10:47:27.014 DEBUG 3324 --- [uponassignment]] o.a.camel.component.kafka.KafkaConsumer  : Auto commitSync topic1,topic2,topic3-Thread 0 from topic topic1,topic2,topic3 with offset: 3225
2019-01-28 10:47:27.014 DEBUG 3324 --- [uponassignment]] o.a.camel.component.kafka.KafkaConsumer  : Auto commitSync topic1,topic2,topic3-Thread 0 from topic topic1,topic2,topic3 with offset: 3225
2019-01-28 10:47:27.512 DEBUG 3324 --- [uponassignment]] o.a.camel.component.kafka.KafkaConsumer  : Auto commitSync topic1,topic2,topic3-Thread 0 from topic topic1,topic2,topic3 with offset: 3328
2019-01-28 10:47:27.512 DEBUG 3324 --- [uponassignment]] o.a.camel.component.kafka.KafkaConsumer  : Auto commitSync topic1,topic2,topic3-Thread 0 from topic topic1,topic2,topic3 with offset: 3328
2019-01-28 10:47:28.001 DEBUG 3324 --- [uponassignment]] o.a.camel.component.kafka.KafkaConsumer  : Auto commitSync topic1,topic2,topic3-Thread 0 from topic topic1,topic2,topic3 with offset: 3226
2019-01-28 10:47:28.001 DEBUG 3324 --- [uponassignment]] o.a.camel.component.kafka.KafkaConsumer  : Auto commitSync topic1,topic2,topic3-Thread 0 from topic topic1,topic2,topic3 with offset: 3226
2019-01-28 10:47:28.497 DEBUG 3324 --- [uponassignment]] o.a.camel.component.kafka.KafkaConsumer  : Auto commitSync topic1,topic2,topic3-Thread 0 from topic topic1,topic2,topic3 with offset: 3329
2019-01-28 10:47:28.497 DEBUG 3324 --- [uponassignment]] o.a.camel.component.kafka.KafkaConsumer  : Auto commitSync topic1,topic2,topic3-Thread 0 from topic topic1,topic2,topic3 with offset: 3329
2019-01-28 10:47:29.024 DEBUG 3324 --- [uponassignment]] o.a.camel.component.kafka.KafkaConsumer  : Auto commitSync topic1,topic2,topic3-Thread 0 from topic topic1,topic2,topic3 with offset: 3330
2019-01-28 10:47:29.024 DEBUG 3324 --- [uponassignment]] o.a.camel.component.kafka.KafkaConsumer  : Auto commitSync topic1,topic2,topic3-Thread 0 from topic topic1,topic2,topic3 with offset: 3330
2019-01-28 10:47:29.521 DEBUG 3324 --- [uponassignment]] o.a.camel.component.kafka.KafkaConsumer  : Auto commitSync topic1,topic2,topic3-Thread 0 from topic topic1,topic2,topic3 with offset: 3227
2019-01-28 10:47:29.521 DEBUG 3324 --- [uponassignment]] o.a.camel.component.kafka.KafkaConsumer  : Auto commitSync topic1,topic2,topic3-Thread 0 from topic topic1,topic2,topic3 with offset: 3227
2019-01-28 10:47:30.012 DEBUG 3324 --- [uponassignment]] o.a.camel.component.kafka.KafkaConsumer  : Auto commitSync topic1,topic2,topic3-Thread 0 from topic topic1,topic2,topic3 with offset: 3228
2019-01-28 10:47:30.012 DEBUG 3324 --- [uponassignment]] o.a.camel.component.kafka.KafkaConsumer  : Auto commitSync topic1,topic2,topic3-Thread 0 from topic topic1,topic2,topic3 with offset: 3228
{code}

When downgraded to camel-kafka 2.20.3 commits are done correctly (once every auto.commit.interval.ms) and there are no messages from o.a.camel.component.kafka.KafkaConsumer in the debug log.
Running with debugger showed that this code actually never gets executed in 2.20.3: https://github.com/apache/camel/blob/2.20.x/components/camel-kafka/src/main/java/org/apache/camel/component/kafka/KafkaConsumer.java#L382 and we seem to rely on the auto-commit feature of the Kafka client itself, not the camel-kafka wrapper.",davsclaus,Bug,Major,Resolved,"camel-kafka - consumer does not respect auto.commit.interval.ms with AutoCommitEnabled=true This is probably a side effect of CAMEL-12454: when auto commit enabled is enabled kafka consumer commits offsets as soon as an exchange is complete with no regard to the auto.commit.interval.ms setting, which may cause additional non-balanced load on the kafka cluster (see attached screenshot depicting kafka brokers cpu load right after upgrade from 2.20.3 to 2.23.0).

Here is an example with debugging turned on for org.apache.camel.component.kafka.KafkaConsumer, as you can see Kafka consumer commits every 10-500 ms instead of once per 5 seconds:
{code:java}
2019-01-28 10:46:55.025  INFO 3324 --- [ontext_Worker-3] o.a.k.clients.consumer.ConsumerConfig    : ConsumerConfig values: 
	auto.commit.interval.ms = 5000
	auto.offset.reset = latest
	bootstrap.servers = [192.168.56.10:9093]
	check.crcs = true
	client.id = 
	connections.max.idle.ms = 540000
	enable.auto.commit = true
	exclude.internal.topics = true
	fetch.max.bytes = 52428800
	fetch.max.wait.ms = 500
	fetch.min.bytes = 1
	group.id = service_new
	heartbeat.interval.ms = 3000
	interceptor.classes = null
	internal.leave.group.on.close = true
	isolation.level = read_uncommitted
	key.deserializer = class org.apache.kafka.common.serialization.StringDeserializer
	max.partition.fetch.bytes = 1048576
	max.poll.interval.ms = 300000
	max.poll.records = 1000
	metadata.max.age.ms = 300000
	metric.reporters = []
	metrics.num.samples = 2
	metrics.recording.level = INFO
	metrics.sample.window.ms = 30000
	partition.assignment.strategy = [org.apache.kafka.clients.consumer.RangeAssignor]
	receive.buffer.bytes = 65536
	reconnect.backoff.max.ms = 1000
	reconnect.backoff.ms = 50
	request.timeout.ms = 40000
	retry.backoff.ms = 100
	sasl.jaas.config = null
	sasl.kerberos.kinit.cmd = /usr/bin/kinit
	sasl.kerberos.min.time.before.relogin = 60000
	sasl.kerberos.service.name = null
	sasl.kerberos.ticket.renew.jitter = 0.05
	sasl.kerberos.ticket.renew.window.factor = 0.8
	sasl.mechanism = GSSAPI
	security.protocol = SSL
	send.buffer.bytes = 131072
	session.timeout.ms = 30000
	ssl.cipher.suites = null
	ssl.enabled.protocols = [TLSv1.2]
	ssl.endpoint.identification.algorithm = null
	ssl.key.password = null
	ssl.keymanager.algorithm = SunX509
	ssl.keystore.location = /usr/files/server.jks
	ssl.keystore.password = [hidden]
	ssl.keystore.type = JCEKS
	ssl.protocol = TLS
	ssl.provider = null
	ssl.secure.random.implementation = null
	ssl.trustmanager.algorithm = PKIX
	ssl.truststore.location = /usr/files/truststore.jks
	ssl.truststore.password = [hidden]
	ssl.truststore.type = JCEKS
	value.deserializer = class org.apache.kafka.common.serialization.StringDeserializer

2019-01-28 10:46:55.160  INFO 3324 --- [ontext_Worker-3] o.a.kafka.common.utils.AppInfoParser     : Kafka version : 1.0.2
2019-01-28 10:46:55.160  INFO 3324 --- [ontext_Worker-3] o.a.kafka.common.utils.AppInfoParser     : Kafka commitId : 2a121f7b1d402825
2019-01-28 10:46:55.160  INFO 3324 --- [ontext_Worker-3] o.a.camel.spring.SpringCamelContext      : Route: route1 started and consuming from: kafka:topic1,topic2,topic3?brokers=192.168.56.10:9093
2019-01-28 10:46:55.161  INFO 3324 --- [uponassignment]] o.a.camel.component.kafka.KafkaConsumer  : Subscribing topic1,topic2,topic3-Thread 0 to topic topic1,topic2,topic3
2019-01-28 10:46:55.161  INFO 3324 --- [uponassignment]] o.a.camel.component.kafka.KafkaConsumer  : Subscribing topic1,topic2,topic3-Thread 0 to topic topic1,topic2,topic3
2019-01-28 10:46:55.313  INFO 3324 --- [uponassignment]] o.a.k.c.c.internals.AbstractCoordinator  : [Consumer clientId=consumer-1, groupId=service_new] Discovered group coordinator 192.168.56.10:9093 (id: 2147483646 rack: null)
2019-01-28 10:46:55.315  INFO 3324 --- [uponassignment]] o.a.k.c.c.internals.ConsumerCoordinator  : [Consumer clientId=consumer-1, groupId=service_new] Revoking previously assigned partitions []
2019-01-28 10:46:55.316  INFO 3324 --- [uponassignment]] o.a.k.c.c.internals.AbstractCoordinator  : [Consumer clientId=consumer-1, groupId=service_new] (Re-)joining group
2019-01-28 10:46:58.469  INFO 3324 --- [uponassignment]] o.a.k.c.c.internals.AbstractCoordinator  : [Consumer clientId=consumer-1, groupId=service_new] Successfully joined group with generation 3
2019-01-28 10:46:58.470  INFO 3324 --- [uponassignment]] o.a.k.c.c.internals.ConsumerCoordinator  : [Consumer clientId=consumer-1, groupId=service_new] Setting newly assigned partitions [topic3-1, topic3-0, topic2-1, topic1-0, topic2-0, topic1-1]
2019-01-28 10:47:24.953 DEBUG 3324 --- [uponassignment]] o.a.camel.component.kafka.KafkaConsumer  : Auto commitSync topic1,topic2,topic3-Thread 0 from topic topic1,topic2,topic3 with offset: 3221
2019-01-28 10:47:24.953 DEBUG 3324 --- [uponassignment]] o.a.camel.component.kafka.KafkaConsumer  : Auto commitSync topic1,topic2,topic3-Thread 0 from topic topic1,topic2,topic3 with offset: 3221
2019-01-28 10:47:24.957 DEBUG 3324 --- [uponassignment]] o.a.camel.component.kafka.KafkaConsumer  : Auto commitSync topic1,topic2,topic3-Thread 0 from topic topic1,topic2,topic3 with offset: 3222
2019-01-28 10:47:24.957 DEBUG 3324 --- [uponassignment]] o.a.camel.component.kafka.KafkaConsumer  : Auto commitSync topic1,topic2,topic3-Thread 0 from topic topic1,topic2,topic3 with offset: 3222
2019-01-28 10:47:24.964 DEBUG 3324 --- [uponassignment]] o.a.camel.component.kafka.KafkaConsumer  : Auto commitSync topic1,topic2,topic3-Thread 0 from topic topic1,topic2,topic3 with offset: 3325
2019-01-28 10:47:24.964 DEBUG 3324 --- [uponassignment]] o.a.camel.component.kafka.KafkaConsumer  : Auto commitSync topic1,topic2,topic3-Thread 0 from topic topic1,topic2,topic3 with offset: 3325
2019-01-28 10:47:25.005 DEBUG 3324 --- [uponassignment]] o.a.camel.component.kafka.KafkaConsumer  : Auto commitSync topic1,topic2,topic3-Thread 0 from topic topic1,topic2,topic3 with offset: 3223
2019-01-28 10:47:25.005 DEBUG 3324 --- [uponassignment]] o.a.camel.component.kafka.KafkaConsumer  : Auto commitSync topic1,topic2,topic3-Thread 0 from topic topic1,topic2,topic3 with offset: 3223
2019-01-28 10:47:25.515 DEBUG 3324 --- [uponassignment]] o.a.camel.component.kafka.KafkaConsumer  : Auto commitSync topic1,topic2,topic3-Thread 0 from topic topic1,topic2,topic3 with offset: 3326
2019-01-28 10:47:25.515 DEBUG 3324 --- [uponassignment]] o.a.camel.component.kafka.KafkaConsumer  : Auto commitSync topic1,topic2,topic3-Thread 0 from topic topic1,topic2,topic3 with offset: 3326
2019-01-28 10:47:26.005 DEBUG 3324 --- [uponassignment]] o.a.camel.component.kafka.KafkaConsumer  : Auto commitSync topic1,topic2,topic3-Thread 0 from topic topic1,topic2,topic3 with offset: 3224
2019-01-28 10:47:26.005 DEBUG 3324 --- [uponassignment]] o.a.camel.component.kafka.KafkaConsumer  : Auto commitSync topic1,topic2,topic3-Thread 0 from topic topic1,topic2,topic3 with offset: 3224
2019-01-28 10:47:26.528 DEBUG 3324 --- [uponassignment]] o.a.camel.component.kafka.KafkaConsumer  : Auto commitSync topic1,topic2,topic3-Thread 0 from topic topic1,topic2,topic3 with offset: 3327
2019-01-28 10:47:26.528 DEBUG 3324 --- [uponassignment]] o.a.camel.component.kafka.KafkaConsumer  : Auto commitSync topic1,topic2,topic3-Thread 0 from topic topic1,topic2,topic3 with offset: 3327
2019-01-28 10:47:27.014 DEBUG 3324 --- [uponassignment]] o.a.camel.component.kafka.KafkaConsumer  : Auto commitSync topic1,topic2,topic3-Thread 0 from topic topic1,topic2,topic3 with offset: 3225
2019-01-28 10:47:27.014 DEBUG 3324 --- [uponassignment]] o.a.camel.component.kafka.KafkaConsumer  : Auto commitSync topic1,topic2,topic3-Thread 0 from topic topic1,topic2,topic3 with offset: 3225
2019-01-28 10:47:27.512 DEBUG 3324 --- [uponassignment]] o.a.camel.component.kafka.KafkaConsumer  : Auto commitSync topic1,topic2,topic3-Thread 0 from topic topic1,topic2,topic3 with offset: 3328
2019-01-28 10:47:27.512 DEBUG 3324 --- [uponassignment]] o.a.camel.component.kafka.KafkaConsumer  : Auto commitSync topic1,topic2,topic3-Thread 0 from topic topic1,topic2,topic3 with offset: 3328
2019-01-28 10:47:28.001 DEBUG 3324 --- [uponassignment]] o.a.camel.component.kafka.KafkaConsumer  : Auto commitSync topic1,topic2,topic3-Thread 0 from topic topic1,topic2,topic3 with offset: 3226
2019-01-28 10:47:28.001 DEBUG 3324 --- [uponassignment]] o.a.camel.component.kafka.KafkaConsumer  : Auto commitSync topic1,topic2,topic3-Thread 0 from topic topic1,topic2,topic3 with offset: 3226
2019-01-28 10:47:28.497 DEBUG 3324 --- [uponassignment]] o.a.camel.component.kafka.KafkaConsumer  : Auto commitSync topic1,topic2,topic3-Thread 0 from topic topic1,topic2,topic3 with offset: 3329
2019-01-28 10:47:28.497 DEBUG 3324 --- [uponassignment]] o.a.camel.component.kafka.KafkaConsumer  : Auto commitSync topic1,topic2,topic3-Thread 0 from topic topic1,topic2,topic3 with offset: 3329
2019-01-28 10:47:29.024 DEBUG 3324 --- [uponassignment]] o.a.camel.component.kafka.KafkaConsumer  : Auto commitSync topic1,topic2,topic3-Thread 0 from topic topic1,topic2,topic3 with offset: 3330
2019-01-28 10:47:29.024 DEBUG 3324 --- [uponassignment]] o.a.camel.component.kafka.KafkaConsumer  : Auto commitSync topic1,topic2,topic3-Thread 0 from topic topic1,topic2,topic3 with offset: 3330
2019-01-28 10:47:29.521 DEBUG 3324 --- [uponassignment]] o.a.camel.component.kafka.KafkaConsumer  : Auto commitSync topic1,topic2,topic3-Thread 0 from topic topic1,topic2,topic3 with offset: 3227
2019-01-28 10:47:29.521 DEBUG 3324 --- [uponassignment]] o.a.camel.component.kafka.KafkaConsumer  : Auto commitSync topic1,topic2,topic3-Thread 0 from topic topic1,topic2,topic3 with offset: 3227
2019-01-28 10:47:30.012 DEBUG 3324 --- [uponassignment]] o.a.camel.component.kafka.KafkaConsumer  : Auto commitSync topic1,topic2,topic3-Thread 0 from topic topic1,topic2,topic3 with offset: 3228
2019-01-28 10:47:30.012 DEBUG 3324 --- [uponassignment]] o.a.camel.component.kafka.KafkaConsumer  : Auto commitSync topic1,topic2,topic3-Thread 0 from topic topic1,topic2,topic3 with offset: 3228
{code}

When downgraded to camel-kafka 2.20.3 commits are done correctly (once every auto.commit.interval.ms) and there are no messages from o.a.camel.component.kafka.KafkaConsumer in the debug log.
Running with debugger showed that this code actually never gets executed in 2.20.3: https://github.com/apache/camel/blob/2.20.x/components/camel-kafka/src/main/java/org/apache/camel/component/kafka/KafkaConsumer.java#L382 and we seem to rely on the auto-commit feature of the Kafka client itself, not the camel-kafka wrapper."
CAMEL-13137,Move rest component out of camel-core,"Create a new camel-rest component which has the rest component (needed when using rest-dsl, or using rest component directly etc).

",davsclaus,Task,Major,Resolved,"Move rest component out of camel-core Create a new camel-rest component which has the rest component (needed when using rest-dsl, or using rest component directly etc).

"
CAMEL-13133,camel3 - build system - Packaging dataformat and language needs to include json metadata,"When we just depend on camel-support for custom dataformats and languages then they cant locate camel-core JAR which has model json metadata they need for enriching their json metadata.

The camel-package-maven-plugin needs to find the camel-core JAR in another way now as its not on the classpath in the maven project.",davsclaus,Task,Major,Resolved,"camel3 - build system - Packaging dataformat and language needs to include json metadata When we just depend on camel-support for custom dataformats and languages then they cant locate camel-core JAR which has model json metadata they need for enriching their json metadata.

The camel-package-maven-plugin needs to find the camel-core JAR in another way now as its not on the classpath in the maven project."
CAMEL-13131,Duplicate declaration of maven dependency in examples,"[WARNING]
[WARNING] Some problems were encountered while building the effective model for org.apache.camel.example:camel-example-cdi:jar:3.0.0-SNAPSHOT
[WARNING] 'dependencies.dependency.(groupId:artifactId:type:classifier)' must be unique: org.apache.camel:camel-core:jar -> duplicate declaration of version (?) @ org.apache.camel.example:camel-example-cdi:[unknown-version], /Users/davsclaus/workspace/camel/examples/camel-example-cdi/pom.xml, line 61, column 17
[WARNING]
[WARNING] Some problems were encountered while building the effective model for org.apache.camel.example:camel-example-cdi-cassandraql:jar:3.0.0-SNAPSHOT
[WARNING] 'dependencies.dependency.(groupId:artifactId:type:classifier)' must be unique: org.apache.camel:camel-core:jar -> duplicate declaration of version (?) @ org.apache.camel.example:camel-example-cdi-cassandraql:[unknown-version], /Users/davsclaus/workspace/camel/examples/camel-example-cdi-cassandraql/pom.xml, line 64, column 17
[WARNING]
[WARNING] It is highly recommended to fix these problems because they threaten the stability of your build.
[WARNING]
[WARNING] For this reason, future Maven versions might no longer support building such malformed projects.
[WARNING]
[INFO] --------------------------------------",davsclaus,Task,Minor,Resolved,"Duplicate declaration of maven dependency in examples [WARNING]
[WARNING] Some problems were encountered while building the effective model for org.apache.camel.example:camel-example-cdi:jar:3.0.0-SNAPSHOT
[WARNING] 'dependencies.dependency.(groupId:artifactId:type:classifier)' must be unique: org.apache.camel:camel-core:jar -> duplicate declaration of version (?) @ org.apache.camel.example:camel-example-cdi:[unknown-version], /Users/davsclaus/workspace/camel/examples/camel-example-cdi/pom.xml, line 61, column 17
[WARNING]
[WARNING] Some problems were encountered while building the effective model for org.apache.camel.example:camel-example-cdi-cassandraql:jar:3.0.0-SNAPSHOT
[WARNING] 'dependencies.dependency.(groupId:artifactId:type:classifier)' must be unique: org.apache.camel:camel-core:jar -> duplicate declaration of version (?) @ org.apache.camel.example:camel-example-cdi-cassandraql:[unknown-version], /Users/davsclaus/workspace/camel/examples/camel-example-cdi-cassandraql/pom.xml, line 64, column 17
[WARNING]
[WARNING] It is highly recommended to fix these problems because they threaten the stability of your build.
[WARNING]
[WARNING] For this reason, future Maven versions might no longer support building such malformed projects.
[WARNING]
[INFO] --------------------------------------"
CAMEL-13130,camel3 - Components should not use XmlConverter directly,"There are a few components that uses XmlConverter directly like camel-cxf and camel-spring-ws. We should use XmlConverterHelper from camel-support if possible, or better yet the neutral TypeConverter API from camel-api.",davsclaus,Task,Major,Resolved,"camel3 - Components should not use XmlConverter directly There are a few components that uses XmlConverter directly like camel-cxf and camel-spring-ws. We should use XmlConverterHelper from camel-support if possible, or better yet the neutral TypeConverter API from camel-api."
CAMEL-13126,"For Swagger, add an option whether to use X-Forward headers","An earlier JIRA: CAMEL-12855 created an issue where the forwarded header could be used to set the ""host"" for Swagger. This overwrote the old behavior where one could specify a ""hard-code"" host in the RestConfiguration.

Add an option to control whether these x-forward headers should be applied or not, to have the old behavior vs the new. (e.g. *useXForwardHeaders* = true/false)

[~cibsen@e-ma.net], a couple of questions:
 # would the default be the new behavior (using the headers), or the old behavior (do not use the headers) ?
 # should the parameter turn on/off the entire X-FORWARD section... that is in [the setupXForwardedHeaders() here|https://github.com/apache/camel/blob/release/2.23.0/components/camel-swagger-java/src/main/java/org/apache/camel/swagger/RestSwaggerSupport.java#L358-L385] ?",davsclaus,Improvement,Major,Resolved,"For Swagger, add an option whether to use X-Forward headers An earlier JIRA: CAMEL-12855 created an issue where the forwarded header could be used to set the ""host"" for Swagger. This overwrote the old behavior where one could specify a ""hard-code"" host in the RestConfiguration.

Add an option to control whether these x-forward headers should be applied or not, to have the old behavior vs the new. (e.g. *useXForwardHeaders* = true/false)

[~cibsen@e-ma.net], a couple of questions:
 # would the default be the new behavior (using the headers), or the old behavior (do not use the headers) ?
 # should the parameter turn on/off the entire X-FORWARD section... that is in [the setupXForwardedHeaders() here|https://github.com/apache/camel/blob/release/2.23.0/components/camel-swagger-java/src/main/java/org/apache/camel/swagger/RestSwaggerSupport.java#L358-L385] ?"
CAMEL-13124,camel3 - move xslt componet out of camel-core,This requires a bit of shared xml code to be moved to camel-support.,davsclaus,Task,Major,Resolved,camel3 - move xslt componet out of camel-core This requires a bit of shared xml code to be moved to camel-support.
CAMEL-13122,Potential bug in BeanExpression/HttpMessage,"I think I found a potential bug when using a bean to set a property if a message is coming through http. I wanted to check here before opening a bug in case I am missing something. It is very similar to the following bug which has already been fixed: [https://stackoverflow.com/questions/40293128/camel-rest-service-throws-exception-when-returning-null/40317432#40317432].

 

The difference is that instead of returning null, an exception is thrown from the bean method. When that happen, I see the same behavior as described in the stackoverflow post above.  I included an example on how to reproduce at the end of this email. Here is what I think happens:

 

Problem starts in BeanExpression:
 1. The exchange is copied, BeanExpression: line 194: Exchange resultExchange = ExchangeHelper.createCopy(exchange, true)
 2. The out body is then retrieved from the exchange, BeanExpression: line 201: result = resultExchange.getOut().getBody();
 3. Since out() is null, the in() message is copied to the out(), this makes a copy of the HttpMessage, which is copied along with the original ServletRequest (which contains a closed stream) DefaultExchange.class line 317.
 4. To copy the message from in to out, the method newInstance() from HttpMessage class is called. HttpMessage line 85
 5. At this point, the new instance of HttpMessage tries to read the stream from the original message which is already closed, IOException.

 

Example just below, I would be expecting the EXCEPTION_CAUGHT to be the RuntimeException I throw but instead it's a RuntimeBeanExpressionException effectively wrapping a IOException.

 
{code:java}
public void configureTestException() {

  restDefinitionV1 = restDefinitionV1

    .get(""/throwException"")

    .route()

     .onException(Exception.class)

       .process(exchange -> {System.out.println(""Caught exception of type: "" + exchange.getProperty(Exchange.EXCEPTION_CAUGHT).getClass());} )

       .handled(true)

     .end()

       .setProperty(""test"").method(new TestBean(), ""throwException"")

     .endRest();

}

               

public static class TestBean {

  public void throwException() {

    throw new RuntimeException(""Excepting this exception to be handled by onException"");

  }

}
{code}
 

I will try to provide an actual unit test shortly.",davsclaus,Bug,Minor,Resolved,"Potential bug in BeanExpression/HttpMessage I think I found a potential bug when using a bean to set a property if a message is coming through http. I wanted to check here before opening a bug in case I am missing something. It is very similar to the following bug which has already been fixed: [https://stackoverflow.com/questions/40293128/camel-rest-service-throws-exception-when-returning-null/40317432#40317432].

 

The difference is that instead of returning null, an exception is thrown from the bean method. When that happen, I see the same behavior as described in the stackoverflow post above.  I included an example on how to reproduce at the end of this email. Here is what I think happens:

 

Problem starts in BeanExpression:
 1. The exchange is copied, BeanExpression: line 194: Exchange resultExchange = ExchangeHelper.createCopy(exchange, true)
 2. The out body is then retrieved from the exchange, BeanExpression: line 201: result = resultExchange.getOut().getBody();
 3. Since out() is null, the in() message is copied to the out(), this makes a copy of the HttpMessage, which is copied along with the original ServletRequest (which contains a closed stream) DefaultExchange.class line 317.
 4. To copy the message from in to out, the method newInstance() from HttpMessage class is called. HttpMessage line 85
 5. At this point, the new instance of HttpMessage tries to read the stream from the original message which is already closed, IOException.

 

Example just below, I would be expecting the EXCEPTION_CAUGHT to be the RuntimeException I throw but instead it's a RuntimeBeanExpressionException effectively wrapping a IOException.

 
{code:java}
public void configureTestException() {

  restDefinitionV1 = restDefinitionV1

    .get(""/throwException"")

    .route()

     .onException(Exception.class)

       .process(exchange -> {System.out.println(""Caught exception of type: "" + exchange.getProperty(Exchange.EXCEPTION_CAUGHT).getClass());} )

       .handled(true)

     .end()

       .setProperty(""test"").method(new TestBean(), ""throwException"")

     .endRest();

}

               

public static class TestBean {

  public void throwException() {

    throw new RuntimeException(""Excepting this exception to be handled by onException"");

  }

}
{code}
 

I will try to provide an actual unit test shortly."
CAMEL-13119,Create Cache Policy for routes,"Let's write a Policy for camel routes that can cache the ""result"" of a route and execute the route next time only if nothing is found in the cache.
 
Related to cache DSL idea, but without DSL change: https://issues.apache.org/jira/browse/CAMEL-11114
 
In the first draft the CachePolicy would cache the Message Body by a key calculated via an Expression.
Interface:
 * cachePolicy.setCacheManager( cacheManager ) - set the CacheManager. If not set, try lookup automatically.

 * cachePolicy.setCacheName ( name ) - Will use this cache from the CacheManager. If not set, we can use the route id by default.
 * cachePolicy.setKeyExpression( expression ) - Camel expression that is evaluated on the Exchange to determine the cache key. If it's found in the cache, the route is not executed and the cached value is set as Body. Otherwise the Message Body is added to the cache after the route with this key.


 
An earlier related implementation: [https://gist.github.com/bszeti/552bf7a1f05a75fc2964a4ce7ce889b5] 
and how it can be used in a route: [https://gist.github.com/bszeti/4f855cd80cd69e3953ff990b0ae056a2]
 
 ",davsclaus,New Feature,Major,Resolved,"Create Cache Policy for routes Let's write a Policy for camel routes that can cache the ""result"" of a route and execute the route next time only if nothing is found in the cache.
 
Related to cache DSL idea, but without DSL change: https://issues.apache.org/jira/browse/CAMEL-11114
 
In the first draft the CachePolicy would cache the Message Body by a key calculated via an Expression.
Interface:
 * cachePolicy.setCacheManager( cacheManager ) - set the CacheManager. If not set, try lookup automatically.

 * cachePolicy.setCacheName ( name ) - Will use this cache from the CacheManager. If not set, we can use the route id by default.
 * cachePolicy.setKeyExpression( expression ) - Camel expression that is evaluated on the Exchange to determine the cache key. If it's found in the cache, the route is not executed and the cached value is set as Body. Otherwise the Message Body is added to the cache after the route with this key.


 
An earlier related implementation: [https://gist.github.com/bszeti/552bf7a1f05a75fc2964a4ce7ce889b5] 
and how it can be used in a route: [https://gist.github.com/bszeti/4f855cd80cd69e3953ff990b0ae056a2]
 
 "
CAMEL-13115,camel3 - build system - camel-catalog should not warn for missing doc for inactive modules,"When we have removed deprecated modules in 3.x, then the folders stay in git when you switch branches.

So we get this WARNs when building camel-catalog
{code}
[WARNING] 	Missing document detected: 40
[WARNING] 		camel-bam
[WARNING] 		camel-cache
[WARNING] 		camel-castor
[WARNING] 		camel-context
[WARNING] 		camel-eclipse
[WARNING] 		camel-elasticsearch
[WARNING] 		camel-elasticsearch5
[WARNING] 		camel-groovy-dsl
[WARNING] 		camel-guice
[WARNING] 		camel-hawtdb
[WARNING] 		camel-hdfs
[WARNING] 		camel-hessian
[WARNING] 		camel-http
[WARNING] 		camel-ibatis
[WARNING] 		camel-javaspace
[WARNING] 		camel-jira
[WARNING] 		camel-josql
[WARNING] 		camel-juel
[WARNING] 		camel-jxpath
[WARNING] 		camel-kestrel
[WARNING] 		camel-krati
[WARNING] 		camel-mina
[WARNING] 		camel-mongodb
[WARNING] 		camel-netty
[WARNING] 		camel-netty-http
[WARNING] 		camel-openshift
[WARNING] 		camel-quartz
[WARNING] 		camel-routebox
[WARNING] 		camel-ruby
[WARNING] 		camel-rx
[WARNING] 		camel-scala
[WARNING] 		camel-scr
[WARNING] 		camel-servletlistener
[WARNING] 		camel-swagger
[WARNING] 		camel-testng
[WARNING] 		camel-urlrewrite
[WARNING] 		camel-xmlbeans
[WARNING] 		camel-xmljson
[WARNING] 		camel-xmlrpc
[WARNING] 		camel-yql
{code}

We should make it detect that these are empty folders (has no pom.xml) and skip them.",davsclaus,Task,Major,Resolved,"camel3 - build system - camel-catalog should not warn for missing doc for inactive modules When we have removed deprecated modules in 3.x, then the folders stay in git when you switch branches.

So we get this WARNs when building camel-catalog
{code}
[WARNING] 	Missing document detected: 40
[WARNING] 		camel-bam
[WARNING] 		camel-cache
[WARNING] 		camel-castor
[WARNING] 		camel-context
[WARNING] 		camel-eclipse
[WARNING] 		camel-elasticsearch
[WARNING] 		camel-elasticsearch5
[WARNING] 		camel-groovy-dsl
[WARNING] 		camel-guice
[WARNING] 		camel-hawtdb
[WARNING] 		camel-hdfs
[WARNING] 		camel-hessian
[WARNING] 		camel-http
[WARNING] 		camel-ibatis
[WARNING] 		camel-javaspace
[WARNING] 		camel-jira
[WARNING] 		camel-josql
[WARNING] 		camel-juel
[WARNING] 		camel-jxpath
[WARNING] 		camel-kestrel
[WARNING] 		camel-krati
[WARNING] 		camel-mina
[WARNING] 		camel-mongodb
[WARNING] 		camel-netty
[WARNING] 		camel-netty-http
[WARNING] 		camel-openshift
[WARNING] 		camel-quartz
[WARNING] 		camel-routebox
[WARNING] 		camel-ruby
[WARNING] 		camel-rx
[WARNING] 		camel-scala
[WARNING] 		camel-scr
[WARNING] 		camel-servletlistener
[WARNING] 		camel-swagger
[WARNING] 		camel-testng
[WARNING] 		camel-urlrewrite
[WARNING] 		camel-xmlbeans
[WARNING] 		camel-xmljson
[WARNING] 		camel-xmlrpc
[WARNING] 		camel-yql
{code}

We should make it detect that these are empty folders (has no pom.xml) and skip them."
CAMEL-13113,Remove camel-script and make camel-javascript,"scripting api/jsr is also deprecated in the jdk and to be removed in the future
we will remove it for camel 3
and deprecate it in 2.x
for camel k and using javascript i think they are doing something custom, and will can make a new camel-javascript language for that purpose solely
all the other scripting languages was also a security vulnerability as well",davsclaus,Task,Major,Resolved,"Remove camel-script and make camel-javascript scripting api/jsr is also deprecated in the jdk and to be removed in the future
we will remove it for camel 3
and deprecate it in 2.x
for camel k and using javascript i think they are doing something custom, and will can make a new camel-javascript language for that purpose solely
all the other scripting languages was also a security vulnerability as well"
CAMEL-13112,Move file component out of camel core,There is some file cluster that uses some abstract cluster stuff which we need to move to camel-support,davsclaus,Task,Major,Resolved,Move file component out of camel core There is some file cluster that uses some abstract cluster stuff which we need to move to camel-support
CAMEL-13108,Move dataset component out of camel-core,"We should likely put mock, dataset and test components in the same JAR as dataset and test extends mock component. So its easier they are in the same JAR.

Also we already have camel-test for junit testing, so the test component would conflict with camel-test.

So if we call it camel-mock JAR then we have a free name to use.",davsclaus,Task,Major,Resolved,"Move dataset component out of camel-core We should likely put mock, dataset and test components in the same JAR as dataset and test extends mock component. So its easier they are in the same JAR.

Also we already have camel-test for junit testing, so the test component would conflict with camel-test.

So if we call it camel-mock JAR then we have a free name to use."
CAMEL-13102,Move camel-dataformat out of camel-core,for dataformat component we need to move MarshalProcessor / UnmarshalProcessor to camel-support first to have it in a public api,davsclaus,Task,Major,Resolved,Move camel-dataformat out of camel-core for dataformat component we need to move MarshalProcessor / UnmarshalProcessor to camel-support first to have it in a public api
CAMEL-13094,Context MBean not unregistered on startup failure,"In Camel-2.23.x a failure to start the context would call ServiceSupport.doStop(). This is no longer the case. Instead, a CamelContextStartupFailureEvent is thrown and services that might previously have been started are never stopped.

As a result or (side effect) the context MBean may remain registered if the startup failure occurred after its initial registration. ",davsclaus,Bug,Major,Resolved,"Context MBean not unregistered on startup failure In Camel-2.23.x a failure to start the context would call ServiceSupport.doStop(). This is no longer the case. Instead, a CamelContextStartupFailureEvent is thrown and services that might previously have been started are never stopped.

As a result or (side effect) the context MBean may remain registered if the startup failure occurred after its initial registration. "
CAMEL-13093,Output of route-profile is empty if there are same route-id for multiple camel-contexts.,"* Unzip the attached reproducer.
 * Build it using 'mvn clean install'.
 * Deploy it in Fuse with command 'bundle:install -s mvn:com.mycompany/camel-blueprint-cbr/1.0.0-SNAPSHOT'.
 * If we execute route-profile command, we find that output is empty or no output.

karaf@root()> route-profile cbr-example-context1 1-route Profile Camel Context: cbr-example-context1 Id Count Last (ms) Delta (ms) Mean (ms) Min (ms) Max (ms) Total (ms) Self (ms) karaf@root()>",davsclaus,Bug,Minor,Resolved,"Output of route-profile is empty if there are same route-id for multiple camel-contexts. * Unzip the attached reproducer.
 * Build it using 'mvn clean install'.
 * Deploy it in Fuse with command 'bundle:install -s mvn:com.mycompany/camel-blueprint-cbr/1.0.0-SNAPSHOT'.
 * If we execute route-profile command, we find that output is empty or no output.

karaf@root()> route-profile cbr-example-context1 1-route Profile Camel Context: cbr-example-context1 Id Count Last (ms) Delta (ms) Mean (ms) Min (ms) Max (ms) Total (ms) Self (ms) karaf@root()>"
CAMEL-13088,build system - Automate list of components in parent and apache-camel poms,"We need to add manually all the camel JARs in the parent/pom and apache-camel poms and the include file as well. 

As we get more and more components and also -starter JARs we should automate this.",davsclaus,Task,Major,Resolved,"build system - Automate list of components in parent and apache-camel poms We need to add manually all the camel JARs in the parent/pom and apache-camel poms and the include file as well. 

As we get more and more components and also -starter JARs we should automate this."
CAMEL-13083,Upgrade to latest Guava version for Swagger dependency,"Guava up to ver 24.1 has a denial of service vulnerability.

Upgrade the camel-swagger dependency on Guava to a newer version.

Would be nice if this could go in the 2.23.x version and above ",davsclaus,Improvement,Minor,Resolved,"Upgrade to latest Guava version for Swagger dependency Guava up to ver 24.1 has a denial of service vulnerability.

Upgrade the camel-swagger dependency on Guava to a newer version.

Would be nice if this could go in the 2.23.x version and above "
CAMEL-13081,doc - pipes and filters should be pipeline-eip,"The tooling report this as a missing EIP doc page.

It should just be renamed to pipeline-eip",davsclaus,Task,Major,Resolved,"doc - pipes and filters should be pipeline-eip The tooling report this as a missing EIP doc page.

It should just be renamed to pipeline-eip"
CAMEL-13075,component docs - Generated description with simple language should include curly brackets,"For example the idempotentKey at
https://github.com/apache/camel/blob/master/camel-core/src/main/docs/file-component.adoc

Should include
{code}
${file:name}-...
{code}
Where the curly brackets are missing.

",davsclaus,Task,Major,Resolved,"component docs - Generated description with simple language should include curly brackets For example the idempotentKey at
https://github.com/apache/camel/blob/master/camel-core/src/main/docs/file-component.adoc

Should include
{code}
${file:name}-...
{code}
Where the curly brackets are missing.

"
CAMEL-13074,FileWatcherReloadStrategy - Use file component instead of JDK FileWatcher,"The FileWatcherReloadStrategy keeps failing on various platforms and CI server.

Lets use Camel's file component instead (to eat our own dog food)",davsclaus,Improvement,Major,Resolved,"FileWatcherReloadStrategy - Use file component instead of JDK FileWatcher The FileWatcherReloadStrategy keeps failing on various platforms and CI server.

Lets use Camel's file component instead (to eat our own dog food)"
CAMEL-13067,camel3 - build system - Component level metadata is missing,"In 2.x we used to have component level metadata but in 3.x they are not there

For example testManagedCamelContextExplainComponentModel fails this test.
",davsclaus,Task,Major,Resolved,"camel3 - build system - Component level metadata is missing In 2.x we used to have component level metadata but in 3.x they are not there

For example testManagedCamelContextExplainComponentModel fails this test.
"
CAMEL-13066,camel-hystrix - Do not fallback on HystrixBadRequestException,"See SO
https://stackoverflow.com/questions/54151657/camel-hystrix-eip-ignoreexceptions-to-prevent-call-to-fallback

And the javadoc at
https://netflix.github.io/Hystrix/javadoc/com/netflix/hystrix/exception/HystrixBadRequestException.html",davsclaus,Improvement,Major,Resolved,"camel-hystrix - Do not fallback on HystrixBadRequestException See SO
https://stackoverflow.com/questions/54151657/camel-hystrix-eip-ignoreexceptions-to-prevent-call-to-fallback

And the javadoc at
https://netflix.github.io/Hystrix/javadoc/com/netflix/hystrix/exception/HystrixBadRequestException.html"
CAMEL-13064,camel-zipfile and camel-tarfile - ZipIterator and TarIterator issue,"There is a little problem with hasNext vs next contract so they dont behave correctly with the EIPs such as splitter with the 3.0 refactored code.
",davsclaus,Task,Major,Resolved,"camel-zipfile and camel-tarfile - ZipIterator and TarIterator issue There is a little problem with hasNext vs next contract so they dont behave correctly with the EIPs such as splitter with the 3.0 refactored code.
"
CAMEL-13055,camel3 - build system - Reduce maven plugins not needed to run,"We can look at reducing some of the maven goals that runs during building components to reduce the burden on maven and speedup the build a bit.

- dont run enforcer plugin
- dont run maven site plugin
- only run osgi plugin on core and components
- skip running integration tests if fastinstall profile enabled on some modules
- ...
",davsclaus,Task,Major,Resolved,"camel3 - build system - Reduce maven plugins not needed to run We can look at reducing some of the maven goals that runs during building components to reduce the burden on maven and speedup the build a bit.

- dont run enforcer plugin
- dont run maven site plugin
- only run osgi plugin on core and components
- skip running integration tests if fastinstall profile enabled on some modules
- ...
"
CAMEL-13053,camel-restdsl-swagger-plugin - Skip running integration tests with -P fastinstall,"When running

mvn clean install -P fastinstall

Then the integration tests are run in this module and they take 40+ sec to run. It would be nice to skip this so the build is quicker in fast install mode

{code}
[INFO] --- maven-invoker-plugin:3.1.0:integration-test (integration-test) @ camel-restdsl-swagger-plugin ---
[INFO] Building: simple-dto/pom.xml
[INFO] run post-build script verify.groovy
[INFO]           simple-dto/pom.xml ............................... SUCCESS (22.3 s)
[INFO] Building: simple-xml-dto/pom.xml
[INFO] run post-build script verify.groovy
[INFO]           simple-xml-dto/pom.xml ........................... SUCCESS (8.5 s)
[INFO] Building: simple-xml/pom.xml
[INFO] run post-build script verify.groovy
[INFO]           simple-xml/pom.xml ............................... SUCCESS (4.8 s)
[INFO] Building: simple/pom.xml
[INFO] run post-build script verify.groovy
[INFO]           simple/pom.xml ................................... SUCCESS (2.9 s)
[INFO] Building: customized/pom.xml
[INFO] run post-build script verify.groovy
[INFO]           customized/pom.xml ............................... SUCCESS (3.3 s)
[INFO]
[INFO] --- maven-invoker-plugin:3.1.0:verify (integration-test) @ camel-restdsl-swagger-plugin ---
[INFO] -------------------------------------------------
[INFO] Build Summary:
[INFO]   Passed: 5, Failed: 0, Errors: 0, Skipped: 0
[INFO] -------------------------------------------------
{code}",davsclaus,Task,Minor,Resolved,"camel-restdsl-swagger-plugin - Skip running integration tests with -P fastinstall When running

mvn clean install -P fastinstall

Then the integration tests are run in this module and they take 40+ sec to run. It would be nice to skip this so the build is quicker in fast install mode

{code}
[INFO] --- maven-invoker-plugin:3.1.0:integration-test (integration-test) @ camel-restdsl-swagger-plugin ---
[INFO] Building: simple-dto/pom.xml
[INFO] run post-build script verify.groovy
[INFO]           simple-dto/pom.xml ............................... SUCCESS (22.3 s)
[INFO] Building: simple-xml-dto/pom.xml
[INFO] run post-build script verify.groovy
[INFO]           simple-xml-dto/pom.xml ........................... SUCCESS (8.5 s)
[INFO] Building: simple-xml/pom.xml
[INFO] run post-build script verify.groovy
[INFO]           simple-xml/pom.xml ............................... SUCCESS (4.8 s)
[INFO] Building: simple/pom.xml
[INFO] run post-build script verify.groovy
[INFO]           simple/pom.xml ................................... SUCCESS (2.9 s)
[INFO] Building: customized/pom.xml
[INFO] run post-build script verify.groovy
[INFO]           customized/pom.xml ............................... SUCCESS (3.3 s)
[INFO]
[INFO] --- maven-invoker-plugin:3.1.0:verify (integration-test) @ camel-restdsl-swagger-plugin ---
[INFO] -------------------------------------------------
[INFO] Build Summary:
[INFO]   Passed: 5, Failed: 0, Errors: 0, Skipped: 0
[INFO] -------------------------------------------------
{code}"
CAMEL-13051,camel3 - build system needs to generate component.properties,"We now generate more of the meta files in the META-INF/services folder. But the JARs from 2.x vs 3.0 is not exactly the same.

The component.properties dataformat.properties language.properties files is currently not being generated.

Some of our tooling depends on that these files are there.

For example the camel-catalog is not correct, try to compare its 2.x JAR vs 3.0 JAR, and you can then find out much more what is wrong currently with the 3.0 branch.",davsclaus,Task,Critical,Resolved,"camel3 - build system needs to generate component.properties We now generate more of the meta files in the META-INF/services folder. But the JARs from 2.x vs 3.0 is not exactly the same.

The component.properties dataformat.properties language.properties files is currently not being generated.

Some of our tooling depends on that these files are there.

For example the camel-catalog is not correct, try to compare its 2.x JAR vs 3.0 JAR, and you can then find out much more what is wrong currently with the 3.0 branch."
CAMEL-13042,camel-core - File producer should by default not allow writing files to directories outside its starting directory,"For example
{code:xml}
<from uri=""file:src/test/resources/data?noop=true""/>
<setHeader headerName=""CamelFileName"">
    <simple>../../${file:name}</simple>
</setHeader>
<to uri=""file:target/results""/>
{code}

Can write the file outside the target/results folder. We should not allow this by default to be more security friendly. 

We should add a new option (maybe name it jailStartingDirectory or allowWriteOutsideStartingDirectory) or some better name

",davsclaus,Improvement,Major,Resolved,"camel-core - File producer should by default not allow writing files to directories outside its starting directory For example
{code:xml}
<from uri=""file:src/test/resources/data?noop=true""/>
<setHeader headerName=""CamelFileName"">
    <simple>../../${file:name}</simple>
</setHeader>
<to uri=""file:target/results""/>
{code}

Can write the file outside the target/results folder. We should not allow this by default to be more security friendly. 

We should add a new option (maybe name it jailStartingDirectory or allowWriteOutsideStartingDirectory) or some better name

"
CAMEL-13036,Add the possibility to disable the invocation of ModelHelper.dumpModelAsXml() during testing,"Add the possibility to disable the invocation of {{ModelHelper.dumpModelAsXml()}}. This is particularly disturbing for Camel contexts with a lot of route definitions as this uses a lot of processing time and the information is only used for log output.

Actual use in 2.x in {{RouteDefinition.java}}:
{code:java|title=RouteDefinition.java}
String beforeAsXml = ModelHelper.dumpModelAsXml(camelContext, this);
...
String afterAsXml = ModelHelper.dumpModelAsXml(camelContext, merged);
log.info(""Adviced route before/after as XML:\n{}\n{}"", beforeAsXml, afterAsXml);
{code}

In 2.X this should be optimized in {{RouteDefinition.java}}, in 3.X in {{RouteReifier.java}}.

Possible solution: Add {{log.isInfoEnabled{}}} guard.

 ",davsclaus,Improvement,Minor,Resolved,"Add the possibility to disable the invocation of ModelHelper.dumpModelAsXml() during testing Add the possibility to disable the invocation of {{ModelHelper.dumpModelAsXml()}}. This is particularly disturbing for Camel contexts with a lot of route definitions as this uses a lot of processing time and the information is only used for log output.

Actual use in 2.x in {{RouteDefinition.java}}:
{code:java|title=RouteDefinition.java}
String beforeAsXml = ModelHelper.dumpModelAsXml(camelContext, this);
...
String afterAsXml = ModelHelper.dumpModelAsXml(camelContext, merged);
log.info(""Adviced route before/after as XML:\n{}\n{}"", beforeAsXml, afterAsXml);
{code}

In 2.X this should be optimized in {{RouteDefinition.java}}, in 3.X in {{RouteReifier.java}}.

Possible solution: Add {{log.isInfoEnabled{}}} guard.

 "
CAMEL-13031,camel-core - test failure: org.apache.camel.impl.FileWatcherReloadStrategyTest.,"[INFO] Running org.apache.camel.impl.FileWatcherReloadStrategyTest
[ERROR] Tests run: 7, Failures: 0, Errors: 6, Skipped: 0, Time elapsed: 123.022 s <<< FAILURE! - in org.apache.camel.impl.FileWatcherReloadStrategyTest
[ERROR] testUpdateXmlRoute(org.apache.camel.impl.FileWatcherReloadStrategyTest) Time elapsed: 20.529 s <<< ERROR!
org.awaitility.core.ConditionTimeoutException: Assertion condition defined as a lambda expression in org.apache.camel.impl.FileWatcherReloadStrategyTest expected:<1> but was:<0> within 20 seconds.
 at org.apache.camel.impl.FileWatcherReloadStrategyTest.testUpdateXmlRoute(FileWatcherReloadStrategyTest.java:166)
Caused by: java.lang.AssertionError: expected:<1> but was:<0>
 at org.apache.camel.impl.FileWatcherReloadStrategyTest.lambda$testUpdateXmlRoute$1(FileWatcherReloadStrategyTest.java:166)

[ERROR] testAddNewRoute(org.apache.camel.impl.FileWatcherReloadStrategyTest) Time elapsed: 20.058 s <<< ERROR!
org.awaitility.core.ConditionTimeoutException: Assertion condition defined as a lambda expression in org.apache.camel.impl.FileWatcherReloadStrategyTest expected:<1> but was:<0> within 20 seconds.
 at org.apache.camel.impl.FileWatcherReloadStrategyTest.testAddNewRoute(FileWatcherReloadStrategyTest.java:71)
Caused by: java.lang.AssertionError: expected:<1> but was:<0>
 at org.apache.camel.impl.FileWatcherReloadStrategyTest.lambda$testAddNewRoute$0(FileWatcherReloadStrategyTest.java:71)

[ERROR] testUpdateXmlRoute(org.apache.camel.impl.FileWatcherReloadStrategyTest) Time elapsed: 20.078 s <<< ERROR!
org.awaitility.core.ConditionTimeoutException: Assertion condition defined as a lambda expression in org.apache.camel.impl.FileWatcherReloadStrategyTest expected:<1> but was:<0> within 20 seconds.
 at org.apache.camel.impl.FileWatcherReloadStrategyTest.testUpdateXmlRoute(FileWatcherReloadStrategyTest.java:166)
Caused by: java.lang.AssertionError: expected:<1> but was:<0>
 at org.apache.camel.impl.FileWatcherReloadStrategyTest.lambda$testUpdateXmlRoute$1(FileWatcherReloadStrategyTest.java:166)

[ERROR] testAddNewRoute(org.apache.camel.impl.FileWatcherReloadStrategyTest) Time elapsed: 20.067 s <<< ERROR!
org.awaitility.core.ConditionTimeoutException: Assertion condition defined as a lambda expression in org.apache.camel.impl.FileWatcherReloadStrategyTest expected:<1> but was:<0> within 20 seconds.
 at org.apache.camel.impl.FileWatcherReloadStrategyTest.testAddNewRoute(FileWatcherReloadStrategyTest.java:71)
Caused by: java.lang.AssertionError: expected:<1> but was:<0>
 at org.apache.camel.impl.FileWatcherReloadStrategyTest.lambda$testAddNewRoute$0(FileWatcherReloadStrategyTest.java:71)

[ERROR] testUpdateXmlRoute(org.apache.camel.impl.FileWatcherReloadStrategyTest) Time elapsed: 20.095 s <<< ERROR!
org.awaitility.core.ConditionTimeoutException: Assertion condition defined as a lambda expression in org.apache.camel.impl.FileWatcherReloadStrategyTest expected:<1> but was:<0> within 20 seconds.
 at org.apache.camel.impl.FileWatcherReloadStrategyTest.testUpdateXmlRoute(FileWatcherReloadStrategyTest.java:166)
Caused by: java.lang.AssertionError: expected:<1> but was:<0>
 at org.apache.camel.impl.FileWatcherReloadStrategyTest.lambda$testUpdateXmlRoute$1(FileWatcherReloadStrategyTest.java:166)

[ERROR] testAddNewRoute(org.apache.camel.impl.FileWatcherReloadStrategyTest) Time elapsed: 20.026 s <<< ERROR!
org.awaitility.core.ConditionTimeoutException: Assertion condition defined as a lambda expression in org.apache.camel.impl.FileWatcherReloadStrategyTest expected:<1> but was:<0> within 20 seconds.
 at org.apache.camel.impl.FileWatcherReloadStrategyTest.testAddNewRoute(FileWatcherReloadStrategyTest.java:71)
Caused by: java.lang.AssertionError: expected:<1> but was:<0>
 at org.apache.camel.impl.FileWatcherReloadStrategyTest.lambda$testAddNewRoute$0(FileWatcherReloadStrategyTest.java:71)

[INFO]
[INFO] Results:
[INFO]
[ERROR] Errors:
[ERROR] org.apache.camel.impl.FileWatcherReloadStrategyTest.testAddNewRoute(org.apache.camel.impl.FileWatcherReloadStrategyTest)
[ERROR] Run 1: FileWatcherReloadStrategyTest.testAddNewRoute:71 » ConditionTimeout Assertion ...
[ERROR] Run 2: FileWatcherReloadStrategyTest.testAddNewRoute:71 » ConditionTimeout Assertion ...
[ERROR] Run 3: FileWatcherReloadStrategyTest.testAddNewRoute:71 » ConditionTimeout Assertion ...
[INFO]
[ERROR] org.apache.camel.impl.FileWatcherReloadStrategyTest.testUpdateXmlRoute(org.apache.camel.impl.FileWatcherReloadStrategyTest)
[ERROR] Run 1: FileWatcherReloadStrategyTest.testUpdateXmlRoute:166 » ConditionTimeout Assert...
[ERROR] Run 2: FileWatcherReloadStrategyTest.testUpdateXmlRoute:166 » ConditionTimeout Assert...
[ERROR] Run 3: FileWatcherReloadStrategyTest.testUpdateXmlRoute:166 » ConditionTimeout Assert...
[INFO]
[INFO]
[ERROR] Tests run: 3, Failures: 0, Errors: 2, Skipped: 0",davsclaus,Test,Minor,Resolved,"camel-core - test failure: org.apache.camel.impl.FileWatcherReloadStrategyTest. [INFO] Running org.apache.camel.impl.FileWatcherReloadStrategyTest
[ERROR] Tests run: 7, Failures: 0, Errors: 6, Skipped: 0, Time elapsed: 123.022 s <<< FAILURE! - in org.apache.camel.impl.FileWatcherReloadStrategyTest
[ERROR] testUpdateXmlRoute(org.apache.camel.impl.FileWatcherReloadStrategyTest) Time elapsed: 20.529 s <<< ERROR!
org.awaitility.core.ConditionTimeoutException: Assertion condition defined as a lambda expression in org.apache.camel.impl.FileWatcherReloadStrategyTest expected:<1> but was:<0> within 20 seconds.
 at org.apache.camel.impl.FileWatcherReloadStrategyTest.testUpdateXmlRoute(FileWatcherReloadStrategyTest.java:166)
Caused by: java.lang.AssertionError: expected:<1> but was:<0>
 at org.apache.camel.impl.FileWatcherReloadStrategyTest.lambda$testUpdateXmlRoute$1(FileWatcherReloadStrategyTest.java:166)

[ERROR] testAddNewRoute(org.apache.camel.impl.FileWatcherReloadStrategyTest) Time elapsed: 20.058 s <<< ERROR!
org.awaitility.core.ConditionTimeoutException: Assertion condition defined as a lambda expression in org.apache.camel.impl.FileWatcherReloadStrategyTest expected:<1> but was:<0> within 20 seconds.
 at org.apache.camel.impl.FileWatcherReloadStrategyTest.testAddNewRoute(FileWatcherReloadStrategyTest.java:71)
Caused by: java.lang.AssertionError: expected:<1> but was:<0>
 at org.apache.camel.impl.FileWatcherReloadStrategyTest.lambda$testAddNewRoute$0(FileWatcherReloadStrategyTest.java:71)

[ERROR] testUpdateXmlRoute(org.apache.camel.impl.FileWatcherReloadStrategyTest) Time elapsed: 20.078 s <<< ERROR!
org.awaitility.core.ConditionTimeoutException: Assertion condition defined as a lambda expression in org.apache.camel.impl.FileWatcherReloadStrategyTest expected:<1> but was:<0> within 20 seconds.
 at org.apache.camel.impl.FileWatcherReloadStrategyTest.testUpdateXmlRoute(FileWatcherReloadStrategyTest.java:166)
Caused by: java.lang.AssertionError: expected:<1> but was:<0>
 at org.apache.camel.impl.FileWatcherReloadStrategyTest.lambda$testUpdateXmlRoute$1(FileWatcherReloadStrategyTest.java:166)

[ERROR] testAddNewRoute(org.apache.camel.impl.FileWatcherReloadStrategyTest) Time elapsed: 20.067 s <<< ERROR!
org.awaitility.core.ConditionTimeoutException: Assertion condition defined as a lambda expression in org.apache.camel.impl.FileWatcherReloadStrategyTest expected:<1> but was:<0> within 20 seconds.
 at org.apache.camel.impl.FileWatcherReloadStrategyTest.testAddNewRoute(FileWatcherReloadStrategyTest.java:71)
Caused by: java.lang.AssertionError: expected:<1> but was:<0>
 at org.apache.camel.impl.FileWatcherReloadStrategyTest.lambda$testAddNewRoute$0(FileWatcherReloadStrategyTest.java:71)

[ERROR] testUpdateXmlRoute(org.apache.camel.impl.FileWatcherReloadStrategyTest) Time elapsed: 20.095 s <<< ERROR!
org.awaitility.core.ConditionTimeoutException: Assertion condition defined as a lambda expression in org.apache.camel.impl.FileWatcherReloadStrategyTest expected:<1> but was:<0> within 20 seconds.
 at org.apache.camel.impl.FileWatcherReloadStrategyTest.testUpdateXmlRoute(FileWatcherReloadStrategyTest.java:166)
Caused by: java.lang.AssertionError: expected:<1> but was:<0>
 at org.apache.camel.impl.FileWatcherReloadStrategyTest.lambda$testUpdateXmlRoute$1(FileWatcherReloadStrategyTest.java:166)

[ERROR] testAddNewRoute(org.apache.camel.impl.FileWatcherReloadStrategyTest) Time elapsed: 20.026 s <<< ERROR!
org.awaitility.core.ConditionTimeoutException: Assertion condition defined as a lambda expression in org.apache.camel.impl.FileWatcherReloadStrategyTest expected:<1> but was:<0> within 20 seconds.
 at org.apache.camel.impl.FileWatcherReloadStrategyTest.testAddNewRoute(FileWatcherReloadStrategyTest.java:71)
Caused by: java.lang.AssertionError: expected:<1> but was:<0>
 at org.apache.camel.impl.FileWatcherReloadStrategyTest.lambda$testAddNewRoute$0(FileWatcherReloadStrategyTest.java:71)

[INFO]
[INFO] Results:
[INFO]
[ERROR] Errors:
[ERROR] org.apache.camel.impl.FileWatcherReloadStrategyTest.testAddNewRoute(org.apache.camel.impl.FileWatcherReloadStrategyTest)
[ERROR] Run 1: FileWatcherReloadStrategyTest.testAddNewRoute:71 >> ConditionTimeout Assertion ...
[ERROR] Run 2: FileWatcherReloadStrategyTest.testAddNewRoute:71 >> ConditionTimeout Assertion ...
[ERROR] Run 3: FileWatcherReloadStrategyTest.testAddNewRoute:71 >> ConditionTimeout Assertion ...
[INFO]
[ERROR] org.apache.camel.impl.FileWatcherReloadStrategyTest.testUpdateXmlRoute(org.apache.camel.impl.FileWatcherReloadStrategyTest)
[ERROR] Run 1: FileWatcherReloadStrategyTest.testUpdateXmlRoute:166 >> ConditionTimeout Assert...
[ERROR] Run 2: FileWatcherReloadStrategyTest.testUpdateXmlRoute:166 >> ConditionTimeout Assert...
[ERROR] Run 3: FileWatcherReloadStrategyTest.testUpdateXmlRoute:166 >> ConditionTimeout Assert...
[INFO]
[INFO]
[ERROR] Tests run: 3, Failures: 0, Errors: 2, Skipped: 0"
CAMEL-13029,camel-swagger-java - Should default use scheme from rest-dsl configuration in swagger doc,"Because http is default then we have not noticed before. But if you use https as the scheme in the rest-dsl for the rest service then the swagger doc generated is outputting http by default. We should use the scheme setting from the rest-dsl out of the box.

You can configure it explicit via

				.apiProperty(""schemes"", ""https"")
",davsclaus,Improvement,Major,Resolved,"camel-swagger-java - Should default use scheme from rest-dsl configuration in swagger doc Because http is default then we have not noticed before. But if you use https as the scheme in the rest-dsl for the rest service then the swagger doc generated is outputting http by default. We should use the scheme setting from the rest-dsl out of the box.

You can configure it explicit via

				.apiProperty(""schemes"", ""https"")
"
CAMEL-13028,camel-undertow - When using SSL with rest-dsl and api-doc then you can get a port already bound exception,"For example this route cannot startup
{code}
	public void configure() throws Exception {

		restConfiguration().scheme(""https"").component(""undertow"").port(7777).contextPath(""/"").host(""0.0.0.0"")
            .apiContextPath(""/swagger.json"")
				.dataFormatProperty(""prettyPrint"", ""true"")

				.apiProperty(""api.schemes"", ""https"")
				.apiProperty(""api.title"", ""Rest swagger"")
				.apiProperty(""api.description"", ""Camel Rest App with Swagger"");

		rest(""/user"").get().to(""direct:start"");

		from(""direct:start"").setBody().constant(""Hi Camels"");
	}
{code}

With a
{code}
Caused by: java.net.BindException: Address already in use
        at sun.nio.ch.Net.bind0(Native Method) ~[na:1.8.0_181]
        at sun.nio.ch.Net.bind(Net.java:433) ~[na:1.8.0_181]
        at sun.nio.ch.Net.bind(Net.java:425) ~[na:1.8.0_181]
        at sun.nio.ch.ServerSocketChannelImpl.bind(ServerSocketChannelImpl.java:223) ~[na:1.8.0_181]
        at sun.nio.ch.ServerSocketAdaptor.bind(ServerSocketAdaptor.java:74) ~[na:1.8.0_181]
...
{code}",davsclaus,Bug,Major,Resolved,"camel-undertow - When using SSL with rest-dsl and api-doc then you can get a port already bound exception For example this route cannot startup
{code}
	public void configure() throws Exception {

		restConfiguration().scheme(""https"").component(""undertow"").port(7777).contextPath(""/"").host(""0.0.0.0"")
            .apiContextPath(""/swagger.json"")
				.dataFormatProperty(""prettyPrint"", ""true"")

				.apiProperty(""api.schemes"", ""https"")
				.apiProperty(""api.title"", ""Rest swagger"")
				.apiProperty(""api.description"", ""Camel Rest App with Swagger"");

		rest(""/user"").get().to(""direct:start"");

		from(""direct:start"").setBody().constant(""Hi Camels"");
	}
{code}

With a
{code}
Caused by: java.net.BindException: Address already in use
        at sun.nio.ch.Net.bind0(Native Method) ~[na:1.8.0_181]
        at sun.nio.ch.Net.bind(Net.java:433) ~[na:1.8.0_181]
        at sun.nio.ch.Net.bind(Net.java:425) ~[na:1.8.0_181]
        at sun.nio.ch.ServerSocketChannelImpl.bind(ServerSocketChannelImpl.java:223) ~[na:1.8.0_181]
        at sun.nio.ch.ServerSocketAdaptor.bind(ServerSocketAdaptor.java:74) ~[na:1.8.0_181]
...
{code}"
CAMEL-13025,camel-core - File read lock changed - If file gets deleted then break out loop,"See SO
https://stackoverflow.com/questions/53865940/apache-camel-route-hangs-when-file-is-deleted-during-processing?noredirect=1#comment94587192_53865940

So if the target file gets deleted during the check interval and you have timeout = 0, then it will keep looping. So we should add a check if the file still exists in the looping.",davsclaus,Improvement,Major,Resolved,"camel-core - File read lock changed - If file gets deleted then break out loop See SO
https://stackoverflow.com/questions/53865940/apache-camel-route-hangs-when-file-is-deleted-during-processing?noredirect=1#comment94587192_53865940

So if the target file gets deleted during the check interval and you have timeout = 0, then it will keep looping. So we should add a check if the file still exists in the looping."
CAMEL-13022,camel-restlet - sending PATCH operation should include body,We currently only include body for PUT and POST. But we should include the body for PATCH as well.,davsclaus,Bug,Minor,Resolved,camel-restlet - sending PATCH operation should include body We currently only include body for PUT and POST. But we should include the body for PATCH as well.
CAMEL-13021,Remove camel-example-swagger-xml,"This example downloads from 3rd party repo - lets avoid this and we have 100 other examples already.
",davsclaus,Task,Minor,Resolved,"Remove camel-example-swagger-xml This example downloads from 3rd party repo - lets avoid this and we have 100 other examples already.
"
CAMEL-13018,Swagger does not work if JMX is disabled,"Swagger returns 402 No Content if jmx is disabled.

How to reproduce:
Add following code to main method of [Application|https://github.com/apache/camel/blob/master/examples/camel-example-spring-boot-rest-swagger/src/main/java/org/apache/camel/example/springboot/Application.java] class

{{System.setProperty(""org.apache.camel.jmx.disabled"", ""true"");}}

 ",davsclaus,Improvement,Minor,Resolved,"Swagger does not work if JMX is disabled Swagger returns 402 No Content if jmx is disabled.

How to reproduce:
Add following code to main method of [Application|https://github.com/apache/camel/blob/master/examples/camel-example-spring-boot-rest-swagger/src/main/java/org/apache/camel/example/springboot/Application.java] class

{{System.setProperty(""org.apache.camel.jmx.disabled"", ""true"");}}

 "
CAMEL-13016,camel-jetty - If multiple bundles uses the same context-path (pathspec) then Jetty should fail,"If you have 2 bundles that both uses the same context-path with a jetty consumer, then the last installed bundle will be routing the incoming requests, and the first installed will not be in use, and if you uninstall the 2nd bundle then the 1st bundle will still not be in use and jetty will return a 404.

We should detect that there is already another jetty consumer with the same context-path to be routing when creating a jetty connector listener and then fail if so.",davsclaus,Bug,Major,Resolved,"camel-jetty - If multiple bundles uses the same context-path (pathspec) then Jetty should fail If you have 2 bundles that both uses the same context-path with a jetty consumer, then the last installed bundle will be routing the incoming requests, and the first installed will not be in use, and if you uninstall the 2nd bundle then the 1st bundle will still not be in use and jetty will return a 404.

We should detect that there is already another jetty consumer with the same context-path to be routing when creating a jetty connector listener and then fail if so."
CAMEL-13015,camel-spring-boot - load multiple route xml files ,"When  I use SpringDSL , i want to load two route files 

For Example route1.xml and route2.xml

If I put two files in same directory like below , it is working

camel.springboot.xmlRoutes: file :directory/*.xml 

 

If I put two files into different directories , it does not work

camel.springboot.xmlRoutes: [file:directory1/route1.xml|file:///directory1/route1.xml] , directory2/route2.xml

Could you please implement this feature?

Thanks",davsclaus,New Feature,Minor,Resolved,"camel-spring-boot - load multiple route xml files  When  I use SpringDSL , i want to load two route files 

For Example route1.xml and route2.xml

If I put two files in same directory like below , it is working

camel.springboot.xmlRoutes: file :directory/*.xml 

 

If I put two files into different directories , it does not work

camel.springboot.xmlRoutes: [file:directory1/route1.xml|file:///directory1/route1.xml] , directory2/route2.xml

Could you please implement this feature?

Thanks"
CAMEL-13010,Deprecate camel-script,"With the release of Java 11, Nashorn is deprecated, and will likely be removed from the JDK at a later time.[9] The GraalVM was suggested as a workaround.
-> https://en.wikipedia.org/wiki/Nashorn_(JavaScript_engine)

We have already deprecated these other scripting languages like python, php etc (https://github.com/apache/camel/blob/master/components/readme.adoc#expression-languages).

And groovy also dont recommend using camel-script by groovy directly, which you can do via camel-groovy
http://docs.groovy-lang.org/latest/html/documentation/guide-integrating.html#jsr223",davsclaus,Task,Major,Resolved,"Deprecate camel-script With the release of Java 11, Nashorn is deprecated, and will likely be removed from the JDK at a later time.[9] The GraalVM was suggested as a workaround.
-> https://en.wikipedia.org/wiki/Nashorn_(JavaScript_engine)

We have already deprecated these other scripting languages like python, php etc (https://github.com/apache/camel/blob/master/components/readme.adoc#expression-languages).

And groovy also dont recommend using camel-script by groovy directly, which you can do via camel-groovy
http://docs.groovy-lang.org/latest/html/documentation/guide-integrating.html#jsr223"
CAMEL-13007,camel-properties : fall-back to env vars,"The camel properties component at the moment fall-back to system properties but to improve cloud integration, it should also fall-back to environment variables",davsclaus,Improvement,Minor,Resolved,"camel-properties : fall-back to env vars The camel properties component at the moment fall-back to system properties but to improve cloud integration, it should also fall-back to environment variables"
CAMEL-13001,Route coverage: specify coverage to fail on,"currently, there is an option to fail the build if the coverage does not reach 100%.

it would be nice to be able to specify the level of coverage wanted as a parameter of the maven plugin",davsclaus,Improvement,Major,Resolved,"Route coverage: specify coverage to fail on currently, there is an option to fail the build if the coverage does not reach 100%.

it would be nice to be able to specify the level of coverage wanted as a parameter of the maven plugin"
CAMEL-12994,xquery syntax problem in SpringDSL with spring-boot,"this JAVADSL sytnax does not exist / supported in SpringDSL 
setHeader(""myHeader"").xquery(""resource:classpath:myxquery.txt"", String.class)


It will cause the problem if return type is String instead of DomReulst or xmlString for xquery, when we use SpringDSL instead of JAVADSL

 we tried all version >= 2.22, same problem ",davsclaus,Bug,Minor,Resolved,"xquery syntax problem in SpringDSL with spring-boot this JAVADSL sytnax does not exist / supported in SpringDSL 
setHeader(""myHeader"").xquery(""resource:classpath:myxquery.txt"", String.class)


It will cause the problem if return type is String instead of DomReulst or xmlString for xquery, when we use SpringDSL instead of JAVADSL

 we tried all version >= 2.22, same problem "
CAMEL-12991,SftpEndpoint does not allow to use custom process strategy,"SftpEndpoint always create generic file strategy even processStrategy object is set in endpoint, same code is used in FtpEndpoint so it's not working also
{code:java}
@Override
protected RemoteFileConsumer<SftpRemoteFile> buildConsumer(Processor processor) {
    return new SftpConsumer(this, processor, createRemoteFileOperations(), createGenericFileStrategy());
}{code}
it is working in FileEnpoint
{code:java}
protected FileConsumer newFileConsumer(Processor processor, GenericFileOperations<File> operations) {
    return new FileConsumer(this, processor, operations, processStrategy != null ? processStrategy : createGenericFileStrategy());
}{code}",davsclaus,Bug,Minor,Resolved,"SftpEndpoint does not allow to use custom process strategy SftpEndpoint always create generic file strategy even processStrategy object is set in endpoint, same code is used in FtpEndpoint so it's not working also
{code:java}
@Override
protected RemoteFileConsumer<SftpRemoteFile> buildConsumer(Processor processor) {
    return new SftpConsumer(this, processor, createRemoteFileOperations(), createGenericFileStrategy());
}{code}
it is working in FileEnpoint
{code:java}
protected FileConsumer newFileConsumer(Processor processor, GenericFileOperations<File> operations) {
    return new FileConsumer(this, processor, operations, processStrategy != null ? processStrategy : createGenericFileStrategy());
}{code}"
CAMEL-12990,FTP endpoint with 'localWorkDirectory' considers File Consumer's 'noop' option,"[https://camel.apache.org/ftp2.html] reads:
{quote}See [File|https://camel.apache.org/file2.html] for more options as all the options from [File|https://camel.apache.org/file2.html] is inherited.
{quote}
 and in *Using Local Work Directory*:
{quote}And finally, when the Exchange is complete the local file is deleted.
{quote}
 [https://camel.apache.org/file2.html] reads:
{quote}
|{{noop}}|{{false}}|If *{{true}}*, the file is not moved or deleted in any way.|
{quote}
I have a use case where I'd need the file transferred to \{{localWorkDirectory}} to stay there. Otherwise I have to change \{{localWorkDirectory}} to something else and add a Producer endpoint to my route which copies the file to the intended directory (i.e. the former \{{localWorkDirectory}}), which is inconvenient with GiB-size files.",davsclaus,New Feature,Minor,Resolved,"FTP endpoint with 'localWorkDirectory' considers File Consumer's 'noop' option [https://camel.apache.org/ftp2.html] reads:
{quote}See [File|https://camel.apache.org/file2.html] for more options as all the options from [File|https://camel.apache.org/file2.html] is inherited.
{quote}
 and in *Using Local Work Directory*:
{quote}And finally, when the Exchange is complete the local file is deleted.
{quote}
 [https://camel.apache.org/file2.html] reads:
{quote}
|{{noop}}|{{false}}|If *{{true}}*, the file is not moved or deleted in any way.|
{quote}
I have a use case where I'd need the file transferred to \{{localWorkDirectory}} to stay there. Otherwise I have to change \{{localWorkDirectory}} to something else and add a Producer endpoint to my route which copies the file to the intended directory (i.e. the former \{{localWorkDirectory}}), which is inconvenient with GiB-size files."
CAMEL-12989,Allow Endpoint to set the key that ProducerCache uses,"ProducerCache is heavily tied to Endpoint URIs. Using the Endpoint URI as the key to the cache does not allow for the creation of Endpoints with the same URI but different configurations. For example, using a RecipientList to call the same SOAP endpoint but with different SSL certificates isn't currently possible. As the URI is always the same.the ProducerCache will always use the first Endpoint it added to the map even if multiple Endpoints are added to the CamelContext with different keys.

Adding getProducerCacheKey & setProducerCacheKey methods to the Endpoint interface would allow for setting the key programmatically. ProducerCache.doGetProducer would use the getProducerCacheKey method instead of getEndpointUri.

DefaultEndpoint would have a new member variable producerCacheKey and could implement the getter such that if the producerCacheKey member was not set it would return getEndpointUri()",davsclaus,Improvement,Minor,Resolved,"Allow Endpoint to set the key that ProducerCache uses ProducerCache is heavily tied to Endpoint URIs. Using the Endpoint URI as the key to the cache does not allow for the creation of Endpoints with the same URI but different configurations. For example, using a RecipientList to call the same SOAP endpoint but with different SSL certificates isn't currently possible. As the URI is always the same.the ProducerCache will always use the first Endpoint it added to the map even if multiple Endpoints are added to the CamelContext with different keys.

Adding getProducerCacheKey & setProducerCacheKey methods to the Endpoint interface would allow for setting the key programmatically. ProducerCache.doGetProducer would use the getProducerCacheKey method instead of getEndpointUri.

DefaultEndpoint would have a new member variable producerCacheKey and could implement the getter such that if the producerCacheKey member was not set it would return getEndpointUri()"
CAMEL-12987,camel-core-osgi: OsgiServiceRegistry.onContextStop never gets called.,"There is also a second problem with how the registry is being managed within the OsgiDefaultCamelContext.  OsgiServiceRegistry is currently extends LifecycleStrategySupport which is suppose to unload the serviceReferenceQueue onContextStop.  However the registry is never getting added to the CamelContext to manage the Lifecycle because the overridden createRegistry method in OsgiDefaultCamelContext is not being called.  This is because the registry is being set in the constructor of OsgiDefaultCamelContext with
{code:java}
super(registry);{code}
this calls the DefaultCamelContext implementation of createRegistry which does not add the registry to lifecyclemanagement since
{code:java}
OsgiCamelContextHelper.wrapRegistry(this, registry, bundleContext);{code}
is never called. 

See CAMEL-12969 for screen captures.

 ",davsclaus,Bug,Major,Resolved,"camel-core-osgi: OsgiServiceRegistry.onContextStop never gets called. There is also a second problem with how the registry is being managed within the OsgiDefaultCamelContext.  OsgiServiceRegistry is currently extends LifecycleStrategySupport which is suppose to unload the serviceReferenceQueue onContextStop.  However the registry is never getting added to the CamelContext to manage the Lifecycle because the overridden createRegistry method in OsgiDefaultCamelContext is not being called.  This is because the registry is being set in the constructor of OsgiDefaultCamelContext with
{code:java}
super(registry);{code}
this calls the DefaultCamelContext implementation of createRegistry which does not add the registry to lifecyclemanagement since
{code:java}
OsgiCamelContextHelper.wrapRegistry(this, registry, bundleContext);{code}
is never called. 

See CAMEL-12969 for screen captures.

 "
CAMEL-12981,camel-catalog: provide information about active/passive endpoints,"In Camel K we need to distinguish active from passive endpoints in order to determine when a integration can be scaled down to 0.

 

E.g.
 * a ""timer"" (start) endpoint is *active*, because it needs to have a JVM always running and do something at each interval
 * a ""jms"" (start) endpoint is *active* because it needs to establish a connection to the broker and keep it alive
 * a ""direct"" or ""seda"" endpoint is *passive*, because they do something when they receive an exchange from another route
 * a ""undertow"" (start) endpoint is *passive*, because it does nothing until somebody calls it from an +external+ service (http based endpoints can all be considered passive in Knative+CamelK)

 

We should add this information to the catalog. Now I've embedded it in Camel K.",davsclaus,Task,Major,Open,"camel-catalog: provide information about active/passive endpoints In Camel K we need to distinguish active from passive endpoints in order to determine when a integration can be scaled down to 0.

 

E.g.
 * a ""timer"" (start) endpoint is *active*, because it needs to have a JVM always running and do something at each interval
 * a ""jms"" (start) endpoint is *active* because it needs to establish a connection to the broker and keep it alive
 * a ""direct"" or ""seda"" endpoint is *passive*, because they do something when they receive an exchange from another route
 * a ""undertow"" (start) endpoint is *passive*, because it does nothing until somebody calls it from an +external+ service (http based endpoints can all be considered passive in Knative+CamelK)

 

We should add this information to the catalog. Now I've embedded it in Camel K."
CAMEL-12974,Route coverage: When and otherwise are not marked as covered,"- use a route with a choice with when and otherwise inside.
- launch mvn test camel:route-coverage
- when and otherwise are marked with a 0 count even if they were used

examples of the CBR examples available in Eclipse Fuse Tooling:
{noformat}Route:	cbr-route

  Line #      Count   Route
  ------      -----   -----
      33          5   from
      34          5     log
      35          5     choice
      36          0       when
      38          2         log
      39          2         to
      41          0       when
      43          2         log
      44          2         to
      46          0       otherwise
      47          1         log
      48          1         to
      51          5     log

Coverage: 10 out of 13 (76.9%){noformat}

we can notice that elements inside when and otherwise are well counted but when and otherwise are at 0",davsclaus,Bug,Minor,Resolved,"Route coverage: When and otherwise are not marked as covered - use a route with a choice with when and otherwise inside.
- launch mvn test camel:route-coverage
- when and otherwise are marked with a 0 count even if they were used

examples of the CBR examples available in Eclipse Fuse Tooling:
{noformat}Route:	cbr-route

  Line #      Count   Route
  ------      -----   -----
      33          5   from
      34          5     log
      35          5     choice
      36          0       when
      38          2         log
      39          2         to
      41          0       when
      43          2         log
      44          2         to
      46          0       otherwise
      47          1         log
      48          1         to
      51          5     log

Coverage: 10 out of 13 (76.9%){noformat}

we can notice that elements inside when and otherwise are well counted but when and otherwise are at 0"
CAMEL-12970,Camel Maven Plugin: false postives with directOrSedaPairCheck,"In one of my RouteBuilders I instantiate and include some routes with {{RouteBuilder::includeRoutes}}. When I run {{mvn camel:validate}}, these routes generate the ""Sending to non existing direct queue name"" error. The routes work though.

Here is the Route. I can make a smaller example, but I won't if I don't need to.
{code:java|title=HealthRoute.java}
import java.sql.Connection;
import java.sql.SQLException;
import java.util.HashMap;
import javax.sql.DataSource;
import org.apache.camel.BeanInject;
import org.apache.camel.Exchange;
import org.apache.camel.Processor;
import org.apache.camel.builder.RouteBuilder;
import org.apache.camel.json.simple.JsonObject;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

/**
 * An HTTP service that validates some application configuration properties. The
 * validation status is returned as simply ""true"" or ""false"" with error messages
 * printed to the log.
 */
public class HealthRoute extends RouteBuilder {

    private static final String ROUTE_CHECK_SUBMIT_ASSESSMENTS_ENDPOINT = ""checkSubmitAssessmentsEndpoint"";
    private static final String ROUTE_CHECK_QUERY_ENDPOINT = ""checkQueryEndpoint"";
    private static final String DATABASE_REACHABLE = ""isDatabaseReachable"";

    @BeanInject(value = ""dataSource"")
    private DataSource dataSource;

    private static final Logger LOGGER = LoggerFactory.getLogger(HealthRoute1.class);

    @Override
    public void configure() throws Exception {

        from(""servlet:smoketest?servletName=HealthServlet"")
                .to(""direct:"" + ROUTE_CHECK_QUERY_ENDPOINT)
                .to(""direct:"" + ROUTE_CHECK_SUBMIT_ASSESSMENTS_ENDPOINT)
                .process(new CheckDatabaseConnection())
                .process(exchange -> {
                    HashMap<String, Object> hashMap = new HashMap<>();
                    hashMap.put(""isQueryEndpointReachable"", exchange.getProperty(ROUTE_CHECK_QUERY_ENDPOINT));
                    hashMap.put(""isSubmitAssessmentsEndpointReachable"", exchange.getProperty(ROUTE_CHECK_SUBMIT_ASSESSMENTS_ENDPOINT));
                    hashMap.put(DATABASE_REACHABLE, exchange.getProperty(DATABASE_REACHABLE));
                    exchange.getIn().setBody(new JsonObject(hashMap).toJson());
                })
                .setHeader(""Content-Type"", constant(""application/json""));

        String queryHumanSubjectsUri = getContext().resolvePropertyPlaceholders(""{{queryHumanSubjectsUri}}"").replaceAll(""https?://"", """");
        String submitExternalAssessmentsUri = getContext().resolvePropertyPlaceholders(""{{submitExternalAssessmentsUri}}"").replaceAll(""https?://"", """");
        includeRoutes(new CheckEndpointRoute(ROUTE_CHECK_QUERY_ENDPOINT, queryHumanSubjectsUri));
        includeRoutes(new CheckEndpointRoute(ROUTE_CHECK_SUBMIT_ASSESSMENTS_ENDPOINT, submitExternalAssessmentsUri));
    }

    /**
     * Smoke tests the availability of a given HTTP resource by issuing a GET
     * request. If the request throws an exception an error flag is set on the
     * Exchange.
     */
    private static class CheckEndpointRoute extends RouteBuilder {

        private final String routeId;
        private final String uri;

        public CheckEndpointRoute(String routeId, String uri) {
            this.routeId = routeId;
            this.uri = uri;
        }

        @Override
        public void configure() throws Exception {
            from(""direct:"" + routeId)
                    .doTry()
                    .to(""https4:""
                            + uri
                            + ""?sslContextParameters=#sslParameters""
                            + ""&bridgeEndpoint=true""
                            + ""&x509HostnameVerifier=#hostnameVerifier"")
                    .setProperty(routeId, constant(true))
                    .doCatch(Exception.class)
                    .to(""log:com.cgi.best.HealthRoute?level=ERROR&showCaughtException=true"")
                    .setProperty(routeId, constant(false))
                    .end();
        }
    }

    /**
     * Smoke tests the availability of the database by executing a standard
     * database health query.
     */
    private class CheckDatabaseConnection implements Processor {

        @Override
        public void process(Exchange exchange) throws Exception {
            try (Connection connection = dataSource.getConnection()) {
                connection.createStatement().execute(""select * from dual"");
                exchange.setProperty(DATABASE_REACHABLE, true);
            } catch (SQLException ex) {
                LOGGER.error(""Database test query failed."", ex);
                exchange.setProperty(DATABASE_REACHABLE, false);
            }
        }
    }
}
{code}
{code}
$ mvn camel:validate
[INFO] Scanning for projects...
[INFO]
[INFO] ------------------------------------------------------------------------
[INFO] Building BestAdapter 1.0-SNAPSHOT
[INFO] ------------------------------------------------------------------------
[INFO]
[INFO] --- camel-maven-plugin:2.23.0:validate (default-cli) @ BestAdapter ---
[INFO] Detected Camel version used in project: 2.23.0
[INFO] Validating using Camel version: 2.23.0
[INFO] Endpoint validation success: (16 = passed, 0 = invalid, 2 = incapable, 0 = unknown components, 0 = deprecated options)
[INFO] Simple validation success: (3 = passed, 0 = invalid)
[WARNING] Endpoint pair (seda/direct) validation error at: com.cgi.best.HealthRoute.configure(HealthRoute.java:45)

        direct:checkQueryEndpoint

                                checkQueryEndpoint      Sending to non existing direct queue name


[WARNING] Endpoint pair (seda/direct) validation error at: com.cgi.best.HealthRoute.configure(HealthRoute.java:45)

        direct:checkSubmitAssessmentsEndpoint

                                checkSubmitAssessmentsEndpoint  Sending to non existing direct queue name


[WARNING] Endpoint pair (seda/direct) validation error at: com.cgi.best.HealthRoute1.configure(HealthRoute1.java:45)

        direct:checkQueryEndpoint

                                checkQueryEndpoint      Sending to non existing direct queue name


[WARNING] Endpoint pair (seda/direct) validation error at: com.cgi.best.HealthRoute1.configure(HealthRoute1.java:45)

        direct:checkSubmitAssessmentsEndpoint

                                checkSubmitAssessmentsEndpoint  Sending to non existing direct queue name


[WARNING] Endpoint pair (seda/direct) validation error: (2 = pairs, 4 = non-pairs)
[INFO] Duplicate route id validation success (3 = ids)
[INFO] ------------------------------------------------------------------------
[INFO] BUILD FAILURE
[INFO] ------------------------------------------------------------------------
[INFO] Total time: 3.030 s
[INFO] Finished at: 2018-11-30T08:55:31-08:00
[INFO] Final Memory: 21M/398M
[INFO] ------------------------------------------------------------------------
[ERROR] Failed to execute goal org.apache.camel:camel-maven-plugin:2.23.0:validate (default-cli) on project BestAdapter: Endpoint validation success: (16 = passed, 0 = invalid, 2 = incapable, 0 = unknown components, 0 = deprecated options)
[ERROR] Simple validation success: (3 = passed, 0 = invalid)
[ERROR] Duplicate route id validation success (3 = ids)
[ERROR] Endpoint pair (seda/direct) validation error: (2 = pairs, 4 = non-pairs)
[ERROR] -> [Help 1]
[ERROR]
[ERROR] To see the full stack trace of the errors, re-run Maven with the -e switch.
[ERROR] Re-run Maven using the -X switch to enable full debug logging.
[ERROR]
[ERROR] For more information about the errors and possible solutions, please read the following articles:
[ERROR] [Help 1] http://cwiki.apache.org/confluence/display/MAVEN/MojoExecutionException
{code}",davsclaus,Bug,Minor,Resolved,"Camel Maven Plugin: false postives with directOrSedaPairCheck In one of my RouteBuilders I instantiate and include some routes with {{RouteBuilder::includeRoutes}}. When I run {{mvn camel:validate}}, these routes generate the ""Sending to non existing direct queue name"" error. The routes work though.

Here is the Route. I can make a smaller example, but I won't if I don't need to.
{code:java|title=HealthRoute.java}
import java.sql.Connection;
import java.sql.SQLException;
import java.util.HashMap;
import javax.sql.DataSource;
import org.apache.camel.BeanInject;
import org.apache.camel.Exchange;
import org.apache.camel.Processor;
import org.apache.camel.builder.RouteBuilder;
import org.apache.camel.json.simple.JsonObject;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

/**
 * An HTTP service that validates some application configuration properties. The
 * validation status is returned as simply ""true"" or ""false"" with error messages
 * printed to the log.
 */
public class HealthRoute extends RouteBuilder {

    private static final String ROUTE_CHECK_SUBMIT_ASSESSMENTS_ENDPOINT = ""checkSubmitAssessmentsEndpoint"";
    private static final String ROUTE_CHECK_QUERY_ENDPOINT = ""checkQueryEndpoint"";
    private static final String DATABASE_REACHABLE = ""isDatabaseReachable"";

    @BeanInject(value = ""dataSource"")
    private DataSource dataSource;

    private static final Logger LOGGER = LoggerFactory.getLogger(HealthRoute1.class);

    @Override
    public void configure() throws Exception {

        from(""servlet:smoketest?servletName=HealthServlet"")
                .to(""direct:"" + ROUTE_CHECK_QUERY_ENDPOINT)
                .to(""direct:"" + ROUTE_CHECK_SUBMIT_ASSESSMENTS_ENDPOINT)
                .process(new CheckDatabaseConnection())
                .process(exchange -> {
                    HashMap<String, Object> hashMap = new HashMap<>();
                    hashMap.put(""isQueryEndpointReachable"", exchange.getProperty(ROUTE_CHECK_QUERY_ENDPOINT));
                    hashMap.put(""isSubmitAssessmentsEndpointReachable"", exchange.getProperty(ROUTE_CHECK_SUBMIT_ASSESSMENTS_ENDPOINT));
                    hashMap.put(DATABASE_REACHABLE, exchange.getProperty(DATABASE_REACHABLE));
                    exchange.getIn().setBody(new JsonObject(hashMap).toJson());
                })
                .setHeader(""Content-Type"", constant(""application/json""));

        String queryHumanSubjectsUri = getContext().resolvePropertyPlaceholders(""{{queryHumanSubjectsUri}}"").replaceAll(""https?://"", """");
        String submitExternalAssessmentsUri = getContext().resolvePropertyPlaceholders(""{{submitExternalAssessmentsUri}}"").replaceAll(""https?://"", """");
        includeRoutes(new CheckEndpointRoute(ROUTE_CHECK_QUERY_ENDPOINT, queryHumanSubjectsUri));
        includeRoutes(new CheckEndpointRoute(ROUTE_CHECK_SUBMIT_ASSESSMENTS_ENDPOINT, submitExternalAssessmentsUri));
    }

    /**
     * Smoke tests the availability of a given HTTP resource by issuing a GET
     * request. If the request throws an exception an error flag is set on the
     * Exchange.
     */
    private static class CheckEndpointRoute extends RouteBuilder {

        private final String routeId;
        private final String uri;

        public CheckEndpointRoute(String routeId, String uri) {
            this.routeId = routeId;
            this.uri = uri;
        }

        @Override
        public void configure() throws Exception {
            from(""direct:"" + routeId)
                    .doTry()
                    .to(""https4:""
                            + uri
                            + ""?sslContextParameters=#sslParameters""
                            + ""&bridgeEndpoint=true""
                            + ""&x509HostnameVerifier=#hostnameVerifier"")
                    .setProperty(routeId, constant(true))
                    .doCatch(Exception.class)
                    .to(""log:com.cgi.best.HealthRoute?level=ERROR&showCaughtException=true"")
                    .setProperty(routeId, constant(false))
                    .end();
        }
    }

    /**
     * Smoke tests the availability of the database by executing a standard
     * database health query.
     */
    private class CheckDatabaseConnection implements Processor {

        @Override
        public void process(Exchange exchange) throws Exception {
            try (Connection connection = dataSource.getConnection()) {
                connection.createStatement().execute(""select * from dual"");
                exchange.setProperty(DATABASE_REACHABLE, true);
            } catch (SQLException ex) {
                LOGGER.error(""Database test query failed."", ex);
                exchange.setProperty(DATABASE_REACHABLE, false);
            }
        }
    }
}
{code}
{code}
$ mvn camel:validate
[INFO] Scanning for projects...
[INFO]
[INFO] ------------------------------------------------------------------------
[INFO] Building BestAdapter 1.0-SNAPSHOT
[INFO] ------------------------------------------------------------------------
[INFO]
[INFO] --- camel-maven-plugin:2.23.0:validate (default-cli) @ BestAdapter ---
[INFO] Detected Camel version used in project: 2.23.0
[INFO] Validating using Camel version: 2.23.0
[INFO] Endpoint validation success: (16 = passed, 0 = invalid, 2 = incapable, 0 = unknown components, 0 = deprecated options)
[INFO] Simple validation success: (3 = passed, 0 = invalid)
[WARNING] Endpoint pair (seda/direct) validation error at: com.cgi.best.HealthRoute.configure(HealthRoute.java:45)

        direct:checkQueryEndpoint

                                checkQueryEndpoint      Sending to non existing direct queue name


[WARNING] Endpoint pair (seda/direct) validation error at: com.cgi.best.HealthRoute.configure(HealthRoute.java:45)

        direct:checkSubmitAssessmentsEndpoint

                                checkSubmitAssessmentsEndpoint  Sending to non existing direct queue name


[WARNING] Endpoint pair (seda/direct) validation error at: com.cgi.best.HealthRoute1.configure(HealthRoute1.java:45)

        direct:checkQueryEndpoint

                                checkQueryEndpoint      Sending to non existing direct queue name


[WARNING] Endpoint pair (seda/direct) validation error at: com.cgi.best.HealthRoute1.configure(HealthRoute1.java:45)

        direct:checkSubmitAssessmentsEndpoint

                                checkSubmitAssessmentsEndpoint  Sending to non existing direct queue name


[WARNING] Endpoint pair (seda/direct) validation error: (2 = pairs, 4 = non-pairs)
[INFO] Duplicate route id validation success (3 = ids)
[INFO] ------------------------------------------------------------------------
[INFO] BUILD FAILURE
[INFO] ------------------------------------------------------------------------
[INFO] Total time: 3.030 s
[INFO] Finished at: 2018-11-30T08:55:31-08:00
[INFO] Final Memory: 21M/398M
[INFO] ------------------------------------------------------------------------
[ERROR] Failed to execute goal org.apache.camel:camel-maven-plugin:2.23.0:validate (default-cli) on project BestAdapter: Endpoint validation success: (16 = passed, 0 = invalid, 2 = incapable, 0 = unknown components, 0 = deprecated options)
[ERROR] Simple validation success: (3 = passed, 0 = invalid)
[ERROR] Duplicate route id validation success (3 = ids)
[ERROR] Endpoint pair (seda/direct) validation error: (2 = pairs, 4 = non-pairs)
[ERROR] -> [Help 1]
[ERROR]
[ERROR] To see the full stack trace of the errors, re-run Maven with the -e switch.
[ERROR] Re-run Maven using the -X switch to enable full debug logging.
[ERROR]
[ERROR] For more information about the errors and possible solutions, please read the following articles:
[ERROR] [Help 1] http://cwiki.apache.org/confluence/display/MAVEN/MojoExecutionException
{code}"
CAMEL-12969,camel-core-osgi: Slow Memory Leak in OsgiServiceRegistry,"The OsgiServiceRegistry has a slow memory leak in the serviceReferenceQueue.  Currently every time a service is looked up by any method an item is added to the serviceReferenceQueue.  This is required because of OSGi ServiceReference counting.  However left unchecked the system just continues to add ConcurrentLinkedQueue$Node objects until memory is exhausted.

!ServiceReferenceQueueLeak.PNG! . 

 

There is also a second problem with how the registry is being managed within the OsgiDefaultCamelContext.  OsgiServiceRegistry is currently extends LifecycleStrategySupport which is suppose to unload the serviceReferenceQueue onContextStop.  However the registry is never getting added to the CamelContext to manage the Lifecycle because the overridden createRegistry method in OsgiDefaultCamelContext is not being called.  This is because the registry is being set in the constructor of OsgiDefaultCamelContext with
{code:java}
super(registry);{code}
this calls the DefaultCamelContext implementation of createRegistry which does not add the registry to lifecyclemanagement since
{code:java}
OsgiCamelContextHelper.wrapRegistry(this, registry, bundleContext);{code}
is never called. 

See serviceReferenceQueue  pre context stop

  !ServiceReferenceQueuePreContextStop.PNG!

!karafCamelContextStop.PNG!

See serviceReferenceQueue   post context stop (still contain objects)

  !ServiceReferenceQueuePostContextStop.PNG!

Both issues would have existed for some time but may have gone unnoticed because the leak was so slow (ConcurrentLinkedQueue$Node takes up very little memory).  It appears the removal of the cache in https://issues.apache.org/jira/browse/CAMEL-9631 makes the leak occur more quickly. 

 

I have a patch that involves reintroducing the cache but with an invalidation strategy using the OSGi ServiceListener that leverages a single clean up thread to remain non-blocking.  I'm working on an upstream adaptation and will post a PR for community review.

 

 ",davsclaus,Bug,Major,Resolved,"camel-core-osgi: Slow Memory Leak in OsgiServiceRegistry The OsgiServiceRegistry has a slow memory leak in the serviceReferenceQueue.  Currently every time a service is looked up by any method an item is added to the serviceReferenceQueue.  This is required because of OSGi ServiceReference counting.  However left unchecked the system just continues to add ConcurrentLinkedQueue$Node objects until memory is exhausted.

!ServiceReferenceQueueLeak.PNG! . 

 

There is also a second problem with how the registry is being managed within the OsgiDefaultCamelContext.  OsgiServiceRegistry is currently extends LifecycleStrategySupport which is suppose to unload the serviceReferenceQueue onContextStop.  However the registry is never getting added to the CamelContext to manage the Lifecycle because the overridden createRegistry method in OsgiDefaultCamelContext is not being called.  This is because the registry is being set in the constructor of OsgiDefaultCamelContext with
{code:java}
super(registry);{code}
this calls the DefaultCamelContext implementation of createRegistry which does not add the registry to lifecyclemanagement since
{code:java}
OsgiCamelContextHelper.wrapRegistry(this, registry, bundleContext);{code}
is never called. 

See serviceReferenceQueue  pre context stop

  !ServiceReferenceQueuePreContextStop.PNG!

!karafCamelContextStop.PNG!

See serviceReferenceQueue   post context stop (still contain objects)

  !ServiceReferenceQueuePostContextStop.PNG!

Both issues would have existed for some time but may have gone unnoticed because the leak was so slow (ConcurrentLinkedQueue$Node takes up very little memory).  It appears the removal of the cache in https://issues.apache.org/jira/browse/CAMEL-9631 makes the leak occur more quickly. 

 

I have a patch that involves reintroducing the cache but with an invalidation strategy using the OSGi ServiceListener that leverages a single clean up thread to remain non-blocking.  I'm working on an upstream adaptation and will post a PR for community review.

 

 "
CAMEL-12968,"DefaultFluentProducerTemplate is not thread safe (endpoint, etc.)","The DefaultFluentProducerTemplate saves state between method calls. This leads to unexpected behavior when the javadoc specifies that it should be thread safe.

For example:
 # thread 1 calls fluentProducerTemplate.to(""direct:a"").send(""message1"");
 # thread 2 calls fluentProducerTemplate.to(""direct:b"").send(""message2"");

If these are run in parallel, the sequence of calls can be:
 # thread 1 calls to(""direct:a"") - endpoint in the object is direct:a
 # thread 2 calls to(""direct:b"") - endpoint in the object is direct:b
 # *thread 1 calls send(""message1"") - this gets sent incorrectly to direct:b*
 # thread 2 calls send(""message2"") - this gets sent correctly to direct:b

Endpoint is one example, but almost all fields in this class share this behavior. It should be clearly documented which fields can be used fluently over multiple threads, and which cannot. As the API is today, all methods returning 'this' should be made thread-safe (state is only local to the caller) so that the fluent interface works as expected.",davsclaus,Bug,Major,Resolved,"DefaultFluentProducerTemplate is not thread safe (endpoint, etc.) The DefaultFluentProducerTemplate saves state between method calls. This leads to unexpected behavior when the javadoc specifies that it should be thread safe.

For example:
 # thread 1 calls fluentProducerTemplate.to(""direct:a"").send(""message1"");
 # thread 2 calls fluentProducerTemplate.to(""direct:b"").send(""message2"");

If these are run in parallel, the sequence of calls can be:
 # thread 1 calls to(""direct:a"") - endpoint in the object is direct:a
 # thread 2 calls to(""direct:b"") - endpoint in the object is direct:b
 # *thread 1 calls send(""message1"") - this gets sent incorrectly to direct:b*
 # thread 2 calls send(""message2"") - this gets sent correctly to direct:b

Endpoint is one example, but almost all fields in this class share this behavior. It should be clearly documented which fields can be used fluently over multiple threads, and which cannot. As the API is today, all methods returning 'this' should be made thread-safe (state is only local to the caller) so that the fluent interface works as expected."
CAMEL-12965,deprecate the Camel maven archetypes,"ts these maven archetypes, we are considering to deprecate for 2.x and remove in 3.x
https://github.com/apache/camel/tree/master/archetypes",davsclaus,Task,Major,Resolved,"deprecate the Camel maven archetypes ts these maven archetypes, we are considering to deprecate for 2.x and remove in 3.x
https://github.com/apache/camel/tree/master/archetypes"
CAMEL-12956,Spring Boot Auto-Configuration via application.properties does not work,"I am trying to configure camel with spring boot to use active MQ. But the jms connection factory (activemq) gets not picked up automatically during auto configuration. Thus, I tried to configure it via application.properties
{code:java}
camel.component.jms.connection-factory=org.apache.activemq.ActiveMQConnectionFactory{code}
But then I get an error on startup stating, that the expected datatype is 
{code:java}
javax.jms.ConnectionFactory{code}
and not
{code:java}
String{code}
The only solutions I have found is not using autoconfiguration and configuring *JmsComponent* by hand or using a *ComponentCustomizer* programatically. This seems to be a Bug, as other component auto configurations expect a String as connectionFactory property.

 ",davsclaus,Bug,Major,Resolved,"Spring Boot Auto-Configuration via application.properties does not work I am trying to configure camel with spring boot to use active MQ. But the jms connection factory (activemq) gets not picked up automatically during auto configuration. Thus, I tried to configure it via application.properties
{code:java}
camel.component.jms.connection-factory=org.apache.activemq.ActiveMQConnectionFactory{code}
But then I get an error on startup stating, that the expected datatype is 
{code:java}
javax.jms.ConnectionFactory{code}
and not
{code:java}
String{code}
The only solutions I have found is not using autoconfiguration and configuring *JmsComponent* by hand or using a *ComponentCustomizer* programatically. This seems to be a Bug, as other component auto configurations expect a String as connectionFactory property.

 "
CAMEL-12949,onWhen predicate with onException can not bind to method with exception subclass parameter,"Inspired by this example for ""Camel in Action, Second Edition"" (page 510):
{code:java}
public final class MyHttpUtil {
    public static boolean isIllegalDataError(
        HttpOperationFailedException cause) {
        int code = cause.getStatusCode();
        if (code != 500) {
            return false;
            }
        return ""ILLEGAL DATA"".equals(cause.getResponseBody().toString());
    }
}

onException(HttpOperationFailedException.class)
    .onWhen(bean(MyHttpUtil.class, ""isIllegalData""))
    .handled(true)
    .to(""file:/rider/files/illegal"");
{code}
I expected this (simplified test) to pass:
{code:java}
public class OnWhenBindMethodWithExceptionSubclassParameterTest extends CamelTestSupport {

    public static class IOExceptionMatcher {
        public static boolean matches(IOException e) {
            // real logic omited
            return true;
        }
    }

    @Override
    protected RouteBuilder createRouteBuilder() throws Exception {
        return new RouteBuilder() {

            public void configure() {
                onException(IOException.class)
                    .onWhen(method(IOExceptionMatcher.class))
                    .to(""mock:ioexception"");
                from(""seda:start"")
                    .throwException(new IOException());
            }
        };
    }

    @Test
    public void test() throws Exception {
        getMockEndpoint(""mock:ioexception"").expectedMessageCount(1);

        template.sendBody(""seda:start"", ""Hello World"");

        assertMockEndpointsSatisfied();
    }
}
{code}
but it fails with with:
{noformat}
java.lang.AssertionError: mock://ioexception Received message count. Expected: <1> but was: <0>
{noformat}
The workaround is to replace the {{IOException}} parameter of {{IOExceptionMatcher#matches}} with an generic {{Exception}}:
{code:java}
public static class IOExceptionMatcher {
    public static boolean matches(Exception e) {
        if (e instanceof IOException) {
            return true;
        }
        return false;
    }
}
{code}

but this is not as elegant and more error prone.",davsclaus,Bug,Minor,Closed,"onWhen predicate with onException can not bind to method with exception subclass parameter Inspired by this example for ""Camel in Action, Second Edition"" (page 510):
{code:java}
public final class MyHttpUtil {
    public static boolean isIllegalDataError(
        HttpOperationFailedException cause) {
        int code = cause.getStatusCode();
        if (code != 500) {
            return false;
            }
        return ""ILLEGAL DATA"".equals(cause.getResponseBody().toString());
    }
}

onException(HttpOperationFailedException.class)
    .onWhen(bean(MyHttpUtil.class, ""isIllegalData""))
    .handled(true)
    .to(""file:/rider/files/illegal"");
{code}
I expected this (simplified test) to pass:
{code:java}
public class OnWhenBindMethodWithExceptionSubclassParameterTest extends CamelTestSupport {

    public static class IOExceptionMatcher {
        public static boolean matches(IOException e) {
            // real logic omited
            return true;
        }
    }

    @Override
    protected RouteBuilder createRouteBuilder() throws Exception {
        return new RouteBuilder() {

            public void configure() {
                onException(IOException.class)
                    .onWhen(method(IOExceptionMatcher.class))
                    .to(""mock:ioexception"");
                from(""seda:start"")
                    .throwException(new IOException());
            }
        };
    }

    @Test
    public void test() throws Exception {
        getMockEndpoint(""mock:ioexception"").expectedMessageCount(1);

        template.sendBody(""seda:start"", ""Hello World"");

        assertMockEndpointsSatisfied();
    }
}
{code}
but it fails with with:
{noformat}
java.lang.AssertionError: mock://ioexception Received message count. Expected: <1> but was: <0>
{noformat}
The workaround is to replace the {{IOException}} parameter of {{IOExceptionMatcher#matches}} with an generic {{Exception}}:
{code:java}
public static class IOExceptionMatcher {
    public static boolean matches(Exception e) {
        if (e instanceof IOException) {
            return true;
        }
        return false;
    }
}
{code}

but this is not as elegant and more error prone."
CAMEL-12937,Stream Caching Cipher is misspelled as chiper,"The typo is in the docs here:
https://camel.apache.org/stream-caching.html

As well as {{org.apache.camel.spring.boot.CamelConfigurationProperties}}

I'm guessing it is in other places as well.",davsclaus,Task,Trivial,Resolved,"Stream Caching Cipher is misspelled as chiper The typo is in the docs here:
https://camel.apache.org/stream-caching.html

As well as {{org.apache.camel.spring.boot.CamelConfigurationProperties}}

I'm guessing it is in other places as well."
CAMEL-12916,camel-http4 - The sslContextParameters option should be documented on endpoint as well,"Reported on gitter
https://gitter.im/apache/apache-camel?at=5be0bcd7de33dd0c96d547b3",davsclaus,Bug,Minor,Resolved,"camel-http4 - The sslContextParameters option should be documented on endpoint as well Reported on gitter
https://gitter.im/apache/apache-camel?at=5be0bcd7de33dd0c96d547b3"
CAMEL-12909,Error handler - Counter and option to log when a retry became success,"Asked on twitter
https://twitter.com/luistrigueiros/status/1053039644093366272

It may be good to have a way to know if a message that has first failed and then with retries from the error handler then became succesful. We should be able to see this with
- counter in the mbean
- log message in the logs, option to configure the logging level.",davsclaus,Improvement,Major,Resolved,"Error handler - Counter and option to log when a retry became success Asked on twitter
https://twitter.com/luistrigueiros/status/1053039644093366272

It may be good to have a way to know if a message that has first failed and then with retries from the error handler then became succesful. We should be able to see this with
- counter in the mbean
- log message in the logs, option to configure the logging level."
CAMEL-12900,Route contract validate does not throw validation exception when validation fails,"This route will not throw validation exception when expected
{code}
                validator().type(""xml"").withUri(""validator:org/apache/camel/impl/validate.xsd"");

                from(""direct:in"").inputTypeWithValidate(""xml"")
                    .to(""mock:result"");
{code}",davsclaus,Bug,Major,Resolved,"Route contract validate does not throw validation exception when validation fails This route will not throw validation exception when expected
{code}
                validator().type(""xml"").withUri(""validator:org/apache/camel/impl/validate.xsd"");

                from(""direct:in"").inputTypeWithValidate(""xml"")
                    .to(""mock:result"");
{code}"
CAMEL-12883,WeaveByType not working for OnExceptionDefinition in camel 2.21.0,"Below is my route
{code:java}
OnException(Exception.class).handled(true).process(EXCEPTION_PROCESSOR).end()

from(""file:"").process(SOME_PROCESSOR).to(""file:"");
{code}
During testing i want to investigate each exchange which goes through OnException block , for which i tried below
{code:java}
weaveByType(OnExceptionDefinition.class).after()
                    .to(assertEndpoint)
{code}
when i ran the test i got below error
{code:java}
java.lang.IllegalArgumentException: There are no outputs which matches: OnExceptionDefinition in the route
{code}
Could you please help in resolving this issue? Please note i have tried adding code mentioned below in test class, but still the same issue.

 
{code:java}
@Override
public boolean isUseAdviceWith() {
    return true;
}
{code}",davsclaus,Bug,Major,Resolved,"WeaveByType not working for OnExceptionDefinition in camel 2.21.0 Below is my route
{code:java}
OnException(Exception.class).handled(true).process(EXCEPTION_PROCESSOR).end()

from(""file:"").process(SOME_PROCESSOR).to(""file:"");
{code}
During testing i want to investigate each exchange which goes through OnException block , for which i tried below
{code:java}
weaveByType(OnExceptionDefinition.class).after()
                    .to(assertEndpoint)
{code}
when i ran the test i got below error
{code:java}
java.lang.IllegalArgumentException: There are no outputs which matches: OnExceptionDefinition in the route
{code}
Could you please help in resolving this issue? Please note i have tried adding code mentioned below in test class, but still the same issue.

 
{code:java}
@Override
public boolean isUseAdviceWith() {
    return true;
}
{code}"
CAMEL-12882,Camel Jms headers missing if producer endpoint has transferExchange=true,The JMS headers are not being extracted if you use transferExchange=true.,davsclaus,Bug,Minor,Resolved,Camel Jms headers missing if producer endpoint has transferExchange=true The JMS headers are not being extracted if you use transferExchange=true.
CAMEL-12872,"When no route is defined, mention in log that it is the reason why it shutdowns the Camel Context automatically","When starting a project and that no Camel route are found, the camel context is shutdown immediately.

it would be nice to have a trace  in log mentioning the reason.
maybe also refer to some documentation on how to configure routes?",davsclaus,Improvement,Minor,Resolved,"When no route is defined, mention in log that it is the reason why it shutdowns the Camel Context automatically When starting a project and that no Camel route are found, the camel context is shutdown immediately.

it would be nice to have a trace  in log mentioning the reason.
maybe also refer to some documentation on how to configure routes?"
CAMEL-12868,Camel project generated from spring initalzr is shutdowning immediately after start,"- go to https://start.spring.io/
- let default values for ""generate a Maven project with Java and Spring Boot 2.0.5""
- add Camel dependencies
- expand zipped project
- launch mvn spring-boot:run
- Camel is started and then shutdowned immediately instead of letting the application running

{noformat}
C:\ws\workingDirectoryForTest\test-project-generated-from-start-spring-io\demo>mvn spring-boot:run
[INFO] Scanning for projects...
[INFO]
[INFO] ------------------------------------------------------------------------
[INFO] Building demo 0.0.1-SNAPSHOT
[INFO] ------------------------------------------------------------------------
[INFO]
[INFO] >>> spring-boot-maven-plugin:2.0.5.RELEASE:run (default-cli) > test-compile @ demo >>>
[INFO]
[INFO] --- maven-resources-plugin:3.0.2:resources (default-resources) @ demo ---
[INFO] Using 'UTF-8' encoding to copy filtered resources.
[INFO] Copying 1 resource
[INFO] Copying 0 resource
[INFO]
[INFO] --- maven-compiler-plugin:3.7.0:compile (default-compile) @ demo ---
[INFO] Changes detected - recompiling the module!
[INFO] Compiling 1 source file to C:\ws\workingDirectoryForTest\test-project-generated-from-start-spring-io\demo\target\classes
[INFO]
[INFO] --- maven-resources-plugin:3.0.2:testResources (default-testResources) @ demo ---
[INFO] Using 'UTF-8' encoding to copy filtered resources.
[INFO] skip non existing resourceDirectory C:\ws\workingDirectoryForTest\test-project-generated-from-start-spring-io\demo\src\test\resources
[INFO]
[INFO] --- maven-compiler-plugin:3.7.0:testCompile (default-testCompile) @ demo ---
[INFO] Changes detected - recompiling the module!
[INFO] Compiling 1 source file to C:\ws\workingDirectoryForTest\test-project-generated-from-start-spring-io\demo\target\test-classes
[INFO]
[INFO] <<< spring-boot-maven-plugin:2.0.5.RELEASE:run (default-cli) < test-compile @ demo <<<
[INFO]
[INFO] --- spring-boot-maven-plugin:2.0.5.RELEASE:run (default-cli) @ demo ---

  .   ____          _            __ _ _
 /\\ / ___'_ __ _ _(_)_ __  __ _ \ \ \ \
( ( )\___ | '_ | '_| | '_ \/ _` | \ \ \ \
 \\/  ___)| |_)| | | | | || (_| |  ) ) ) )
  '  |____| .__|_| |_|_| |_\__, | / / / /
 =========|_|==============|___/=/_/_/_/
 :: Spring Boot ::        (v2.0.5.RELEASE)

2018-10-08 16:25:13.240  INFO 18328 --- [           main] com.example.demo.DemoApplication         : Starting DemoApplication on DESKTOP-9NT300B with PID 18328 (C:\ws\workingDirectoryForTest\test-project-generated-from-start-spring-io\demo\target\classes started by Aurelien Pupier in C:\ws\workingDirectoryForTest\test-project-generated-from-start-spring-io\demo)
2018-10-08 16:25:13.243  INFO 18328 --- [           main] com.example.demo.DemoApplication         : No active profile set, falling back
to default profiles: default
2018-10-08 16:25:13.283  INFO 18328 --- [           main] s.c.a.AnnotationConfigApplicationContext : Refreshing org.springframework.context.annotation.AnnotationConfigApplicationContext@5fc55560: startup date [Mon Oct 08 16:25:13 CEST 2018]; root of context hierarchy
2018-10-08 16:25:14.102  INFO 18328 --- [           main] trationDelegate$BeanPostProcessorChecker : Bean 'org.apache.camel.spring.boot.CamelAutoConfiguration' of type [org.apache.camel.spring.boot.CamelAutoConfiguration$$EnhancerBySpringCGLIB$$cae74b74] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2018-10-08 16:25:14.283  INFO 18328 --- [           main] o.a.c.i.converter.DefaultTypeConverter   : Type converters loaded (core: 195, classpath: 1)
2018-10-08 16:25:14.788  INFO 18328 --- [           main] o.s.j.e.a.AnnotationMBeanExporter        : Registering beans for JMX exposure on startup
2018-10-08 16:25:14.804  INFO 18328 --- [           main] o.a.camel.spring.boot.RoutesCollector    : Loading additional Camel XML routes
from: classpath:camel/*.xml
2018-10-08 16:25:14.805  INFO 18328 --- [           main] o.a.camel.spring.boot.RoutesCollector    : Loading additional Camel XML rests from: classpath:camel-rest/*.xml
2018-10-08 16:25:14.814  INFO 18328 --- [           main] o.a.camel.spring.SpringCamelContext      : Apache Camel 2.22.1 (CamelContext: camel-1) is starting
2018-10-08 16:25:14.817  INFO 18328 --- [           main] o.a.c.m.ManagedManagementStrategy        : JMX is enabled
2018-10-08 16:25:14.981  INFO 18328 --- [           main] o.a.camel.spring.SpringCamelContext      : StreamCaching is not in use. If using streams then its recommended to enable stream caching. See more details at http://camel.apache.org/stream-caching.html
2018-10-08 16:25:14.983  INFO 18328 --- [           main] o.a.camel.spring.SpringCamelContext      : Total 0 routes, of which 0 are started
2018-10-08 16:25:14.984  INFO 18328 --- [           main] o.a.camel.spring.SpringCamelContext      : Apache Camel 2.22.1 (CamelContext: camel-1) started in 0.169 seconds
2018-10-08 16:25:14.988  INFO 18328 --- [           main] com.example.demo.DemoApplication         : Started DemoApplication in 2.083 seconds (JVM running for 8.856)
[INFO] ------------------------------------------------------------------------
[INFO] BUILD SUCCESS
[INFO] ------------------------------------------------------------------------
[INFO] Total time: 6.266 s
[INFO] Finished at: 2018-10-08T16:25:14+02:00
[INFO] Final Memory: 48M/575M
[INFO] ------------------------------------------------------------------------
2018-10-08 16:25:15.274  INFO 18328 --- [       Thread-2] s.c.a.AnnotationConfigApplicationContext : Closing org.springframework.context.annotation.AnnotationConfigApplicationContext@5fc55560: startup date [Mon Oct 08 16:25:13 CEST 2018]; root of context hierarchy
2018-10-08 16:25:15.277  INFO 18328 --- [       Thread-2] o.s.c.support.DefaultLifecycleProcessor  : Stopping beans in phase 2147483647
2018-10-08 16:25:15.278  INFO 18328 --- [       Thread-2] o.a.camel.spring.SpringCamelContext      : Apache Camel 2.22.1 (CamelContext: camel-1) is shutting down
2018-10-08 16:25:15.300  INFO 18328 --- [       Thread-2] o.a.camel.spring.SpringCamelContext      : Apache Camel 2.22.1 (CamelContext: camel-1) uptime 0.486 seconds
2018-10-08 16:25:15.301  INFO 18328 --- [       Thread-2] o.a.camel.spring.SpringCamelContext      : Apache Camel 2.22.1 (CamelContext: camel-1) is shutdown in 0.022 seconds
2018-10-08 16:25:15.301  INFO 18328 --- [       Thread-2] o.s.j.e.a.AnnotationMBeanExporter        : Unregistering JMX-exposed beans on shutdown
{noformat}",davsclaus,Improvement,Major,Resolved,"Camel project generated from spring initalzr is shutdowning immediately after start - go to https://start.spring.io/
- let default values for ""generate a Maven project with Java and Spring Boot 2.0.5""
- add Camel dependencies
- expand zipped project
- launch mvn spring-boot:run
- Camel is started and then shutdowned immediately instead of letting the application running

{noformat}
C:\ws\workingDirectoryForTest\test-project-generated-from-start-spring-io\demo>mvn spring-boot:run
[INFO] Scanning for projects...
[INFO]
[INFO] ------------------------------------------------------------------------
[INFO] Building demo 0.0.1-SNAPSHOT
[INFO] ------------------------------------------------------------------------
[INFO]
[INFO] >>> spring-boot-maven-plugin:2.0.5.RELEASE:run (default-cli) > test-compile @ demo >>>
[INFO]
[INFO] --- maven-resources-plugin:3.0.2:resources (default-resources) @ demo ---
[INFO] Using 'UTF-8' encoding to copy filtered resources.
[INFO] Copying 1 resource
[INFO] Copying 0 resource
[INFO]
[INFO] --- maven-compiler-plugin:3.7.0:compile (default-compile) @ demo ---
[INFO] Changes detected - recompiling the module!
[INFO] Compiling 1 source file to C:\ws\workingDirectoryForTest\test-project-generated-from-start-spring-io\demo\target\classes
[INFO]
[INFO] --- maven-resources-plugin:3.0.2:testResources (default-testResources) @ demo ---
[INFO] Using 'UTF-8' encoding to copy filtered resources.
[INFO] skip non existing resourceDirectory C:\ws\workingDirectoryForTest\test-project-generated-from-start-spring-io\demo\src\test\resources
[INFO]
[INFO] --- maven-compiler-plugin:3.7.0:testCompile (default-testCompile) @ demo ---
[INFO] Changes detected - recompiling the module!
[INFO] Compiling 1 source file to C:\ws\workingDirectoryForTest\test-project-generated-from-start-spring-io\demo\target\test-classes
[INFO]
[INFO] <<< spring-boot-maven-plugin:2.0.5.RELEASE:run (default-cli) < test-compile @ demo <<<
[INFO]
[INFO] --- spring-boot-maven-plugin:2.0.5.RELEASE:run (default-cli) @ demo ---

  .   ____          _            __ _ _
 /\\ / ___'_ __ _ _(_)_ __  __ _ \ \ \ \
( ( )\___ | '_ | '_| | '_ \/ _` | \ \ \ \
 \\/  ___)| |_)| | | | | || (_| |  ) ) ) )
  '  |____| .__|_| |_|_| |_\__, | / / / /
 =========|_|==============|___/=/_/_/_/
 :: Spring Boot ::        (v2.0.5.RELEASE)

2018-10-08 16:25:13.240  INFO 18328 --- [           main] com.example.demo.DemoApplication         : Starting DemoApplication on DESKTOP-9NT300B with PID 18328 (C:\ws\workingDirectoryForTest\test-project-generated-from-start-spring-io\demo\target\classes started by Aurelien Pupier in C:\ws\workingDirectoryForTest\test-project-generated-from-start-spring-io\demo)
2018-10-08 16:25:13.243  INFO 18328 --- [           main] com.example.demo.DemoApplication         : No active profile set, falling back
to default profiles: default
2018-10-08 16:25:13.283  INFO 18328 --- [           main] s.c.a.AnnotationConfigApplicationContext : Refreshing org.springframework.context.annotation.AnnotationConfigApplicationContext@5fc55560: startup date [Mon Oct 08 16:25:13 CEST 2018]; root of context hierarchy
2018-10-08 16:25:14.102  INFO 18328 --- [           main] trationDelegate$BeanPostProcessorChecker : Bean 'org.apache.camel.spring.boot.CamelAutoConfiguration' of type [org.apache.camel.spring.boot.CamelAutoConfiguration$$EnhancerBySpringCGLIB$$cae74b74] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2018-10-08 16:25:14.283  INFO 18328 --- [           main] o.a.c.i.converter.DefaultTypeConverter   : Type converters loaded (core: 195, classpath: 1)
2018-10-08 16:25:14.788  INFO 18328 --- [           main] o.s.j.e.a.AnnotationMBeanExporter        : Registering beans for JMX exposure on startup
2018-10-08 16:25:14.804  INFO 18328 --- [           main] o.a.camel.spring.boot.RoutesCollector    : Loading additional Camel XML routes
from: classpath:camel/*.xml
2018-10-08 16:25:14.805  INFO 18328 --- [           main] o.a.camel.spring.boot.RoutesCollector    : Loading additional Camel XML rests from: classpath:camel-rest/*.xml
2018-10-08 16:25:14.814  INFO 18328 --- [           main] o.a.camel.spring.SpringCamelContext      : Apache Camel 2.22.1 (CamelContext: camel-1) is starting
2018-10-08 16:25:14.817  INFO 18328 --- [           main] o.a.c.m.ManagedManagementStrategy        : JMX is enabled
2018-10-08 16:25:14.981  INFO 18328 --- [           main] o.a.camel.spring.SpringCamelContext      : StreamCaching is not in use. If using streams then its recommended to enable stream caching. See more details at http://camel.apache.org/stream-caching.html
2018-10-08 16:25:14.983  INFO 18328 --- [           main] o.a.camel.spring.SpringCamelContext      : Total 0 routes, of which 0 are started
2018-10-08 16:25:14.984  INFO 18328 --- [           main] o.a.camel.spring.SpringCamelContext      : Apache Camel 2.22.1 (CamelContext: camel-1) started in 0.169 seconds
2018-10-08 16:25:14.988  INFO 18328 --- [           main] com.example.demo.DemoApplication         : Started DemoApplication in 2.083 seconds (JVM running for 8.856)
[INFO] ------------------------------------------------------------------------
[INFO] BUILD SUCCESS
[INFO] ------------------------------------------------------------------------
[INFO] Total time: 6.266 s
[INFO] Finished at: 2018-10-08T16:25:14+02:00
[INFO] Final Memory: 48M/575M
[INFO] ------------------------------------------------------------------------
2018-10-08 16:25:15.274  INFO 18328 --- [       Thread-2] s.c.a.AnnotationConfigApplicationContext : Closing org.springframework.context.annotation.AnnotationConfigApplicationContext@5fc55560: startup date [Mon Oct 08 16:25:13 CEST 2018]; root of context hierarchy
2018-10-08 16:25:15.277  INFO 18328 --- [       Thread-2] o.s.c.support.DefaultLifecycleProcessor  : Stopping beans in phase 2147483647
2018-10-08 16:25:15.278  INFO 18328 --- [       Thread-2] o.a.camel.spring.SpringCamelContext      : Apache Camel 2.22.1 (CamelContext: camel-1) is shutting down
2018-10-08 16:25:15.300  INFO 18328 --- [       Thread-2] o.a.camel.spring.SpringCamelContext      : Apache Camel 2.22.1 (CamelContext: camel-1) uptime 0.486 seconds
2018-10-08 16:25:15.301  INFO 18328 --- [       Thread-2] o.a.camel.spring.SpringCamelContext      : Apache Camel 2.22.1 (CamelContext: camel-1) is shutdown in 0.022 seconds
2018-10-08 16:25:15.301  INFO 18328 --- [       Thread-2] o.s.j.e.a.AnnotationMBeanExporter        : Unregistering JMX-exposed beans on shutdown
{noformat}"
CAMEL-12864,rest: Host header should not overwrite host attribute on rest-swagger component,"When defining a rest-swagger component

{code}
@Bean
 public Component mobile(CamelContext camelContext) throws URISyntaxException

{ RestSwaggerComponent mobile = new RestSwaggerComponent(camelContext); mobile.setHost(mobileHost); mobile.setBasePath(mobileBasePath); mobile.setSpecificationUri( new URI(mobileSpecificationPath)); mobile.setComponentName(""http4""); return mobile; }
{code}

in the following route (rest-endpoint missing, this is calling direct:getMobileAccountById) the host attribute is overwritten by the previous host header (therefore removeHeader needs to be called prior to invocation of the rest-swagger endpoint):(

{code}
from(""direct:getMobileAccountById"").routeId(""getMobileAccountById"")
 .setHeader(""customerId"", simple(""headers.mobileAndFixedlineCustomerId.split(',')[1]""))
 .removeHeader(""Host"")
 .to(""mobile:getAccountById"")
 .unmarshal(gsonDataFormatMobile)
 .log(""Just got called for Mobile"");
{code}

The attribute host should not be overwritten by the host-header, if it is set explicitly on the component.

 ",davsclaus,Improvement,Minor,Resolved,"rest: Host header should not overwrite host attribute on rest-swagger component When defining a rest-swagger component

{code}
@Bean
 public Component mobile(CamelContext camelContext) throws URISyntaxException

{ RestSwaggerComponent mobile = new RestSwaggerComponent(camelContext); mobile.setHost(mobileHost); mobile.setBasePath(mobileBasePath); mobile.setSpecificationUri( new URI(mobileSpecificationPath)); mobile.setComponentName(""http4""); return mobile; }
{code}

in the following route (rest-endpoint missing, this is calling direct:getMobileAccountById) the host attribute is overwritten by the previous host header (therefore removeHeader needs to be called prior to invocation of the rest-swagger endpoint):(

{code}
from(""direct:getMobileAccountById"").routeId(""getMobileAccountById"")
 .setHeader(""customerId"", simple(""headers.mobileAndFixedlineCustomerId.split(',')[1]""))
 .removeHeader(""Host"")
 .to(""mobile:getAccountById"")
 .unmarshal(gsonDataFormatMobile)
 .log(""Just got called for Mobile"");
{code}

The attribute host should not be overwritten by the host-header, if it is set explicitly on the component.

 "
CAMEL-12847,IntrospectionSupport - Allow to use dash style naming,"See ticket
https://github.com/apache/camel-k/issues/142",davsclaus,New Feature,Major,Resolved,"IntrospectionSupport - Allow to use dash style naming See ticket
https://github.com/apache/camel-k/issues/142"
CAMEL-12844,splitter with grouping looses encoding property,"Reported on user list and today also on gitter
http://camel.465427.n5.nabble.com/File-Encoding-falls-back-to-default-encoding-while-grouping-after-split-using-tokenize-td5797769.html

Jakob Krejberg Ørhøj @jakoborhoj_twitter Sep 28 12:30
Hello. I've been battling with some encoding issues when using split().tokenize() in Camel. I am having the same issue as described in: http://camel.465427.n5.nabble.com/File-Encoding-falls-back-to-default-encoding-while-grouping-after-split-using-tokenize-td5797769.html. Is it a bug that Camel does not pass the exchange to the converter so that it can get the encoding set in the exchange? Currently it will always default to UTF-8 as I see it.",davsclaus,Bug,Major,Resolved,"splitter with grouping looses encoding property Reported on user list and today also on gitter
http://camel.465427.n5.nabble.com/File-Encoding-falls-back-to-default-encoding-while-grouping-after-split-using-tokenize-td5797769.html

Jakob Krejberg Orhoj @jakoborhoj_twitter Sep 28 12:30
Hello. I've been battling with some encoding issues when using split().tokenize() in Camel. I am having the same issue as described in: http://camel.465427.n5.nabble.com/File-Encoding-falls-back-to-default-encoding-while-grouping-after-split-using-tokenize-td5797769.html. Is it a bug that Camel does not pass the exchange to the converter so that it can get the encoding set in the exchange? Currently it will always default to UTF-8 as I see it."
CAMEL-12841,camel-restdsl-swagger:generate - Add restConfiguration with common defaults,"We should add restConfiguration in the generated DSL source code so the Camel developer can see the configuration bits there, and more easily be able to configure rest-dsl options.

We should detect which component is on the classpath and choose, eg jetty / servlet etc.",davsclaus,New Feature,Major,Resolved,"camel-restdsl-swagger:generate - Add restConfiguration with common defaults We should add restConfiguration in the generated DSL source code so the Camel developer can see the configuration bits there, and more easily be able to configure rest-dsl options.

We should detect which component is on the classpath and choose, eg jetty / servlet etc."
CAMEL-12836,Type Converter Loader Exception: Elasticsearch-Rest cannot find any in package defined,"{code:java}
{{Error creating bean with name 'servletEndpointRegistrar' defined in class path resource [org/springframework/boot/actuate/autoconfigure/endpoint/web/ServletEndpointManagementContextConfiguration$WebMvcServletEndpointManagementContextConfiguration.class]: Bean instantiation via factory method failed; nested exception is org.springframework.beans.BeanInstantiationException: Failed to instantiate [org.springframework.boot.actuate.endpoint.web.ServletEndpointRegistrar]: Factory method 'servletEndpointRegistrar' threw exception; nested exception is org.springframework.beans.factory.UnsatisfiedDependencyException: Error creating bean with name 'routeControllerEndpoint' defined in class path resource [org/apache/camel/spring/boot/actuate/endpoint/CamelRouteControllerEndpointAutoConfiguration.class]: Unsatisfied dependency expressed through method 'routeControllerEndpoint' parameter 0; nested exception is org.springframework.beans.factory.BeanCreationException: Error creating bean with name 'camelContext' defined in class path resource [org/apache/camel/spring/boot/CamelAutoConfiguration.class]: Bean instantiation via factory method failed; nested exception is org.springframework.beans.BeanInstantiationException: Failed to instantiate [org.apache.camel.CamelContext]: Factory method 'camelContext' threw exception; nested exception is org.apache.camel.RuntimeCamelException: org.apache.camel.TypeConverterLoaderException: Failed to load type converters because of: Cannot find any type converter classes from the following packages: [org.apache.camel.component.elasticsearch.converter] }}{code}
 

 

A possible solution to this is to use FQN class names instead of package name",davsclaus,Bug,Major,Resolved,"Type Converter Loader Exception: Elasticsearch-Rest cannot find any in package defined {code:java}
{{Error creating bean with name 'servletEndpointRegistrar' defined in class path resource [org/springframework/boot/actuate/autoconfigure/endpoint/web/ServletEndpointManagementContextConfiguration$WebMvcServletEndpointManagementContextConfiguration.class]: Bean instantiation via factory method failed; nested exception is org.springframework.beans.BeanInstantiationException: Failed to instantiate [org.springframework.boot.actuate.endpoint.web.ServletEndpointRegistrar]: Factory method 'servletEndpointRegistrar' threw exception; nested exception is org.springframework.beans.factory.UnsatisfiedDependencyException: Error creating bean with name 'routeControllerEndpoint' defined in class path resource [org/apache/camel/spring/boot/actuate/endpoint/CamelRouteControllerEndpointAutoConfiguration.class]: Unsatisfied dependency expressed through method 'routeControllerEndpoint' parameter 0; nested exception is org.springframework.beans.factory.BeanCreationException: Error creating bean with name 'camelContext' defined in class path resource [org/apache/camel/spring/boot/CamelAutoConfiguration.class]: Bean instantiation via factory method failed; nested exception is org.springframework.beans.BeanInstantiationException: Failed to instantiate [org.apache.camel.CamelContext]: Factory method 'camelContext' threw exception; nested exception is org.apache.camel.RuntimeCamelException: org.apache.camel.TypeConverterLoaderException: Failed to load type converters because of: Cannot find any type converter classes from the following packages: [org.apache.camel.component.elasticsearch.converter] }}{code}
 

 

A possible solution to this is to use FQN class names instead of package name"
CAMEL-12835,camel-json-validator - Potential issue with reading from streams,"See SO
https://stackoverflow.com/questions/52228692/camel-json-validator-throws-stream-closed-exception?noredirect=1#comment91912061_52228692",davsclaus,Bug,Major,Resolved,"camel-json-validator - Potential issue with reading from streams See SO
https://stackoverflow.com/questions/52228692/camel-json-validator-throws-stream-closed-exception?noredirect=1#comment91912061_52228692"
CAMEL-12828,camel-restdsl-swagger:generate - Add option to generate dto objects,"We should add an option to generete DTO objects defined in the swagger json file. But we should not create our own logic that does that, but execute the existing swagger-codegen maven plugin and then have some default convention. And make this useable for 90% of the use-cases, and if people need more advanced dto generation then they can use the swagger-codegen maven plugin as-is.

We should add some documentation on both situations and maybe a little example as well.",davsclaus,New Feature,Major,Resolved,"camel-restdsl-swagger:generate - Add option to generate dto objects We should add an option to generete DTO objects defined in the swagger json file. But we should not create our own logic that does that, but execute the existing swagger-codegen maven plugin and then have some default convention. And make this useable for 90% of the use-cases, and if people need more advanced dto generation then they can use the swagger-codegen maven plugin as-is.

We should add some documentation on both situations and maybe a little example as well."
CAMEL-12827,camel-http-common HttpSendDynamicAware setting port to -1 when port is not defined in uri,"If the route qualifies for SendDyanamicAware processing within the camel-http or camel-http4 component and the route does not specify a port it is getting set to -1.  This should simply assume port 80 or 443 based on http vs https.  Logic exists to trim those ports if they are specified however if you omit them your get the following exception:

 
{code:java}
2018-09-21T16:20:32,797 | ERROR | Camel (camel-2) thread #10 - NettyEventExecutorGroup | AbstractErrorListProcessor       | 26 - com.somebundle - 1.0.76 | Error Handled for route: http://0.0.0.0:8880/%7BsiteId%7D/%7Bcountry%7D/somepath?httpMethodRestrict=GET
org.apache.camel.ResolveEndpointFailedException: Failed to resolve endpoint: https4://somedomain.com:-1?bridgeEndpoint=true due to: Expected scheme-specific part at index 6: https:
    at org.apache.camel.impl.DefaultCamelContext.getEndpoint(DefaultCamelContext.java:758) ~[91:org.apache.camel.camel-core:2.22.0]
    at org.apache.camel.util.CamelContextHelper.getMandatoryEndpoint(CamelContextHelper.java:80) ~[91:org.apache.camel.camel-core:2.22.0]
    at org.apache.camel.util.ExchangeHelper.resolveEndpoint(ExchangeHelper.java:91) ~[91:org.apache.camel.camel-core:2.22.0]
    at org.apache.camel.processor.SendDynamicProcessor.resolveEndpoint(SendDynamicProcessor.java:239) ~[91:org.apache.camel.camel-core:2.22.0]
    at org.apache.camel.processor.SendDynamicProcessor.process(SendDynamicProcessor.java:132) ~[91:org.apache.camel.camel-core:2.22.0]
    at org.apache.camel.processor.interceptor.TraceInterceptor.process(TraceInterceptor.java:181) ~[91:org.apache.camel.camel-core:2.22.0]
    at org.apache.camel.processor.InterceptorToAsyncProcessorBridge.process(InterceptorToAsyncProcessorBridge.java:67) ~[91:org.apache.camel.camel-core:2.22.0]{code}",davsclaus,Bug,Major,Resolved,"camel-http-common HttpSendDynamicAware setting port to -1 when port is not defined in uri If the route qualifies for SendDyanamicAware processing within the camel-http or camel-http4 component and the route does not specify a port it is getting set to -1.  This should simply assume port 80 or 443 based on http vs https.  Logic exists to trim those ports if they are specified however if you omit them your get the following exception:

 
{code:java}
2018-09-21T16:20:32,797 | ERROR | Camel (camel-2) thread #10 - NettyEventExecutorGroup | AbstractErrorListProcessor       | 26 - com.somebundle - 1.0.76 | Error Handled for route: http://0.0.0.0:8880/%7BsiteId%7D/%7Bcountry%7D/somepath?httpMethodRestrict=GET
org.apache.camel.ResolveEndpointFailedException: Failed to resolve endpoint: https4://somedomain.com:-1?bridgeEndpoint=true due to: Expected scheme-specific part at index 6: https:
    at org.apache.camel.impl.DefaultCamelContext.getEndpoint(DefaultCamelContext.java:758) ~[91:org.apache.camel.camel-core:2.22.0]
    at org.apache.camel.util.CamelContextHelper.getMandatoryEndpoint(CamelContextHelper.java:80) ~[91:org.apache.camel.camel-core:2.22.0]
    at org.apache.camel.util.ExchangeHelper.resolveEndpoint(ExchangeHelper.java:91) ~[91:org.apache.camel.camel-core:2.22.0]
    at org.apache.camel.processor.SendDynamicProcessor.resolveEndpoint(SendDynamicProcessor.java:239) ~[91:org.apache.camel.camel-core:2.22.0]
    at org.apache.camel.processor.SendDynamicProcessor.process(SendDynamicProcessor.java:132) ~[91:org.apache.camel.camel-core:2.22.0]
    at org.apache.camel.processor.interceptor.TraceInterceptor.process(TraceInterceptor.java:181) ~[91:org.apache.camel.camel-core:2.22.0]
    at org.apache.camel.processor.InterceptorToAsyncProcessorBridge.process(InterceptorToAsyncProcessorBridge.java:67) ~[91:org.apache.camel.camel-core:2.22.0]{code}"
CAMEL-12824,camel-route-parser - Add parser for rest-dsl,So we can have better tooling for rest-dsl,davsclaus,New Feature,Major,Resolved,camel-route-parser - Add parser for rest-dsl So we can have better tooling for rest-dsl
CAMEL-12822,camel-http4 - Expose connection pool stats in JMX,"So end users can track the stats of the client connection pool, for example to see when all connections are in use, or the number of idle connections and so on.",davsclaus,New Feature,Major,Resolved,"camel-http4 - Expose connection pool stats in JMX So end users can track the stats of the client connection pool, for example to see when all connections are in use, or the number of idle connections and so on."
CAMEL-12821,Fix MQTT URI param typo,The URI params 'willQos' and 'qualityOfService' of the MQTT component have a typo in their enum description.,davsclaus,Bug,Trivial,Resolved,Fix MQTT URI param typo The URI params 'willQos' and 'qualityOfService' of the MQTT component have a typo in their enum description.
CAMEL-12805,camel-restdsl-swagger-plugin doesn't convert integer default value to string,"When generating a RouteBuilder from a swagger that defines default parameter values of type integer, there is no conversion to a string when setting it:

Swagger:

""limit"":{
 ""name"":""limit"",
 ""in"":""query"",
 ""type"":""integer"",
 ""minimum"":1,
 ""default"":20,
 ""description"":""the limit of the results for the collections query""
 },

RouteBuilder:

.param()
 .name(""limit"")
 .type(RestParamType.query)
 .dataType(""integer"")
 .defaultValue(20)
 .required(false)
 .description(""the limit of the results for the collections query"")
 .endParam()

defaultValue only accepts parameters of type string and therefore the generated code can't be compiled and needs to be corrected manually.

 

 

 ",davsclaus,Bug,Major,Resolved,"camel-restdsl-swagger-plugin doesn't convert integer default value to string When generating a RouteBuilder from a swagger that defines default parameter values of type integer, there is no conversion to a string when setting it:

Swagger:

""limit"":{
 ""name"":""limit"",
 ""in"":""query"",
 ""type"":""integer"",
 ""minimum"":1,
 ""default"":20,
 ""description"":""the limit of the results for the collections query""
 },

RouteBuilder:

.param()
 .name(""limit"")
 .type(RestParamType.query)
 .dataType(""integer"")
 .defaultValue(20)
 .required(false)
 .description(""the limit of the results for the collections query"")
 .endParam()

defaultValue only accepts parameters of type string and therefore the generated code can't be compiled and needs to be corrected manually.

 

 

 "
CAMEL-12782,swagger-java - Provide more clear exception when model class is not visible to ClassResolver,"Within an OSGi the camel-swagger-java component be run within a different bundle than the routes and models required to generate the swagger document.  In this case the swagger code may not be able to read the model.  Currently this generates a Nullpointer Exception and the swagger document does not get rendered. 

Would prefer that the exception be more specific to help developers with debugging.  Also toyed with the idea of converting to a LOG statement instead of an exception but it may be better to fail fast.

 
{code:java}
org.apache.camel.camel-swagger-java - 2.22.0 | Error rendering Swagger API due null
java.lang.NullPointerException: null
    at org.apache.camel.swagger.RestModelConverters.readClass(RestModelConverters.java:32) ~[108:org.apache.camel.camel-swagger-java:2.22.0]
    at org.apache.camel.swagger.RestSwaggerReader.appendModels(RestSwaggerReader.java:755) ~[108:org.apache.camel.camel-swagger-java:2.22.0]
    at org.apache.camel.swagger.RestSwaggerReader.parse(RestSwaggerReader.java:227) ~[108:org.apache.camel.camel-swagger-java:2.22.0]
    at org.apache.camel.swagger.RestSwaggerReader.read(RestSwaggerReader.java:113) ~[108:org.apache.camel.camel-swagger-java:2.22.0]
    at org.apache.camel.swagger.RestSwaggerSupport.renderResourceListing(RestSwaggerSupport.java:210) ~[108:org.apache.camel.camel-swagger-java:2.22.0]
    at org.apache.camel.swagger.RestSwaggerProcessor.process(RestSwaggerProcessor.java:119) [108:org.apache.camel.camel-swagger-java:2.22.0]
    at org.apache.camel.component.rest.RestApiProducer.process(RestApiProducer.java:36) [89:org.apache.camel.camel-core:2.22.0]
    at org.apache.camel.util.AsyncProcessorConverterHelper$ProcessorToAsyncProcessorBridge.process(AsyncProcessorConverterHelper.java:61) [89:org.apache.camel.camel-core:2.22.0]
    at org.apache.camel.processor.SendProcessor.process(SendProcessor.java:148) [89:org.apache.camel.camel-core:2.22.0]
    at org.apache.camel.processor.interceptor.TraceInterceptor.process(TraceInterceptor.java:181) [89:org.apache.camel.camel-core:2.22.0]
    at org.apache.camel.processor.DelegateAsyncProcessor.process(DelegateAsyncProcessor.java:110) [89:org.apache.camel.camel-core:2.22.0]
    at org.apache.camel.processor.RedeliveryErrorHandler.process(RedeliveryErrorHandler.java:548) [89:org.apache.camel.camel-core:2.22.0]
    at org.apache.camel.processor.CamelInternalProcessor.process(CamelInternalProcessor.java:201) [89:org.apache.camel.camel-core:2.22.0]
    at org.apache.camel.processor.CamelInternalProcessor.process(CamelInternalProcessor.java:201) [89:org.apache.camel.camel-core:2.22.0]
    at org.apache.camel.component.netty4.handlers.ServerChannelHandler.processAsynchronously(ServerChannelHandler.java:141) [105:org.apache.camel.camel-netty4:2.22.0]
    at org.apache.camel.component.netty4.handlers.ServerChannelHandler.channelRead0(ServerChannelHandler.java:112) [105:org.apache.camel.camel-netty4:2.22.0]
    at org.apache.camel.component.netty4.http.handlers.HttpServerChannelHandler.channelRead0(HttpServerChannelHandler.java:213) [106:org.apache.camel.camel-netty4-http:2.22.0]
    at io.netty.channel.SimpleChannelInboundHandler.channelRead(SimpleChannelInboundHandler.java:105) [55:io.netty.transport:4.1.25.Final]
    at org.apache.camel.component.netty4.http.handlers.HttpServerMultiplexChannelHandler.channelRead0(HttpServerMultiplexChannelHandler.java:113) [106:org.apache.camel.camel-netty4-http:2.22.0]
    at io.netty.channel.SimpleChannelInboundHandler.channelRead(SimpleChannelInboundHandler.java:105) [55:io.netty.transport:4.1.25.Final]
    at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:362) [55:io.netty.transport:4.1.25.Final]
    at io.netty.channel.AbstractChannelHandlerContext.access$600(AbstractChannelHandlerContext.java:38) [55:io.netty.transport:4.1.25.Final]
    at io.netty.channel.AbstractChannelHandlerContext$7.run(AbstractChannelHandlerContext.java:353) [55:io.netty.transport:4.1.25.Final]
    at io.netty.util.concurrent.DefaultEventExecutor.run(DefaultEventExecutor.java:66) [51:io.netty.common:4.1.25.Final]
    at io.netty.util.concurrent.SingleThreadEventExecutor$5.run(SingleThreadEventExecutor.java:884) [51:io.netty.common:4.1.25.Final]
    at java.lang.Thread.run(Thread.java:748) [?:?]{code}",davsclaus,Bug,Minor,Resolved,"swagger-java - Provide more clear exception when model class is not visible to ClassResolver Within an OSGi the camel-swagger-java component be run within a different bundle than the routes and models required to generate the swagger document.  In this case the swagger code may not be able to read the model.  Currently this generates a Nullpointer Exception and the swagger document does not get rendered. 

Would prefer that the exception be more specific to help developers with debugging.  Also toyed with the idea of converting to a LOG statement instead of an exception but it may be better to fail fast.

 
{code:java}
org.apache.camel.camel-swagger-java - 2.22.0 | Error rendering Swagger API due null
java.lang.NullPointerException: null
    at org.apache.camel.swagger.RestModelConverters.readClass(RestModelConverters.java:32) ~[108:org.apache.camel.camel-swagger-java:2.22.0]
    at org.apache.camel.swagger.RestSwaggerReader.appendModels(RestSwaggerReader.java:755) ~[108:org.apache.camel.camel-swagger-java:2.22.0]
    at org.apache.camel.swagger.RestSwaggerReader.parse(RestSwaggerReader.java:227) ~[108:org.apache.camel.camel-swagger-java:2.22.0]
    at org.apache.camel.swagger.RestSwaggerReader.read(RestSwaggerReader.java:113) ~[108:org.apache.camel.camel-swagger-java:2.22.0]
    at org.apache.camel.swagger.RestSwaggerSupport.renderResourceListing(RestSwaggerSupport.java:210) ~[108:org.apache.camel.camel-swagger-java:2.22.0]
    at org.apache.camel.swagger.RestSwaggerProcessor.process(RestSwaggerProcessor.java:119) [108:org.apache.camel.camel-swagger-java:2.22.0]
    at org.apache.camel.component.rest.RestApiProducer.process(RestApiProducer.java:36) [89:org.apache.camel.camel-core:2.22.0]
    at org.apache.camel.util.AsyncProcessorConverterHelper$ProcessorToAsyncProcessorBridge.process(AsyncProcessorConverterHelper.java:61) [89:org.apache.camel.camel-core:2.22.0]
    at org.apache.camel.processor.SendProcessor.process(SendProcessor.java:148) [89:org.apache.camel.camel-core:2.22.0]
    at org.apache.camel.processor.interceptor.TraceInterceptor.process(TraceInterceptor.java:181) [89:org.apache.camel.camel-core:2.22.0]
    at org.apache.camel.processor.DelegateAsyncProcessor.process(DelegateAsyncProcessor.java:110) [89:org.apache.camel.camel-core:2.22.0]
    at org.apache.camel.processor.RedeliveryErrorHandler.process(RedeliveryErrorHandler.java:548) [89:org.apache.camel.camel-core:2.22.0]
    at org.apache.camel.processor.CamelInternalProcessor.process(CamelInternalProcessor.java:201) [89:org.apache.camel.camel-core:2.22.0]
    at org.apache.camel.processor.CamelInternalProcessor.process(CamelInternalProcessor.java:201) [89:org.apache.camel.camel-core:2.22.0]
    at org.apache.camel.component.netty4.handlers.ServerChannelHandler.processAsynchronously(ServerChannelHandler.java:141) [105:org.apache.camel.camel-netty4:2.22.0]
    at org.apache.camel.component.netty4.handlers.ServerChannelHandler.channelRead0(ServerChannelHandler.java:112) [105:org.apache.camel.camel-netty4:2.22.0]
    at org.apache.camel.component.netty4.http.handlers.HttpServerChannelHandler.channelRead0(HttpServerChannelHandler.java:213) [106:org.apache.camel.camel-netty4-http:2.22.0]
    at io.netty.channel.SimpleChannelInboundHandler.channelRead(SimpleChannelInboundHandler.java:105) [55:io.netty.transport:4.1.25.Final]
    at org.apache.camel.component.netty4.http.handlers.HttpServerMultiplexChannelHandler.channelRead0(HttpServerMultiplexChannelHandler.java:113) [106:org.apache.camel.camel-netty4-http:2.22.0]
    at io.netty.channel.SimpleChannelInboundHandler.channelRead(SimpleChannelInboundHandler.java:105) [55:io.netty.transport:4.1.25.Final]
    at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:362) [55:io.netty.transport:4.1.25.Final]
    at io.netty.channel.AbstractChannelHandlerContext.access$600(AbstractChannelHandlerContext.java:38) [55:io.netty.transport:4.1.25.Final]
    at io.netty.channel.AbstractChannelHandlerContext$7.run(AbstractChannelHandlerContext.java:353) [55:io.netty.transport:4.1.25.Final]
    at io.netty.util.concurrent.DefaultEventExecutor.run(DefaultEventExecutor.java:66) [51:io.netty.common:4.1.25.Final]
    at io.netty.util.concurrent.SingleThreadEventExecutor$5.run(SingleThreadEventExecutor.java:884) [51:io.netty.common:4.1.25.Final]
    at java.lang.Thread.run(Thread.java:748) [?:?]{code}"
CAMEL-12779,camel-spring-redis - When stopping consumer it should stop the message listener,"The consumer needs to remove the message listener when its stopping so it wont continue to receive messages, which otherwise can happen when shutting down Camel graceful.

",davsclaus,Bug,Major,Resolved,"camel-spring-redis - When stopping consumer it should stop the message listener The consumer needs to remove the message listener when its stopping so it wont continue to receive messages, which otherwise can happen when shutting down Camel graceful.

"
CAMEL-12778,CamelCatalog - Should be JMX compliant,"We have this error

Failed
org.apache.camel.catalog.CamelCatalogMBeanExporterTest.testMBeanExporter

Failing for the past 8 builds (Since Unstable#599 )
Took 7 ms.
Error Message
org.apache.camel.catalog.CamelCatalog: Method org.apache.camel.catalog.CamelCatalog.setSuggestionStrategy has parameter or return type that cannot be translated into an open type
Stacktrace
javax.management.NotCompliantMBeanException: org.apache.camel.catalog.CamelCatalog: Method org.apache.camel.catalog.CamelCatalog.setSuggestionStrategy has parameter or return type that cannot be translated into an open type
	at org.apache.camel.catalog.CamelCatalogMBeanExporterTest.testMBeanExporter(CamelCatalogMBeanExporterTest.java:35)
Caused by: java.lang.IllegalArgumentException: Method org.apache.camel.catalog.CamelCatalog.setSuggestionStrategy has parameter or return type that cannot be translated into an open type
	at org.apache.camel.catalog.CamelCatalogMBeanExporterTest.testMBeanExporter(CamelCatalogMBeanExporterTest.java:35)
Caused by: javax.management.openmbean.OpenDataException: Cannot convert type: org.apache.camel.catalog.SuggestionStrategy
	at org.apache.camel.catalog.CamelCatalogMBeanExporterTest.testMBeanExporter(CamelCatalogMBeanExporterTest.java:35)
Caused by: javax.management.openmbean.OpenDataException: Can't map org.apache.camel.catalog.SuggestionStrategy to an open data type
	at org.apache.camel.catalog.CamelCatalogMBeanExporterTest.testMBeanExporter(CamelCatalogMBeanExporterTest.java:35)",davsclaus,Bug,Major,Resolved,"CamelCatalog - Should be JMX compliant We have this error

Failed
org.apache.camel.catalog.CamelCatalogMBeanExporterTest.testMBeanExporter

Failing for the past 8 builds (Since Unstable#599 )
Took 7 ms.
Error Message
org.apache.camel.catalog.CamelCatalog: Method org.apache.camel.catalog.CamelCatalog.setSuggestionStrategy has parameter or return type that cannot be translated into an open type
Stacktrace
javax.management.NotCompliantMBeanException: org.apache.camel.catalog.CamelCatalog: Method org.apache.camel.catalog.CamelCatalog.setSuggestionStrategy has parameter or return type that cannot be translated into an open type
	at org.apache.camel.catalog.CamelCatalogMBeanExporterTest.testMBeanExporter(CamelCatalogMBeanExporterTest.java:35)
Caused by: java.lang.IllegalArgumentException: Method org.apache.camel.catalog.CamelCatalog.setSuggestionStrategy has parameter or return type that cannot be translated into an open type
	at org.apache.camel.catalog.CamelCatalogMBeanExporterTest.testMBeanExporter(CamelCatalogMBeanExporterTest.java:35)
Caused by: javax.management.openmbean.OpenDataException: Cannot convert type: org.apache.camel.catalog.SuggestionStrategy
	at org.apache.camel.catalog.CamelCatalogMBeanExporterTest.testMBeanExporter(CamelCatalogMBeanExporterTest.java:35)
Caused by: javax.management.openmbean.OpenDataException: Can't map org.apache.camel.catalog.SuggestionStrategy to an open data type
	at org.apache.camel.catalog.CamelCatalogMBeanExporterTest.testMBeanExporter(CamelCatalogMBeanExporterTest.java:35)"
CAMEL-12775,Using StubComponent can block routes depending on MEP,"As the name implies and per the documentation 'stub:' should be a no-op.

However, if the exchange pattarn is InOut, routes are actually blocked waiting for a response.

Discovered against camel 2.16.3

Confirmed against Camel 2.22.0 (see attached test-case)

 ",davsclaus,Bug,Major,Resolved,"Using StubComponent can block routes depending on MEP As the name implies and per the documentation 'stub:' should be a no-op.

However, if the exchange pattarn is InOut, routes are actually blocked waiting for a response.

Discovered against camel 2.16.3

Confirmed against Camel 2.22.0 (see attached test-case)

 "
CAMEL-12760,deprecate camel-xmlrpc,This project is no longer active maintained and last release was from 2010,davsclaus,Task,Major,Resolved,deprecate camel-xmlrpc This project is no longer active maintained and last release was from 2010
CAMEL-12757,add camel-jclouds-starter,With SB 1 it was a conflict with a gson library. But now with SB2 we can add a jclouds starter.,davsclaus,Task,Major,Resolved,add camel-jclouds-starter With SB 1 it was a conflict with a gson library. But now with SB2 we can add a jclouds starter.
CAMEL-12756,`@ConditionalOnProperty` target property with no metadata," Several auto-configurations use a condition on a property that has no metadata. As a result, trying to use it to customize the auto-configuration lead to a warning in an IDE.

The report detected the following:
 
{noformat}
org.apache.camel.model.rest.springboot.RestConfigurationDefinitionAutoConfiguration [camel.rest.enabled]
org.apache.camel.spring.boot.TypeConversionConfiguration [camel.springboot.typeConversion]
{noformat}

For the latter, the property in {{@ConditionalOnProperty}} must use the canonical format (i.e. must be {{camel.springboot.type-conversion}})",davsclaus,Improvement,Major,Resolved,"`@ConditionalOnProperty` target property with no metadata  Several auto-configurations use a condition on a property that has no metadata. As a result, trying to use it to customize the auto-configuration lead to a warning in an IDE.

The report detected the following:
 
{noformat}
org.apache.camel.model.rest.springboot.RestConfigurationDefinitionAutoConfiguration [camel.rest.enabled]
org.apache.camel.spring.boot.TypeConversionConfiguration [camel.springboot.typeConversion]
{noformat}

For the latter, the property in {{@ConditionalOnProperty}} must use the canonical format (i.e. must be {{camel.springboot.type-conversion}})"
CAMEL-12755,Upgrade Infinispan,"We should upgrade to a newer version, 9.3.1",davsclaus,Task,Major,Resolved,"Upgrade Infinispan We should upgrade to a newer version, 9.3.1"
CAMEL-12754,Upgrade Apache Ignite,We should upgrade ignite as it has some good fixes needed,davsclaus,Task,Major,Resolved,Upgrade Apache Ignite We should upgrade ignite as it has some good fixes needed
CAMEL-12753,OPTIONS Http request on REST resource returns incorrect content of Allow header,"I have a REST resource which consumes multiple Http methods (for example GET, POST and PUT). If I send OPTIONS request to resource and I expect to receive Allow Http header with this content:
Allow: GET,POST,PUT,OPTIONS
That does not happen because I receive header which contains only two methods one of them is OPTIONS.
Allow: GET,OPTIONS
I have try multiple implementations and only camel-restlet works as I expect. These components contain bug:
camel-undertow
camel-servlet
camel-jetty
camel-netty4-http",davsclaus,Bug,Minor,Resolved,"OPTIONS Http request on REST resource returns incorrect content of Allow header I have a REST resource which consumes multiple Http methods (for example GET, POST and PUT). If I send OPTIONS request to resource and I expect to receive Allow Http header with this content:
Allow: GET,POST,PUT,OPTIONS
That does not happen because I receive header which contains only two methods one of them is OPTIONS.
Allow: GET,OPTIONS
I have try multiple implementations and only camel-restlet works as I expect. These components contain bug:
camel-undertow
camel-servlet
camel-jetty
camel-netty4-http"
CAMEL-12752,Upgrade jetty to 9.4.11,We are using 9.4.6 but there is a 9.4.11 version,davsclaus,Task,Major,Resolved,Upgrade jetty to 9.4.11 We are using 9.4.6 but there is a 9.4.11 version
CAMEL-12746,Temporary reply queues being created with main endpoint autoAck setting,"As discussed here:

[http://camel.465427.n5.nabble.com/Camel-with-Rabbitmq-messages-in-temp-reply-queue-not-being-acked-td5822286.html]

When temporary reply queues are used on InOut capable routes with autoAck set to false on the main queue(s) the reply messages keep piling up in the temporary queue in an un-acked state until a consumer restart.

This can be prevented with a change to the TemporaryQueueReplyManager line 139 to always start the consumer of temprary queues with auto acknowledge mode of true.

Changing this:

    private void start() throws IOException {
        tag = channel.basicConsume(getReplyTo(), endpoint.isAutoAck(), this);
    }

To:

    private void start() throws IOException {
        tag = channel.basicConsume(getReplyTo(), *true*, this);
    }

 ",davsclaus,Bug,Major,Resolved,"Temporary reply queues being created with main endpoint autoAck setting As discussed here:

[http://camel.465427.n5.nabble.com/Camel-with-Rabbitmq-messages-in-temp-reply-queue-not-being-acked-td5822286.html]

When temporary reply queues are used on InOut capable routes with autoAck set to false on the main queue(s) the reply messages keep piling up in the temporary queue in an un-acked state until a consumer restart.

This can be prevented with a change to the TemporaryQueueReplyManager line 139 to always start the consumer of temprary queues with auto acknowledge mode of true.

Changing this:

    private void start() throws IOException {
        tag = channel.basicConsume(getReplyTo(), endpoint.isAutoAck(), this);
    }

To:

    private void start() throws IOException {
        tag = channel.basicConsume(getReplyTo(), *true*, this);
    }

 "
CAMEL-12743,Some @link javadoc notations not handled well in auto-generated adocs,"For example, this javadoc:
https://github.com/apache/camel/blob/master/camel-core/src/main/java/org/apache/camel/model/SplitDefinition.java#L257-L271
{code:java}
    /**
     * When in streaming mode, then the splitter splits the original message on-demand, and each splitted
     * message is processed one by one. This reduces memory usage as the splitter do not split all the messages first,
     * but then we do not know the total size, and therefore the {@link org.apache.camel.Exchange#SPLIT_SIZE} is empty.
     * <p/>
     * In non-streaming mode (default) the splitter will split each message first, to know the total size, and then
     * process each message one by one. This requires to keep all the splitted messages in memory and therefore requires
     * more memory. The total size is provided in the {@link org.apache.camel.Exchange#SPLIT_SIZE} header.
     * <p/>
     * The streaming mode also affects the aggregation behavior.
     * If enabled then Camel will process replies out-of-order, eg in the order they come back.
     * If disabled, Camel will process replies in the same order as the messages was splitted.
     *
     * @return the builder
     */
{code}
is generated to:
https://github.com/apache/camel/blob/master/camel-core/src/main/docs/eips/split-eip.adoc
{code}
When in streaming mode, then the splitter splits the original message on-demand, and each splitted message is processed one by one. This reduces memory usage as the splitter do not split all the messages first, but then we do not know the total size, and therefore the *link* org.apache.camel.ExchangeSPLIT_SIZE is empty. In non-streaming mode (default) the splitter will split each message first, to know the total size, and then process each message one by one. This requires to keep all the splitted messages in memory and therefore requires more memory. The total size is provided in the *link* org.apache.camel.ExchangeSPLIT_SIZE header. The streaming mode also affects the aggregation behavior. If enabled then Camel will process replies out-of-order, eg in the order they come back. If disabled, Camel will process replies in the same order as the messages was splitted.
{code}

It is my impression that the current doc generator handles only FQCN well but fails to handle all other forms of Java source references.",davsclaus,Task,Major,Resolved,"Some @link javadoc notations not handled well in auto-generated adocs For example, this javadoc:
https://github.com/apache/camel/blob/master/camel-core/src/main/java/org/apache/camel/model/SplitDefinition.java#L257-L271
{code:java}
    /**
     * When in streaming mode, then the splitter splits the original message on-demand, and each splitted
     * message is processed one by one. This reduces memory usage as the splitter do not split all the messages first,
     * but then we do not know the total size, and therefore the {@link org.apache.camel.Exchange#SPLIT_SIZE} is empty.
     * <p/>
     * In non-streaming mode (default) the splitter will split each message first, to know the total size, and then
     * process each message one by one. This requires to keep all the splitted messages in memory and therefore requires
     * more memory. The total size is provided in the {@link org.apache.camel.Exchange#SPLIT_SIZE} header.
     * <p/>
     * The streaming mode also affects the aggregation behavior.
     * If enabled then Camel will process replies out-of-order, eg in the order they come back.
     * If disabled, Camel will process replies in the same order as the messages was splitted.
     *
     * @return the builder
     */
{code}
is generated to:
https://github.com/apache/camel/blob/master/camel-core/src/main/docs/eips/split-eip.adoc
{code}
When in streaming mode, then the splitter splits the original message on-demand, and each splitted message is processed one by one. This reduces memory usage as the splitter do not split all the messages first, but then we do not know the total size, and therefore the *link* org.apache.camel.ExchangeSPLIT_SIZE is empty. In non-streaming mode (default) the splitter will split each message first, to know the total size, and then process each message one by one. This requires to keep all the splitted messages in memory and therefore requires more memory. The total size is provided in the *link* org.apache.camel.ExchangeSPLIT_SIZE header. The streaming mode also affects the aggregation behavior. If enabled then Camel will process replies out-of-order, eg in the order they come back. If disabled, Camel will process replies in the same order as the messages was splitted.
{code}

It is my impression that the current doc generator handles only FQCN well but fails to handle all other forms of Java source references."
CAMEL-12740,Olingo4Component creates and ignores HttpAsyncClientBuilder,"The Olingo4Component will create an instance of HttpAsyncClientBuilder is the provided Olingo4Configuration does not contain one. The new instance of HttpAsyncClientBuilder will be configured with timeout settings, proxy and SSL, but will never be used.

Extract from Olingo4Component.createOlingo4App:
{code:java}
Object clientBuilder = configuration.getHttpAsyncClientBuilder();
if (clientBuilder == null) {
    HttpAsyncClientBuilder asyncClientBuilder = HttpAsyncClientBuilder.create();
    Builder requestConfigBuilder = RequestConfig.custom();
    requestConfigBuilder.setConnectTimeout(configuration.getConnectTimeout());
    requestConfigBuilder.setSocketTimeout(configuration.getSocketTimeout());
    HttpHost proxy = configuration.getProxy();
    if (proxy != null) {
        requestConfigBuilder.setProxy(proxy);
    }

    asyncClientBuilder.setDefaultRequestConfig(requestConfigBuilder.build());
    SSLContextParameters sslContextParameters = configuration.getSslContextParameters();
    if (sslContextParameters == null) {
        sslContextParameters = this.retrieveGlobalSslContextParameters();
    }

    if (sslContextParameters == null) {
        sslContextParameters = new SSLContextParameters();
    }

    try {
        asyncClientBuilder.setSSLContext(sslContextParameters.createSSLContext(this.getCamelContext()));
    } catch (GeneralSecurityException var8) {
        throw ObjectHelper.wrapRuntimeCamelException(var8);
    } catch (IOException var9) {
        throw ObjectHelper.wrapRuntimeCamelException(var9);
    }
}

Olingo4AppImpl olingo4App;
if (clientBuilder != null && !(clientBuilder instanceof HttpAsyncClientBuilder)) {
    olingo4App = new Olingo4AppImpl(configuration.getServiceUri(), (HttpClientBuilder)clientBuilder);
} else {
    olingo4App = new Olingo4AppImpl(configuration.getServiceUri(), (HttpAsyncClientBuilder)clientBuilder);
}
{code}
The class Olingo4AppImpl gets a null clientBuilder reference and then instantiates its own:
{code:java}
public Olingo4AppImpl(String serviceUri, HttpAsyncClientBuilder builder) {
    this.odataClient = ODataClientFactory.getClient();
    this.odataReader = this.odataClient.getReader();
    this.odataWriter = this.odataClient.getWriter();
    this.setServiceUri(serviceUri);
    CloseableHttpAsyncClient asyncClient;
    if (builder == null) {
        asyncClient = HttpAsyncClients.createDefault();
    } else {
        asyncClient = builder.build();
    }

    asyncClient.start();
    this.client = asyncClient;
    this.contentType = DEFAULT_CONTENT_TYPE;
}
{code}
Because of this, none of the Olingo4Configuration settings are used and for example connect and socket timeout defaults to -1.",davsclaus,Bug,Major,Resolved,"Olingo4Component creates and ignores HttpAsyncClientBuilder The Olingo4Component will create an instance of HttpAsyncClientBuilder is the provided Olingo4Configuration does not contain one. The new instance of HttpAsyncClientBuilder will be configured with timeout settings, proxy and SSL, but will never be used.

Extract from Olingo4Component.createOlingo4App:
{code:java}
Object clientBuilder = configuration.getHttpAsyncClientBuilder();
if (clientBuilder == null) {
    HttpAsyncClientBuilder asyncClientBuilder = HttpAsyncClientBuilder.create();
    Builder requestConfigBuilder = RequestConfig.custom();
    requestConfigBuilder.setConnectTimeout(configuration.getConnectTimeout());
    requestConfigBuilder.setSocketTimeout(configuration.getSocketTimeout());
    HttpHost proxy = configuration.getProxy();
    if (proxy != null) {
        requestConfigBuilder.setProxy(proxy);
    }

    asyncClientBuilder.setDefaultRequestConfig(requestConfigBuilder.build());
    SSLContextParameters sslContextParameters = configuration.getSslContextParameters();
    if (sslContextParameters == null) {
        sslContextParameters = this.retrieveGlobalSslContextParameters();
    }

    if (sslContextParameters == null) {
        sslContextParameters = new SSLContextParameters();
    }

    try {
        asyncClientBuilder.setSSLContext(sslContextParameters.createSSLContext(this.getCamelContext()));
    } catch (GeneralSecurityException var8) {
        throw ObjectHelper.wrapRuntimeCamelException(var8);
    } catch (IOException var9) {
        throw ObjectHelper.wrapRuntimeCamelException(var9);
    }
}

Olingo4AppImpl olingo4App;
if (clientBuilder != null && !(clientBuilder instanceof HttpAsyncClientBuilder)) {
    olingo4App = new Olingo4AppImpl(configuration.getServiceUri(), (HttpClientBuilder)clientBuilder);
} else {
    olingo4App = new Olingo4AppImpl(configuration.getServiceUri(), (HttpAsyncClientBuilder)clientBuilder);
}
{code}
The class Olingo4AppImpl gets a null clientBuilder reference and then instantiates its own:
{code:java}
public Olingo4AppImpl(String serviceUri, HttpAsyncClientBuilder builder) {
    this.odataClient = ODataClientFactory.getClient();
    this.odataReader = this.odataClient.getReader();
    this.odataWriter = this.odataClient.getWriter();
    this.setServiceUri(serviceUri);
    CloseableHttpAsyncClient asyncClient;
    if (builder == null) {
        asyncClient = HttpAsyncClients.createDefault();
    } else {
        asyncClient = builder.build();
    }

    asyncClient.start();
    this.client = asyncClient;
    this.contentType = DEFAULT_CONTENT_TYPE;
}
{code}
Because of this, none of the Olingo4Configuration settings are used and for example connect and socket timeout defaults to -1."
CAMEL-12739,TypeConverters are not registered to all contexts,"When using multiple Camel contexts in CDI, auto-discovered TypeConverters are registered only to the first encoutered context.",davsclaus,Bug,Major,Resolved,"TypeConverters are not registered to all contexts When using multiple Camel contexts in CDI, auto-discovered TypeConverters are registered only to the first encoutered context."
CAMEL-12736,Create FHIR authorization and transaction quickstart,"Showcase the following features of the underlying HAPI library:

[http://hapifhir.io/doc_rest_client_interceptor.html]

[http://hapifhir.io/doc_rest_client_examples.html#Transaction_With_Placeholder_IDs] 

 ",davsclaus,Task,Major,Resolved,"Create FHIR authorization and transaction quickstart Showcase the following features of the underlying HAPI library:

[http://hapifhir.io/doc_rest_client_interceptor.html]

[http://hapifhir.io/doc_rest_client_examples.html#Transaction_With_Placeholder_IDs] 

 "
CAMEL-12735,XmlRouteParser does not handle usage of xml namespace prefix for camel,"for instance with this file content, using the org.apache.camel.parser.XmlRouteParser.parseXmlRouteEndpoints(InputStream, String, String, List<CamelEndpointDetails>) method will not find the endpoint

{quote}<?xml version=""1.0"" encoding=""UTF-8""?>
<beans xmlns=""http://www.springframework.org/schema/beans""
    xmlns:xsi=""http://www.w3.org/2001/XMLSchema-instance"" xsi:schemaLocation=""        http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd        http://camel.apache.org/schema/spring http://camel.apache.org/schema/spring/camel-spring.xsd"">
    <camel:camelContext id=""camel"" xmlns:camel=""http://camel.apache.org/schema/spring"">
        <camel:endpoint uri=""timer:timerName?delay=p""/>
        <camel:route id=""a route"">
            <camel:from id=""_from1"" uri=""timer:timerName?delay=1000""/>
            <camel:to id=""_to1"" uri=""direct:drink""/>
        </camel:route>
    </camel:camelContext>
</beans>{quote}",davsclaus,Improvement,Major,Resolved,"XmlRouteParser does not handle usage of xml namespace prefix for camel for instance with this file content, using the org.apache.camel.parser.XmlRouteParser.parseXmlRouteEndpoints(InputStream, String, String, List<CamelEndpointDetails>) method will not find the endpoint

{quote}<?xml version=""1.0"" encoding=""UTF-8""?>
<beans xmlns=""http://www.springframework.org/schema/beans""
    xmlns:xsi=""http://www.w3.org/2001/XMLSchema-instance"" xsi:schemaLocation=""        http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd        http://camel.apache.org/schema/spring http://camel.apache.org/schema/spring/camel-spring.xsd"">
    <camel:camelContext id=""camel"" xmlns:camel=""http://camel.apache.org/schema/spring"">
        <camel:endpoint uri=""timer:timerName?delay=p""/>
        <camel:route id=""a route"">
            <camel:from id=""_from1"" uri=""timer:timerName?delay=1000""/>
            <camel:to id=""_to1"" uri=""direct:drink""/>
        </camel:route>
    </camel:camelContext>
</beans>{quote}"
CAMEL-12734,camel-sql - Add support for basic dynamic query parameters in consumer,"See SO
https://stackoverflow.com/questions/51855665/how-to-implement-stateful-polling-sql-consumer-in-camel

It would be nice if we add support for calling simple expressions like beans and the likes, so end users can have dynamic consumer queries in the SQL from routes ",davsclaus,New Feature,Major,Resolved,"camel-sql - Add support for basic dynamic query parameters in consumer See SO
https://stackoverflow.com/questions/51855665/how-to-implement-stateful-polling-sql-consumer-in-camel

It would be nice if we add support for calling simple expressions like beans and the likes, so end users can have dynamic consumer queries in the SQL from routes "
CAMEL-12732,Kafka manual commit to file repository doesn't work properly (using Spring boot),"I'im trying to save the Kafka offset into FileStateRepository, the offset is correctly writing but it is not reading at route start so camel will read all the topic every time

 
{code:java}
@Component
public class Route extends RouteBuilder {
    @Override
    public void configure() throws Exception {
        from(kafka())
                .to(""log:TEST?level=INFO"")
                .process(Route::commitKafka);
    }

    private String kafka() {

        String kafkaEndpoint = ""kafka:"";

        kafkaEndpoint += ""topictest"";
        kafkaEndpoint += ""?brokers="";
        kafkaEndpoint += ""localhost:9092"";
        kafkaEndpoint += ""&groupId="";
        kafkaEndpoint += ""TEST"";
        kafkaEndpoint += ""&autoOffsetReset="";
        kafkaEndpoint += ""earliest"";
        kafkaEndpoint += ""&autoCommitEnable="";
        kafkaEndpoint += false;
        kafkaEndpoint += ""&allowManualCommit="";
        kafkaEndpoint += true;
        kafkaEndpoint += ""&offsetRepository="";
        kafkaEndpoint += ""#fileStore"";

        return kafkaEndpoint;
    }

    @Bean(name = ""fileStore"")
    private FileStateRepository fileStateRepository() {
        FileStateRepository fileStateRepository = FileStateRepository.fileStateRepository(new File(""/kafka/offset_repo/repo.dat""));

        // This will be empty
        // System.out.println(fileStateRepository.getCache());
        return fileStateRepository;
    }

    private static void commitKafka(Exchange exchange) {

        KafkaManualCommit manual = exchange.getIn().getHeader(KafkaConstants.MANUAL_COMMIT, KafkaManualCommit.class);
        manual.commitSync();
    }
}

{code}
 ",davsclaus,Bug,Major,Resolved,"Kafka manual commit to file repository doesn't work properly (using Spring boot) I'im trying to save the Kafka offset into FileStateRepository, the offset is correctly writing but it is not reading at route start so camel will read all the topic every time

 
{code:java}
@Component
public class Route extends RouteBuilder {
    @Override
    public void configure() throws Exception {
        from(kafka())
                .to(""log:TEST?level=INFO"")
                .process(Route::commitKafka);
    }

    private String kafka() {

        String kafkaEndpoint = ""kafka:"";

        kafkaEndpoint += ""topictest"";
        kafkaEndpoint += ""?brokers="";
        kafkaEndpoint += ""localhost:9092"";
        kafkaEndpoint += ""&groupId="";
        kafkaEndpoint += ""TEST"";
        kafkaEndpoint += ""&autoOffsetReset="";
        kafkaEndpoint += ""earliest"";
        kafkaEndpoint += ""&autoCommitEnable="";
        kafkaEndpoint += false;
        kafkaEndpoint += ""&allowManualCommit="";
        kafkaEndpoint += true;
        kafkaEndpoint += ""&offsetRepository="";
        kafkaEndpoint += ""#fileStore"";

        return kafkaEndpoint;
    }

    @Bean(name = ""fileStore"")
    private FileStateRepository fileStateRepository() {
        FileStateRepository fileStateRepository = FileStateRepository.fileStateRepository(new File(""/kafka/offset_repo/repo.dat""));

        // This will be empty
        // System.out.println(fileStateRepository.getCache());
        return fileStateRepository;
    }

    private static void commitKafka(Exchange exchange) {

        KafkaManualCommit manual = exchange.getIn().getHeader(KafkaConstants.MANUAL_COMMIT, KafkaManualCommit.class);
        manual.commitSync();
    }
}

{code}
 "
CAMEL-12727,java.util.ConcurrentModificationException at org.apache.camel.impl.DefaultExchange.createProperties(DefaultExchange.java:550) in 2.20.1,"A concurrent access exception occurs during our load tests while consuming messages from a rabbitmq queue.

The call stack embedded below shows that the issue is related to an ""optimization"" which was introduced in https://issues.apache.org/jira/browse/CAMEL-11330 to replace a ConcurrentHashMap with a regular one from version 2.19.5 to 2.20.0 onward.

The faulty code is still present in latest 2.22.0.

 

 ",davsclaus,Bug,Major,Resolved,"java.util.ConcurrentModificationException at org.apache.camel.impl.DefaultExchange.createProperties(DefaultExchange.java:550) in 2.20.1 A concurrent access exception occurs during our load tests while consuming messages from a rabbitmq queue.

The call stack embedded below shows that the issue is related to an ""optimization"" which was introduced in https://issues.apache.org/jira/browse/CAMEL-11330 to replace a ConcurrentHashMap with a regular one from version 2.19.5 to 2.20.0 onward.

The faulty code is still present in latest 2.22.0.

 

 "
CAMEL-12716,Some spring-boot-starters generated have wrong component name in their javadoc documentation,"See talk on @dev
http://camel.465427.n5.nabble.com/Re-generating-source-code-Modified-source-files-afterwards-tp5822115.html",davsclaus,Task,Major,Resolved,"Some spring-boot-starters generated have wrong component name in their javadoc documentation See talk on @dev
http://camel.465427.n5.nabble.com/Re-generating-source-code-Modified-source-files-afterwards-tp5822115.html"
CAMEL-12714,support handlers in cxf payload data format without SEI,"When using a cxf endpoint in payload mode, specifying a WSDL and no service class, the JAX-WS protocol handlers are ignored.

Documentation however indicates that payload mode supports protocol JAX-WS handlers.

I made a pull request that activates the JAX-WS handlers in this scenario as well, by using a JaxWsEndpointImpl instead of EndpointImpl and removing some checks that avoid the handlers being set.

 ",davsclaus,Improvement,Major,Resolved,"support handlers in cxf payload data format without SEI When using a cxf endpoint in payload mode, specifying a WSDL and no service class, the JAX-WS protocol handlers are ignored.

Documentation however indicates that payload mode supports protocol JAX-WS handlers.

I made a pull request that activates the JAX-WS handlers in this scenario as well, by using a JaxWsEndpointImpl instead of EndpointImpl and removing some checks that avoid the handlers being set.

 "
CAMEL-12713,relative paths can remove scheme from xslt URI,"When using relative paths in an XSLT referenced from another one, the used URI scheme may be ignored.

e.g. in case of an XSLT specified by URI ""classpath:location/master.xsl"",  that includes another one:  <xsl:include href=""../child.xsl""/>

In this case, the URI of child.xsl is resolved as just ""child.xsl"" instead of ""classpath:child.xsl"", omitting the URI scheme.

The cause is XsltUriResolver, in which FileUtil.compactPath() is used to calculate the relative URI, but this call ignores the colon separator and considers ""classpath:location"" as a single path part.

I'm creating a pull request which passes the URI without scheme to FileUtil.compactPath().",davsclaus,Bug,Major,Resolved,"relative paths can remove scheme from xslt URI When using relative paths in an XSLT referenced from another one, the used URI scheme may be ignored.

e.g. in case of an XSLT specified by URI ""classpath:location/master.xsl"",  that includes another one:  <xsl:include href=""../child.xsl""/>

In this case, the URI of child.xsl is resolved as just ""child.xsl"" instead of ""classpath:child.xsl"", omitting the URI scheme.

The cause is XsltUriResolver, in which FileUtil.compactPath() is used to calculate the relative URI, but this call ignores the colon separator and considers ""classpath:location"" as a single path part.

I'm creating a pull request which passes the URI without scheme to FileUtil.compactPath()."
CAMEL-12711,SFTP: Cannot specify bind address of local network interface,"In an environment with multiple network interfaces, it might be necessary to specify the address of the local interface, to which the SFTP connection should bind. Unfortunately, this is not possible with the latest version of camel-ftp.

 

A new URI parameter 'bindAddress' should be introduces which can then be set to the IP-Address of the local network interface against which the SFTP connection should bind.",davsclaus,Improvement,Major,Resolved,"SFTP: Cannot specify bind address of local network interface In an environment with multiple network interfaces, it might be necessary to specify the address of the local interface, to which the SFTP connection should bind. Unfortunately, this is not possible with the latest version of camel-ftp.

 

A new URI parameter 'bindAddress' should be introduces which can then be set to the IP-Address of the local network interface against which the SFTP connection should bind."
CAMEL-12709,UseOriginalAggregationStrategy in outer loops,"Using splitters with the UseOriginalAggregationStrategy +in a loop+ causes the splitter to return always the same original exchange.

 
{code:java}
// my code is similar to the following one:
from(""direct:myLoop"")
  .loop(simple(""{{export.maxLoopsPerRun}}""))
    .setHeader(...) // changing header fields
    .split(body(), new UseOriginalAggregationStrategy(null, false))
      .to(""direct:handleRecord"")
    .end()
    .log(""${in.headers}"") // the headers of the exchange of the very first loop iteration
  .end()
{code}
Reason: Once the original exchange is set by UseOriginalAggregationStrategy#setOriginal(Exchange), it is not updated any more for loop iterations > 1.

 ",davsclaus,Bug,Major,Resolved,"UseOriginalAggregationStrategy in outer loops Using splitters with the UseOriginalAggregationStrategy +in a loop+ causes the splitter to return always the same original exchange.

 
{code:java}
// my code is similar to the following one:
from(""direct:myLoop"")
  .loop(simple(""{{export.maxLoopsPerRun}}""))
    .setHeader(...) // changing header fields
    .split(body(), new UseOriginalAggregationStrategy(null, false))
      .to(""direct:handleRecord"")
    .end()
    .log(""${in.headers}"") // the headers of the exchange of the very first loop iteration
  .end()
{code}
Reason: Once the original exchange is set by UseOriginalAggregationStrategy#setOriginal(Exchange), it is not updated any more for loop iterations > 1.

 "
CAMEL-12705,Optimising toD via SendDynamicAware component removes the 3rd octet from IP address,"IP address 10.192.1.10 is optimized as 10.192.10
{code:java}
DEBUG in SendDynamicProcessor:264 [main] - DynamicSendTo sendTo(netty4-http:http://10.192.1.10:8080/client/alerts/summary?throwExceptionOnFailure=false) using ProducerCache with default cache size

DEBUG in SendDynamicProcessor:125 [Camel (camel-1) thread #6 - seda://alertSummary] - Optimising toD via SendDynamicAware component: netty4-http to use static uri: netty4-http:http:10.192.10:8080/path?throwExceptionOnFailure=false
{code}
The issue seems to be in AbstractCamelCatalog class, method ""doAsEndpointUri(String scheme, Map<String, String> properties, String ampersand, boolean encode) throws URISyntaxException""",davsclaus,Bug,Major,Resolved,"Optimising toD via SendDynamicAware component removes the 3rd octet from IP address IP address 10.192.1.10 is optimized as 10.192.10
{code:java}
DEBUG in SendDynamicProcessor:264 [main] - DynamicSendTo sendTo(netty4-http:http://10.192.1.10:8080/client/alerts/summary?throwExceptionOnFailure=false) using ProducerCache with default cache size

DEBUG in SendDynamicProcessor:125 [Camel (camel-1) thread #6 - seda://alertSummary] - Optimising toD via SendDynamicAware component: netty4-http to use static uri: netty4-http:http:10.192.10:8080/path?throwExceptionOnFailure=false
{code}
The issue seems to be in AbstractCamelCatalog class, method ""doAsEndpointUri(String scheme, Map<String, String> properties, String ampersand, boolean encode) throws URISyntaxException"""
CAMEL-12702,camel-spring-boot - Improve its auto configuration docs,"Some of these options has no docs, or its sparse, or has some javadoc link reference etc
https://github.com/apache/camel/blob/master/components/camel-spring-boot/src/main/docs/spring-boot.adoc#spring-boot-auto-configuration",davsclaus,Improvement,Major,Resolved,"camel-spring-boot - Improve its auto configuration docs Some of these options has no docs, or its sparse, or has some javadoc link reference etc
https://github.com/apache/camel/blob/master/components/camel-spring-boot/src/main/docs/spring-boot.adoc#spring-boot-auto-configuration"
CAMEL-12699,Unable to combine retry with Hystrix circuit breaker,There as been more comment activity and no real resolution for the following ticket -> https://issues.apache.org/jira/browse/CAMEL-12195. This is blocking our ability to create resilient clients combining retry/exponential back-off/circuit-breaker without pulling in other frameworks or hacking in our own retry logic.,davsclaus,Improvement,Major,Resolved,Unable to combine retry with Hystrix circuit breaker There as been more comment activity and no real resolution for the following ticket -> https://issues.apache.org/jira/browse/CAMEL-12195. This is blocking our ability to create resilient clients combining retry/exponential back-off/circuit-breaker without pulling in other frameworks or hacking in our own retry logic.
CAMEL-12691,Allow configuration of org.xml.sax.ErrorHandler on DocumentBuilders used in Camel,"I have trivial route that processes XMLs. When the XML is route and has no content (like empty file processed by {{<from uri=""file:xxx"">}}) I'm getting:
{noformat}
[Fatal Error] :-1:-1: Premature end of file.
{noformat}

printed directly on STDOUT.

If there was a way to make {{org.apache.camel.converter.jaxp.XmlConverter}} call {{javax.xml.parsers.DocumentBuilder#setErrorHandler}} (for example delegating to logger), it'd be great.",davsclaus,Improvement,Major,Resolved,"Allow configuration of org.xml.sax.ErrorHandler on DocumentBuilders used in Camel I have trivial route that processes XMLs. When the XML is route and has no content (like empty file processed by {{<from uri=""file:xxx"">}}) I'm getting:
{noformat}
[Fatal Error] :-1:-1: Premature end of file.
{noformat}

printed directly on STDOUT.

If there was a way to make {{org.apache.camel.converter.jaxp.XmlConverter}} call {{javax.xml.parsers.DocumentBuilder#setErrorHandler}} (for example delegating to logger), it'd be great."
CAMEL-12667,camel-spring-boot - Turn of options with @NestedConfigurationProperty in generated auto configuration source,See my last comment on CAMEL-10197,davsclaus,Improvement,Major,Resolved,camel-spring-boot - Turn of options with @NestedConfigurationProperty in generated auto configuration source See my last comment on CAMEL-10197
CAMEL-12661,Spring Boot auto configuration - NestedConfigurationProperty should only be for known Camel types,"Currently we generte this for a range of complex objects that may appear as POJOs but they are likely not, so you cannot configure them, eg they dont have setters and a default no-arg constructor etc.

We have a blacklist today, but instead we should flip it to be a whitelist for known Camel types that can be configured like the SSLContextParameters and others.
",davsclaus,Improvement,Major,Resolved,"Spring Boot auto configuration - NestedConfigurationProperty should only be for known Camel types Currently we generte this for a range of complex objects that may appear as POJOs but they are likely not, so you cannot configure them, eg they dont have setters and a default no-arg constructor etc.

We have a blacklist today, but instead we should flip it to be a whitelist for known Camel types that can be configured like the SSLContextParameters and others.
"
CAMEL-12660,Spring Boot configuration documentation should be polished,"Some of the options have descriptions with html tags for advanced javadoc. We should remove those to make it plain then the spring tooling that generates the metadata json file will be improved for tooling, and also our own online ascii docs

For example
https://github.com/apache/camel/blob/camel-12644/components/camel-spring-boot/src/main/docs/spring-boot.adoc#spring-boot-auto-configuration",davsclaus,Improvement,Major,Resolved,"Spring Boot configuration documentation should be polished Some of the options have descriptions with html tags for advanced javadoc. We should remove those to make it plain then the spring tooling that generates the metadata json file will be improved for tooling, and also our own online ascii docs

For example
https://github.com/apache/camel/blob/camel-12644/components/camel-spring-boot/src/main/docs/spring-boot.adoc#spring-boot-auto-configuration"
CAMEL-12656,camel-zipkin - Root Span Id is not reported if the route calls multiple route,"Camel-Zipkin does not report traces with root span id when there are multiple routes. 

For example: 

 
{code:java}
from(""direct:foo"")
        .delay(1000)
        .to(""direct:bar"")
        .to(""direct:moo"")
        .to(""direct:tar"");

from(""direct:bar"")
        .delay(2000);

from(""direct:moo"")
        .delay(1000);

from(""direct:tar"")
        .delay(3000);
{code}
Root SpanId(TraceId) should be for service-name = direct:foo and the trace in UI should show all the 4 routes in one sequence. But it breaks. Check the attached screenshot: Traces Breaking.png

I looked into the code and figured out why its happening. Here is the code which is breaking the functionality.

Class Name: ZipkinTracer.ZipkinRoutePolicy
Inside onExchangeBegin() method 

 
{code:java}
// add on completion after the route is done, but before the consumer writes the response
// this allows us to track the zipkin event before returning the response which is the right time
exchange.addOnCompletion(new SynchronizationAdapter() {
    @Override
    public void onAfterRoute(Route route, Exchange exchange) {
        String serviceName = getServiceName(exchange, route.getEndpoint(), true, false);
        Brave brave = getBrave(serviceName);
        if (brave != null) {
            serverResponse(brave, serviceName, exchange);
        }
    }

    @Override
    public String toString() {
        return ""ZipkinTracerOnCompletion["" + routeId + ""]"";
    }
});
{code}
 

 

Using onAfterRoute() :  if the exchange is being routed through multiple routes, there will be callbacks for each route.

I have fix for it: 
If I use onExchangeDone() instead of above code. The traces are reported properly.  Check screenshots.

[https://zipkin.io/pages/instrumenting.html]

*Note* This process must be repeated if the service makes multiple downstream calls. That is each subsequent span will have the same trace id and parent id, but a new and different span id.",davsclaus,Bug,Major,Resolved,"camel-zipkin - Root Span Id is not reported if the route calls multiple route Camel-Zipkin does not report traces with root span id when there are multiple routes. 

For example: 

 
{code:java}
from(""direct:foo"")
        .delay(1000)
        .to(""direct:bar"")
        .to(""direct:moo"")
        .to(""direct:tar"");

from(""direct:bar"")
        .delay(2000);

from(""direct:moo"")
        .delay(1000);

from(""direct:tar"")
        .delay(3000);
{code}
Root SpanId(TraceId) should be for service-name = direct:foo and the trace in UI should show all the 4 routes in one sequence. But it breaks. Check the attached screenshot: Traces Breaking.png

I looked into the code and figured out why its happening. Here is the code which is breaking the functionality.

Class Name: ZipkinTracer.ZipkinRoutePolicy
Inside onExchangeBegin() method 

 
{code:java}
// add on completion after the route is done, but before the consumer writes the response
// this allows us to track the zipkin event before returning the response which is the right time
exchange.addOnCompletion(new SynchronizationAdapter() {
    @Override
    public void onAfterRoute(Route route, Exchange exchange) {
        String serviceName = getServiceName(exchange, route.getEndpoint(), true, false);
        Brave brave = getBrave(serviceName);
        if (brave != null) {
            serverResponse(brave, serviceName, exchange);
        }
    }

    @Override
    public String toString() {
        return ""ZipkinTracerOnCompletion["" + routeId + ""]"";
    }
});
{code}
 

 

Using onAfterRoute() :  if the exchange is being routed through multiple routes, there will be callbacks for each route.

I have fix for it: 
If I use onExchangeDone() instead of above code. The traces are reported properly.  Check screenshots.

[https://zipkin.io/pages/instrumenting.html]

*Note* This process must be repeated if the service makes multiple downstream calls. That is each subsequent span will have the same trace id and parent id, but a new and different span id."
CAMEL-12650,Log messages that do not match with their method function,"There are some possible copy and paste errors in the log messages (The logging statement was copied from an old place to a new place, but the message wasn't changed to adapt to the function of the new place) which may cause confusion when operators are reading the log messages. 

 

Here is a list of the related logging statements:

 

 

*1. log.debug(""Created FTPClient [connectTimeout: {}, soTimeout: {}, dataTimeout: {}, bufferSize: {}"" + "", receiveDataSocketBufferSize: {}, sendDataSocketBufferSize: {}]: {}"";*

      *Callsites:*
 * org.apache.camel.component.file.remote.*{color:#205081}FTPEndpoint{color}*.createRemoteFileOperations,
 * org.apache.camel.component.file.remote.*{color:#205081}FtpsEndpoint{color}*.createRemoteFileOperations,

 

*2. LOG.debug(""Adding to producer service pool with key: {} for producer: {}"", endpoint, answer);*

      *Callsites:*
 * org.apache.camel.impl.*{color:#205081}ProducerCache{color}*.doGetProducer,

 * org.apache.camel.impl.*{color:#205081}ConsumerCache{color}*.doGetPollingConsumer

 

*3. LOG.debug(""Trying to update the post {} with id {}"", exchange.getIn().getBody(), this.getConfiguration().getId());*

      *Callsites:*
 * org.apache.camel.component.wordpress.producer.{color:#205081}*WordpressPostProducer*.{color}processUpdate,

 * org.apache.camel.component.wordpress.producer.{color:#205081}*WordpressUserProducer*.{color}processUpdate

 

*4. LOG.error(""Create a specific pod require specify a namespace name"");*

      *Callsites:*
 * org.apache.camel.component.kubernetes.pods.KubernetesPodsProducer.*{color:#205081}doCreatePod{color},*

 * org.apache.camel.component.kubernetes.deployments.KubernetesDeploymentsProducer.*{color:#205081}doCreateDeployment{color}*

 

*5. LOG.debug(""Channel closed but no message received from address: {}"", producer.getConfiguration().getAddress());*

      *Callsites:*
 * org.apache.camel.component.netty.handlers.ClientChannelHandler.*{color:#205081}channelClosed{color},*

 * org.apache.camel.component.netty4.handlers.ClientChannelHandler.*{color:#205081}channelInactive{color}*

 

 

*6. LOG.trace(""Delete Broker command returned the error code {}"", ase.getErrorCode());*

      *Callsites:*
 * org.apache.camel.component.aws.mq.MQProducer.*{color:#205081}rebootBroker{color}*,

 * org.apache.camel.component.aws.mq.MQProducer.*{color:#205081}deleteBroker{color}*

 

*7. LOG.debug(""Stopping JmsReplyManager: {} from processing replies from: {}"", replyManager, endpoint.getReplyTo() != null ? endpoint.getReplyTo() : ""temporary queue"");*

      *Callsites:*
 * org.apache.camel.component.rabbitmq.*{color:#205081}RabbitMQProducer{color}*.unInitReplyManager,

 * org.apache.camel.component.jms.*{color:#205081}JmsProducer{color}*.unInitReplyManager

 

*8. logger.warn(""Error scanning JAR for custom Camel components"", e);*

      *Callsites:*
 * org.apache.camel.catalog.nexus.*{color:#205081}ComponentCatalogNexusRepository{color}*.addCustomCamelComponentsFromArtifact,

 * org.apache.camel.catalog.nexus.*{color:#205081}ConnectorCatalogNexusRepository.{color}*addCustomCamelConnectorFromArtifact

 

*9. LOGGER.debug(""Subscribe to events for queue: {}"", resourceName);*

      *Callsites:*
 * org.apache.camel.component.atomix.client.value.{color:#205081}*AtomixValueConsumer*{color}.doStart,

 * org.apache.camel.component.atomix.client.queue.*{color:#205081}AtomixQueueConsumer{color}*.doStart

 

*10. LOG.warn(""TimeoutEvent received at Sip Subscription Listener"");*

      *Callsites:*
 * org.apache.camel.component.sip.listener.{color:#205081}*SipSubscriptionListener*{color}.processTimeout,

 * org.apache.camel.component.sip.listener.{color:#205081}*SipPresenceAgentListener*{color}.processTimeout

 

*11. LOGGER.debug(""Executing Docker Kill Container Request"");*

      *Callsites:*
 * org.apache.camel.component.docker.producer.DockerProducer.execute{color:#205081}*StopContainer*{color}Request,

 * org.apache.camel.component.docker.producer.DockerProducer.execute{color:#205081}*KillContainer*{color}Request

 

*12. LOG.trace(""Rename Droplet {} : [{}] "", dropletId, action);*

      *Callsites:*
 * org.apache.camel.component.digitalocean.producer.DigitalOceanDropletsProducer.change.*{color:#205081}DropletKernel{color}*,

 * org.apache.camel.component.digitalocean.producer.DigitalOceanDropletsProducer.{color:#205081}*renameDroplet*{color}

 

 ",davsclaus,Improvement,Minor,Resolved,"Log messages that do not match with their method function There are some possible copy and paste errors in the log messages (The logging statement was copied from an old place to a new place, but the message wasn't changed to adapt to the function of the new place) which may cause confusion when operators are reading the log messages. 

 

Here is a list of the related logging statements:

 

 

*1. log.debug(""Created FTPClient [connectTimeout: {}, soTimeout: {}, dataTimeout: {}, bufferSize: {}"" + "", receiveDataSocketBufferSize: {}, sendDataSocketBufferSize: {}]: {}"";*

      *Callsites:*
 * org.apache.camel.component.file.remote.*{color:#205081}FTPEndpoint{color}*.createRemoteFileOperations,
 * org.apache.camel.component.file.remote.*{color:#205081}FtpsEndpoint{color}*.createRemoteFileOperations,

 

*2. LOG.debug(""Adding to producer service pool with key: {} for producer: {}"", endpoint, answer);*

      *Callsites:*
 * org.apache.camel.impl.*{color:#205081}ProducerCache{color}*.doGetProducer,

 * org.apache.camel.impl.*{color:#205081}ConsumerCache{color}*.doGetPollingConsumer

 

*3. LOG.debug(""Trying to update the post {} with id {}"", exchange.getIn().getBody(), this.getConfiguration().getId());*

      *Callsites:*
 * org.apache.camel.component.wordpress.producer.{color:#205081}*WordpressPostProducer*.{color}processUpdate,

 * org.apache.camel.component.wordpress.producer.{color:#205081}*WordpressUserProducer*.{color}processUpdate

 

*4. LOG.error(""Create a specific pod require specify a namespace name"");*

      *Callsites:*
 * org.apache.camel.component.kubernetes.pods.KubernetesPodsProducer.*{color:#205081}doCreatePod{color},*

 * org.apache.camel.component.kubernetes.deployments.KubernetesDeploymentsProducer.*{color:#205081}doCreateDeployment{color}*

 

*5. LOG.debug(""Channel closed but no message received from address: {}"", producer.getConfiguration().getAddress());*

      *Callsites:*
 * org.apache.camel.component.netty.handlers.ClientChannelHandler.*{color:#205081}channelClosed{color},*

 * org.apache.camel.component.netty4.handlers.ClientChannelHandler.*{color:#205081}channelInactive{color}*

 

 

*6. LOG.trace(""Delete Broker command returned the error code {}"", ase.getErrorCode());*

      *Callsites:*
 * org.apache.camel.component.aws.mq.MQProducer.*{color:#205081}rebootBroker{color}*,

 * org.apache.camel.component.aws.mq.MQProducer.*{color:#205081}deleteBroker{color}*

 

*7. LOG.debug(""Stopping JmsReplyManager: {} from processing replies from: {}"", replyManager, endpoint.getReplyTo() != null ? endpoint.getReplyTo() : ""temporary queue"");*

      *Callsites:*
 * org.apache.camel.component.rabbitmq.*{color:#205081}RabbitMQProducer{color}*.unInitReplyManager,

 * org.apache.camel.component.jms.*{color:#205081}JmsProducer{color}*.unInitReplyManager

 

*8. logger.warn(""Error scanning JAR for custom Camel components"", e);*

      *Callsites:*
 * org.apache.camel.catalog.nexus.*{color:#205081}ComponentCatalogNexusRepository{color}*.addCustomCamelComponentsFromArtifact,

 * org.apache.camel.catalog.nexus.*{color:#205081}ConnectorCatalogNexusRepository.{color}*addCustomCamelConnectorFromArtifact

 

*9. LOGGER.debug(""Subscribe to events for queue: {}"", resourceName);*

      *Callsites:*
 * org.apache.camel.component.atomix.client.value.{color:#205081}*AtomixValueConsumer*{color}.doStart,

 * org.apache.camel.component.atomix.client.queue.*{color:#205081}AtomixQueueConsumer{color}*.doStart

 

*10. LOG.warn(""TimeoutEvent received at Sip Subscription Listener"");*

      *Callsites:*
 * org.apache.camel.component.sip.listener.{color:#205081}*SipSubscriptionListener*{color}.processTimeout,

 * org.apache.camel.component.sip.listener.{color:#205081}*SipPresenceAgentListener*{color}.processTimeout

 

*11. LOGGER.debug(""Executing Docker Kill Container Request"");*

      *Callsites:*
 * org.apache.camel.component.docker.producer.DockerProducer.execute{color:#205081}*StopContainer*{color}Request,

 * org.apache.camel.component.docker.producer.DockerProducer.execute{color:#205081}*KillContainer*{color}Request

 

*12. LOG.trace(""Rename Droplet {} : [{}] "", dropletId, action);*

      *Callsites:*
 * org.apache.camel.component.digitalocean.producer.DigitalOceanDropletsProducer.change.*{color:#205081}DropletKernel{color}*,

 * org.apache.camel.component.digitalocean.producer.DigitalOceanDropletsProducer.{color:#205081}*renameDroplet*{color}

 

 "
CAMEL-12648,ExchangeSentEvent not fired if no EventNotifier is accepting ExchangeSendingEvent,"Due to changes in CAMEL-11346, many processors (including SendProcessor) no longer send ExchangeSentEvent when processing is done. The StopWatch object is not created when EventHelper.notifyExchangeSending returns false. If no EventNotifier is registered to receive that event, it will be false. But an EventNotifier may still be registered to receive ExchangeSentEvent. The StopWatch should be created when there is an EventNotifier registered for ExchangeSentEvent even when ExchangeSendingEvent is not, unless those events are always required to be paired together.",davsclaus,Bug,Major,Resolved,"ExchangeSentEvent not fired if no EventNotifier is accepting ExchangeSendingEvent Due to changes in CAMEL-11346, many processors (including SendProcessor) no longer send ExchangeSentEvent when processing is done. The StopWatch object is not created when EventHelper.notifyExchangeSending returns false. If no EventNotifier is registered to receive that event, it will be false. But an EventNotifier may still be registered to receive ExchangeSentEvent. The StopWatch should be created when there is an EventNotifier registered for ExchangeSentEvent even when ExchangeSendingEvent is not, unless those events are always required to be paired together."
CAMEL-12646,camel-spring-boot - Auto configuration of complex types should be more tooling friendly,"If you have complex types like javax.sql.DataSource and wants to allow to configure this via spring boot autoconfiguration in application.properties - then the generated spring boot classes with all the options will use getter/setter of types javax.sql.DataSource. That seems correct, but the spring-boot tooling itself (that generates additional json file) will skip those as it only support primitives and string types.

So we may need to fool, and generate the getter/setter as String type as you use it for configuring it as a bean reference by id anyway, eg

camel.component.jdbc.data-source = #myDataSource

We can add in the javadoc that the type is javax.sql.DataSource.",davsclaus,Improvement,Major,Resolved,"camel-spring-boot - Auto configuration of complex types should be more tooling friendly If you have complex types like javax.sql.DataSource and wants to allow to configure this via spring boot autoconfiguration in application.properties - then the generated spring boot classes with all the options will use getter/setter of types javax.sql.DataSource. That seems correct, but the spring-boot tooling itself (that generates additional json file) will skip those as it only support primitives and string types.

So we may need to fool, and generate the getter/setter as String type as you use it for configuring it as a bean reference by id anyway, eg

camel.component.jdbc.data-source = #myDataSource

We can add in the javadoc that the type is javax.sql.DataSource."
CAMEL-12645,camel-jdbc - Allow to use default datasource from spring-boot,"Like we do in camel-sql where we lookup and use default data source if there is none configured and there is only 1. Then camel-sql and camel-jdbc is a bit similar and easier to use, such as when using spring boot.",davsclaus,Improvement,Major,Resolved,"camel-jdbc - Allow to use default datasource from spring-boot Like we do in camel-sql where we lookup and use default data source if there is none configured and there is only 1. Then camel-sql and camel-jdbc is a bit similar and easier to use, such as when using spring boot."
CAMEL-12644,Generate documentation for Spring Boot starters,We could add auto-configuration properties section to the component documentation something like that can be seen in the [spring-boot documentation|https://docs.spring.io/spring-boot/docs/1.5.14.RELEASE/reference/htmlsingle/#common-application-properties] to help the users know which properties are available in application.[properties|yaml] under what keys.,davsclaus,New Feature,Major,Resolved,Generate documentation for Spring Boot starters We could add auto-configuration properties section to the component documentation something like that can be seen in the [spring-boot documentation|https://docs.spring.io/spring-boot/docs/1.5.14.RELEASE/reference/htmlsingle/#common-application-properties] to help the users know which properties are available in application.[properties|yaml] under what keys.
CAMEL-12643,camel-rabbitmq - Inadequate information for handling catch clauses,"There are some situations that different exception types are caught, but the handling of those exceptions cannot show the differences between those types. Here are the code snippets which have this problem:
{code}
org.apache.camel.component.rabbitmq.*RabbitConsumer*.handleShutdownSignal, *Line 271*

catch (IOException | TimeoutException e)

{   log.warn(""Unable to obtain a RabbitMQ channel. Will try again"");     ...      }
{code}

It may cause confusions to the person who is reading the log, the person can not know what exception happened here and cannot distinguish if the exception type is IOException or TimeoutException. Simply adding a full stack trace is able to improve it.

 ",davsclaus,Improvement,Minor,Resolved,"camel-rabbitmq - Inadequate information for handling catch clauses There are some situations that different exception types are caught, but the handling of those exceptions cannot show the differences between those types. Here are the code snippets which have this problem:
{code}
org.apache.camel.component.rabbitmq.*RabbitConsumer*.handleShutdownSignal, *Line 271*

catch (IOException | TimeoutException e)

{   log.warn(""Unable to obtain a RabbitMQ channel. Will try again"");     ...      }
{code}

It may cause confusions to the person who is reading the log, the person can not know what exception happened here and cannot distinguish if the exception type is IOException or TimeoutException. Simply adding a full stack trace is able to improve it.

 "
CAMEL-12640,tooling - Provide character position in validation result,currently the line start and line end are provided but not the character position,davsclaus,Improvement,Minor,Resolved,tooling - Provide character position in validation result currently the line start and line end are provided but not the character position
CAMEL-12639,tooling - Provide line numbers for CamelEndpointDetails for java dsl,currently it is provided for xml dsl but not for java dsl,davsclaus,Improvement,Minor,Resolved,tooling - Provide line numbers for CamelEndpointDetails for java dsl currently it is provided for xml dsl but not for java dsl
CAMEL-12638,DefaultFluentProducerTemplate is not thread safe,"I think we have rediscovered the CAMEL-10820 bug. A body of one request gets replaced with a body of proceeding request, in our case we use *request()* method instead of *asyncSend()*.

We use camel together with spring-boot. Consider following code:

 
{code:java}
@Service
public class UseCamelService {

   private FluentProducerTemplate producer;

   @Autowired
   public UseCamelService(FluentProducerTemplate producer) {
      this.producer = producer;
   }

   public String getValueFromCamel(String body) {
      return producer.to(""route"").withBody(body).request(String.class);
   }

}
{code}
If *UseCamelService.getValueFromCamel()* gets called from two different threads it is possible for the latter one to override the body of the first one.",davsclaus,Bug,Major,Resolved,"DefaultFluentProducerTemplate is not thread safe I think we have rediscovered the CAMEL-10820 bug. A body of one request gets replaced with a body of proceeding request, in our case we use *request()* method instead of *asyncSend()*.

We use camel together with spring-boot. Consider following code:

 
{code:java}
@Service
public class UseCamelService {

   private FluentProducerTemplate producer;

   @Autowired
   public UseCamelService(FluentProducerTemplate producer) {
      this.producer = producer;
   }

   public String getValueFromCamel(String body) {
      return producer.to(""route"").withBody(body).request(String.class);
   }

}
{code}
If *UseCamelService.getValueFromCamel()* gets called from two different threads it is possible for the latter one to override the body of the first one."
CAMEL-12636,camel-jmx - Should use a thread pool for routing notifications,The handleNotification event should be a simple noop operation. But if we route in Camel then it may do many things and call external systems etc. So ideally we should have a little thread pool to process these events - eg a like a wire tap.,davsclaus,Improvement,Major,Resolved,camel-jmx - Should use a thread pool for routing notifications The handleNotification event should be a simple noop operation. But if we route in Camel then it may do many things and call external systems etc. So ideally we should have a little thread pool to process these events - eg a like a wire tap.
CAMEL-12633,camel-jmx - Add support for monitoring boolean attribute changes,"We can monitor counters, gauges and string values. But its not possible to monitor when a boolean value changes.

You cannot use the string monitor as JMX does not support that :(

So we need to add out own code to handle booleans",davsclaus,Improvement,Minor,Resolved,"camel-jmx - Add support for monitoring boolean attribute changes We can monitor counters, gauges and string values. But its not possible to monitor when a boolean value changes.

You cannot use the string monitor as JMX does not support that :(

So we need to add out own code to handle booleans"
CAMEL-12628,[doc] camel-hawtdb documentation should be updated,"The documentation for [camel-hawtdb |http://camel.apache.org/hawtdb.html]says:

{quote}
The [HawtDB|http://hawtdb.fusesource.org/] project is being deprecated and replaced by [leveldb|https://code.google.com/p/leveldb/] as the lightweight and embedable key value database. To make using leveldb easy there is a [leveldbjni|https://github.com/fusesource/leveldbjni] project for that. The Apache ActiveMQ project is planning on using leveldb as their primary file based message store in the future, to replace kahadb.
{quote}

The last part about ActiveMQ replacing KahaDB with LevelDB is out of date. 
LevelDB has been deprecated on ActiveMQ and KahaDB remains the standard persistence adapter. The top level warning on http://activemq.apache.org/leveldb-store.html. 
So I suggest to remove that sentence at minimum.

Also, I am not sure do we still recommend LevelDB as an alternative to hawtdb or would there be even better options these days? 
 

 ",davsclaus,Improvement,Major,Resolved,"[doc] camel-hawtdb documentation should be updated The documentation for [camel-hawtdb |http://camel.apache.org/hawtdb.html]says:

{quote}
The [HawtDB|http://hawtdb.fusesource.org/] project is being deprecated and replaced by [leveldb|https://code.google.com/p/leveldb/] as the lightweight and embedable key value database. To make using leveldb easy there is a [leveldbjni|https://github.com/fusesource/leveldbjni] project for that. The Apache ActiveMQ project is planning on using leveldb as their primary file based message store in the future, to replace kahadb.
{quote}

The last part about ActiveMQ replacing KahaDB with LevelDB is out of date. 
LevelDB has been deprecated on ActiveMQ and KahaDB remains the standard persistence adapter. The top level warning on http://activemq.apache.org/leveldb-store.html. 
So I suggest to remove that sentence at minimum.

Also, I am not sure do we still recommend LevelDB as an alternative to hawtdb or would there be even better options these days? 
 

 "
CAMEL-12627,Use Spring Boot autoconfigure-processor to optimize auto-configurations,"As explained in [the its reference documentation|https://github.com/spring-projects/spring-boot/blob/master/spring-boot-project/spring-boot-docs/src/main/asciidoc/spring-boot-features.adoc#autoconfigure-module], Spring Boot provides a {{spring-boot-autoconfigure-processor}}.

This should be added as an optional dependency to each module that contains AutoConfiguration classes (and the `spring.factories` file declaring them).

Once configured, this annotation processor will generate metadata at compile time and will help Spring Boot process those auto-configurations without loading the actual classes in some cases.

In this project, the several modules are declaring auto-configurations but are not using this annotation processor. Could you add it to the build files?

{code:xml}
<dependency>
 <groupId>org.springframework.boot</groupId>
 <artifactId>spring-boot-autoconfigure-processor</artifactId>
 <optional>true</optional>
</dependency>
{code}

Once added, this should generate a {{spring-autoconfigure-metadata.properties}} file in the {{target/classes/META-INF}} folder of earch module.",davsclaus,Improvement,Major,Resolved,"Use Spring Boot autoconfigure-processor to optimize auto-configurations As explained in [the its reference documentation|https://github.com/spring-projects/spring-boot/blob/master/spring-boot-project/spring-boot-docs/src/main/asciidoc/spring-boot-features.adoc#autoconfigure-module], Spring Boot provides a {{spring-boot-autoconfigure-processor}}.

This should be added as an optional dependency to each module that contains AutoConfiguration classes (and the `spring.factories` file declaring them).

Once configured, this annotation processor will generate metadata at compile time and will help Spring Boot process those auto-configurations without loading the actual classes in some cases.

In this project, the several modules are declaring auto-configurations but are not using this annotation processor. Could you add it to the build files?

{code:xml}
<dependency>
 <groupId>org.springframework.boot</groupId>
 <artifactId>spring-boot-autoconfigure-processor</artifactId>
 <optional>true</optional>
</dependency>
{code}

Once added, this should generate a {{spring-autoconfigure-metadata.properties}} file in the {{target/classes/META-INF}} folder of earch module."
CAMEL-12626,Camel Tracing is not working for route with redelivery strategy,"Camel Tracing is not being executed if there is redelivery strategy defined.
 In our context we have switched on the camel Tracer with the following:
{code:java}
    public static void main(String[] args) throws Exception {
        DefaultCamelContext context = new DefaultCamelContext();
        context.addRoutes(new RouteBuilder() {
            @Override
            public void configure() throws Exception {

                // If errorHandler with redelivery is removed then tracer output is visible again.
                errorHandler(new DefaultErrorHandlerBuilder().maximumRedeliveries(3).redeliveryDelay(2000L));

                from(""direct:start"").process(new Processor() {
                    public void process(Exchange exchange) throws Exception {
                        System.out.println(""PROCESSED"");
                    }
                });
            }
        });

        // Enable Tracer.
        context.setTracing(true);
        context.start();
        ProducerTemplate template = context.createProducerTemplate();
        template.sendBody(""direct:start"", ""foo"");
    }
{code}
We noticed that we were missing output from the tracer that we were excepting.
If you remove the errohandler with redelivery you can see the output we expected:

 
{code:java}
[main] INFO org.apache.camel.processor.interceptor.Tracer - ID-rmm-xxx-xxx-x-x >>> (route1) from(direct://start) --> Processor@0x130d63be <<< Pattern:InOnly, Headers:{breadcrumbId=ID-rmm-xxx-xxx-x-x}, BodyType:String, Body:foo
{code}
 ",davsclaus,Bug,Minor,Resolved,"Camel Tracing is not working for route with redelivery strategy Camel Tracing is not being executed if there is redelivery strategy defined.
 In our context we have switched on the camel Tracer with the following:
{code:java}
    public static void main(String[] args) throws Exception {
        DefaultCamelContext context = new DefaultCamelContext();
        context.addRoutes(new RouteBuilder() {
            @Override
            public void configure() throws Exception {

                // If errorHandler with redelivery is removed then tracer output is visible again.
                errorHandler(new DefaultErrorHandlerBuilder().maximumRedeliveries(3).redeliveryDelay(2000L));

                from(""direct:start"").process(new Processor() {
                    public void process(Exchange exchange) throws Exception {
                        System.out.println(""PROCESSED"");
                    }
                });
            }
        });

        // Enable Tracer.
        context.setTracing(true);
        context.start();
        ProducerTemplate template = context.createProducerTemplate();
        template.sendBody(""direct:start"", ""foo"");
    }
{code}
We noticed that we were missing output from the tracer that we were excepting.
If you remove the errohandler with redelivery you can see the output we expected:

 
{code:java}
[main] INFO org.apache.camel.processor.interceptor.Tracer - ID-rmm-xxx-xxx-x-x >>> (route1) from(direct://start) --> Processor@0x130d63be <<< Pattern:InOnly, Headers:{breadcrumbId=ID-rmm-xxx-xxx-x-x}, BodyType:String, Body:foo
{code}
 "
CAMEL-12610,Camel bean component invokes cached instance of bean (that impl processor) in Registry,"Related SO question: [https://stackoverflow.com/questions/51108913/camel-bean-component-invokes-cached-instance-of-named-dependent-bean]

Every invocation of bean component should query Registry for actual instance. Now it is cached in {{BeanProcessor#delegate}} variable, even if endpoint parameter {{cache=false}} specified.

This behavior breaks java-ee compliance: [https://docs.oracle.com/javaee/7/api/javax/enterprise/context/Dependent.html]
{quote}Every invocation of the [{{Context.get(Contextual, CreationalContext)}}|https://docs.oracle.com/javaee/7/api/javax/enterprise/context/spi/Context.html#get-javax.enterprise.context.spi.Contextual-javax.enterprise.context.spi.CreationalContext-] operation of the context object for the {{@Dependent}} scope returns a new instance of the given bean.
{quote}
Marking this as Major, because upgrading of Camel from 2.19.x to 2.2x.x leads to unpredictable results in CDI environment. Since this is tied to CDI environment, this issue is hard to notice even in well junit covered application and can result in major issues in pre-production or production environment.

Full reproducible project with unit test and deployable WAR package, which passes with 2.19.x and lower. Fails with 2.20.x and higher [on Github|https://github.com/bedlaj/camel-dependent-bean]. 

Attachments are based on version 2.21.1",davsclaus,Bug,Minor,Resolved,"Camel bean component invokes cached instance of bean (that impl processor) in Registry Related SO question: [https://stackoverflow.com/questions/51108913/camel-bean-component-invokes-cached-instance-of-named-dependent-bean]

Every invocation of bean component should query Registry for actual instance. Now it is cached in {{BeanProcessor#delegate}} variable, even if endpoint parameter {{cache=false}} specified.

This behavior breaks java-ee compliance: [https://docs.oracle.com/javaee/7/api/javax/enterprise/context/Dependent.html]
{quote}Every invocation of the [{{Context.get(Contextual, CreationalContext)}}|https://docs.oracle.com/javaee/7/api/javax/enterprise/context/spi/Context.html#get-javax.enterprise.context.spi.Contextual-javax.enterprise.context.spi.CreationalContext-] operation of the context object for the {{@Dependent}} scope returns a new instance of the given bean.
{quote}
Marking this as Major, because upgrading of Camel from 2.19.x to 2.2x.x leads to unpredictable results in CDI environment. Since this is tied to CDI environment, this issue is hard to notice even in well junit covered application and can result in major issues in pre-production or production environment.

Full reproducible project with unit test and deployable WAR package, which passes with 2.19.x and lower. Fails with 2.20.x and higher [on Github|https://github.com/bedlaj/camel-dependent-bean]. 

Attachments are based on version 2.21.1"
CAMEL-12609,DefaultExchangeFormatter: Make it easy to override the header and property formatting ,"To omit certain headers (or mask their values) in ExchangeFormatter, one can write a custom implementation. 

In [DefaultExchangeFormatter|[https://github.com/apache/camel/blob/apache-master/camel-core/src/main/java/org/apache/camel/processor/DefaultExchangeFormatter.java],] ... it would be nice if the header-formatting (maybe the Property formatting) was done as separate methods that we could over-ride, while keeping the rest of the functionality.

Not sure if it would be acceptable to do this without also changing the ExchangeFormatter interface to add such methods.",davsclaus,Improvement,Minor,Resolved,"DefaultExchangeFormatter: Make it easy to override the header and property formatting  To omit certain headers (or mask their values) in ExchangeFormatter, one can write a custom implementation. 

In [DefaultExchangeFormatter|[https://github.com/apache/camel/blob/apache-master/camel-core/src/main/java/org/apache/camel/processor/DefaultExchangeFormatter.java],] ... it would be nice if the header-formatting (maybe the Property formatting) was done as separate methods that we could over-ride, while keeping the rest of the functionality.

Not sure if it would be acceptable to do this without also changing the ExchangeFormatter interface to add such methods."
CAMEL-12597,camel-servlet - Add whitelist for accepted file types,"Reported on user forum

http://camel.465427.n5.nabble.com/Report-Issues-Apache-Camel-Servlet-Component-td5820710.html",davsclaus,Improvement,Major,Resolved,"camel-servlet - Add whitelist for accepted file types Reported on user forum

http://camel.465427.n5.nabble.com/Report-Issues-Apache-Camel-Servlet-Component-td5820710.html"
CAMEL-12594,Rest Producer - Query Parameters : Wrong query parameter name is used when header substitution is performed ,"CAMEL-11050 [https://github.com/apache/camel/commit/35638b280be7ca43031ea4c5d937590f30495e70]

Introduced a bug in this line 

[https://github.com/apache/camel/blob/6938a4ea6b68e295fae48f52e8e7cb2628f161a3/camel-core/src/main/java/org/apache/camel/component/rest/RestProducer.java#L409]

 

The fix is (probably) to replace the line with :

params.put(entry.getKey(), value);

 

 

 ",davsclaus,Bug,Major,Resolved,"Rest Producer - Query Parameters : Wrong query parameter name is used when header substitution is performed  CAMEL-11050 [https://github.com/apache/camel/commit/35638b280be7ca43031ea4c5d937590f30495e70]

Introduced a bug in this line 

[https://github.com/apache/camel/blob/6938a4ea6b68e295fae48f52e8e7cb2628f161a3/camel-core/src/main/java/org/apache/camel/component/rest/RestProducer.java#L409]

 

The fix is (probably) to replace the line with :

params.put(entry.getKey(), value);

 

 

 "
CAMEL-12590,Type converter confusion when camel-cxf and camel-mail are in same classpath,"The CxfRsProducer needs to find a converter to take the String body of an exchange message and turn it into an Object[]. However when camel-mail is present in the classpath the converter search method picks: 
 
 com.sun.mail.imap.SortTerm[] org.apache.camel.component.mail.MailConverters.toSortTerm(String msg) 
 
This causes the CxfRsProducer to bomb on a NoSuchMethodException. 
 
 If camel-mail is removed, the CxfRsProducer client works, finding the right String -> Object[] converter.

[Issue discussed here on Camel user mailing list|http://camel.465427.n5.nabble.com/Type-converter-misbehavior-with-camel-cxf-and-camel-mail-td5820546.html]

 ",davsclaus,Bug,Minor,Resolved,"Type converter confusion when camel-cxf and camel-mail are in same classpath The CxfRsProducer needs to find a converter to take the String body of an exchange message and turn it into an Object[]. However when camel-mail is present in the classpath the converter search method picks: 
 
 com.sun.mail.imap.SortTerm[] org.apache.camel.component.mail.MailConverters.toSortTerm(String msg) 
 
This causes the CxfRsProducer to bomb on a NoSuchMethodException. 
 
 If camel-mail is removed, the CxfRsProducer client works, finding the right String -> Object[] converter.

[Issue discussed here on Camel user mailing list|http://camel.465427.n5.nabble.com/Type-converter-misbehavior-with-camel-cxf-and-camel-mail-td5820546.html]

 "
CAMEL-12589,Surviving Header AGGREGATION_COMPLETE_ALL_GROUPS_INCLUSIVE affects following aggregations,"When AGGREGATION_COMPLETE_ALL_GROUPS_INCLUSIVE is once set true it survives current aggregation processing and affects in unexpected way following aggregation by triggering ""forceCompletionOfAllGroups()"" again

in next code snippet might be needed some additional handling when the header is true:
{code:java}
protected void doProcess(Exchange exchange) throws Exception {
...
        // check for the special header to force completion of all groups (inclusive of the message)
        boolean completeAllGroupsInclusive = exchange.getIn().getHeader(Exchange.AGGREGATION_COMPLETE_ALL_GROUPS_INCLUSIVE, false, boolean.class);
        if (completeAllGroupsInclusive) {
            forceCompletionOfAllGroups();
        }
...

{code}
this consideration is made by analysing similar behavior and lifecycle of header AGGREGATION_COMPLETE_ALL_GROUPS:
{code:java}
private List<Exchange> doAggregation(String key, Exchange newExchange) throws CamelExchangeException {
...
...        
        // check for the special exchange property to force completion of all groups
        boolean completeAllGroups = answer.getProperty(Exchange.AGGREGATION_COMPLETE_ALL_GROUPS, false, boolean.class);
        if (completeAllGroups) {
            // remove the exchange property so we do not complete again
            answer.removeProperty(Exchange.AGGREGATION_COMPLETE_ALL_GROUPS);
            forceCompletionOfAllGroups();
        } else if (isCompletionOnNewCorrelationGroup() && originalExchange == null) {
            // its a new group so force complete of all existing groups
            forceCompletionOfAllGroups();
        }
...
{code}",davsclaus,Bug,Major,Closed,"Surviving Header AGGREGATION_COMPLETE_ALL_GROUPS_INCLUSIVE affects following aggregations When AGGREGATION_COMPLETE_ALL_GROUPS_INCLUSIVE is once set true it survives current aggregation processing and affects in unexpected way following aggregation by triggering ""forceCompletionOfAllGroups()"" again

in next code snippet might be needed some additional handling when the header is true:
{code:java}
protected void doProcess(Exchange exchange) throws Exception {
...
        // check for the special header to force completion of all groups (inclusive of the message)
        boolean completeAllGroupsInclusive = exchange.getIn().getHeader(Exchange.AGGREGATION_COMPLETE_ALL_GROUPS_INCLUSIVE, false, boolean.class);
        if (completeAllGroupsInclusive) {
            forceCompletionOfAllGroups();
        }
...

{code}
this consideration is made by analysing similar behavior and lifecycle of header AGGREGATION_COMPLETE_ALL_GROUPS:
{code:java}
private List<Exchange> doAggregation(String key, Exchange newExchange) throws CamelExchangeException {
...
...        
        // check for the special exchange property to force completion of all groups
        boolean completeAllGroups = answer.getProperty(Exchange.AGGREGATION_COMPLETE_ALL_GROUPS, false, boolean.class);
        if (completeAllGroups) {
            // remove the exchange property so we do not complete again
            answer.removeProperty(Exchange.AGGREGATION_COMPLETE_ALL_GROUPS);
            forceCompletionOfAllGroups();
        } else if (isCompletionOnNewCorrelationGroup() && originalExchange == null) {
            // its a new group so force complete of all existing groups
            forceCompletionOfAllGroups();
        }
...
{code}"
CAMEL-12571,Seda component forgets URI setting when duplicates are present,"when {color:#008000}blockWhenFull=true&blockWhenFull=true {color}{color:#333333}is set twice the option is not set at all{color}

{color:#333333}it might out of context but from my point of view the last one should win (as it is in a properties file){color}

{color:#333333}of if an error should be thrown could also be welcome{color}

 

{color:#333333}I quickly adapted{color} SedaComponentConfigurationAndDocumentationTest (I know, it uses now deprecated stuff) and the result is an array of set values ( 2 in this case) and the test fails.

kind regards

G.

 ",davsclaus,Bug,Trivial,Closed,"Seda component forgets URI setting when duplicates are present when {color:#008000}blockWhenFull=true&blockWhenFull=true {color}{color:#333333}is set twice the option is not set at all{color}

{color:#333333}it might out of context but from my point of view the last one should win (as it is in a properties file){color}

{color:#333333}of if an error should be thrown could also be welcome{color}

 

{color:#333333}I quickly adapted{color} SedaComponentConfigurationAndDocumentationTest (I know, it uses now deprecated stuff) and the result is an array of set values ( 2 in this case) and the test fails.

kind regards

G.

 "
CAMEL-12567,camel-stream - Add support for configuring timeout for HTTP urls,So you can set connect and read timeouts.,davsclaus,New Feature,Major,Resolved,camel-stream - Add support for configuring timeout for HTTP urls So you can set connect and read timeouts.
CAMEL-12566,camel-stream - Add support for HTTP headers,"Asked on user forum

http://camel.465427.n5.nabble.com/url-http-streaming-issue-tp5820467.html",davsclaus,New Feature,Major,Resolved,"camel-stream - Add support for HTTP headers Asked on user forum

http://camel.465427.n5.nabble.com/url-http-streaming-issue-tp5820467.html"
CAMEL-12565,outputTypeWithValidate (or inputTypeWithValidate) + validator()... doesn't work as expected,"{code:java}
package org.mike.tests;

import org.apache.camel.ValidationException;
import org.apache.camel.builder.RouteBuilder;
import org.apache.camel.test.junit4.CamelTestSupport;
import org.junit.Test;

public class ValidatorTests extends CamelTestSupport {
    @Override
    protected RouteBuilder createRouteBuilder() throws Exception {
        return new RouteBuilder() {
            @Override
            public void configure() throws Exception {

                validator()
                        .type(String.class)
                        .withExpression(bodyAs(String.class).isEqualToIgnoreCase(""valid""));

                onException(ValidationException.class)
                        .handled(true)
                        .log(""Invalid predicate: ${exception.message}"")
                        .to(""mock:invalid"");

                from(""direct:in"")
                        //.validate(bodyAs(String.class).isEqualToIgnoreCase(""valid""))
                        .outputTypeWithValidate(String.class) // or .inputTypeWithValidate(String.class)
                        .to(""mock:out"");
            }
        };
    }

    @Test
    public void testValid() throws InterruptedException {

        getMockEndpoint(""mock:out"").expectedMessageCount(1);
        getMockEndpoint(""mock:invalid"").expectedMessageCount(0);

        template.sendBody(""direct:in"", ""valid"");

        assertMockEndpointsSatisfied();
    }

    @Test
    public void testInvalid() throws InterruptedException {
        getMockEndpoint(""mock:out"").expectedMessageCount(0);
        getMockEndpoint(""mock:invalid"").expectedMessageCount(1);

        template.sendBody(""direct:in"", ""wrong"");

        assertMockEndpointsSatisfied();
    }
}


{code}
Expected result: both tests pass

Actual result: 'testValid' - passed, 'testInvalid' - failed

If uncomment line 25 & comment 26
{code:java}
.validate(bodyAs(String.class).isEqualToIgnoreCase(""valid""))
//.inputTypeWithValidate(String.class)
{code}
tests will OK

 

Other test case with same results

 
{code:java}
package org.mike.tests;

import org.apache.camel.Message;
import org.apache.camel.ValidationException;
import org.apache.camel.builder.RouteBuilder;
import org.apache.camel.impl.JndiRegistry;
import org.apache.camel.spi.DataType;
import org.apache.camel.spi.Validator;
import org.apache.camel.test.junit4.CamelTestSupport;
import org.junit.Test;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

public class BeanValidatorTest extends CamelTestSupport {
    @Override
    protected RouteBuilder createRouteBuilder() throws Exception {
        return new RouteBuilder() {
            @Override
            public void configure() throws Exception {
                validator()
                        .type(""toValidate"")
                        .withBean(""testValidator"");

                onException(ValidationException.class)
                        .handled(true)
                        .log(""Invalid validation: ${exception.message}"")
                        .to(""mock:invalid"");

                from(""direct:in"")
                        .outputTypeWithValidate(""toValidate"")
                        .to(""mock:out"");
            }
        };
    }

    public static class TestValidator extends Validator {
        private static final Logger LOG = LoggerFactory.getLogger(TestValidator.class);

        @Override
        public void validate(Message message, DataType type) throws ValidationException {
            Object body = message.getBody();
            LOG.info(""Validating : [{}]"", body);
            if (body instanceof String && body.equals(""valid"")) {
                LOG.info(""OK"");
            } else {
                throw new ValidationException(message.getExchange(), ""Wrong content"");
            }
        }
    }


    @Override
    protected JndiRegistry createRegistry() throws Exception {
        JndiRegistry registry = super.createRegistry();

        registry.bind(""testValidator"", new TestValidator());

        return registry;
    }

    @Test
    public void testValid() throws InterruptedException {

        getMockEndpoint(""mock:out"").expectedMessageCount(1);
        getMockEndpoint(""mock:invalid"").expectedMessageCount(0);

        template.sendBody(""direct:in"", ""valid"");

        assertMockEndpointsSatisfied();
    }

    @Test
    public void testInvalid() throws InterruptedException {
        getMockEndpoint(""mock:out"").expectedMessageCount(0);
        getMockEndpoint(""mock:invalid"").expectedMessageCount(1);

        template.sendBody(""direct:in"", ""wrong"");

        assertMockEndpointsSatisfied();
    }
}

{code}",davsclaus,Bug,Major,Resolved,"outputTypeWithValidate (or inputTypeWithValidate) + validator()... doesn't work as expected {code:java}
package org.mike.tests;

import org.apache.camel.ValidationException;
import org.apache.camel.builder.RouteBuilder;
import org.apache.camel.test.junit4.CamelTestSupport;
import org.junit.Test;

public class ValidatorTests extends CamelTestSupport {
    @Override
    protected RouteBuilder createRouteBuilder() throws Exception {
        return new RouteBuilder() {
            @Override
            public void configure() throws Exception {

                validator()
                        .type(String.class)
                        .withExpression(bodyAs(String.class).isEqualToIgnoreCase(""valid""));

                onException(ValidationException.class)
                        .handled(true)
                        .log(""Invalid predicate: ${exception.message}"")
                        .to(""mock:invalid"");

                from(""direct:in"")
                        //.validate(bodyAs(String.class).isEqualToIgnoreCase(""valid""))
                        .outputTypeWithValidate(String.class) // or .inputTypeWithValidate(String.class)
                        .to(""mock:out"");
            }
        };
    }

    @Test
    public void testValid() throws InterruptedException {

        getMockEndpoint(""mock:out"").expectedMessageCount(1);
        getMockEndpoint(""mock:invalid"").expectedMessageCount(0);

        template.sendBody(""direct:in"", ""valid"");

        assertMockEndpointsSatisfied();
    }

    @Test
    public void testInvalid() throws InterruptedException {
        getMockEndpoint(""mock:out"").expectedMessageCount(0);
        getMockEndpoint(""mock:invalid"").expectedMessageCount(1);

        template.sendBody(""direct:in"", ""wrong"");

        assertMockEndpointsSatisfied();
    }
}


{code}
Expected result: both tests pass

Actual result: 'testValid' - passed, 'testInvalid' - failed

If uncomment line 25 & comment 26
{code:java}
.validate(bodyAs(String.class).isEqualToIgnoreCase(""valid""))
//.inputTypeWithValidate(String.class)
{code}
tests will OK

 

Other test case with same results

 
{code:java}
package org.mike.tests;

import org.apache.camel.Message;
import org.apache.camel.ValidationException;
import org.apache.camel.builder.RouteBuilder;
import org.apache.camel.impl.JndiRegistry;
import org.apache.camel.spi.DataType;
import org.apache.camel.spi.Validator;
import org.apache.camel.test.junit4.CamelTestSupport;
import org.junit.Test;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

public class BeanValidatorTest extends CamelTestSupport {
    @Override
    protected RouteBuilder createRouteBuilder() throws Exception {
        return new RouteBuilder() {
            @Override
            public void configure() throws Exception {
                validator()
                        .type(""toValidate"")
                        .withBean(""testValidator"");

                onException(ValidationException.class)
                        .handled(true)
                        .log(""Invalid validation: ${exception.message}"")
                        .to(""mock:invalid"");

                from(""direct:in"")
                        .outputTypeWithValidate(""toValidate"")
                        .to(""mock:out"");
            }
        };
    }

    public static class TestValidator extends Validator {
        private static final Logger LOG = LoggerFactory.getLogger(TestValidator.class);

        @Override
        public void validate(Message message, DataType type) throws ValidationException {
            Object body = message.getBody();
            LOG.info(""Validating : [{}]"", body);
            if (body instanceof String && body.equals(""valid"")) {
                LOG.info(""OK"");
            } else {
                throw new ValidationException(message.getExchange(), ""Wrong content"");
            }
        }
    }


    @Override
    protected JndiRegistry createRegistry() throws Exception {
        JndiRegistry registry = super.createRegistry();

        registry.bind(""testValidator"", new TestValidator());

        return registry;
    }

    @Test
    public void testValid() throws InterruptedException {

        getMockEndpoint(""mock:out"").expectedMessageCount(1);
        getMockEndpoint(""mock:invalid"").expectedMessageCount(0);

        template.sendBody(""direct:in"", ""valid"");

        assertMockEndpointsSatisfied();
    }

    @Test
    public void testInvalid() throws InterruptedException {
        getMockEndpoint(""mock:out"").expectedMessageCount(0);
        getMockEndpoint(""mock:invalid"").expectedMessageCount(1);

        template.sendBody(""direct:in"", ""wrong"");

        assertMockEndpointsSatisfied();
    }
}

{code}"
CAMEL-12558,camel-catalog - Transacted and Policy should not have outputs,"These 2 eips should not have output: true in the camel-catalog json meta-data.

For Camel 3.0 we will change their base class in the model so they are no outputs",davsclaus,Bug,Major,Resolved,"camel-catalog - Transacted and Policy should not have outputs These 2 eips should not have output: true in the camel-catalog json meta-data.

For Camel 3.0 we will change their base class in the model so they are no outputs"
CAMEL-12553,Using cxf new LoggingFeature,"CXF deprecated the old LoggingFeature, we need to switch to [new one|http://cxf.apache.org/docs/message-logging.html].",njiang,Improvement,Major,Resolved,"Using cxf new LoggingFeature CXF deprecated the old LoggingFeature, we need to switch to [new one|http://cxf.apache.org/docs/message-logging.html]."
CAMEL-12551,Camel does not have logic that checks that it should only retry when its a new/changed file,"Hello,

I am reading a file using the stream camel component. The behaviour expected is the following :
 # Read the stream
 # When the file roll over, start the reading the file from the begining

My code :

{{from(""stream:file?fileName=myfile&scanStream=true&scanStreamDelay=1000&retry=true"") }}

The problem with the code above is that the same file is read every 1000ms. The component don't check is the file was rolled over.

Thanks in advance.",davsclaus,Bug,Major,Resolved,"Camel does not have logic that checks that it should only retry when its a new/changed file Hello,

I am reading a file using the stream camel component. The behaviour expected is the following :
 # Read the stream
 # When the file roll over, start the reading the file from the begining

My code :

{{from(""stream:file?fileName=myfile&scanStream=true&scanStreamDelay=1000&retry=true"") }}

The problem with the code above is that the same file is read every 1000ms. The component don't check is the file was rolled over.

Thanks in advance."
CAMEL-12546,rest-dsl - Allow to configure rest configuration via spring boot auto configuration,"There are some global configurations you can configure on restConfiguration. We should make it possible to configure these via spring boot auto configuration, eg application.properties etc.",davsclaus,Improvement,Major,Resolved,"rest-dsl - Allow to configure rest configuration via spring boot auto configuration There are some global configurations you can configure on restConfiguration. We should make it possible to configure these via spring boot auto configuration, eg application.properties etc."
CAMEL-12540,We should avoid the address setting of CxfRsEndpointConfigurer ,"When using the CxfRsEndpointConfigurer to do the setting, the address setting from the Message header could be override.  We just need to make sure the address can be override from message header.",njiang,Bug,Minor,Resolved,"We should avoid the address setting of CxfRsEndpointConfigurer  When using the CxfRsEndpointConfigurer to do the setting, the address setting from the Message header could be override.  We just need to make sure the address can be override from message header."
CAMEL-12533,rest-dsl - Should check for required parameters generally,"See SO

[https://stackoverflow.com/questions/50489713/camel-rest-dsl-required-param-ignored]

There is AFAIR a little bit of required validation. But we could might as well do this if the user has specified those in the rest-dsl. 

Currently we rely a bit on the chosen http component to do its own validation. But since we have the rest-dsl contract at hand in the rest-dsl we should let camel-core figure this out.",davsclaus,Improvement,Major,Resolved,"rest-dsl - Should check for required parameters generally See SO

[https://stackoverflow.com/questions/50489713/camel-rest-dsl-required-param-ignored]

There is AFAIR a little bit of required validation. But we could might as well do this if the user has specified those in the rest-dsl. 

Currently we rely a bit on the chosen http component to do its own validation. But since we have the rest-dsl contract at hand in the rest-dsl we should let camel-core figure this out."
CAMEL-12532,Content Based Router in Java DSL may not resolve property placeholders in when predicates,Reported on gitter,davsclaus,Bug,Major,Resolved,Content Based Router in Java DSL may not resolve property placeholders in when predicates Reported on gitter
CAMEL-12529,Dynamic Router implementation behavior inconsistent with Dynamic Router EIP specification,"Currently, the Dynamic Router component of camel-core repeatedly routes messages back through the dynamic router, as indicated in the documentation. However, when examining the Dynamic Router EIP specification at [http://www.enterpriseintegrationpatterns.com/patterns/messaging/DynamicRouter.html], we can see that this behavior is not consistent with the specification.

The description is:
{quote}Use a Dynamic Router, a Router that can self-configure based on special configuration messages from participating destinations.

Besides the usual input and output channels the Dynamic Router uses an additional control channel. During system start-up, each potential recipient sends a special message to the Dynamic Router on this control channel, announcing its presence and listing the conditions under which it can handle a message. The Dynamic Router stores the 'preferences' for each participant in a rule base. When a message arrives, the Dynamic Router evaluates all rules and routes the message to the recipient whose rules are fulfilled. This allows for efficient, predictive routing without the maintenance dependency of the Dynamic Router on each potential recipient.
{quote}
Since the documentation specifies the re-routing nature of the dynamic router quite clearly, this is obviously not an unintended side-effect or consequence but, I believe, a misunderstanding of the EIP itself.  It appears that there _might_ be a point of confusion with the control channel that connects the potential endpoints to the rule base. This is not for re-routing of the messages, but for the potential endpoints to register rules with the dynamic router. While I am not certain how this should (or would) be implemented within Camel, the current behavior is not quite consistent with the description of the EIP",davsclaus,Improvement,Minor,Resolved,"Dynamic Router implementation behavior inconsistent with Dynamic Router EIP specification Currently, the Dynamic Router component of camel-core repeatedly routes messages back through the dynamic router, as indicated in the documentation. However, when examining the Dynamic Router EIP specification at [http://www.enterpriseintegrationpatterns.com/patterns/messaging/DynamicRouter.html], we can see that this behavior is not consistent with the specification.

The description is:
{quote}Use a Dynamic Router, a Router that can self-configure based on special configuration messages from participating destinations.

Besides the usual input and output channels the Dynamic Router uses an additional control channel. During system start-up, each potential recipient sends a special message to the Dynamic Router on this control channel, announcing its presence and listing the conditions under which it can handle a message. The Dynamic Router stores the 'preferences' for each participant in a rule base. When a message arrives, the Dynamic Router evaluates all rules and routes the message to the recipient whose rules are fulfilled. This allows for efficient, predictive routing without the maintenance dependency of the Dynamic Router on each potential recipient.
{quote}
Since the documentation specifies the re-routing nature of the dynamic router quite clearly, this is obviously not an unintended side-effect or consequence but, I believe, a misunderstanding of the EIP itself.  It appears that there _might_ be a point of confusion with the control channel that connects the potential endpoints to the rule base. This is not for re-routing of the messages, but for the potential endpoints to register rules with the dynamic router. While I am not certain how this should (or would) be implemented within Camel, the current behavior is not quite consistent with the description of the EIP"
CAMEL-12525,camel-kafka component commits the offset as soon as it is retrieved,"I am trying the maual commit from consumer below is the code snippet, i want to consume and  commit the message after 2 mins of its arrival in the topic. My consumer retrieves and checks the time difference if it is above 2 mins then it should commit. But message once retrieved and not committed manually. I am expecting it to come back but it does not comeback ever.  when i try creating kafka consumer it works fine

public void configure() throws Exception {
from(""kafka:BENEFITSLOADER.LOAD?brokers=xxxx:9092,xxxx:9092,xxxx:9092&groupId=BENEFITSLOADER&consumersCount=1&pollTimeoutMs=1000&autoCommitEnable=false&allowManualCommit=true&maxPollRecords=1"")
.process(new Processor() {
 @Override
 public void process(Exchange exchange) throws Exception {

 Long msgDateTime = (Long) exchange.getIn().getHeaders().get(KafkaConstants.TIMESTAMP);
 System.out.println(""Message : "" + (exchange.getIn().getHeaders()));
 System.out.println(""Message : "" + (exchange.getIn().getBody()));
 Date msgDate = new Date(msgDateTime);
 Date currentDate = new Date();
 long diff = currentDate.getTime() - msgDate.getTime();
 long diffMinutes = diff / (60 * 1000) % 60;
 System.out.println(""Difference in Minutes "" + diffMinutes);
 KafkaManualCommit manualCommit = exchange.getIn().getHeader(KafkaConstants.MANUAL_COMMIT, KafkaManualCommit.class);
if(diffMinutes > 2)
 {
 System.out.println(""Commiting Message "" + exchange.getIn().getBody()); 
 manualCommit.commitSync(); 
 } 
 }
 });
 }
 }

 

 

Code that works fine

 

public class TestKafkaConsumer {
 static Consumer<String, String> consumer = null;
 static ConsumerRecord<String,String> fetchedRecord; 
 static ConsumerRecords<String, String> records;
 public static void main(String... args) {


String topicName = ""BENEFITSLOADER.LOAD"";
 consumer = createConsumer();
 consumer.subscribe(Collections.singletonList(topicName));

try {
 while (true) {
 
 if(fetchedRecord == null)
 records = consumer.poll(1000);
 
 
 records.forEach(record -> { 
 fetchedRecord = record; 
 });
 
 if(fetchedRecord != null)
 {
 Date msgDate = new Date(fetchedRecord.timestamp());
 Date date = new Date(System.currentTimeMillis());
 long diff = date.getTime() - msgDate.getTime();
 long diffMinutes = diff / (60 * 1000) % 60;
 
 System.out.printf(""Consumer Record:(%s, %s, %d, %d)\n"",
 fetchedRecord.key(), fetchedRecord.value(),
 fetchedRecord.partition(), fetchedRecord.offset());
 if(diffMinutes > 2)
 {
 System.out.printf(""Consumer Record Commiting:(%s, %s, %d, %d)\n"",
 fetchedRecord.key(), fetchedRecord.value(),
 fetchedRecord.partition(), fetchedRecord.offset());
 consumer.commitSync();
 System.out.println(""Commited"");
 fetchedRecord = null;
 }
 } 
 }
 }

catch (Exception ex) {
 ex.printStackTrace();
 } finally { 
 consumer.close();
 }

}

private static Consumer<String, String> createConsumer() {
 Properties props = new Properties();
 props.put(ConsumerConfig.BOOTSTRAP_SERVERS_CONFIG, ""xxx:9092,xxx:9092,xxx:9093"");
 props.put(ConsumerConfig.GROUP_ID_CONFIG, ""BENEFITSLOADER"");
 props.put(ConsumerConfig.KEY_DESERIALIZER_CLASS_CONFIG, StringDeserializer.class.getName());
 props.put(ConsumerConfig.VALUE_DESERIALIZER_CLASS_CONFIG, StringDeserializer.class.getName());
 props.put(ConsumerConfig.ENABLE_AUTO_COMMIT_CONFIG, false);
 props.put(ConsumerConfig.MAX_POLL_RECORDS_CONFIG, 1);
 return new KafkaConsumer<>(props);
 }

}",davsclaus,Bug,Major,Resolved,"camel-kafka component commits the offset as soon as it is retrieved I am trying the maual commit from consumer below is the code snippet, i want to consume and  commit the message after 2 mins of its arrival in the topic. My consumer retrieves and checks the time difference if it is above 2 mins then it should commit. But message once retrieved and not committed manually. I am expecting it to come back but it does not comeback ever.  when i try creating kafka consumer it works fine

public void configure() throws Exception {
from(""kafka:BENEFITSLOADER.LOAD?brokers=xxxx:9092,xxxx:9092,xxxx:9092&groupId=BENEFITSLOADER&consumersCount=1&pollTimeoutMs=1000&autoCommitEnable=false&allowManualCommit=true&maxPollRecords=1"")
.process(new Processor() {
 @Override
 public void process(Exchange exchange) throws Exception {

 Long msgDateTime = (Long) exchange.getIn().getHeaders().get(KafkaConstants.TIMESTAMP);
 System.out.println(""Message : "" + (exchange.getIn().getHeaders()));
 System.out.println(""Message : "" + (exchange.getIn().getBody()));
 Date msgDate = new Date(msgDateTime);
 Date currentDate = new Date();
 long diff = currentDate.getTime() - msgDate.getTime();
 long diffMinutes = diff / (60 * 1000) % 60;
 System.out.println(""Difference in Minutes "" + diffMinutes);
 KafkaManualCommit manualCommit = exchange.getIn().getHeader(KafkaConstants.MANUAL_COMMIT, KafkaManualCommit.class);
if(diffMinutes > 2)
 {
 System.out.println(""Commiting Message "" + exchange.getIn().getBody()); 
 manualCommit.commitSync(); 
 } 
 }
 });
 }
 }

 

 

Code that works fine

 

public class TestKafkaConsumer {
 static Consumer<String, String> consumer = null;
 static ConsumerRecord<String,String> fetchedRecord; 
 static ConsumerRecords<String, String> records;
 public static void main(String... args) {


String topicName = ""BENEFITSLOADER.LOAD"";
 consumer = createConsumer();
 consumer.subscribe(Collections.singletonList(topicName));

try {
 while (true) {
 
 if(fetchedRecord == null)
 records = consumer.poll(1000);
 
 
 records.forEach(record -> { 
 fetchedRecord = record; 
 });
 
 if(fetchedRecord != null)
 {
 Date msgDate = new Date(fetchedRecord.timestamp());
 Date date = new Date(System.currentTimeMillis());
 long diff = date.getTime() - msgDate.getTime();
 long diffMinutes = diff / (60 * 1000) % 60;
 
 System.out.printf(""Consumer Record:(%s, %s, %d, %d)\n"",
 fetchedRecord.key(), fetchedRecord.value(),
 fetchedRecord.partition(), fetchedRecord.offset());
 if(diffMinutes > 2)
 {
 System.out.printf(""Consumer Record Commiting:(%s, %s, %d, %d)\n"",
 fetchedRecord.key(), fetchedRecord.value(),
 fetchedRecord.partition(), fetchedRecord.offset());
 consumer.commitSync();
 System.out.println(""Commited"");
 fetchedRecord = null;
 }
 } 
 }
 }

catch (Exception ex) {
 ex.printStackTrace();
 } finally { 
 consumer.close();
 }

}

private static Consumer<String, String> createConsumer() {
 Properties props = new Properties();
 props.put(ConsumerConfig.BOOTSTRAP_SERVERS_CONFIG, ""xxx:9092,xxx:9092,xxx:9093"");
 props.put(ConsumerConfig.GROUP_ID_CONFIG, ""BENEFITSLOADER"");
 props.put(ConsumerConfig.KEY_DESERIALIZER_CLASS_CONFIG, StringDeserializer.class.getName());
 props.put(ConsumerConfig.VALUE_DESERIALIZER_CLASS_CONFIG, StringDeserializer.class.getName());
 props.put(ConsumerConfig.ENABLE_AUTO_COMMIT_CONFIG, false);
 props.put(ConsumerConfig.MAX_POLL_RECORDS_CONFIG, 1);
 return new KafkaConsumer<>(props);
 }

}"
CAMEL-12520,FluentProducerTemplate.withExchange() does not seem to send exchange,"When I use the following simple but complete code example:
{code:java}
public static void main(String[] args) throws Exception {
    CamelContext camelContext = new DefaultCamelContext();
    camelContext.start();
    camelContext.addRoutes(new RouteBuilder() {
        @Override
        public void configure() {
            from(""direct-vm:start"").process(exchange -> {
                String incoming = exchange.getIn().getBody(String.class);
                exchange.getIn().setBody(""Message received: "" + incoming, String.class);
            });
        }
    });
    Exchange exchange = ExchangeBuilder.anExchange(camelContext)
            .withBody(""Hello!"")
            .withPattern(ExchangePattern.InOut)
            .build();
    System.out.println(
            camelContext.createFluentProducerTemplate()
            .withExchange(exchange)
            .to(""direct-vm:start"")
            .request(String.class)
    );
}{code}
The message body appears to be missing, as indicated in the program output:
{code:java}
Message received: null{code}
I have tried this with java 1.8 and 1.9, and with camel 2.19.2 and 2.21.1, and both camel versions exhibit the same behavior when run with both java versions.",davsclaus,Improvement,Minor,Resolved,"FluentProducerTemplate.withExchange() does not seem to send exchange When I use the following simple but complete code example:
{code:java}
public static void main(String[] args) throws Exception {
    CamelContext camelContext = new DefaultCamelContext();
    camelContext.start();
    camelContext.addRoutes(new RouteBuilder() {
        @Override
        public void configure() {
            from(""direct-vm:start"").process(exchange -> {
                String incoming = exchange.getIn().getBody(String.class);
                exchange.getIn().setBody(""Message received: "" + incoming, String.class);
            });
        }
    });
    Exchange exchange = ExchangeBuilder.anExchange(camelContext)
            .withBody(""Hello!"")
            .withPattern(ExchangePattern.InOut)
            .build();
    System.out.println(
            camelContext.createFluentProducerTemplate()
            .withExchange(exchange)
            .to(""direct-vm:start"")
            .request(String.class)
    );
}{code}
The message body appears to be missing, as indicated in the program output:
{code:java}
Message received: null{code}
I have tried this with java 1.8 and 1.9, and with camel 2.19.2 and 2.21.1, and both camel versions exhibit the same behavior when run with both java versions."
CAMEL-12513,Camel breadcrumb - Consider turning it off by default,"This was added many years ago with the breadcrumbId header. But today there is standards with opentracing / zipkin etc.

So ideally we should turn this off by default, and then point people to these other standards.

[http://camel.apache.org/mdc-logging.html]

 ",davsclaus,Improvement,Major,Resolved,"Camel breadcrumb - Consider turning it off by default This was added many years ago with the breadcrumbId header. But today there is standards with opentracing / zipkin etc.

So ideally we should turn this off by default, and then point people to these other standards.

[http://camel.apache.org/mdc-logging.html]

 "
CAMEL-12510,"Camel servlet component throw ""IOException: Stream closed"" during route processing for HTTP get request with custom processor","If i just build a simple Route like this to proxy a incoming Get request to external host:
{code:java}
    @Override
    public void configure() throws Exception {
        from(format(""servlet://%s?httpMethodRestrict=GET&servletName=%s"", RETRIEVE_PATH, servletName))
                .process((exchange) -> {
                    exchange.getOut().setHeader(Exchange.HTTP_URI, ""https://some.external.system/"");
                }).to(""https4:something"");
    }
{code}
The following exception is thrown:
{code:java}
org.apache.camel.RuntimeCamelException: java.io.IOException: Stream closed
	at org.apache.camel.http.common.HttpMessage.createBody(HttpMessage.java:80)
	at org.apache.camel.impl.MessageSupport.getBody(MessageSupport.java:54)
	at org.apache.camel.processor.DefaultExchangeFormatter.getBodyTypeAsString(DefaultExchangeFormatter.java:468)
	at org.apache.camel.processor.DefaultExchangeFormatter.format(DefaultExchangeFormatter.java:126)
	at org.apache.camel.processor.CamelLogProcessor.process(CamelLogProcessor.java:88)
	at org.apache.camel.component.log.LogProducer.process(LogProducer.java:40)
	at org.apache.camel.processor.SendProcessor.process(SendProcessor.java:148)
	at org.apache.camel.processor.RedeliveryErrorHandler.process(RedeliveryErrorHandler.java:548)
	at org.apache.camel.processor.CamelInternalProcessor.process(CamelInternalProcessor.java:201)
	at org.apache.camel.processor.Pipeline.process(Pipeline.java:138)
	at org.apache.camel.processor.Pipeline.process(Pipeline.java:101)
	at org.apache.camel.processor.CamelInternalProcessor.process(CamelInternalProcessor.java:201)
	at org.apache.camel.processor.DelegateAsyncProcessor.process(DelegateAsyncProcessor.java:97)
	at org.apache.camel.http.common.CamelServlet.doService(CamelServlet.java:208)
	at org.apache.camel.http.common.CamelServlet.service(CamelServlet.java:78)
	at javax.servlet.http.HttpServlet.service(HttpServlet.java:742)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:231)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166)
	at org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:52)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166)
	at org.springframework.boot.actuate.trace.WebRequestTraceFilter.doFilterInternal(WebRequestTraceFilter.java:110)
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:107)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166)
	at org.springframework.web.filter.RequestContextFilter.doFilterInternal(RequestContextFilter.java:99)
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:107)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166)
	at org.springframework.web.filter.HttpPutFormContentFilter.doFilterInternal(HttpPutFormContentFilter.java:108)
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:107)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166)
	at org.springframework.web.filter.HiddenHttpMethodFilter.doFilterInternal(HiddenHttpMethodFilter.java:81)
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:107)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166)
	at org.springframework.web.filter.CharacterEncodingFilter.doFilterInternal(CharacterEncodingFilter.java:197)
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:107)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166)
	at org.springframework.boot.actuate.autoconfigure.MetricsFilter.doFilterInternal(MetricsFilter.java:106)
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:107)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166)
	at org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:199)
	at org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:96)
	at org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:504)
	at org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:140)
	at org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:81)
	at org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:87)
	at org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:342)
	at org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:803)
	at org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:66)
	at org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:790)
	at org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1459)
	at org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:49)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)
	at org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:61)
	at java.lang.Thread.run(Thread.java:748)
Caused by: java.io.IOException: Stream closed
	at org.apache.catalina.connector.InputBuffer.read(InputBuffer.java:346)
	at org.apache.catalina.connector.CoyoteInputStream.read(CoyoteInputStream.java:152)
	at org.apache.camel.util.IOHelper.copy(IOHelper.java:202)
	at org.apache.camel.util.IOHelper.copy(IOHelper.java:174)
	at org.apache.camel.util.IOHelper.copyAndCloseInput(IOHelper.java:234)
	at org.apache.camel.util.IOHelper.copyAndCloseInput(IOHelper.java:230)
	at org.apache.camel.http.common.HttpHelper.readResponseBodyFromInputStream(HttpHelper.java:245)
	at org.apache.camel.http.common.HttpHelper.readRequestBodyFromServletRequest(HttpHelper.java:196)
	at org.apache.camel.http.common.DefaultHttpBinding.parseBody(DefaultHttpBinding.java:577)
	at org.apache.camel.http.common.HttpMessage.createBody(HttpMessage.java:78)
	... 60 more
{code}
*Workaround / Additional notice:*
 * If I rewrite my example route to work without a processor, {{.setHeader(Exchange.HTTP_URI, constant(""https://some.external.system/""))}} everything works, so it seems to be an issue with the processor handling. Nevertheless, processor logic should also work.
 * even if i use a simple {{to(""log:com.mycompany.order?showAll=true&multiline=true"")}} the issue occurs as well. So it has nothing to with the camel-http4 producer.
 * Adding ""mapHttpMessageBody=false"" to the servlet definition seems to be a proper workaround for my example, since I only proxy GET requests which never have a body in the request.
 * I already debug into the camel code, but i am not 100% sure if this is the correct place to fix: {{org.apache.camel.http.common.DefaultHttpBinding.parseBody(HttpMessage)}} - here it might make sense to skip body parsing for certain HTTP methods (e.g. GET)
 * I found two quiet similar issues on the mailing list:
 ** [http://camel.465427.n5.nabble.com/Stream-closed-exception-when-using-camel-as-http-proxy-with-tomcat-servlet-tt5809653.html#none]
 ** [http://camel.465427.n5.nabble.com/IOException-Stream-closed-when-forwarding-HTTP-request-td5796802.html]",davsclaus,Bug,Major,Resolved,"Camel servlet component throw ""IOException: Stream closed"" during route processing for HTTP get request with custom processor If i just build a simple Route like this to proxy a incoming Get request to external host:
{code:java}
    @Override
    public void configure() throws Exception {
        from(format(""servlet://%s?httpMethodRestrict=GET&servletName=%s"", RETRIEVE_PATH, servletName))
                .process((exchange) -> {
                    exchange.getOut().setHeader(Exchange.HTTP_URI, ""https://some.external.system/"");
                }).to(""https4:something"");
    }
{code}
The following exception is thrown:
{code:java}
org.apache.camel.RuntimeCamelException: java.io.IOException: Stream closed
	at org.apache.camel.http.common.HttpMessage.createBody(HttpMessage.java:80)
	at org.apache.camel.impl.MessageSupport.getBody(MessageSupport.java:54)
	at org.apache.camel.processor.DefaultExchangeFormatter.getBodyTypeAsString(DefaultExchangeFormatter.java:468)
	at org.apache.camel.processor.DefaultExchangeFormatter.format(DefaultExchangeFormatter.java:126)
	at org.apache.camel.processor.CamelLogProcessor.process(CamelLogProcessor.java:88)
	at org.apache.camel.component.log.LogProducer.process(LogProducer.java:40)
	at org.apache.camel.processor.SendProcessor.process(SendProcessor.java:148)
	at org.apache.camel.processor.RedeliveryErrorHandler.process(RedeliveryErrorHandler.java:548)
	at org.apache.camel.processor.CamelInternalProcessor.process(CamelInternalProcessor.java:201)
	at org.apache.camel.processor.Pipeline.process(Pipeline.java:138)
	at org.apache.camel.processor.Pipeline.process(Pipeline.java:101)
	at org.apache.camel.processor.CamelInternalProcessor.process(CamelInternalProcessor.java:201)
	at org.apache.camel.processor.DelegateAsyncProcessor.process(DelegateAsyncProcessor.java:97)
	at org.apache.camel.http.common.CamelServlet.doService(CamelServlet.java:208)
	at org.apache.camel.http.common.CamelServlet.service(CamelServlet.java:78)
	at javax.servlet.http.HttpServlet.service(HttpServlet.java:742)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:231)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166)
	at org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:52)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166)
	at org.springframework.boot.actuate.trace.WebRequestTraceFilter.doFilterInternal(WebRequestTraceFilter.java:110)
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:107)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166)
	at org.springframework.web.filter.RequestContextFilter.doFilterInternal(RequestContextFilter.java:99)
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:107)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166)
	at org.springframework.web.filter.HttpPutFormContentFilter.doFilterInternal(HttpPutFormContentFilter.java:108)
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:107)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166)
	at org.springframework.web.filter.HiddenHttpMethodFilter.doFilterInternal(HiddenHttpMethodFilter.java:81)
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:107)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166)
	at org.springframework.web.filter.CharacterEncodingFilter.doFilterInternal(CharacterEncodingFilter.java:197)
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:107)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166)
	at org.springframework.boot.actuate.autoconfigure.MetricsFilter.doFilterInternal(MetricsFilter.java:106)
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:107)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166)
	at org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:199)
	at org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:96)
	at org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:504)
	at org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:140)
	at org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:81)
	at org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:87)
	at org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:342)
	at org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:803)
	at org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:66)
	at org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:790)
	at org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1459)
	at org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:49)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)
	at org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:61)
	at java.lang.Thread.run(Thread.java:748)
Caused by: java.io.IOException: Stream closed
	at org.apache.catalina.connector.InputBuffer.read(InputBuffer.java:346)
	at org.apache.catalina.connector.CoyoteInputStream.read(CoyoteInputStream.java:152)
	at org.apache.camel.util.IOHelper.copy(IOHelper.java:202)
	at org.apache.camel.util.IOHelper.copy(IOHelper.java:174)
	at org.apache.camel.util.IOHelper.copyAndCloseInput(IOHelper.java:234)
	at org.apache.camel.util.IOHelper.copyAndCloseInput(IOHelper.java:230)
	at org.apache.camel.http.common.HttpHelper.readResponseBodyFromInputStream(HttpHelper.java:245)
	at org.apache.camel.http.common.HttpHelper.readRequestBodyFromServletRequest(HttpHelper.java:196)
	at org.apache.camel.http.common.DefaultHttpBinding.parseBody(DefaultHttpBinding.java:577)
	at org.apache.camel.http.common.HttpMessage.createBody(HttpMessage.java:78)
	... 60 more
{code}
*Workaround / Additional notice:*
 * If I rewrite my example route to work without a processor, {{.setHeader(Exchange.HTTP_URI, constant(""https://some.external.system/""))}} everything works, so it seems to be an issue with the processor handling. Nevertheless, processor logic should also work.
 * even if i use a simple {{to(""log:com.mycompany.order?showAll=true&multiline=true"")}} the issue occurs as well. So it has nothing to with the camel-http4 producer.
 * Adding ""mapHttpMessageBody=false"" to the servlet definition seems to be a proper workaround for my example, since I only proxy GET requests which never have a body in the request.
 * I already debug into the camel code, but i am not 100% sure if this is the correct place to fix: {{org.apache.camel.http.common.DefaultHttpBinding.parseBody(HttpMessage)}} - here it might make sense to skip body parsing for certain HTTP methods (e.g. GET)
 * I found two quiet similar issues on the mailing list:
 ** [http://camel.465427.n5.nabble.com/Stream-closed-exception-when-using-camel-as-http-proxy-with-tomcat-servlet-tt5809653.html#none]
 ** [http://camel.465427.n5.nabble.com/IOException-Stream-closed-when-forwarding-HTTP-request-td5796802.html]"
CAMEL-12503,Kafka component should be able to propagate camel headers to kafka,"Since 0.11.0 Kafka support headers, and it would be awesome to have such feature available also in camel component.",davsclaus,New Feature,Major,Resolved,"Kafka component should be able to propagate camel headers to kafka Since 0.11.0 Kafka support headers, and it would be awesome to have such feature available also in camel component."
CAMEL-12491,route-coverage : report summary problem,"Consider the example code given in CAMEL-12483

When running camel:route-coverage the report show to many passes for the routes. It looks like the RouteCoverageEventNotifier files holds the sum of all tests, and not just the values for the single test method. 
 
{code:java}
Class:  dk.smor.MySpringBootRouter
Route:  myRouteId

  Line #      Count   Route
  ------      -----   -----
      11          8   from
      13          8     log
      15          8     choice
      16          2       setBody
      18          2       log
      20          2       setBody
      22          2       log
      24          2       setBody
      26          2       log
      28          2       setBody
      30          2       log

Coverage: 11 out of 11 (100.0%)
{code}

each log statement should only have been passed 1 time. And a total for 4 passes for the whole route. 
 ",davsclaus,Bug,Minor,Resolved,"route-coverage : report summary problem Consider the example code given in CAMEL-12483

When running camel:route-coverage the report show to many passes for the routes. It looks like the RouteCoverageEventNotifier files holds the sum of all tests, and not just the values for the single test method. 
 
{code:java}
Class:  dk.smor.MySpringBootRouter
Route:  myRouteId

  Line #      Count   Route
  ------      -----   -----
      11          8   from
      13          8     log
      15          8     choice
      16          2       setBody
      18          2       log
      20          2       setBody
      22          2       log
      24          2       setBody
      26          2       log
      28          2       setBody
      30          2       log

Coverage: 11 out of 11 (100.0%)
{code}

each log statement should only have been passed 1 time. And a total for 4 passes for the whole route. 
 "
CAMEL-12490,Camel-jms: ClassNotFoundException: org.springframework.messaging.handler.annotation.support.MessageHandlerMethodFactory in Spring-Boot,"Not sure if this is a Camel bug, but I'm using activemq-camel 5.14.5 in a spring-boot 1.5.12 application.

After upgrading from Camel 2.21.0 to 2.21.1 start-up fails with:

{noformat}
2018-05-07 09:45:34.213 ERROR 7992 --- [  restartedMain] o.s.boot.SpringApplication               : Application startup failed

org.springframework.beans.factory.BeanCreationException: Error creating bean with name 'org.springframework.jms.config.internalJmsListenerAnnotationProcessor' defined in class path resource [org/springframework/jms/annotation/JmsBootstrapConfiguration.class]: Bean instantiation via factory method failed; nested exception is org.springframework.beans.BeanInstantiationException: Failed to instantiate [org.springframework.jms.annotation.JmsListenerAnnotationBeanPostProcessor]: Factory method 'jmsListenerAnnotationProcessor' threw exception; nested exception is java.lang.NoClassDefFoundError: org/springframework/messaging/handler/annotation/support/MessageHandlerMethodFactory
	at org.springframework.beans.factory.support.ConstructorResolver.instantiateUsingFactoryMethod(ConstructorResolver.java:599) ~[spring-beans-4.3.16.RELEASE.jar:4.3.16.RELEASE]
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.instantiateUsingFactoryMethod(AbstractAutowireCapableBeanFactory.java:1177) ~[spring-beans-4.3.16.RELEASE.jar:4.3.16.RELEASE]
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBeanInstance(AbstractAutowireCapableBeanFactory.java:1071) ~[spring-beans-4.3.16.RELEASE.jar:4.3.16.RELEASE]
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:513) ~[spring-beans-4.3.16.RELEASE.jar:4.3.16.RELEASE]
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:483) ~[spring-beans-4.3.16.RELEASE.jar:4.3.16.RELEASE]
	at org.springframework.beans.factory.support.AbstractBeanFactory$1.getObject(AbstractBeanFactory.java:312) ~[spring-beans-4.3.16.RELEASE.jar:4.3.16.RELEASE]
	at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:230) ~[spring-beans-4.3.16.RELEASE.jar:4.3.16.RELEASE]
	at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:308) ~[spring-beans-4.3.16.RELEASE.jar:4.3.16.RELEASE]
	at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:202) ~[spring-beans-4.3.16.RELEASE.jar:4.3.16.RELEASE]
	at org.springframework.context.support.PostProcessorRegistrationDelegate.registerBeanPostProcessors(PostProcessorRegistrationDelegate.java:225) ~[spring-context-4.3.16.RELEASE.jar:4.3.16.RELEASE]
	at org.springframework.context.support.AbstractApplicationContext.registerBeanPostProcessors(AbstractApplicationContext.java:703) ~[spring-context-4.3.16.RELEASE.jar:4.3.16.RELEASE]
	at org.springframework.context.support.AbstractApplicationContext.refresh(AbstractApplicationContext.java:528) ~[spring-context-4.3.16.RELEASE.jar:4.3.16.RELEASE]
	at org.springframework.boot.SpringApplication.refresh(SpringApplication.java:693) [spring-boot-1.5.12.RELEASE.jar:1.5.12.RELEASE]
	at org.springframework.boot.SpringApplication.refreshContext(SpringApplication.java:360) [spring-boot-1.5.12.RELEASE.jar:1.5.12.RELEASE]
	at org.springframework.boot.SpringApplication.run(SpringApplication.java:303) [spring-boot-1.5.12.RELEASE.jar:1.5.12.RELEASE]
	at org.springframework.boot.SpringApplication.run(SpringApplication.java:1118) [spring-boot-1.5.12.RELEASE.jar:1.5.12.RELEASE]
	at org.springframework.boot.SpringApplication.run(SpringApplication.java:1107) [spring-boot-1.5.12.RELEASE.jar:1.5.12.RELEASE]
	at de.telekom.dms.FlexKommBusinessServicesApplication.main(FlexKommBusinessServicesApplication.java:10) [classes/:na]
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) ~[na:1.8.0_121]
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) ~[na:1.8.0_121]
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) ~[na:1.8.0_121]
	at java.lang.reflect.Method.invoke(Method.java:498) ~[na:1.8.0_121]
	at org.springframework.boot.devtools.restart.RestartLauncher.run(RestartLauncher.java:49) [spring-boot-devtools-1.5.12.RELEASE.jar:1.5.12.RELEASE]
Caused by: org.springframework.beans.BeanInstantiationException: Failed to instantiate [org.springframework.jms.annotation.JmsListenerAnnotationBeanPostProcessor]: Factory method 'jmsListenerAnnotationProcessor' threw exception; nested exception is java.lang.NoClassDefFoundError: org/springframework/messaging/handler/annotation/support/MessageHandlerMethodFactory
	at org.springframework.beans.factory.support.SimpleInstantiationStrategy.instantiate(SimpleInstantiationStrategy.java:189) ~[spring-beans-4.3.16.RELEASE.jar:4.3.16.RELEASE]
	at org.springframework.beans.factory.support.ConstructorResolver.instantiateUsingFactoryMethod(ConstructorResolver.java:588) ~[spring-beans-4.3.16.RELEASE.jar:4.3.16.RELEASE]
	... 22 common frames omitted
Caused by: java.lang.NoClassDefFoundError: org/springframework/messaging/handler/annotation/support/MessageHandlerMethodFactory
	at java.lang.ClassLoader.defineClass1(Native Method) ~[na:1.8.0_121]
	at java.lang.ClassLoader.defineClass(ClassLoader.java:763) ~[na:1.8.0_121]
	at java.security.SecureClassLoader.defineClass(SecureClassLoader.java:142) ~[na:1.8.0_121]
	at java.net.URLClassLoader.defineClass(URLClassLoader.java:467) ~[na:1.8.0_121]
	at java.net.URLClassLoader.access$100(URLClassLoader.java:73) ~[na:1.8.0_121]
	at java.net.URLClassLoader$1.run(URLClassLoader.java:368) ~[na:1.8.0_121]
	at java.net.URLClassLoader$1.run(URLClassLoader.java:362) ~[na:1.8.0_121]
	at java.security.AccessController.doPrivileged(Native Method) ~[na:1.8.0_121]
	at java.net.URLClassLoader.findClass(URLClassLoader.java:361) ~[na:1.8.0_121]
	at java.lang.ClassLoader.loadClass(ClassLoader.java:424) ~[na:1.8.0_121]
	at sun.misc.Launcher$AppClassLoader.loadClass(Launcher.java:331) ~[na:1.8.0_121]
	at java.lang.ClassLoader.loadClass(ClassLoader.java:357) ~[na:1.8.0_121]
	at org.springframework.jms.annotation.JmsListenerAnnotationBeanPostProcessor.<init>(JmsListenerAnnotationBeanPostProcessor.java:103) ~[spring-jms-4.3.16.RELEASE.jar:4.3.16.RELEASE]
	at org.springframework.jms.annotation.JmsBootstrapConfiguration.jmsListenerAnnotationProcessor(JmsBootstrapConfiguration.java:47) ~[spring-jms-4.3.16.RELEASE.jar:4.3.16.RELEASE]
	at org.springframework.jms.annotation.JmsBootstrapConfiguration$$EnhancerBySpringCGLIB$$1878cc3d.CGLIB$jmsListenerAnnotationProcessor$1(<generated>) ~[spring-jms-4.3.16.RELEASE.jar:4.3.16.RELEASE]
	at org.springframework.jms.annotation.JmsBootstrapConfiguration$$EnhancerBySpringCGLIB$$1878cc3d$$FastClassBySpringCGLIB$$265c8d54.invoke(<generated>) ~[spring-jms-4.3.16.RELEASE.jar:4.3.16.RELEASE]
	at org.springframework.cglib.proxy.MethodProxy.invokeSuper(MethodProxy.java:228) ~[spring-core-4.3.16.RELEASE.jar:4.3.16.RELEASE]
	at org.springframework.context.annotation.ConfigurationClassEnhancer$BeanMethodInterceptor.intercept(ConfigurationClassEnhancer.java:358) ~[spring-context-4.3.16.RELEASE.jar:4.3.16.RELEASE]
	at org.springframework.jms.annotation.JmsBootstrapConfiguration$$EnhancerBySpringCGLIB$$1878cc3d.jmsListenerAnnotationProcessor(<generated>) ~[spring-jms-4.3.16.RELEASE.jar:4.3.16.RELEASE]
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) ~[na:1.8.0_121]
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) ~[na:1.8.0_121]
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) ~[na:1.8.0_121]
	at java.lang.reflect.Method.invoke(Method.java:498) ~[na:1.8.0_121]
	at org.springframework.beans.factory.support.SimpleInstantiationStrategy.instantiate(SimpleInstantiationStrategy.java:162) ~[spring-beans-4.3.16.RELEASE.jar:4.3.16.RELEASE]
	... 23 common frames omitted
Caused by: java.lang.ClassNotFoundException: org.springframework.messaging.handler.annotation.support.MessageHandlerMethodFactory
	at java.net.URLClassLoader.findClass(URLClassLoader.java:381) ~[na:1.8.0_121]
	at java.lang.ClassLoader.loadClass(ClassLoader.java:424) ~[na:1.8.0_121]
	at sun.misc.Launcher$AppClassLoader.loadClass(Launcher.java:331) ~[na:1.8.0_121]
	at java.lang.ClassLoader.loadClass(ClassLoader.java:357) ~[na:1.8.0_121]
	... 47 common frames omitted
{noformat}

The cause is https://issues.apache.org/jira/browse/CAMEL-12447, because when I add

{code}
<dependency>
    <groupId>org.springframework</groupId>
    <artifactId>spring-messaging</artifactId>
</dependency>
{code}

everything works fine again.

",davsclaus,Bug,Major,Resolved,"Camel-jms: ClassNotFoundException: org.springframework.messaging.handler.annotation.support.MessageHandlerMethodFactory in Spring-Boot Not sure if this is a Camel bug, but I'm using activemq-camel 5.14.5 in a spring-boot 1.5.12 application.

After upgrading from Camel 2.21.0 to 2.21.1 start-up fails with:

{noformat}
2018-05-07 09:45:34.213 ERROR 7992 --- [  restartedMain] o.s.boot.SpringApplication               : Application startup failed

org.springframework.beans.factory.BeanCreationException: Error creating bean with name 'org.springframework.jms.config.internalJmsListenerAnnotationProcessor' defined in class path resource [org/springframework/jms/annotation/JmsBootstrapConfiguration.class]: Bean instantiation via factory method failed; nested exception is org.springframework.beans.BeanInstantiationException: Failed to instantiate [org.springframework.jms.annotation.JmsListenerAnnotationBeanPostProcessor]: Factory method 'jmsListenerAnnotationProcessor' threw exception; nested exception is java.lang.NoClassDefFoundError: org/springframework/messaging/handler/annotation/support/MessageHandlerMethodFactory
	at org.springframework.beans.factory.support.ConstructorResolver.instantiateUsingFactoryMethod(ConstructorResolver.java:599) ~[spring-beans-4.3.16.RELEASE.jar:4.3.16.RELEASE]
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.instantiateUsingFactoryMethod(AbstractAutowireCapableBeanFactory.java:1177) ~[spring-beans-4.3.16.RELEASE.jar:4.3.16.RELEASE]
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBeanInstance(AbstractAutowireCapableBeanFactory.java:1071) ~[spring-beans-4.3.16.RELEASE.jar:4.3.16.RELEASE]
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:513) ~[spring-beans-4.3.16.RELEASE.jar:4.3.16.RELEASE]
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:483) ~[spring-beans-4.3.16.RELEASE.jar:4.3.16.RELEASE]
	at org.springframework.beans.factory.support.AbstractBeanFactory$1.getObject(AbstractBeanFactory.java:312) ~[spring-beans-4.3.16.RELEASE.jar:4.3.16.RELEASE]
	at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:230) ~[spring-beans-4.3.16.RELEASE.jar:4.3.16.RELEASE]
	at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:308) ~[spring-beans-4.3.16.RELEASE.jar:4.3.16.RELEASE]
	at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:202) ~[spring-beans-4.3.16.RELEASE.jar:4.3.16.RELEASE]
	at org.springframework.context.support.PostProcessorRegistrationDelegate.registerBeanPostProcessors(PostProcessorRegistrationDelegate.java:225) ~[spring-context-4.3.16.RELEASE.jar:4.3.16.RELEASE]
	at org.springframework.context.support.AbstractApplicationContext.registerBeanPostProcessors(AbstractApplicationContext.java:703) ~[spring-context-4.3.16.RELEASE.jar:4.3.16.RELEASE]
	at org.springframework.context.support.AbstractApplicationContext.refresh(AbstractApplicationContext.java:528) ~[spring-context-4.3.16.RELEASE.jar:4.3.16.RELEASE]
	at org.springframework.boot.SpringApplication.refresh(SpringApplication.java:693) [spring-boot-1.5.12.RELEASE.jar:1.5.12.RELEASE]
	at org.springframework.boot.SpringApplication.refreshContext(SpringApplication.java:360) [spring-boot-1.5.12.RELEASE.jar:1.5.12.RELEASE]
	at org.springframework.boot.SpringApplication.run(SpringApplication.java:303) [spring-boot-1.5.12.RELEASE.jar:1.5.12.RELEASE]
	at org.springframework.boot.SpringApplication.run(SpringApplication.java:1118) [spring-boot-1.5.12.RELEASE.jar:1.5.12.RELEASE]
	at org.springframework.boot.SpringApplication.run(SpringApplication.java:1107) [spring-boot-1.5.12.RELEASE.jar:1.5.12.RELEASE]
	at de.telekom.dms.FlexKommBusinessServicesApplication.main(FlexKommBusinessServicesApplication.java:10) [classes/:na]
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) ~[na:1.8.0_121]
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) ~[na:1.8.0_121]
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) ~[na:1.8.0_121]
	at java.lang.reflect.Method.invoke(Method.java:498) ~[na:1.8.0_121]
	at org.springframework.boot.devtools.restart.RestartLauncher.run(RestartLauncher.java:49) [spring-boot-devtools-1.5.12.RELEASE.jar:1.5.12.RELEASE]
Caused by: org.springframework.beans.BeanInstantiationException: Failed to instantiate [org.springframework.jms.annotation.JmsListenerAnnotationBeanPostProcessor]: Factory method 'jmsListenerAnnotationProcessor' threw exception; nested exception is java.lang.NoClassDefFoundError: org/springframework/messaging/handler/annotation/support/MessageHandlerMethodFactory
	at org.springframework.beans.factory.support.SimpleInstantiationStrategy.instantiate(SimpleInstantiationStrategy.java:189) ~[spring-beans-4.3.16.RELEASE.jar:4.3.16.RELEASE]
	at org.springframework.beans.factory.support.ConstructorResolver.instantiateUsingFactoryMethod(ConstructorResolver.java:588) ~[spring-beans-4.3.16.RELEASE.jar:4.3.16.RELEASE]
	... 22 common frames omitted
Caused by: java.lang.NoClassDefFoundError: org/springframework/messaging/handler/annotation/support/MessageHandlerMethodFactory
	at java.lang.ClassLoader.defineClass1(Native Method) ~[na:1.8.0_121]
	at java.lang.ClassLoader.defineClass(ClassLoader.java:763) ~[na:1.8.0_121]
	at java.security.SecureClassLoader.defineClass(SecureClassLoader.java:142) ~[na:1.8.0_121]
	at java.net.URLClassLoader.defineClass(URLClassLoader.java:467) ~[na:1.8.0_121]
	at java.net.URLClassLoader.access$100(URLClassLoader.java:73) ~[na:1.8.0_121]
	at java.net.URLClassLoader$1.run(URLClassLoader.java:368) ~[na:1.8.0_121]
	at java.net.URLClassLoader$1.run(URLClassLoader.java:362) ~[na:1.8.0_121]
	at java.security.AccessController.doPrivileged(Native Method) ~[na:1.8.0_121]
	at java.net.URLClassLoader.findClass(URLClassLoader.java:361) ~[na:1.8.0_121]
	at java.lang.ClassLoader.loadClass(ClassLoader.java:424) ~[na:1.8.0_121]
	at sun.misc.Launcher$AppClassLoader.loadClass(Launcher.java:331) ~[na:1.8.0_121]
	at java.lang.ClassLoader.loadClass(ClassLoader.java:357) ~[na:1.8.0_121]
	at org.springframework.jms.annotation.JmsListenerAnnotationBeanPostProcessor.<init>(JmsListenerAnnotationBeanPostProcessor.java:103) ~[spring-jms-4.3.16.RELEASE.jar:4.3.16.RELEASE]
	at org.springframework.jms.annotation.JmsBootstrapConfiguration.jmsListenerAnnotationProcessor(JmsBootstrapConfiguration.java:47) ~[spring-jms-4.3.16.RELEASE.jar:4.3.16.RELEASE]
	at org.springframework.jms.annotation.JmsBootstrapConfiguration$$EnhancerBySpringCGLIB$$1878cc3d.CGLIB$jmsListenerAnnotationProcessor$1(<generated>) ~[spring-jms-4.3.16.RELEASE.jar:4.3.16.RELEASE]
	at org.springframework.jms.annotation.JmsBootstrapConfiguration$$EnhancerBySpringCGLIB$$1878cc3d$$FastClassBySpringCGLIB$$265c8d54.invoke(<generated>) ~[spring-jms-4.3.16.RELEASE.jar:4.3.16.RELEASE]
	at org.springframework.cglib.proxy.MethodProxy.invokeSuper(MethodProxy.java:228) ~[spring-core-4.3.16.RELEASE.jar:4.3.16.RELEASE]
	at org.springframework.context.annotation.ConfigurationClassEnhancer$BeanMethodInterceptor.intercept(ConfigurationClassEnhancer.java:358) ~[spring-context-4.3.16.RELEASE.jar:4.3.16.RELEASE]
	at org.springframework.jms.annotation.JmsBootstrapConfiguration$$EnhancerBySpringCGLIB$$1878cc3d.jmsListenerAnnotationProcessor(<generated>) ~[spring-jms-4.3.16.RELEASE.jar:4.3.16.RELEASE]
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) ~[na:1.8.0_121]
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) ~[na:1.8.0_121]
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) ~[na:1.8.0_121]
	at java.lang.reflect.Method.invoke(Method.java:498) ~[na:1.8.0_121]
	at org.springframework.beans.factory.support.SimpleInstantiationStrategy.instantiate(SimpleInstantiationStrategy.java:162) ~[spring-beans-4.3.16.RELEASE.jar:4.3.16.RELEASE]
	... 23 common frames omitted
Caused by: java.lang.ClassNotFoundException: org.springframework.messaging.handler.annotation.support.MessageHandlerMethodFactory
	at java.net.URLClassLoader.findClass(URLClassLoader.java:381) ~[na:1.8.0_121]
	at java.lang.ClassLoader.loadClass(ClassLoader.java:424) ~[na:1.8.0_121]
	at sun.misc.Launcher$AppClassLoader.loadClass(Launcher.java:331) ~[na:1.8.0_121]
	at java.lang.ClassLoader.loadClass(ClassLoader.java:357) ~[na:1.8.0_121]
	... 47 common frames omitted
{noformat}

The cause is https://issues.apache.org/jira/browse/CAMEL-12447, because when I add

{code}
<dependency>
    <groupId>org.springframework</groupId>
    <artifactId>spring-messaging</artifactId>
</dependency>
{code}

everything works fine again.

"
CAMEL-12486,Placeholders are not resolved in Simple language while using resource: prefix,"This behavior was found in question https://stackoverflow.com/questions/50063874/load-camels-body-dynamically-depending-on-header

This is because expression with prefix *resource* is resolved in LanguageSupport#loadResource before property placeholders are resolved. This is reasonable, as placeholders are resolved in expression loaded from file. But it prevents from dynamic resource loading.

It would be nice to allow property resolution in resource in this way
{code:java}
.transform().simple(""resource:classpath:${header.myFileName}""){code}
I would expect this behavior:
 # Resolve placeholders in expression (now missing)
 # Load String from resource as new expression (exists)
 # Resolve placeholders in new expression (exists)

I have tried to create patch for *SimpleLanguage*, but I failed. Attaching patch to *SimpleResourceTest* with expected behavior based on master.",davsclaus,Wish,Minor,Resolved,"Placeholders are not resolved in Simple language while using resource: prefix This behavior was found in question https://stackoverflow.com/questions/50063874/load-camels-body-dynamically-depending-on-header

This is because expression with prefix *resource* is resolved in LanguageSupport#loadResource before property placeholders are resolved. This is reasonable, as placeholders are resolved in expression loaded from file. But it prevents from dynamic resource loading.

It would be nice to allow property resolution in resource in this way
{code:java}
.transform().simple(""resource:classpath:${header.myFileName}""){code}
I would expect this behavior:
 # Resolve placeholders in expression (now missing)
 # Load String from resource as new expression (exists)
 # Resolve placeholders in new expression (exists)

I have tried to create patch for *SimpleLanguage*, but I failed. Attaching patch to *SimpleResourceTest* with expected behavior based on master."
CAMEL-12483,route-coverage : endChoice() problem,"When running 
{code:java}
mvn camel:route-coverage{code}
on routes that use endChoice() you get a NullPointerException. 
{code:java}
[WARNING] Error parsing java file c:\workspace\kk\coverage\src\main\java\dk\smor\MySpringBootRouter.java code due null
java.lang.NullPointerException
at org.apache.camel.parser.helper.CamelJavaTreeParserHelper.parseCamelRouteTree(CamelJavaTreeParserHelper.java:132)
at org.apache.camel.parser.RouteBuilderParser.parseRouteBuilderTree(RouteBuilderParser.java:80)
at org.apache.camel.maven.RouteCoverageMojo.execute(RouteCoverageMojo.java:158)
at org.apache.maven.plugin.DefaultBuildPluginManager.executeMojo(DefaultBuildPluginManager.java:134)
at org.apache.maven.lifecycle.internal.MojoExecutor.execute(MojoExecutor.java:207)
at org.apache.maven.lifecycle.internal.MojoExecutor.execute(MojoExecutor.java:153)
at org.apache.maven.lifecycle.internal.MojoExecutor.execute(MojoExecutor.java:145)
at org.apache.maven.lifecycle.internal.LifecycleModuleBuilder.buildProject(LifecycleModuleBuilder.java:116)
at org.apache.maven.lifecycle.internal.LifecycleModuleBuilder.buildProject(LifecycleModuleBuilder.java:80)
at org.apache.maven.lifecycle.internal.builder.singlethreaded.SingleThreadedBuilder.build(SingleThreadedBuilder.java:51)
at org.apache.maven.lifecycle.internal.LifecycleStarter.execute(LifecycleStarter.java:128)
at org.apache.maven.DefaultMaven.doExecute(DefaultMaven.java:307)
at org.apache.maven.DefaultMaven.doExecute(DefaultMaven.java:193)
at org.apache.maven.DefaultMaven.execute(DefaultMaven.java:106)
at org.apache.maven.cli.MavenCli.execute(MavenCli.java:863)
at org.apache.maven.cli.MavenCli.doMain(MavenCli.java:288)
at org.apache.maven.cli.MavenCli.main(MavenCli.java:199)
at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
at java.lang.reflect.Method.invoke(Method.java:498)
at org.codehaus.plexus.classworlds.launcher.Launcher.launchEnhanced(Launcher.java:289)
at org.codehaus.plexus.classworlds.launcher.Launcher.launch(Launcher.java:229)
at org.codehaus.plexus.classworlds.launcher.Launcher.mainWithExitCode(Launcher.java:415)
at org.codehaus.plexus.classworlds.launcher.Launcher.main(Launcher.java:356)
{code}

I have attached a zip file with some example code to re-produce the problem.
The example code has 2 routes, 1 with endChoice() and 1 without. The 2 route should behave equally.
",davsclaus,Bug,Minor,Resolved,"route-coverage : endChoice() problem When running 
{code:java}
mvn camel:route-coverage{code}
on routes that use endChoice() you get a NullPointerException. 
{code:java}
[WARNING] Error parsing java file c:\workspace\kk\coverage\src\main\java\dk\smor\MySpringBootRouter.java code due null
java.lang.NullPointerException
at org.apache.camel.parser.helper.CamelJavaTreeParserHelper.parseCamelRouteTree(CamelJavaTreeParserHelper.java:132)
at org.apache.camel.parser.RouteBuilderParser.parseRouteBuilderTree(RouteBuilderParser.java:80)
at org.apache.camel.maven.RouteCoverageMojo.execute(RouteCoverageMojo.java:158)
at org.apache.maven.plugin.DefaultBuildPluginManager.executeMojo(DefaultBuildPluginManager.java:134)
at org.apache.maven.lifecycle.internal.MojoExecutor.execute(MojoExecutor.java:207)
at org.apache.maven.lifecycle.internal.MojoExecutor.execute(MojoExecutor.java:153)
at org.apache.maven.lifecycle.internal.MojoExecutor.execute(MojoExecutor.java:145)
at org.apache.maven.lifecycle.internal.LifecycleModuleBuilder.buildProject(LifecycleModuleBuilder.java:116)
at org.apache.maven.lifecycle.internal.LifecycleModuleBuilder.buildProject(LifecycleModuleBuilder.java:80)
at org.apache.maven.lifecycle.internal.builder.singlethreaded.SingleThreadedBuilder.build(SingleThreadedBuilder.java:51)
at org.apache.maven.lifecycle.internal.LifecycleStarter.execute(LifecycleStarter.java:128)
at org.apache.maven.DefaultMaven.doExecute(DefaultMaven.java:307)
at org.apache.maven.DefaultMaven.doExecute(DefaultMaven.java:193)
at org.apache.maven.DefaultMaven.execute(DefaultMaven.java:106)
at org.apache.maven.cli.MavenCli.execute(MavenCli.java:863)
at org.apache.maven.cli.MavenCli.doMain(MavenCli.java:288)
at org.apache.maven.cli.MavenCli.main(MavenCli.java:199)
at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
at java.lang.reflect.Method.invoke(Method.java:498)
at org.codehaus.plexus.classworlds.launcher.Launcher.launchEnhanced(Launcher.java:289)
at org.codehaus.plexus.classworlds.launcher.Launcher.launch(Launcher.java:229)
at org.codehaus.plexus.classworlds.launcher.Launcher.mainWithExitCode(Launcher.java:415)
at org.codehaus.plexus.classworlds.launcher.Launcher.main(Launcher.java:356)
{code}

I have attached a zip file with some example code to re-produce the problem.
The example code has 2 routes, 1 with endChoice() and 1 without. The 2 route should behave equally.
"
CAMEL-12475,Undertow consumer with http4 producer results in Undertow throwing NullPointerException,"I have a very simple setup of Camel (standalone).

My route is as follows:
{code:java}
public class Application {
    public static void main(String... args) throws Exception {
        Main main = new Main();

        main.addRouteBuilder(new RouteBuilder() {
            @Override
            public void configure() throws Exception {
                restConfiguration().port(8080);

                rest(""/pi"")
                        .get()
                        .route()
                        .setExchangePattern(ExchangePattern.InOut)
                        .to(""https4://api.pi.delivery/v1/pi?bridgeEndpoint=true"");
            }
        });

        main.run();
    }
}{code}
Call the endpoint with: 
{noformat}
curl ""http://localhost:8080/pi?start=0&numberOfDigits=10""{noformat}
 

When using camel-undertow for consumer and camel-http4 for producer, I get a NullPointerException.
{code:java}
java.lang.NullPointerException: null
at io.undertow.io.AsyncSenderImpl.send(AsyncSenderImpl.java:141) ~[undertow-core-1.4.23.Final.jar:1.4.23.Final]
at io.undertow.io.AsyncSenderImpl.send(AsyncSenderImpl.java:285) ~[undertow-core-1.4.23.Final.jar:1.4.23.Final]
at org.apache.camel.component.undertow.UndertowConsumer.handleRequest(UndertowConsumer.java:142) ~[camel-undertow-2.21.0.jar:2.21.0]
at io.undertow.server.Connectors.executeRootHandler(Connectors.java:336) ~[undertow-core-1.4.23.Final.jar:1.4.23.Final]
at io.undertow.server.HttpServerExchange$1.run(HttpServerExchange.java:830) ~[undertow-core-1.4.23.Final.jar:1.4.23.Final]
at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142) ~[na:1.8.0_102]
at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617) ~[na:1.8.0_102]
at java.lang.Thread.run(Thread.java:745) ~[na:1.8.0_102]
{code}
However, if I switch out the camel-undertow dependency with camel-jetty, the above route configuration works just fine.",njiang,Bug,Major,Resolved,"Undertow consumer with http4 producer results in Undertow throwing NullPointerException I have a very simple setup of Camel (standalone).

My route is as follows:
{code:java}
public class Application {
    public static void main(String... args) throws Exception {
        Main main = new Main();

        main.addRouteBuilder(new RouteBuilder() {
            @Override
            public void configure() throws Exception {
                restConfiguration().port(8080);

                rest(""/pi"")
                        .get()
                        .route()
                        .setExchangePattern(ExchangePattern.InOut)
                        .to(""https4://api.pi.delivery/v1/pi?bridgeEndpoint=true"");
            }
        });

        main.run();
    }
}{code}
Call the endpoint with: 
{noformat}
curl ""http://localhost:8080/pi?start=0&numberOfDigits=10""{noformat}
 

When using camel-undertow for consumer and camel-http4 for producer, I get a NullPointerException.
{code:java}
java.lang.NullPointerException: null
at io.undertow.io.AsyncSenderImpl.send(AsyncSenderImpl.java:141) ~[undertow-core-1.4.23.Final.jar:1.4.23.Final]
at io.undertow.io.AsyncSenderImpl.send(AsyncSenderImpl.java:285) ~[undertow-core-1.4.23.Final.jar:1.4.23.Final]
at org.apache.camel.component.undertow.UndertowConsumer.handleRequest(UndertowConsumer.java:142) ~[camel-undertow-2.21.0.jar:2.21.0]
at io.undertow.server.Connectors.executeRootHandler(Connectors.java:336) ~[undertow-core-1.4.23.Final.jar:1.4.23.Final]
at io.undertow.server.HttpServerExchange$1.run(HttpServerExchange.java:830) ~[undertow-core-1.4.23.Final.jar:1.4.23.Final]
at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142) ~[na:1.8.0_102]
at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617) ~[na:1.8.0_102]
at java.lang.Thread.run(Thread.java:745) ~[na:1.8.0_102]
{code}
However, if I switch out the camel-undertow dependency with camel-jetty, the above route configuration works just fine."
CAMEL-12469,How to do dynamic redirecting for rest and soap calls in Apache Camel without bothering what the request method type(post/get/update/delete) and request payload.,"Incoming REST Url: [http://localhost:8888/carParking/carCheckOut]

Redirect URL  will be like: Redirect Url – [http://\|http://issues.apache.org/]{localhost:9090}/\{MainController}/\{requestParam}

Example: [http://camelRouteHost:9090/carParking/carCheckIn|http://camelroutehost:9090/carParking/carCheckIn]

I just want to redirect the rest/soap url without bothering method type(post/put etc..) and request payload(json/xml)

And i just want to display same result what my actual endpoint is giving.

 

 ",davsclaus,Bug,Major,Closed,"How to do dynamic redirecting for rest and soap calls in Apache Camel without bothering what the request method type(post/get/update/delete) and request payload. Incoming REST Url: [http://localhost:8888/carParking/carCheckOut]

Redirect URL  will be like: Redirect Url - [http://\|http://issues.apache.org/]{localhost:9090}/\{MainController}/\{requestParam}

Example: [http://camelRouteHost:9090/carParking/carCheckIn|http://camelroutehost:9090/carParking/carCheckIn]

I just want to redirect the rest/soap url without bothering method type(post/put etc..) and request payload(json/xml)

And i just want to display same result what my actual endpoint is giving.

 

 "
CAMEL-12467,FatJarRouter no longer exists,"Inthe documentation, FatJarRouter is referenced as the entry point for spring boot apps

 

[http://camel.apache.org/spring-boot.html]

 

This is no longer the case.  If I read this PR correctly, [https://github.com/apache/camel/pull/1222] , users have to implement it the normal way in spring boot, just using a main method.",davsclaus,Bug,Major,Resolved,"FatJarRouter no longer exists Inthe documentation, FatJarRouter is referenced as the entry point for spring boot apps

 

[http://camel.apache.org/spring-boot.html]

 

This is no longer the case.  If I read this PR correctly, [https://github.com/apache/camel/pull/1222] , users have to implement it the normal way in spring boot, just using a main method."
CAMEL-12462,toD with HTTP endpoints - Optimise dynamic query to leverage HTTP_QUERY header,"We can consider for some HTTP components that support dynamic parts of their endpoints from Camel headers such as HTTP_QUERY and others.

We can then in toD detect those components and then build a processor chain that does
 # setHeader - set dynamic header HTTP_QUERY
 # toD - call the endpoint with a more static uri

This optimises to reuse the toD with more static uris, especially if you hit the same host for each toD and its only the query parameters that are dynamic.

Today developers would need to use setHeader and to combo to do this, instead of a single toD.

The trick is to separate the query parameters and the endpoint parameters and only set query parameters in the setHeader, and the endpoint parameters in toD.",davsclaus,Improvement,Major,Resolved,"toD with HTTP endpoints - Optimise dynamic query to leverage HTTP_QUERY header We can consider for some HTTP components that support dynamic parts of their endpoints from Camel headers such as HTTP_QUERY and others.

We can then in toD detect those components and then build a processor chain that does
 # setHeader - set dynamic header HTTP_QUERY
 # toD - call the endpoint with a more static uri

This optimises to reuse the toD with more static uris, especially if you hit the same host for each toD and its only the query parameters that are dynamic.

Today developers would need to use setHeader and to combo to do this, instead of a single toD.

The trick is to separate the query parameters and the endpoint parameters and only set query parameters in the setHeader, and the endpoint parameters in toD."
CAMEL-12458,camel-twitter - Should support extended mode by default,"So we can receive > 140 chars.

 

See this PR

https://github.com/apache/camel/pull/2292",davsclaus,Improvement,Major,Resolved,"camel-twitter - Should support extended mode by default So we can receive > 140 chars.

 

See this PR

https://github.com/apache/camel/pull/2292"
CAMEL-12457,file consumer - Should not use readlock by default,"The file consumer should use readLock=none by default, which is also what the documentation says. However its reconfigured to markerFile which is a little mistake.

 ",davsclaus,Bug,Major,Resolved,"file consumer - Should not use readlock by default The file consumer should use readLock=none by default, which is also what the documentation says. However its reconfigured to markerFile which is a little mistake.

 "
CAMEL-12454,camel-kafka - AutoCommitEnabled=false should not auto commit,"Reported on gitter

John Culleton @jcullet Apr 17 17:22
Hi All - I'm running into an issue with the camel-kafka component when attempting to disable auto commit behavior. On camel 2.21, I'm finding that the offset is being committed even when ""autoCommitEnable=false"" is specified. When running through a debugger, I see that the offset commit is happening here: https://github.com/apache/camel/blob/0f98938e3b6ea15a2e022c707bf21a2af4ed7e0d/components/camel-kafka/src/main/java/org/apache/camel/component/kafka/KafkaConsumer.java#L382. Based on the conditional, I think it would always evaluate to true when autoCommitEnable is set to false?",davsclaus,Bug,Major,Resolved,"camel-kafka - AutoCommitEnabled=false should not auto commit Reported on gitter

John Culleton @jcullet Apr 17 17:22
Hi All - I'm running into an issue with the camel-kafka component when attempting to disable auto commit behavior. On camel 2.21, I'm finding that the offset is being committed even when ""autoCommitEnable=false"" is specified. When running through a debugger, I see that the offset commit is happening here: https://github.com/apache/camel/blob/0f98938e3b6ea15a2e022c707bf21a2af4ed7e0d/components/camel-kafka/src/main/java/org/apache/camel/component/kafka/KafkaConsumer.java#L382. Based on the conditional, I think it would always evaluate to true when autoCommitEnable is set to false?"
