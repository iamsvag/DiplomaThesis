{"issues":[
    {
      "key":"CAMEL-14041",
      "title":"scheduled poll consumer - Add option to limit number of polls",
      "description":"In the timer\/scheduler component you can set a max number of polls so the consumer stop after that.\r\n\r\nWe could add something similar so you can eg tell the consumer to run only once etc.",
      "assignee":"davsclaus",
      "type":"Improvement",
      "priority":"Major",
      "status":"Resolved",
      "text":"scheduled poll consumer - Add option to limit number of polls In the timer\/scheduler component you can set a max number of polls so the consumer stop after that.\r\n\r\nWe could add something similar so you can eg tell the consumer to run only once etc."
    },
    {
      "key":"CAMEL-14040",
      "title":"DefaultRegistry - findByType should return merged result incl fallback",
      "description":"Reported by Luca in camel-quarkus",
      "assignee":"davsclaus",
      "type":"Improvement",
      "priority":"Major",
      "status":"Resolved",
      "text":"DefaultRegistry - findByType should return merged result incl fallback Reported by Luca in camel-quarkus"
    },
    {
      "key":"CAMEL-14035",
      "title":"JDBC StreamList and outputClass does not work",
      "description":"Situation is simple:\r\n\r\nI try to load data from jdbc by Stream to Java object\r\n\r\nwith such command jdbc:dbBean?outputType=StreamList&outputClass=myClass.\r\n\r\nI estimate Java object on exit of flow? but i have Map<String, Object>.\r\n\r\nBug in\u00a0JdbcProducer at lines 326.\r\n\r\nif (outputType == JdbcOutputType.StreamList) {\r\n exchange.getOut().setBody(iterator);\r\n exchange.addOnCompletion(new ResultSetIteratorCompletion(iterator));\r\n \/\/ do not close resources as we are in streaming mode\r\n answer = false;\r\n}\r\n\r\nHere need wrap iterator to map objects by method\u00a0newBeanInstance",
      "assignee":"davsclaus",
      "type":"Bug",
      "priority":"Major",
      "status":"Resolved",
      "text":"JDBC StreamList and outputClass does not work Situation is simple:\r\n\r\nI try to load data from jdbc by Stream to Java object\r\n\r\nwith such command jdbc:dbBean?outputType=StreamList&outputClass=myClass.\r\n\r\nI estimate Java object on exit of flow? but i have Map<String, Object>.\r\n\r\nBug in JdbcProducer at lines 326.\r\n\r\nif (outputType == JdbcOutputType.StreamList) {\r\n exchange.getOut().setBody(iterator);\r\n exchange.addOnCompletion(new ResultSetIteratorCompletion(iterator));\r\n \/\/ do not close resources as we are in streaming mode\r\n answer = false;\r\n}\r\n\r\nHere need wrap iterator to map objects by method newBeanInstance"
    },
    {
      "key":"CAMEL-14034",
      "title":"Orderes RoutesBuilder",
      "description":"RoutesBuilder are now loaded according to the order the user add them but in some cases it may be needed to load them according to an order.\r\n\r\nWe should then make the RoutesBuilder interface extends Ordered and take it into account i.e. in MainSupport.",
      "assignee":"davsclaus",
      "type":"Improvement",
      "priority":"Minor",
      "status":"Resolved",
      "text":"Orderes RoutesBuilder RoutesBuilder are now loaded according to the order the user add them but in some cases it may be needed to load them according to an order.\r\n\r\nWe should then make the RoutesBuilder interface extends Ordered and take it into account i.e. in MainSupport."
    },
    {
      "key":"CAMEL-14033",
      "title":"multiple consumers for namedReplyTo results in a cryptic nullPointer",
      "description":"Per [https:\/\/camel.apache.org\/components\/latest\/sjms-component.html#_clustering]\u00a0you should not have multiple inOut producerEndpoints using the same replyTo address but if you do it results in a cryptic null pointer exception it would be nice to have a better error message of some sort directing you to use a unique replyTo address or temporary queue. Additionally if the replyTo is a topic then I don't believe it should result in an error and it may be better to actually use a message selector for this case.\r\n\r\njava.lang.NullPointerException: nulljava.lang.NullPointerException: null at org.apache.camel.component.sjms.producer.InOutProducer$MessageConsumerResourcesFactory$1.onMessage(InOutProducer.java:103) ~[?:?] at org.apache.activemq.artemis.jms.client.JMSMessageListenerWrapper.onMessage(JMSMessageListenerWrapper.java:110) ~[254:org.apache.activemq.artemis-server-osgi:2.8.1] at org.apache.activemq.artemis.core.client.impl.ClientConsumerImpl.callOnMessage(ClientConsumerImpl.java:1031) ~[?:?] at org.apache.activemq.artemis.core.client.impl.ClientConsumerImpl.access$400(ClientConsumerImpl.java:50) ~[?:?] at org.apache.activemq.artemis.core.client.impl.ClientConsumerImpl$Runner.run(ClientConsumerImpl.java:1154) ~[?:?] at org.apache.activemq.artemis.utils.actors.OrderedExecutor.doTask(OrderedExecutor.java:42) ~[?:?] at org.apache.activemq.artemis.utils.actors.OrderedExecutor.doTask(OrderedExecutor.java:31) ~[?:?] at org.apache.activemq.artemis.utils.actors.ProcessorBase.executePendingTasks(ProcessorBase.java:66) ~[?:?] at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149) [?:?] at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624) [?:?]",
      "assignee":"davsclaus",
      "type":"Bug",
      "priority":"Minor",
      "status":"Resolved",
      "text":"multiple consumers for namedReplyTo results in a cryptic nullPointer Per [https:\/\/camel.apache.org\/components\/latest\/sjms-component.html#_clustering] you should not have multiple inOut producerEndpoints using the same replyTo address but if you do it results in a cryptic null pointer exception it would be nice to have a better error message of some sort directing you to use a unique replyTo address or temporary queue. Additionally if the replyTo is a topic then I don't believe it should result in an error and it may be better to actually use a message selector for this case.\r\n\r\njava.lang.NullPointerException: nulljava.lang.NullPointerException: null at org.apache.camel.component.sjms.producer.InOutProducer$MessageConsumerResourcesFactory$1.onMessage(InOutProducer.java:103) ~[?:?] at org.apache.activemq.artemis.jms.client.JMSMessageListenerWrapper.onMessage(JMSMessageListenerWrapper.java:110) ~[254:org.apache.activemq.artemis-server-osgi:2.8.1] at org.apache.activemq.artemis.core.client.impl.ClientConsumerImpl.callOnMessage(ClientConsumerImpl.java:1031) ~[?:?] at org.apache.activemq.artemis.core.client.impl.ClientConsumerImpl.access$400(ClientConsumerImpl.java:50) ~[?:?] at org.apache.activemq.artemis.core.client.impl.ClientConsumerImpl$Runner.run(ClientConsumerImpl.java:1154) ~[?:?] at org.apache.activemq.artemis.utils.actors.OrderedExecutor.doTask(OrderedExecutor.java:42) ~[?:?] at org.apache.activemq.artemis.utils.actors.OrderedExecutor.doTask(OrderedExecutor.java:31) ~[?:?] at org.apache.activemq.artemis.utils.actors.ProcessorBase.executePendingTasks(ProcessorBase.java:66) ~[?:?] at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149) [?:?] at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624) [?:?]"
    },
    {
      "key":"CAMEL-14031",
      "title":"Move process control from Main to MainSupport",
      "description":"org.apache.camel.main.MainSupport is now in charge to parse command line arguments, keep the process up according to some policies, intercepts shutdown events and so on.\r\n\r\nTo make it easier to re-use MainSupport in other projects such as camel-quarkus where as example there's no control over command line arguments, it would be nice to move the process control logic to org.apache.camel.main.Main.\r\n\r\n[~davsclaus] does it make sense or there is something I haven't taken into account ?",
      "assignee":"davsclaus",
      "type":"Improvement",
      "priority":"Major",
      "status":"Resolved",
      "text":"Move process control from Main to MainSupport org.apache.camel.main.MainSupport is now in charge to parse command line arguments, keep the process up according to some policies, intercepts shutdown events and so on.\r\n\r\nTo make it easier to re-use MainSupport in other projects such as camel-quarkus where as example there's no control over command line arguments, it would be nice to move the process control logic to org.apache.camel.main.Main.\r\n\r\n[~davsclaus] does it make sense or there is something I haven't taken into account ?"
    },
    {
      "key":"CAMEL-14030",
      "title":"camel-ftp - streamDownload=true and move options dont work",
      "description":"Reported on mailing list\r\nhttps:\/\/camel.465427.n5.nabble.com\/Bug-Camel-FTP-streamdownload-move-options-tp5843791.html",
      "assignee":"davsclaus",
      "type":"Bug",
      "priority":"Major",
      "status":"Resolved",
      "text":"camel-ftp - streamDownload=true and move options dont work Reported on mailing list\r\nhttps:\/\/camel.465427.n5.nabble.com\/Bug-Camel-FTP-streamdownload-move-options-tp5843791.html"
    },
    {
      "key":"CAMEL-13999",
      "title":"Salesforce Component IDLE_TIMEOUT Blocks Async Request Responses for 2.x",
      "description":"Bulk, Composite Batch, etc. all throw an exception when trying to return on more than a few records due to [static final IDLE_TIMEOUT|https:\/\/github.com\/apache\/camel\/blob\/master\/components\/camel-salesforce\/camel-salesforce-component\/src\/main\/java\/org\/apache\/camel\/component\/salesforce\/SalesforceComponent.java#L80] on the instantiated salesforce component httpClient:\r\n\r\n\u00a0\r\n\r\nCaused by: org.apache.camel.component.salesforce.api.SalesforceException: Unexpected error \\{0:null} executing \\{POST:https:\/\/genericSFDCInstance.salesforce.com\/services\/data\/v38.0\/composite\/batch}\r\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 at org.apache.camel.component.salesforce.internal.client.AbstractClientBase$1.onComplete(AbstractClientBase.java:199) ~[camel-salesforce-2.23.0.jar:2.23.0]\r\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 at org.eclipse.jetty.client.ResponseNotifier.notifyComplete(ResponseNotifier.java:202) ~[jetty-client-9.4.12.v20180830.jar:9.4.12.v20180830]\r\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 at org.eclipse.jetty.client.ResponseNotifier.notifyComplete(ResponseNotifier.java:194) ~[jetty-client-9.4.12.v20180830.jar:9.4.12.v20180830]\r\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 at org.eclipse.jetty.client.HttpReceiver.terminateResponse(HttpReceiver.java:470) ~[jetty-client-9.4.12.v20180830.jar:9.4.12.v20180830]\r\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 at org.eclipse.jetty.client.HttpReceiver.abort(HttpReceiver.java:552) ~[jetty-client-9.4.12.v20180830.jar:9.4.12.v20180830]\r\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 at org.eclipse.jetty.client.HttpChannel.abortResponse(HttpChannel.java:156) ~[jetty-client-9.4.12.v20180830.jar:9.4.12.v20180830]\r\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 at org.eclipse.jetty.client.HttpChannel.abort(HttpChannel.java:149) ~[jetty-client-9.4.12.v20180830.jar:9.4.12.v20180830]\r\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 at org.eclipse.jetty.client.HttpExchange.abort(HttpExchange.java:257) ~[jetty-client-9.4.12.v20180830.jar:9.4.12.v20180830]\r\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 at org.eclipse.jetty.client.HttpConversation.abort(HttpConversation.java:141) ~[jetty-client-9.4.12.v20180830.jar:9.4.12.v20180830]\r\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 at org.eclipse.jetty.client.HttpRequest.abort(HttpRequest.java:767) ~[jetty-client-9.4.12.v20180830.jar:9.4.12.v20180830]\r\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 at org.eclipse.jetty.client.http.HttpConnectionOverHTTP.abort(HttpConnectionOverHTTP.java:204) ~[jetty-client-9.4.12.v20180830.jar:9.4.12.v20180830]\r\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 at org.eclipse.jetty.client.http.HttpConnectionOverHTTP.close(HttpConnectionOverHTTP.java:190) ~[jetty-client-9.4.12.v20180830.jar:9.4.12.v20180830]\r\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 at org.eclipse.jetty.client.http.HttpConnectionOverHTTP.onIdleExpired(HttpConnectionOverHTTP.java:145) ~[jetty-client-9.4.12.v20180830.jar:9.4.12.v20180830]\r\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 at org.eclipse.jetty.io.ssl.SslConnection.onIdleExpired(SslConnection.java:286) ~[jetty-io-9.4.12.v20180830.jar:9.4.12.v20180830]\r\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 at org.eclipse.jetty.io.AbstractEndPoint.onIdleExpired(AbstractEndPoint.java:401) ~[jetty-io-9.4.12.v20180830.jar:9.4.12.v20180830]\r\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 at org.eclipse.jetty.io.IdleTimeout.checkIdleTimeout(IdleTimeout.java:166) ~[jetty-io-9.4.12.v20180830.jar:9.4.12.v20180830]\r\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 at org.eclipse.jetty.io.IdleTimeout$1.run(IdleTimeout.java:50) ~[jetty-io-9.4.12.v20180830.jar:9.4.12.v20180830]\r\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511) ~[?:1.8.0_201]\r\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 at java.util.concurrent.FutureTask.run(FutureTask.java:266) ~[?:1.8.0_201]\r\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.access$201(ScheduledThreadPoolExecutor.java:180) ~[?:1.8.0_201]\r\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:293) ~[?:1.8.0_201]\r\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149) ~[?:1.8.0_201]\r\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624) ~[?:1.8.0_201]\r\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 ... 1 more\r\n\r\n\r\n*Caused by: java.util.concurrent.TimeoutException: Idle timeout 5000 ms*\r\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 at org.eclipse.jetty.client.http.HttpConnectionOverHTTP.onIdleExpired(HttpConnectionOverHTTP.java:145) ~[jetty-client-9.4.12.v20180830.jar:9.4.12.v20180830]\r\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 at org.eclipse.jetty.io.ssl.SslConnection.onIdleExpired(SslConnection.java:286) ~[jetty-io-9.4.12.v20180830.jar:9.4.12.v20180830]\r\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 at org.eclipse.jetty.io.AbstractEndPoint.onIdleExpired(AbstractEndPoint.java:401) ~[jetty-io-9.4.12.v20180830.jar:9.4.12.v20180830]\r\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 at org.eclipse.jetty.io.IdleTimeout.checkIdleTimeout(IdleTimeout.java:166) ~[jetty-io-9.4.12.v20180830.jar:9.4.12.v20180830]\r\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 at org.eclipse.jetty.io.IdleTimeout$1.run(IdleTimeout.java:50) ~[jetty-io-9.4.12.v20180830.jar:9.4.12.v20180830]\r\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511) ~[?:1.8.0_201]\r\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 at java.util.concurrent.FutureTask.run(FutureTask.java:266) ~[?:1.8.0_201]\r\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.access$201(ScheduledThreadPoolExecutor.java:180) ~[?:1.8.0_201]\r\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:293) ~[?:1.8.0_201]\r\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149) ~[?:1.8.0_201]\r\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624) ~[?:1.8.0_201]\r\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 ... 1 more\r\n\r\n\u00a0\r\n\r\nNote that as IDLE_TIMEOUT is static, it cannot be set via Spring, and the httpClientProperties map is [never used to set any timeouts|https:\/\/github.com\/apache\/camel\/blob\/master\/components\/camel-salesforce\/camel-salesforce-component\/src\/main\/java\/org\/apache\/camel\/component\/salesforce\/SalesforceComponent.java#L714], instead opting to take the [hardcoded defaults|https:\/\/github.com\/apache\/camel\/blob\/master\/components\/camel-salesforce\/camel-salesforce-component\/src\/main\/java\/org\/apache\/camel\/component\/salesforce\/SalesforceComponent.java#L707].\r\n\r\n\u00a0",
      "assignee":"davsclaus",
      "type":"Bug",
      "priority":"Minor",
      "status":"Resolved",
      "text":"Salesforce Component IDLE_TIMEOUT Blocks Async Request Responses for 2.x Bulk, Composite Batch, etc. all throw an exception when trying to return on more than a few records due to [static final IDLE_TIMEOUT|https:\/\/github.com\/apache\/camel\/blob\/master\/components\/camel-salesforce\/camel-salesforce-component\/src\/main\/java\/org\/apache\/camel\/component\/salesforce\/SalesforceComponent.java#L80] on the instantiated salesforce component httpClient:\r\n\r\n \r\n\r\nCaused by: org.apache.camel.component.salesforce.api.SalesforceException: Unexpected error \\{0:null} executing \\{POST:https:\/\/genericSFDCInstance.salesforce.com\/services\/data\/v38.0\/composite\/batch}\r\n        at org.apache.camel.component.salesforce.internal.client.AbstractClientBase$1.onComplete(AbstractClientBase.java:199) ~[camel-salesforce-2.23.0.jar:2.23.0]\r\n        at org.eclipse.jetty.client.ResponseNotifier.notifyComplete(ResponseNotifier.java:202) ~[jetty-client-9.4.12.v20180830.jar:9.4.12.v20180830]\r\n        at org.eclipse.jetty.client.ResponseNotifier.notifyComplete(ResponseNotifier.java:194) ~[jetty-client-9.4.12.v20180830.jar:9.4.12.v20180830]\r\n        at org.eclipse.jetty.client.HttpReceiver.terminateResponse(HttpReceiver.java:470) ~[jetty-client-9.4.12.v20180830.jar:9.4.12.v20180830]\r\n        at org.eclipse.jetty.client.HttpReceiver.abort(HttpReceiver.java:552) ~[jetty-client-9.4.12.v20180830.jar:9.4.12.v20180830]\r\n        at org.eclipse.jetty.client.HttpChannel.abortResponse(HttpChannel.java:156) ~[jetty-client-9.4.12.v20180830.jar:9.4.12.v20180830]\r\n        at org.eclipse.jetty.client.HttpChannel.abort(HttpChannel.java:149) ~[jetty-client-9.4.12.v20180830.jar:9.4.12.v20180830]\r\n        at org.eclipse.jetty.client.HttpExchange.abort(HttpExchange.java:257) ~[jetty-client-9.4.12.v20180830.jar:9.4.12.v20180830]\r\n        at org.eclipse.jetty.client.HttpConversation.abort(HttpConversation.java:141) ~[jetty-client-9.4.12.v20180830.jar:9.4.12.v20180830]\r\n        at org.eclipse.jetty.client.HttpRequest.abort(HttpRequest.java:767) ~[jetty-client-9.4.12.v20180830.jar:9.4.12.v20180830]\r\n        at org.eclipse.jetty.client.http.HttpConnectionOverHTTP.abort(HttpConnectionOverHTTP.java:204) ~[jetty-client-9.4.12.v20180830.jar:9.4.12.v20180830]\r\n        at org.eclipse.jetty.client.http.HttpConnectionOverHTTP.close(HttpConnectionOverHTTP.java:190) ~[jetty-client-9.4.12.v20180830.jar:9.4.12.v20180830]\r\n        at org.eclipse.jetty.client.http.HttpConnectionOverHTTP.onIdleExpired(HttpConnectionOverHTTP.java:145) ~[jetty-client-9.4.12.v20180830.jar:9.4.12.v20180830]\r\n        at org.eclipse.jetty.io.ssl.SslConnection.onIdleExpired(SslConnection.java:286) ~[jetty-io-9.4.12.v20180830.jar:9.4.12.v20180830]\r\n        at org.eclipse.jetty.io.AbstractEndPoint.onIdleExpired(AbstractEndPoint.java:401) ~[jetty-io-9.4.12.v20180830.jar:9.4.12.v20180830]\r\n        at org.eclipse.jetty.io.IdleTimeout.checkIdleTimeout(IdleTimeout.java:166) ~[jetty-io-9.4.12.v20180830.jar:9.4.12.v20180830]\r\n        at org.eclipse.jetty.io.IdleTimeout$1.run(IdleTimeout.java:50) ~[jetty-io-9.4.12.v20180830.jar:9.4.12.v20180830]\r\n        at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511) ~[?:1.8.0_201]\r\n        at java.util.concurrent.FutureTask.run(FutureTask.java:266) ~[?:1.8.0_201]\r\n        at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.access$201(ScheduledThreadPoolExecutor.java:180) ~[?:1.8.0_201]\r\n        at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:293) ~[?:1.8.0_201]\r\n        at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149) ~[?:1.8.0_201]\r\n        at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624) ~[?:1.8.0_201]\r\n        ... 1 more\r\n\r\n\r\n*Caused by: java.util.concurrent.TimeoutException: Idle timeout 5000 ms*\r\n        at org.eclipse.jetty.client.http.HttpConnectionOverHTTP.onIdleExpired(HttpConnectionOverHTTP.java:145) ~[jetty-client-9.4.12.v20180830.jar:9.4.12.v20180830]\r\n        at org.eclipse.jetty.io.ssl.SslConnection.onIdleExpired(SslConnection.java:286) ~[jetty-io-9.4.12.v20180830.jar:9.4.12.v20180830]\r\n        at org.eclipse.jetty.io.AbstractEndPoint.onIdleExpired(AbstractEndPoint.java:401) ~[jetty-io-9.4.12.v20180830.jar:9.4.12.v20180830]\r\n        at org.eclipse.jetty.io.IdleTimeout.checkIdleTimeout(IdleTimeout.java:166) ~[jetty-io-9.4.12.v20180830.jar:9.4.12.v20180830]\r\n        at org.eclipse.jetty.io.IdleTimeout$1.run(IdleTimeout.java:50) ~[jetty-io-9.4.12.v20180830.jar:9.4.12.v20180830]\r\n        at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511) ~[?:1.8.0_201]\r\n        at java.util.concurrent.FutureTask.run(FutureTask.java:266) ~[?:1.8.0_201]\r\n        at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.access$201(ScheduledThreadPoolExecutor.java:180) ~[?:1.8.0_201]\r\n        at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:293) ~[?:1.8.0_201]\r\n        at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149) ~[?:1.8.0_201]\r\n        at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624) ~[?:1.8.0_201]\r\n        ... 1 more\r\n\r\n \r\n\r\nNote that as IDLE_TIMEOUT is static, it cannot be set via Spring, and the httpClientProperties map is [never used to set any timeouts|https:\/\/github.com\/apache\/camel\/blob\/master\/components\/camel-salesforce\/camel-salesforce-component\/src\/main\/java\/org\/apache\/camel\/component\/salesforce\/SalesforceComponent.java#L714], instead opting to take the [hardcoded defaults|https:\/\/github.com\/apache\/camel\/blob\/master\/components\/camel-salesforce\/camel-salesforce-component\/src\/main\/java\/org\/apache\/camel\/component\/salesforce\/SalesforceComponent.java#L707].\r\n\r\n "
    },
    {
      "key":"CAMEL-13991",
      "title":"camel-main - Configuring component options with #class dont work",
      "description":"The fast component configurer is in use before we check whether the value is a #class etc which we need to do beforehand",
      "assignee":"davsclaus",
      "type":"Bug",
      "priority":"Major",
      "status":"Resolved",
      "text":"camel-main - Configuring component options with #class dont work The fast component configurer is in use before we check whether the value is a #class etc which we need to do beforehand"
    },
    {
      "key":"CAMEL-13961",
      "title":"Reconsider default for xslt:allowStAX",
      "description":"This is currently set to true. However, Xalan (which the default XSLT processor for most) cannot handle StAXSource\r\n\r\n{code}\r\nCaused by: javax.xml.transform.TransformerException: javax.xml.transform.TransformerException: org.apache.xml.dtm.DTMException: Not supported: javax.xml.transform.stax.StAXSource@6a35603\r\n\tat org.apache.xalan.xsltc.trax.TransformerImpl.transform(TransformerImpl.java:642)\r\n\tat org.apache.xalan.xsltc.trax.TransformerImpl.transform(TransformerImpl.java:303)\r\n\tat org.apache.camel.component.xslt.XsltBuilder.process(XsltBuilder.java:132)\r\n\tat org.apache.camel.support.ProcessorEndpoint.onExchange(ProcessorEndpoint.java:95)\r\n\tat org.apache.camel.component.xslt.XsltEndpoint.onExchange(XsltEndpoint.java:121)\r\n\r\n{code}",
      "assignee":"davsclaus",
      "type":"Bug",
      "priority":"Major",
      "status":"Resolved",
      "text":"Reconsider default for xslt:allowStAX This is currently set to true. However, Xalan (which the default XSLT processor for most) cannot handle StAXSource\r\n\r\n{code}\r\nCaused by: javax.xml.transform.TransformerException: javax.xml.transform.TransformerException: org.apache.xml.dtm.DTMException: Not supported: javax.xml.transform.stax.StAXSource@6a35603\r\n\tat org.apache.xalan.xsltc.trax.TransformerImpl.transform(TransformerImpl.java:642)\r\n\tat org.apache.xalan.xsltc.trax.TransformerImpl.transform(TransformerImpl.java:303)\r\n\tat org.apache.camel.component.xslt.XsltBuilder.process(XsltBuilder.java:132)\r\n\tat org.apache.camel.support.ProcessorEndpoint.onExchange(ProcessorEndpoint.java:95)\r\n\tat org.apache.camel.component.xslt.XsltEndpoint.onExchange(XsltEndpoint.java:121)\r\n\r\n{code}"
    },
    {
      "key":"CAMEL-13955",
      "title":"SJMS-Batch does not support CompletionAware aggregators",
      "description":"SJMS-Batch isn't aware of the CompletionAwareAggregationStrategy interface and so never calls the completion method.\r\n\r\nThis prevents SJMS-Batch from working as expected with built in aggregators such as\u00a0org.apache.camel.processor.aggregate.GroupedBodyAggregationStrategy - the aggregated message remains as an exchange header instead of being the message body.\r\n\r\n\u00a0",
      "assignee":"davsclaus",
      "type":"Improvement",
      "priority":"Minor",
      "status":"Resolved",
      "text":"SJMS-Batch does not support CompletionAware aggregators SJMS-Batch isn't aware of the CompletionAwareAggregationStrategy interface and so never calls the completion method.\r\n\r\nThis prevents SJMS-Batch from working as expected with built in aggregators such as org.apache.camel.processor.aggregate.GroupedBodyAggregationStrategy - the aggregated message remains as an exchange header instead of being the message body.\r\n\r\n "
    },
    {
      "key":"CAMEL-13949",
      "title":"camel-core vs camel-core-engine",
      "description":"The camel-core-engine trims camel-core using maven exclusions which may lead to unexpected result as if both are present in the dependencies tree, then one may win over the other depending of the maven resolution.\r\n",
      "assignee":"davsclaus",
      "type":"Improvement",
      "priority":"Major",
      "status":"Resolved",
      "text":"camel-core vs camel-core-engine The camel-core-engine trims camel-core using maven exclusions which may lead to unexpected result as if both are present in the dependencies tree, then one may win over the other depending of the maven resolution.\r\n"
    },
    {
      "key":"CAMEL-13947",
      "title":"Create a configuration service instead of leveraging the properties component",
      "description":"As today the way camel resolves properties\/configuration is trough the Properties Component which leads to a chicken and egg problem as:\r\n\r\n- camel core depends on properties component\r\n- the properties component depends on camel core\r\n\r\nWe should probably have a proper configuration service part of camel core that can eventually be leveraged by the Properties Component.\r\n\r\n",
      "assignee":"davsclaus",
      "type":"Improvement",
      "priority":"Major",
      "status":"Resolved",
      "text":"Create a configuration service instead of leveraging the properties component As today the way camel resolves properties\/configuration is trough the Properties Component which leads to a chicken and egg problem as:\r\n\r\n- camel core depends on properties component\r\n- the properties component depends on camel core\r\n\r\nWe should probably have a proper configuration service part of camel core that can eventually be leveraged by the Properties Component.\r\n\r\n"
    },
    {
      "key":"CAMEL-13941",
      "title":"NullPointerException when Conduit is null",
      "description":"Hello,\r\n\r\nthe CxfProducer.doStart() retrieves a Conduit.\r\n\r\nIf this Conduit is null, should we still throw a NullPointerException or, should we check nullity before condition?\r\n{code:java}\r\nConduit conduit = client.getConduit();\r\n\r\n        if (conduit.getClass().getName().endsWith(\"JMSConduit\")) {\r\n...\r\n}{code}\r\n\r\nhttps:\/\/github.com\/apache\/camel\/blob\/camel-2.21.2\/components\/camel-cxf\/src\/main\/java\/org\/apache\/camel\/component\/cxf\/CxfProducer.java#L87\r\nhttps:\/\/github.com\/apache\/camel\/blob\/camel-2.23.1\/components\/camel-cxf\/src\/main\/java\/org\/apache\/camel\/component\/cxf\/CxfProducer.java#L87\r\nhttps:\/\/github.com\/apache\/camel\/blob\/camel-2.24.1\/components\/camel-cxf\/src\/main\/java\/org\/apache\/camel\/component\/cxf\/CxfProducer.java#L87\r\n\r\nThanks for your point of view.",
      "assignee":"davsclaus",
      "type":"Bug",
      "priority":"Minor",
      "status":"Resolved",
      "text":"NullPointerException when Conduit is null Hello,\r\n\r\nthe CxfProducer.doStart() retrieves a Conduit.\r\n\r\nIf this Conduit is null, should we still throw a NullPointerException or, should we check nullity before condition?\r\n{code:java}\r\nConduit conduit = client.getConduit();\r\n\r\n        if (conduit.getClass().getName().endsWith(\"JMSConduit\")) {\r\n...\r\n}{code}\r\n\r\nhttps:\/\/github.com\/apache\/camel\/blob\/camel-2.21.2\/components\/camel-cxf\/src\/main\/java\/org\/apache\/camel\/component\/cxf\/CxfProducer.java#L87\r\nhttps:\/\/github.com\/apache\/camel\/blob\/camel-2.23.1\/components\/camel-cxf\/src\/main\/java\/org\/apache\/camel\/component\/cxf\/CxfProducer.java#L87\r\nhttps:\/\/github.com\/apache\/camel\/blob\/camel-2.24.1\/components\/camel-cxf\/src\/main\/java\/org\/apache\/camel\/component\/cxf\/CxfProducer.java#L87\r\n\r\nThanks for your point of view."
    },
    {
      "key":"CAMEL-13939",
      "title":"camel3 - Rename camel-management-impl to camel-management",
      "description":"Lets avoid the -impl in the name as its the only Camel artifact that has this ending.\r\n\r\n\r\n",
      "assignee":"davsclaus",
      "type":"Task",
      "priority":"Major",
      "status":"Resolved",
      "text":"camel3 - Rename camel-management-impl to camel-management Lets avoid the -impl in the name as its the only Camel artifact that has this ending.\r\n\r\n\r\n"
    },
    {
      "key":"CAMEL-13936",
      "title":"SNMP Component support \u2018snmp walk\u2019",
      "description":"The current version, the SNMP Component can not support 'snmp walk'.\r\n\r\nAlthough\u00a0the source code has appear 'GET_NEXT' in SnmpActionType.java, but no found in processor.\r\n\r\nNow, i add the 'snmp walk' and in my application it run\u00a0successfully.\r\n\r\nSo, if it need add to the next camel version, please check.\r\n\r\nThanks!",
      "assignee":"davsclaus",
      "type":"New Feature",
      "priority":"Minor",
      "status":"Resolved",
      "text":"SNMP Component support 'snmp walk' The current version, the SNMP Component can not support 'snmp walk'.\r\n\r\nAlthough the source code has appear 'GET_NEXT' in SnmpActionType.java, but no found in processor.\r\n\r\nNow, i add the 'snmp walk' and in my application it run successfully.\r\n\r\nSo, if it need add to the next camel version, please check.\r\n\r\nThanks!"
    },
    {
      "key":"CAMEL-13935",
      "title":"camel-properties: Properties with types different from string are not taken into account",
      "description":"\r\nThe properties component spi has a setOverrideProperties that allow to use an arbitrary Properties object so it is possible that the properties it holds are not of type string. \r\n\r\nIn case the properties component is asked to resolve a non string property, then it will fail as DefaultPropertiesLookup uses Properties::getProperty [\u00b9] which returns null in case of the requested property is not of type string.\r\n\r\nThe error is a little bit misleading as it states: \r\n\r\n{code}\r\nbecause of PropertiesComponent with name properties must be defined in CamelContext to support property placeholders. Property with key [the.body] not found in properties from text: in.body == {{the.body}}\r\n{code}\r\n\r\n[1] https:\/\/github.com\/apache\/camel\/blob\/master\/components\/camel-properties\/src\/main\/java\/org\/apache\/camel\/component\/properties\/DefaultPropertiesLookup.java#L40",
      "assignee":"davsclaus",
      "type":"Bug",
      "priority":"Minor",
      "status":"Resolved",
      "text":"camel-properties: Properties with types different from string are not taken into account \r\nThe properties component spi has a setOverrideProperties that allow to use an arbitrary Properties object so it is possible that the properties it holds are not of type string. \r\n\r\nIn case the properties component is asked to resolve a non string property, then it will fail as DefaultPropertiesLookup uses Properties::getProperty [1] which returns null in case of the requested property is not of type string.\r\n\r\nThe error is a little bit misleading as it states: \r\n\r\n{code}\r\nbecause of PropertiesComponent with name properties must be defined in CamelContext to support property placeholders. Property with key [the.body] not found in properties from text: in.body == {{the.body}}\r\n{code}\r\n\r\n[1] https:\/\/github.com\/apache\/camel\/blob\/master\/components\/camel-properties\/src\/main\/java\/org\/apache\/camel\/component\/properties\/DefaultPropertiesLookup.java#L40"
    },
    {
      "key":"CAMEL-13931",
      "title":"camel-file - tempFileName directory is not auto-created if it is relative before the endpoint path",
      "description":"Hi,\r\n\r\nI face a requirement to place temp files in a folder at the same hierarchy as the output folder like this:\r\n * {{target\/data\/output\/claus.txt}}\r\n * {{target\/data\/temp\/claus.tmp}}\r\n\r\nUsing a simple route definition like:\r\n{code:java}\r\nfrom(\"direct:a\").to(\"file:\/\/target\/data\/output\/?tempFileName=..\/temp\/${file:name.noext}.tmp\"){code}\r\n\u00a0\r\n\r\nIf the temp folder does not exist, the GenericFileProducer should auto-create it. However, it only does so correctly for the tempFileName path, if it is *relativ \"after\" the endpoint path*. If it is above\/before the endpoint path the tempFileName path will be created as a child of the endpoint path instead:\r\n * {{target\/data\/output\/target\/data\/temp}}\r\n\r\nThis results in a NoSuchFileException when camel tries to write the temp file into the \"correct\" temp directory target\/data\/temp afterwards.\r\n\r\n\u00a0\r\n\r\n\u00a0\r\n\r\nA very easy way to reproduce this is to use the 'parentFileUrl' instead of the 'fileUrl' in the createRouteBuilder method of\u00a0FileProduceTempFileNameTest.java ([https:\/\/github.com\/apache\/camel\/blob\/master\/core\/camel-core\/src\/test\/java\/org\/apache\/camel\/component\/file\/FileProduceTempFileNameTest.java]).",
      "assignee":"davsclaus",
      "type":"Bug",
      "priority":"Minor",
      "status":"Resolved",
      "text":"camel-file - tempFileName directory is not auto-created if it is relative before the endpoint path Hi,\r\n\r\nI face a requirement to place temp files in a folder at the same hierarchy as the output folder like this:\r\n * {{target\/data\/output\/claus.txt}}\r\n * {{target\/data\/temp\/claus.tmp}}\r\n\r\nUsing a simple route definition like:\r\n{code:java}\r\nfrom(\"direct:a\").to(\"file:\/\/target\/data\/output\/?tempFileName=..\/temp\/${file:name.noext}.tmp\"){code}\r\n \r\n\r\nIf the temp folder does not exist, the GenericFileProducer should auto-create it. However, it only does so correctly for the tempFileName path, if it is *relativ \"after\" the endpoint path*. If it is above\/before the endpoint path the tempFileName path will be created as a child of the endpoint path instead:\r\n * {{target\/data\/output\/target\/data\/temp}}\r\n\r\nThis results in a NoSuchFileException when camel tries to write the temp file into the \"correct\" temp directory target\/data\/temp afterwards.\r\n\r\n \r\n\r\n \r\n\r\nA very easy way to reproduce this is to use the 'parentFileUrl' instead of the 'fileUrl' in the createRouteBuilder method of FileProduceTempFileNameTest.java ([https:\/\/github.com\/apache\/camel\/blob\/master\/core\/camel-core\/src\/test\/java\/org\/apache\/camel\/component\/file\/FileProduceTempFileNameTest.java])."
    },
    {
      "key":"CAMEL-13929",
      "title":"camel3 - ApiEndpoint should extend ScheduledPollEndpoint",
      "description":"As the ApiConsumer is scheduled poll based, but the endpoint was not its base class. Then options get out of sync and not documented either.",
      "assignee":"davsclaus",
      "type":"Improvement",
      "priority":"Major",
      "status":"Resolved",
      "text":"camel3 - ApiEndpoint should extend ScheduledPollEndpoint As the ApiConsumer is scheduled poll based, but the endpoint was not its base class. Then options get out of sync and not documented either."
    },
    {
      "key":"CAMEL-13925",
      "title":"camel-seda - SedaConsumer should extend DefaultConsumer",
      "description":"So its like the other components where we extend default classes",
      "assignee":"davsclaus",
      "type":"Improvement",
      "priority":"Major",
      "status":"Resolved",
      "text":"camel-seda - SedaConsumer should extend DefaultConsumer So its like the other components where we extend default classes"
    },
    {
      "key":"CAMEL-13919",
      "title":"\"camel-package:update-readme\" throws ArrayIndexOutOfBoundsException when there is an empty \"adoc\" file",
      "description":"Steps to produce:\u00a0\r\n * Create an empty\u00a0{{adoc}} file in any component.\r\n * Run {{camel-package:update-readme}}.\r\n * It will fail with the following error: \r\n{code}\r\nCaused by: java.lang.ArrayIndexOutOfBoundsException: Index 1 out of bounds for length 1\r\n    at org.apache.camel.maven.packaging.UpdateReadmeMojo.updateAvailableFrom (UpdateReadmeMojo.java:510)\r\n    at org.apache.camel.maven.packaging.UpdateReadmeMojo.executeComponent (UpdateReadmeMojo.java:151)\r\n    at org.apache.camel.maven.packaging.UpdateReadmeMojo.execute (UpdateReadmeMojo.java:105)\r\n{code}\r\n\r\n* As I can see [here|https:\/\/github.com\/apache\/camel\/blob\/master\/tooling\/maven\/camel-package-maven-plugin\/src\/main\/java\/org\/apache\/camel\/maven\/packaging\/UpdateReadmeMojo.java#L510], it looks it will try to retrieve index although there are empty lines",
      "assignee":"davsclaus",
      "type":"Bug",
      "priority":"Minor",
      "status":"Resolved",
      "text":"\"camel-package:update-readme\" throws ArrayIndexOutOfBoundsException when there is an empty \"adoc\" file Steps to produce: \r\n * Create an empty {{adoc}} file in any component.\r\n * Run {{camel-package:update-readme}}.\r\n * It will fail with the following error: \r\n{code}\r\nCaused by: java.lang.ArrayIndexOutOfBoundsException: Index 1 out of bounds for length 1\r\n    at org.apache.camel.maven.packaging.UpdateReadmeMojo.updateAvailableFrom (UpdateReadmeMojo.java:510)\r\n    at org.apache.camel.maven.packaging.UpdateReadmeMojo.executeComponent (UpdateReadmeMojo.java:151)\r\n    at org.apache.camel.maven.packaging.UpdateReadmeMojo.execute (UpdateReadmeMojo.java:105)\r\n{code}\r\n\r\n* As I can see [here|https:\/\/github.com\/apache\/camel\/blob\/master\/tooling\/maven\/camel-package-maven-plugin\/src\/main\/java\/org\/apache\/camel\/maven\/packaging\/UpdateReadmeMojo.java#L510], it looks it will try to retrieve index although there are empty lines"
    },
    {
      "key":"CAMEL-13918",
      "title":"camel3 - camel-http - Remove deprecate url rewrite",
      "description":"UrlRewrite has been deprecated on 2.x, and should be removed for 3",
      "assignee":"davsclaus",
      "type":"Task",
      "priority":"Major",
      "status":"Resolved",
      "text":"camel3 - camel-http - Remove deprecate url rewrite UrlRewrite has been deprecated on 2.x, and should be removed for 3"
    },
    {
      "key":"CAMEL-13917",
      "title":"camel3 - Deprecate and remove consumer.xxx syntax for delay options",
      "description":"You can configure them on the endpoint directly, so consumer.delay=5000 should just be delay=5000 and so on.",
      "assignee":"davsclaus",
      "type":"Task",
      "priority":"Major",
      "status":"Resolved",
      "text":"camel3 - Deprecate and remove consumer.xxx syntax for delay options You can configure them on the endpoint directly, so consumer.delay=5000 should just be delay=5000 and so on."
    },
    {
      "key":"CAMEL-13913",
      "title":"camel3 - components - Use BeanIntrospection instead of IntrospectionSupport",
      "description":"They should use BeanIntrosepction which you can get from camel context",
      "assignee":"davsclaus",
      "type":"Task",
      "priority":"Major",
      "status":"Resolved",
      "text":"camel3 - components - Use BeanIntrospection instead of IntrospectionSupport They should use BeanIntrosepction which you can get from camel context"
    },
    {
      "key":"CAMEL-13907",
      "title":"camel3 - JMX can clear its bean introspection cache after all MBeans have been registered",
      "description":"Those are no longer needed and it can free up a bit of memory hold by the cache. Mind the cache is weak anyway, but this makes it more explicit",
      "assignee":"davsclaus",
      "type":"Task",
      "priority":"Major",
      "status":"Resolved",
      "text":"camel3 - JMX can clear its bean introspection cache after all MBeans have been registered Those are no longer needed and it can free up a bit of memory hold by the cache. Mind the cache is weak anyway, but this makes it more explicit"
    },
    {
      "key":"CAMEL-13906",
      "title":"Component options - Only include if they have @Metadata",
      "description":"Properties component include some options which should not be there, as we should only take the getter\/setter pairs that have @Metadata annotation",
      "assignee":"davsclaus",
      "type":"Task",
      "priority":"Major",
      "status":"Resolved",
      "text":"Component options - Only include if they have @Metadata Properties component include some options which should not be there, as we should only take the getter\/setter pairs that have @Metadata annotation"
    },
    {
      "key":"CAMEL-13904",
      "title":"JMX - Early registered services may not be enlisted in XML DSL",
      "description":"In some use-cases depending on how you run Camel then some early services for JMX may not get registered",
      "assignee":"davsclaus",
      "type":"Bug",
      "priority":"Major",
      "status":"Resolved",
      "text":"JMX - Early registered services may not be enlisted in XML DSL In some use-cases depending on how you run Camel then some early services for JMX may not get registered"
    },
    {
      "key":"CAMEL-13901",
      "title":"camel-main-plugin - Dont run it automatic on compile",
      "description":"Lets just add instructions in the readme and avoid running it on each build. Its used for setting up the project for tooling support, and if you want to have it to do auto-detection of certain JMS clients - eg ActiveMQ vs Artemis and adapt the project accordingly.",
      "assignee":"davsclaus",
      "type":"Improvement",
      "priority":"Major",
      "status":"Resolved",
      "text":"camel-main-plugin - Dont run it automatic on compile Lets just add instructions in the readme and avoid running it on each build. Its used for setting up the project for tooling support, and if you want to have it to do auto-detection of certain JMS clients - eg ActiveMQ vs Artemis and adapt the project accordingly."
    },
    {
      "key":"CAMEL-13895",
      "title":"camel3 - TypeConverter(loader = true) rename to generateLoader",
      "description":"We are using generateConfigurer for fast endpoint configurer, so lets rename this for type converter loader to generateLoader on these annotations",
      "assignee":"davsclaus",
      "type":"Improvement",
      "priority":"Major",
      "status":"Resolved",
      "text":"camel3 - TypeConverter(loader = true) rename to generateLoader We are using generateConfigurer for fast endpoint configurer, so lets rename this for type converter loader to generateLoader on these annotations"
    },
    {
      "key":"CAMEL-13878",
      "title":"Message is forwarded to the wrong Kafka Topic",
      "description":"I have 3 Apache Spring Boot applications and 3 topics.\r\n\r\nLet's call them Topic A, B and C and the Spring Boot applications FirstApp, SecondApp and ThridApp. I use Java DSL for the Kafka configuration.\r\n\r\nThe FirstApp creates a message to Kafka Topic A.\r\n\r\nThe SecondApp reads from Topic A makes transformations and passes each value to Topic B.\r\n\r\nThe ThirdApp reads from Topic B and after transformations tries to pass it to Topic C.\r\n\r\nAt this point through the debugger I saw that at the class\u00a0\u00a0org.apache.camel.component.kafka.KafkaProducer and at the method\u00a0\r\n\r\nprotected Iterator<ProducerRecord> createRecorder(Exchange exchange) something strange is happening.\r\nThe headerTopic (line 140) from the following line:\r\n\r\nString headerTopic = exchange.getIn().getHeader(KafkaConstants.TOPIC, String.class);\r\n\r\ncontains the topic A! The correct topic that I have clearly set through the Java DSL can be found under the line 137:\u00a0\r\n\r\nString topic = endpoint.getConfiguration().getTopic();\r\n\r\nAs a workaround I have entered the following line inside a processor at the SecondProgram:\r\n\r\nexchange.getIn().setHeader(KafkaConstants.TOPIC, null);\r\n\r\nThis has the side-effect that the headerTopic at line 140 is empty and thus the correct topic from line 137 is used.\r\n\r\nI believe that since I have clearly set the destination topic at the ThirdProgram to Topic C then Apache Camel should not override this with Topic A.\r\n\r\nIt looks like a bug since from the method description I understand that we try to avoid circular loops.\r\n\r\n\u00a0",
      "assignee":"davsclaus",
      "type":"Bug",
      "priority":"Major",
      "status":"Resolved",
      "text":"Message is forwarded to the wrong Kafka Topic I have 3 Apache Spring Boot applications and 3 topics.\r\n\r\nLet's call them Topic A, B and C and the Spring Boot applications FirstApp, SecondApp and ThridApp. I use Java DSL for the Kafka configuration.\r\n\r\nThe FirstApp creates a message to Kafka Topic A.\r\n\r\nThe SecondApp reads from Topic A makes transformations and passes each value to Topic B.\r\n\r\nThe ThirdApp reads from Topic B and after transformations tries to pass it to Topic C.\r\n\r\nAt this point through the debugger I saw that at the class  org.apache.camel.component.kafka.KafkaProducer and at the method \r\n\r\nprotected Iterator<ProducerRecord> createRecorder(Exchange exchange) something strange is happening.\r\nThe headerTopic (line 140) from the following line:\r\n\r\nString headerTopic = exchange.getIn().getHeader(KafkaConstants.TOPIC, String.class);\r\n\r\ncontains the topic A! The correct topic that I have clearly set through the Java DSL can be found under the line 137: \r\n\r\nString topic = endpoint.getConfiguration().getTopic();\r\n\r\nAs a workaround I have entered the following line inside a processor at the SecondProgram:\r\n\r\nexchange.getIn().setHeader(KafkaConstants.TOPIC, null);\r\n\r\nThis has the side-effect that the headerTopic at line 140 is empty and thus the correct topic from line 137 is used.\r\n\r\nI believe that since I have clearly set the destination topic at the ThirdProgram to Topic C then Apache Camel should not override this with Topic A.\r\n\r\nIt looks like a bug since from the method description I understand that we try to avoid circular loops.\r\n\r\n "
    },
    {
      "key":"CAMEL-13870",
      "title":"camel3 - Fast configuring of endpoint options",
      "description":"Like we did for fast property placeholders on EIPs we can optimize endpoints as well, by using the apt compiler plugin to generate a configurer classes that uses direct java method invocations and then the property builder support class can detect that we have such a configurer and use it, when it looks for the setter. \r\n\r\n",
      "assignee":"davsclaus",
      "type":"Improvement",
      "priority":"Major",
      "status":"Resolved",
      "text":"camel3 - Fast configuring of endpoint options Like we did for fast property placeholders on EIPs we can optimize endpoints as well, by using the apt compiler plugin to generate a configurer classes that uses direct java method invocations and then the property builder support class can detect that we have such a configurer and use it, when it looks for the setter. \r\n\r\n"
    },
    {
      "key":"CAMEL-13863",
      "title":"camel3 - Optimize XmlConverterLoader",
      "description":"I wonder if we can optimize XmlConverterLoader this to init the getXmlConverter once only and avoid synchronized.\r\n\r\nIt does take a bit time to load according to the yourkit profiler",
      "assignee":"davsclaus",
      "type":"Improvement",
      "priority":"Major",
      "status":"Resolved",
      "text":"camel3 - Optimize XmlConverterLoader I wonder if we can optimize XmlConverterLoader this to init the getXmlConverter once only and avoid synchronized.\r\n\r\nIt does take a bit time to load according to the yourkit profiler"
    },
    {
      "key":"CAMEL-13850",
      "title":"camel3 - Property placeholders on EIP models can be optimized",
      "description":"We do a bit of introspection on each model class to fin its getter\/setter properties, which we can then use for property placeholders.\r\n\r\norg.apache.camel.model.ProcessorDefinitionHelper#resolvePropertyPlaceholders\r\n\r\nWe should look at optimising this",
      "assignee":"davsclaus",
      "type":"Improvement",
      "priority":"Major",
      "status":"Resolved",
      "text":"camel3 - Property placeholders on EIP models can be optimized We do a bit of introspection on each model class to fin its getter\/setter properties, which we can then use for property placeholders.\r\n\r\norg.apache.camel.model.ProcessorDefinitionHelper#resolvePropertyPlaceholders\r\n\r\nWe should look at optimising this"
    },
    {
      "key":"CAMEL-13848",
      "title":"Support room password in camel-xmpp",
      "description":"Camel-xmpp does not support room passwords at the moment. With small patch it could. Patch file included.",
      "assignee":"davsclaus",
      "type":"Improvement",
      "priority":"Minor",
      "status":"Resolved",
      "text":"Support room password in camel-xmpp Camel-xmpp does not support room passwords at the moment. With small patch it could. Patch file included."
    },
    {
      "key":"CAMEL-13847",
      "title":"camel-webhook - Should be lenient properties",
      "description":"So you can pass in uri parameters to the target endpoint, as today it will validate its own configuration only.",
      "assignee":"davsclaus",
      "type":"Bug",
      "priority":"Major",
      "status":"Resolved",
      "text":"camel-webhook - Should be lenient properties So you can pass in uri parameters to the target endpoint, as today it will validate its own configuration only."
    },
    {
      "key":"CAMEL-13846",
      "title":"Make PropertyBindingSupport a fluent builder only",
      "description":"PropertyBindingSupport provides a number of flag to customize how properties should be bound to a target object and it is likely possible that in the future more flags are required so instead of adding yet another overloaded method for each flag we should turn PropertyBindingSupport intop a fluent builder",
      "assignee":"davsclaus",
      "type":"Improvement",
      "priority":"Major",
      "status":"Resolved",
      "text":"Make PropertyBindingSupport a fluent builder only PropertyBindingSupport provides a number of flag to customize how properties should be bound to a target object and it is likely possible that in the future more flags are required so instead of adding yet another overloaded method for each flag we should turn PropertyBindingSupport intop a fluent builder"
    },
    {
      "key":"CAMEL-13845",
      "title":"camel-telegram - Do not show authorizationToken in uri",
      "description":"We should hide this sensitive information, this requires to migrate it from uri path to uri parameter instead. ",
      "assignee":"davsclaus",
      "type":"Improvement",
      "priority":"Major",
      "status":"Resolved",
      "text":"camel-telegram - Do not show authorizationToken in uri We should hide this sensitive information, this requires to migrate it from uri path to uri parameter instead. "
    },
    {
      "key":"CAMEL-13837",
      "title":"camel3 - FactoryFinder - Return null if not found instead of exception",
      "description":"When starting Camel we attempt to find custom factories for SPI. But this means we end up throwing 40+ exceptions just for a basic Camel route. We can optimize this to use null as response for \"no factory exists\".",
      "assignee":"davsclaus",
      "type":"Improvement",
      "priority":"Major",
      "status":"Resolved",
      "text":"camel3 - FactoryFinder - Return null if not found instead of exception When starting Camel we attempt to find custom factories for SPI. But this means we end up throwing 40+ exceptions just for a basic Camel route. We can optimize this to use null as response for \"no factory exists\"."
    },
    {
      "key":"CAMEL-13832",
      "title":"Properties component - Check ENV before JVM System property",
      "description":"We should favour using OS ENV properties over JVM system properties out of the box, for the same keys. This works the best with containers and cloud platforms.",
      "assignee":"davsclaus",
      "type":"Improvement",
      "priority":"Major",
      "status":"Resolved",
      "text":"Properties component - Check ENV before JVM System property We should favour using OS ENV properties over JVM system properties out of the box, for the same keys. This works the best with containers and cloud platforms."
    },
    {
      "key":"CAMEL-13829",
      "title":"Deprecate transferExchange option",
      "description":"Its a bad design to transfer Camel Exchange Java objects over the wire. Lets deprecate it in 2.x and remove in 3.0.\r\n\r\nThe camel-jms component has this option, and some of the http too, and others maybe.",
      "assignee":"davsclaus",
      "type":"Improvement",
      "priority":"Major",
      "status":"Resolved",
      "text":"Deprecate transferExchange option Its a bad design to transfer Camel Exchange Java objects over the wire. Lets deprecate it in 2.x and remove in 3.0.\r\n\r\nThe camel-jms component has this option, and some of the http too, and others maybe."
    },
    {
      "key":"CAMEL-13828",
      "title":"DefaultExchangeHolder - Do not propgate exchange id",
      "description":"The exchange id should not be preserved as it should not mutate the existing ids",
      "assignee":"davsclaus",
      "type":"Improvement",
      "priority":"Major",
      "status":"Resolved",
      "text":"DefaultExchangeHolder - Do not propgate exchange id The exchange id should not be preserved as it should not mutate the existing ids"
    },
    {
      "key":"CAMEL-13820",
      "title":"ResolveEndpointFailedException should mask sensitive information in uri",
      "description":"Misconfiguration of routes\u00a0throws ResolveEndpointFailedException.\r\n\r\nThis exception prints sensitive information like passwords which should be masked.",
      "assignee":"davsclaus",
      "type":"Improvement",
      "priority":"Major",
      "status":"Resolved",
      "text":"ResolveEndpointFailedException should mask sensitive information in uri Misconfiguration of routes throws ResolveEndpointFailedException.\r\n\r\nThis exception prints sensitive information like passwords which should be masked."
    },
    {
      "key":"CAMEL-13810",
      "title":"camel3 - Always log ERROR if failed to start CamelContext",
      "description":"As starting Camel mail fail then lets ensure we always get the exception logged as we rethrow it out of start of camel context, and it may be that some runtimes may not log this, so you can have harder time find out why it failed.\r\n\r\n",
      "assignee":"davsclaus",
      "type":"Improvement",
      "priority":"Major",
      "status":"Resolved",
      "text":"camel3 - Always log ERROR if failed to start CamelContext As starting Camel mail fail then lets ensure we always get the exception logged as we rethrow it out of start of camel context, and it may be that some runtimes may not log this, so you can have harder time find out why it failed.\r\n\r\n"
    },
    {
      "key":"CAMEL-13799",
      "title":"camel-cdi: Remove support for multiple context via @ContextName (was: NPE with recent camel-cdi changes)",
      "description":"{code}\r\nException 0 :\r\njavax.enterprise.inject.InjectionException: Error adding routes of type [org.wildfly.camel.test.cdi.subA.RouteBuilderB] to Camel context [contextB]\r\n\tat org.apache.camel.cdi.CdiCamelExtension.addRouteToContext(CdiCamelExtension.java:467)\r\n\tat org.apache.camel.cdi.CdiCamelExtension.afterDeploymentValidation(CdiCamelExtension.java:410)\r\n\tat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\r\n\tat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)\r\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\r\n\tat java.lang.reflect.Method.invoke(Method.java:498)\r\n\tat org.jboss.weld.injection.StaticMethodInjectionPoint.invoke(StaticMethodInjectionPoint.java:95)\r\n\tat org.jboss.weld.injection.MethodInvocationStrategy$SpecialParamPlusBeanManagerStrategy.invoke(MethodInvocationStrategy.java:187)\r\n\tat org.jboss.weld.event.ObserverMethodImpl.sendEvent(ObserverMethodImpl.java:330)\r\n\tat org.jboss.weld.event.ExtensionObserverMethodImpl.sendEvent(ExtensionObserverMethodImpl.java:123)\r\n\tat org.jboss.weld.event.ObserverMethodImpl.sendEvent(ObserverMethodImpl.java:308)\r\n\tat org.jboss.weld.event.ObserverMethodImpl.notify(ObserverMethodImpl.java:286)\r\n\tat javax.enterprise.inject.spi.ObserverMethod.notify(ObserverMethod.java:124)\r\n\tat org.jboss.weld.util.Observers.notify(Observers.java:166)\r\n\tat org.jboss.weld.event.ObserverNotifier.notifySyncObservers(ObserverNotifier.java:285)\r\n\tat org.jboss.weld.event.ObserverNotifier.notify(ObserverNotifier.java:273)\r\n\tat org.jboss.weld.event.ObserverNotifier.fireEvent(ObserverNotifier.java:177)\r\n\tat org.jboss.weld.event.ObserverNotifier.fireEvent(ObserverNotifier.java:171)\r\n\tat org.jboss.weld.bootstrap.events.AbstractContainerEvent.fire(AbstractContainerEvent.java:53)\r\n\tat org.jboss.weld.bootstrap.events.AbstractDeploymentContainerEvent.fire(AbstractDeploymentContainerEvent.java:35)\r\n\tat org.jboss.weld.bootstrap.events.AfterDeploymentValidationImpl.fire(AfterDeploymentValidationImpl.java:28)\r\n\tat org.jboss.weld.bootstrap.WeldStartup.validateBeans(WeldStartup.java:505)\r\n\tat org.jboss.weld.bootstrap.WeldBootstrap.validateBeans(WeldBootstrap.java:93)\r\n\tat org.jboss.as.weld.WeldStartService.start(WeldStartService.java:98)\r\n\tat org.jboss.msc.service.ServiceControllerImpl$StartTask.startService(ServiceControllerImpl.java:1737)\r\n\tat org.jboss.msc.service.ServiceControllerImpl$StartTask.execute(ServiceControllerImpl.java:1699)\r\n\tat org.jboss.msc.service.ServiceControllerImpl$ControllerTask.run(ServiceControllerImpl.java:1557)\r\n\tat org.jboss.threads.ContextClassLoaderSavingRunnable.run(ContextClassLoaderSavingRunnable.java:35)\r\n\tat org.jboss.threads.EnhancedQueueExecutor.safeRun(EnhancedQueueExecutor.java:1982)\r\n\tat org.jboss.threads.EnhancedQueueExecutor$ThreadBody.doRunTask(EnhancedQueueExecutor.java:1486)\r\n\tat org.jboss.threads.EnhancedQueueExecutor$ThreadBody.run(EnhancedQueueExecutor.java:1377)\r\n\tat java.lang.Thread.run(Thread.java:748)\r\nCaused by: javax.enterprise.inject.InjectionException: Camel annotations post processing of [InjectionTarget for Managed Bean [class org.wildfly.camel.test.cdi.subA.RouteBuilderB] with qualifiers [@Any @ContextName]] failed!\r\n\tat org.apache.camel.cdi.CamelBeanInjectionTarget.inject(CamelBeanInjectionTarget.java:44)\r\n\tat org.jboss.weld.bean.ManagedBean.create(ManagedBean.java:161)\r\n\tat org.jboss.weld.contexts.unbound.DependentContextImpl.get(DependentContextImpl.java:70)\r\n\tat org.jboss.weld.bean.ContextualInstanceStrategy$DefaultContextualInstanceStrategy.get(ContextualInstanceStrategy.java:100)\r\n\tat org.jboss.weld.bean.ContextualInstance.get(ContextualInstance.java:50)\r\n\tat org.jboss.weld.manager.BeanManagerImpl.getReference(BeanManagerImpl.java:694)\r\n\tat org.jboss.weld.manager.BeanManagerImpl.getReference(BeanManagerImpl.java:717)\r\n\tat org.jboss.weld.util.ForwardingBeanManager.getReference(ForwardingBeanManager.java:64)\r\n\tat org.jboss.weld.bean.builtin.BeanManagerProxy.getReference(BeanManagerProxy.java:87)\r\n\tat org.apache.camel.cdi.BeanManagerHelper.getReference(BeanManagerHelper.java:53)\r\n\tat org.apache.camel.cdi.CdiCamelExtension.addRouteToContext(CdiCamelExtension.java:452)\r\n\t... 31 more\r\nCaused by: java.lang.NullPointerException\r\n\tat org.apache.camel.support.CamelContextHelper.getEndpointInjection(CamelContextHelper.java:187)\r\n\tat org.apache.camel.impl.engine.CamelPostProcessorHelper.doGetEndpointInjection(CamelPostProcessorHelper.java:160)\r\n\tat org.apache.camel.impl.engine.CamelPostProcessorHelper.getEndpointInjection(CamelPostProcessorHelper.java:150)\r\n\tat org.apache.camel.impl.engine.CamelPostProcessorHelper.getInjectionValue(CamelPostProcessorHelper.java:228)\r\n\tat org.apache.camel.impl.engine.DefaultCamelBeanPostProcessor.injectField(DefaultCamelBeanPostProcessor.java:210)\r\n\tat org.apache.camel.impl.engine.DefaultCamelBeanPostProcessor.injectField(DefaultCamelBeanPostProcessor.java:204)\r\n\tat org.apache.camel.impl.engine.DefaultCamelBeanPostProcessor.lambda$injectFields$0(DefaultCamelBeanPostProcessor.java:181)\r\n\tat org.apache.camel.util.ReflectionHelper.doWithFields(ReflectionHelper.java:108)\r\n\tat org.apache.camel.impl.engine.DefaultCamelBeanPostProcessor.injectFields(DefaultCamelBeanPostProcessor.java:166)\r\n\tat org.apache.camel.impl.engine.DefaultCamelBeanPostProcessor.postProcessBeforeInitialization(DefaultCamelBeanPostProcessor.java:91)\r\n\tat org.apache.camel.cdi.CamelBeanInjectionTarget.inject(CamelBeanInjectionTarget.java:41)\r\n\t... 41 more\r\nException 1 :\r\njavax.enterprise.inject.InjectionException: Error adding routes of type [org.wildfly.camel.test.cdi.subA.RouteBuilderA] to Camel context [contextA]\r\n\tat org.apache.camel.cdi.CdiCamelExtension.addRouteToContext(CdiCamelExtension.java:467)\r\n\tat org.apache.camel.cdi.CdiCamelExtension.afterDeploymentValidation(CdiCamelExtension.java:410)\r\n\tat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\r\n\tat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)\r\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\r\n\tat java.lang.reflect.Method.invoke(Method.java:498)\r\n\tat org.jboss.weld.injection.StaticMethodInjectionPoint.invoke(StaticMethodInjectionPoint.java:95)\r\n\tat org.jboss.weld.injection.MethodInvocationStrategy$SpecialParamPlusBeanManagerStrategy.invoke(MethodInvocationStrategy.java:187)\r\n\tat org.jboss.weld.event.ObserverMethodImpl.sendEvent(ObserverMethodImpl.java:330)\r\n\tat org.jboss.weld.event.ExtensionObserverMethodImpl.sendEvent(ExtensionObserverMethodImpl.java:123)\r\n\tat org.jboss.weld.event.ObserverMethodImpl.sendEvent(ObserverMethodImpl.java:308)\r\n\tat org.jboss.weld.event.ObserverMethodImpl.notify(ObserverMethodImpl.java:286)\r\n\tat javax.enterprise.inject.spi.ObserverMethod.notify(ObserverMethod.java:124)\r\n\tat org.jboss.weld.util.Observers.notify(Observers.java:166)\r\n\tat org.jboss.weld.event.ObserverNotifier.notifySyncObservers(ObserverNotifier.java:285)\r\n\tat org.jboss.weld.event.ObserverNotifier.notify(ObserverNotifier.java:273)\r\n\tat org.jboss.weld.event.ObserverNotifier.fireEvent(ObserverNotifier.java:177)\r\n\tat org.jboss.weld.event.ObserverNotifier.fireEvent(ObserverNotifier.java:171)\r\n\tat org.jboss.weld.bootstrap.events.AbstractContainerEvent.fire(AbstractContainerEvent.java:53)\r\n\tat org.jboss.weld.bootstrap.events.AbstractDeploymentContainerEvent.fire(AbstractDeploymentContainerEvent.java:35)\r\n\tat org.jboss.weld.bootstrap.events.AfterDeploymentValidationImpl.fire(AfterDeploymentValidationImpl.java:28)\r\n\tat org.jboss.weld.bootstrap.WeldStartup.validateBeans(WeldStartup.java:505)\r\n\tat org.jboss.weld.bootstrap.WeldBootstrap.validateBeans(WeldBootstrap.java:93)\r\n\tat org.jboss.as.weld.WeldStartService.start(WeldStartService.java:98)\r\n\tat org.jboss.msc.service.ServiceControllerImpl$StartTask.startService(ServiceControllerImpl.java:1737)\r\n\tat org.jboss.msc.service.ServiceControllerImpl$StartTask.execute(ServiceControllerImpl.java:1699)\r\n\tat org.jboss.msc.service.ServiceControllerImpl$ControllerTask.run(ServiceControllerImpl.java:1557)\r\n\tat org.jboss.threads.ContextClassLoaderSavingRunnable.run(ContextClassLoaderSavingRunnable.java:35)\r\n\tat org.jboss.threads.EnhancedQueueExecutor.safeRun(EnhancedQueueExecutor.java:1982)\r\n\tat org.jboss.threads.EnhancedQueueExecutor$ThreadBody.doRunTask(EnhancedQueueExecutor.java:1486)\r\n\tat org.jboss.threads.EnhancedQueueExecutor$ThreadBody.run(EnhancedQueueExecutor.java:1377)\r\n\tat java.lang.Thread.run(Thread.java:748)\r\nCaused by: javax.enterprise.inject.InjectionException: Camel annotations post processing of [InjectionTarget for Managed Bean [class org.wildfly.camel.test.cdi.subA.RouteBuilderA] with qualifiers [@Any @ContextName]] failed!\r\n\tat org.apache.camel.cdi.CamelBeanInjectionTarget.inject(CamelBeanInjectionTarget.java:44)\r\n\tat org.jboss.weld.bean.ManagedBean.create(ManagedBean.java:161)\r\n\tat org.jboss.weld.contexts.unbound.DependentContextImpl.get(DependentContextImpl.java:70)\r\n\tat org.jboss.weld.bean.ContextualInstanceStrategy$DefaultContextualInstanceStrategy.get(ContextualInstanceStrategy.java:100)\r\n\tat org.jboss.weld.bean.ContextualInstance.get(ContextualInstance.java:50)\r\n\tat org.jboss.weld.manager.BeanManagerImpl.getReference(BeanManagerImpl.java:694)\r\n\tat org.jboss.weld.manager.BeanManagerImpl.getReference(BeanManagerImpl.java:717)\r\n\tat org.jboss.weld.util.ForwardingBeanManager.getReference(ForwardingBeanManager.java:64)\r\n\tat org.jboss.weld.bean.builtin.BeanManagerProxy.getReference(BeanManagerProxy.java:87)\r\n\tat org.apache.camel.cdi.BeanManagerHelper.getReference(BeanManagerHelper.java:53)\r\n\tat org.apache.camel.cdi.CdiCamelExtension.addRouteToContext(CdiCamelExtension.java:452)\r\n\t... 31 more\r\nCaused by: java.lang.NullPointerException\r\n\tat org.apache.camel.support.CamelContextHelper.getEndpointInjection(CamelContextHelper.java:187)\r\n\tat org.apache.camel.impl.engine.CamelPostProcessorHelper.doGetEndpointInjection(CamelPostProcessorHelper.java:160)\r\n\tat org.apache.camel.impl.engine.CamelPostProcessorHelper.getEndpointInjection(CamelPostProcessorHelper.java:150)\r\n\tat org.apache.camel.impl.engine.CamelPostProcessorHelper.getInjectionValue(CamelPostProcessorHelper.java:228)\r\n\tat org.apache.camel.impl.engine.DefaultCamelBeanPostProcessor.injectField(DefaultCamelBeanPostProcessor.java:210)\r\n\tat org.apache.camel.impl.engine.DefaultCamelBeanPostProcessor.injectField(DefaultCamelBeanPostProcessor.java:204)\r\n\tat org.apache.camel.impl.engine.DefaultCamelBeanPostProcessor.lambda$injectFields$0(DefaultCamelBeanPostProcessor.java:181)\r\n\tat org.apache.camel.util.ReflectionHelper.doWithFields(ReflectionHelper.java:108)\r\n\tat org.apache.camel.impl.engine.DefaultCamelBeanPostProcessor.injectFields(DefaultCamelBeanPostProcessor.java:166)\r\n\tat org.apache.camel.impl.engine.DefaultCamelBeanPostProcessor.postProcessBeforeInitialization(DefaultCamelBeanPostProcessor.java:91)\r\n\tat org.apache.camel.cdi.CamelBeanInjectionTarget.inject(CamelBeanInjectionTarget.java:41)\r\n\t... 41 more\r\n\"}}}}\r\n{code}\r\n\r\nCrossRef: https:\/\/github.com\/wildfly-extras\/wildfly-camel\/issues\/2859",
      "assignee":"davsclaus",
      "type":"Improvement",
      "priority":"Major",
      "status":"Resolved",
      "text":"camel-cdi: Remove support for multiple context via @ContextName (was: NPE with recent camel-cdi changes) {code}\r\nException 0 :\r\njavax.enterprise.inject.InjectionException: Error adding routes of type [org.wildfly.camel.test.cdi.subA.RouteBuilderB] to Camel context [contextB]\r\n\tat org.apache.camel.cdi.CdiCamelExtension.addRouteToContext(CdiCamelExtension.java:467)\r\n\tat org.apache.camel.cdi.CdiCamelExtension.afterDeploymentValidation(CdiCamelExtension.java:410)\r\n\tat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\r\n\tat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)\r\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\r\n\tat java.lang.reflect.Method.invoke(Method.java:498)\r\n\tat org.jboss.weld.injection.StaticMethodInjectionPoint.invoke(StaticMethodInjectionPoint.java:95)\r\n\tat org.jboss.weld.injection.MethodInvocationStrategy$SpecialParamPlusBeanManagerStrategy.invoke(MethodInvocationStrategy.java:187)\r\n\tat org.jboss.weld.event.ObserverMethodImpl.sendEvent(ObserverMethodImpl.java:330)\r\n\tat org.jboss.weld.event.ExtensionObserverMethodImpl.sendEvent(ExtensionObserverMethodImpl.java:123)\r\n\tat org.jboss.weld.event.ObserverMethodImpl.sendEvent(ObserverMethodImpl.java:308)\r\n\tat org.jboss.weld.event.ObserverMethodImpl.notify(ObserverMethodImpl.java:286)\r\n\tat javax.enterprise.inject.spi.ObserverMethod.notify(ObserverMethod.java:124)\r\n\tat org.jboss.weld.util.Observers.notify(Observers.java:166)\r\n\tat org.jboss.weld.event.ObserverNotifier.notifySyncObservers(ObserverNotifier.java:285)\r\n\tat org.jboss.weld.event.ObserverNotifier.notify(ObserverNotifier.java:273)\r\n\tat org.jboss.weld.event.ObserverNotifier.fireEvent(ObserverNotifier.java:177)\r\n\tat org.jboss.weld.event.ObserverNotifier.fireEvent(ObserverNotifier.java:171)\r\n\tat org.jboss.weld.bootstrap.events.AbstractContainerEvent.fire(AbstractContainerEvent.java:53)\r\n\tat org.jboss.weld.bootstrap.events.AbstractDeploymentContainerEvent.fire(AbstractDeploymentContainerEvent.java:35)\r\n\tat org.jboss.weld.bootstrap.events.AfterDeploymentValidationImpl.fire(AfterDeploymentValidationImpl.java:28)\r\n\tat org.jboss.weld.bootstrap.WeldStartup.validateBeans(WeldStartup.java:505)\r\n\tat org.jboss.weld.bootstrap.WeldBootstrap.validateBeans(WeldBootstrap.java:93)\r\n\tat org.jboss.as.weld.WeldStartService.start(WeldStartService.java:98)\r\n\tat org.jboss.msc.service.ServiceControllerImpl$StartTask.startService(ServiceControllerImpl.java:1737)\r\n\tat org.jboss.msc.service.ServiceControllerImpl$StartTask.execute(ServiceControllerImpl.java:1699)\r\n\tat org.jboss.msc.service.ServiceControllerImpl$ControllerTask.run(ServiceControllerImpl.java:1557)\r\n\tat org.jboss.threads.ContextClassLoaderSavingRunnable.run(ContextClassLoaderSavingRunnable.java:35)\r\n\tat org.jboss.threads.EnhancedQueueExecutor.safeRun(EnhancedQueueExecutor.java:1982)\r\n\tat org.jboss.threads.EnhancedQueueExecutor$ThreadBody.doRunTask(EnhancedQueueExecutor.java:1486)\r\n\tat org.jboss.threads.EnhancedQueueExecutor$ThreadBody.run(EnhancedQueueExecutor.java:1377)\r\n\tat java.lang.Thread.run(Thread.java:748)\r\nCaused by: javax.enterprise.inject.InjectionException: Camel annotations post processing of [InjectionTarget for Managed Bean [class org.wildfly.camel.test.cdi.subA.RouteBuilderB] with qualifiers [@Any @ContextName]] failed!\r\n\tat org.apache.camel.cdi.CamelBeanInjectionTarget.inject(CamelBeanInjectionTarget.java:44)\r\n\tat org.jboss.weld.bean.ManagedBean.create(ManagedBean.java:161)\r\n\tat org.jboss.weld.contexts.unbound.DependentContextImpl.get(DependentContextImpl.java:70)\r\n\tat org.jboss.weld.bean.ContextualInstanceStrategy$DefaultContextualInstanceStrategy.get(ContextualInstanceStrategy.java:100)\r\n\tat org.jboss.weld.bean.ContextualInstance.get(ContextualInstance.java:50)\r\n\tat org.jboss.weld.manager.BeanManagerImpl.getReference(BeanManagerImpl.java:694)\r\n\tat org.jboss.weld.manager.BeanManagerImpl.getReference(BeanManagerImpl.java:717)\r\n\tat org.jboss.weld.util.ForwardingBeanManager.getReference(ForwardingBeanManager.java:64)\r\n\tat org.jboss.weld.bean.builtin.BeanManagerProxy.getReference(BeanManagerProxy.java:87)\r\n\tat org.apache.camel.cdi.BeanManagerHelper.getReference(BeanManagerHelper.java:53)\r\n\tat org.apache.camel.cdi.CdiCamelExtension.addRouteToContext(CdiCamelExtension.java:452)\r\n\t... 31 more\r\nCaused by: java.lang.NullPointerException\r\n\tat org.apache.camel.support.CamelContextHelper.getEndpointInjection(CamelContextHelper.java:187)\r\n\tat org.apache.camel.impl.engine.CamelPostProcessorHelper.doGetEndpointInjection(CamelPostProcessorHelper.java:160)\r\n\tat org.apache.camel.impl.engine.CamelPostProcessorHelper.getEndpointInjection(CamelPostProcessorHelper.java:150)\r\n\tat org.apache.camel.impl.engine.CamelPostProcessorHelper.getInjectionValue(CamelPostProcessorHelper.java:228)\r\n\tat org.apache.camel.impl.engine.DefaultCamelBeanPostProcessor.injectField(DefaultCamelBeanPostProcessor.java:210)\r\n\tat org.apache.camel.impl.engine.DefaultCamelBeanPostProcessor.injectField(DefaultCamelBeanPostProcessor.java:204)\r\n\tat org.apache.camel.impl.engine.DefaultCamelBeanPostProcessor.lambda$injectFields$0(DefaultCamelBeanPostProcessor.java:181)\r\n\tat org.apache.camel.util.ReflectionHelper.doWithFields(ReflectionHelper.java:108)\r\n\tat org.apache.camel.impl.engine.DefaultCamelBeanPostProcessor.injectFields(DefaultCamelBeanPostProcessor.java:166)\r\n\tat org.apache.camel.impl.engine.DefaultCamelBeanPostProcessor.postProcessBeforeInitialization(DefaultCamelBeanPostProcessor.java:91)\r\n\tat org.apache.camel.cdi.CamelBeanInjectionTarget.inject(CamelBeanInjectionTarget.java:41)\r\n\t... 41 more\r\nException 1 :\r\njavax.enterprise.inject.InjectionException: Error adding routes of type [org.wildfly.camel.test.cdi.subA.RouteBuilderA] to Camel context [contextA]\r\n\tat org.apache.camel.cdi.CdiCamelExtension.addRouteToContext(CdiCamelExtension.java:467)\r\n\tat org.apache.camel.cdi.CdiCamelExtension.afterDeploymentValidation(CdiCamelExtension.java:410)\r\n\tat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\r\n\tat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)\r\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\r\n\tat java.lang.reflect.Method.invoke(Method.java:498)\r\n\tat org.jboss.weld.injection.StaticMethodInjectionPoint.invoke(StaticMethodInjectionPoint.java:95)\r\n\tat org.jboss.weld.injection.MethodInvocationStrategy$SpecialParamPlusBeanManagerStrategy.invoke(MethodInvocationStrategy.java:187)\r\n\tat org.jboss.weld.event.ObserverMethodImpl.sendEvent(ObserverMethodImpl.java:330)\r\n\tat org.jboss.weld.event.ExtensionObserverMethodImpl.sendEvent(ExtensionObserverMethodImpl.java:123)\r\n\tat org.jboss.weld.event.ObserverMethodImpl.sendEvent(ObserverMethodImpl.java:308)\r\n\tat org.jboss.weld.event.ObserverMethodImpl.notify(ObserverMethodImpl.java:286)\r\n\tat javax.enterprise.inject.spi.ObserverMethod.notify(ObserverMethod.java:124)\r\n\tat org.jboss.weld.util.Observers.notify(Observers.java:166)\r\n\tat org.jboss.weld.event.ObserverNotifier.notifySyncObservers(ObserverNotifier.java:285)\r\n\tat org.jboss.weld.event.ObserverNotifier.notify(ObserverNotifier.java:273)\r\n\tat org.jboss.weld.event.ObserverNotifier.fireEvent(ObserverNotifier.java:177)\r\n\tat org.jboss.weld.event.ObserverNotifier.fireEvent(ObserverNotifier.java:171)\r\n\tat org.jboss.weld.bootstrap.events.AbstractContainerEvent.fire(AbstractContainerEvent.java:53)\r\n\tat org.jboss.weld.bootstrap.events.AbstractDeploymentContainerEvent.fire(AbstractDeploymentContainerEvent.java:35)\r\n\tat org.jboss.weld.bootstrap.events.AfterDeploymentValidationImpl.fire(AfterDeploymentValidationImpl.java:28)\r\n\tat org.jboss.weld.bootstrap.WeldStartup.validateBeans(WeldStartup.java:505)\r\n\tat org.jboss.weld.bootstrap.WeldBootstrap.validateBeans(WeldBootstrap.java:93)\r\n\tat org.jboss.as.weld.WeldStartService.start(WeldStartService.java:98)\r\n\tat org.jboss.msc.service.ServiceControllerImpl$StartTask.startService(ServiceControllerImpl.java:1737)\r\n\tat org.jboss.msc.service.ServiceControllerImpl$StartTask.execute(ServiceControllerImpl.java:1699)\r\n\tat org.jboss.msc.service.ServiceControllerImpl$ControllerTask.run(ServiceControllerImpl.java:1557)\r\n\tat org.jboss.threads.ContextClassLoaderSavingRunnable.run(ContextClassLoaderSavingRunnable.java:35)\r\n\tat org.jboss.threads.EnhancedQueueExecutor.safeRun(EnhancedQueueExecutor.java:1982)\r\n\tat org.jboss.threads.EnhancedQueueExecutor$ThreadBody.doRunTask(EnhancedQueueExecutor.java:1486)\r\n\tat org.jboss.threads.EnhancedQueueExecutor$ThreadBody.run(EnhancedQueueExecutor.java:1377)\r\n\tat java.lang.Thread.run(Thread.java:748)\r\nCaused by: javax.enterprise.inject.InjectionException: Camel annotations post processing of [InjectionTarget for Managed Bean [class org.wildfly.camel.test.cdi.subA.RouteBuilderA] with qualifiers [@Any @ContextName]] failed!\r\n\tat org.apache.camel.cdi.CamelBeanInjectionTarget.inject(CamelBeanInjectionTarget.java:44)\r\n\tat org.jboss.weld.bean.ManagedBean.create(ManagedBean.java:161)\r\n\tat org.jboss.weld.contexts.unbound.DependentContextImpl.get(DependentContextImpl.java:70)\r\n\tat org.jboss.weld.bean.ContextualInstanceStrategy$DefaultContextualInstanceStrategy.get(ContextualInstanceStrategy.java:100)\r\n\tat org.jboss.weld.bean.ContextualInstance.get(ContextualInstance.java:50)\r\n\tat org.jboss.weld.manager.BeanManagerImpl.getReference(BeanManagerImpl.java:694)\r\n\tat org.jboss.weld.manager.BeanManagerImpl.getReference(BeanManagerImpl.java:717)\r\n\tat org.jboss.weld.util.ForwardingBeanManager.getReference(ForwardingBeanManager.java:64)\r\n\tat org.jboss.weld.bean.builtin.BeanManagerProxy.getReference(BeanManagerProxy.java:87)\r\n\tat org.apache.camel.cdi.BeanManagerHelper.getReference(BeanManagerHelper.java:53)\r\n\tat org.apache.camel.cdi.CdiCamelExtension.addRouteToContext(CdiCamelExtension.java:452)\r\n\t... 31 more\r\nCaused by: java.lang.NullPointerException\r\n\tat org.apache.camel.support.CamelContextHelper.getEndpointInjection(CamelContextHelper.java:187)\r\n\tat org.apache.camel.impl.engine.CamelPostProcessorHelper.doGetEndpointInjection(CamelPostProcessorHelper.java:160)\r\n\tat org.apache.camel.impl.engine.CamelPostProcessorHelper.getEndpointInjection(CamelPostProcessorHelper.java:150)\r\n\tat org.apache.camel.impl.engine.CamelPostProcessorHelper.getInjectionValue(CamelPostProcessorHelper.java:228)\r\n\tat org.apache.camel.impl.engine.DefaultCamelBeanPostProcessor.injectField(DefaultCamelBeanPostProcessor.java:210)\r\n\tat org.apache.camel.impl.engine.DefaultCamelBeanPostProcessor.injectField(DefaultCamelBeanPostProcessor.java:204)\r\n\tat org.apache.camel.impl.engine.DefaultCamelBeanPostProcessor.lambda$injectFields$0(DefaultCamelBeanPostProcessor.java:181)\r\n\tat org.apache.camel.util.ReflectionHelper.doWithFields(ReflectionHelper.java:108)\r\n\tat org.apache.camel.impl.engine.DefaultCamelBeanPostProcessor.injectFields(DefaultCamelBeanPostProcessor.java:166)\r\n\tat org.apache.camel.impl.engine.DefaultCamelBeanPostProcessor.postProcessBeforeInitialization(DefaultCamelBeanPostProcessor.java:91)\r\n\tat org.apache.camel.cdi.CamelBeanInjectionTarget.inject(CamelBeanInjectionTarget.java:41)\r\n\t... 41 more\r\n\"}}}}\r\n{code}\r\n\r\nCrossRef: https:\/\/github.com\/wildfly-extras\/wildfly-camel\/issues\/2859"
    },
    {
      "key":"CAMEL-13797",
      "title":"Move @InvokeOnHeader\/@InvokeOnHeaders to org.apache.camel.spi package",
      "description":"Contributions is welcome, there is a number of components that are using these annotations which needs to be updated too",
      "assignee":"davsclaus",
      "type":"Improvement",
      "priority":"Major",
      "status":"Resolved",
      "text":"Move @InvokeOnHeader\/@InvokeOnHeaders to org.apache.camel.spi package Contributions is welcome, there is a number of components that are using these annotations which needs to be updated too"
    },
    {
      "key":"CAMEL-13796",
      "title":"Salesforce Component IDLE_TIMEOUT Blocks Async Request Responses",
      "description":"Bulk, Composite Batch, etc. all throw an exception when trying to return on more than a few records due to [static final IDLE_TIMEOUT|https:\/\/github.com\/apache\/camel\/blob\/master\/components\/camel-salesforce\/camel-salesforce-component\/src\/main\/java\/org\/apache\/camel\/component\/salesforce\/SalesforceComponent.java#L80] on the instantiated salesforce component httpClient:\r\n\r\n\u00a0\r\n\r\nCaused by: org.apache.camel.component.salesforce.api.SalesforceException: Unexpected error \\{0:null} executing \\{POST:https:\/\/genericSFDCInstance.salesforce.com\/services\/data\/v38.0\/composite\/batch}\r\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 at org.apache.camel.component.salesforce.internal.client.AbstractClientBase$1.onComplete(AbstractClientBase.java:199) ~[camel-salesforce-2.23.0.jar:2.23.0]\r\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 at org.eclipse.jetty.client.ResponseNotifier.notifyComplete(ResponseNotifier.java:202) ~[jetty-client-9.4.12.v20180830.jar:9.4.12.v20180830]\r\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 at org.eclipse.jetty.client.ResponseNotifier.notifyComplete(ResponseNotifier.java:194) ~[jetty-client-9.4.12.v20180830.jar:9.4.12.v20180830]\r\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 at org.eclipse.jetty.client.HttpReceiver.terminateResponse(HttpReceiver.java:470) ~[jetty-client-9.4.12.v20180830.jar:9.4.12.v20180830]\r\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 at org.eclipse.jetty.client.HttpReceiver.abort(HttpReceiver.java:552) ~[jetty-client-9.4.12.v20180830.jar:9.4.12.v20180830]\r\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 at org.eclipse.jetty.client.HttpChannel.abortResponse(HttpChannel.java:156) ~[jetty-client-9.4.12.v20180830.jar:9.4.12.v20180830]\r\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 at org.eclipse.jetty.client.HttpChannel.abort(HttpChannel.java:149) ~[jetty-client-9.4.12.v20180830.jar:9.4.12.v20180830]\r\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 at org.eclipse.jetty.client.HttpExchange.abort(HttpExchange.java:257) ~[jetty-client-9.4.12.v20180830.jar:9.4.12.v20180830]\r\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 at org.eclipse.jetty.client.HttpConversation.abort(HttpConversation.java:141) ~[jetty-client-9.4.12.v20180830.jar:9.4.12.v20180830]\r\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 at org.eclipse.jetty.client.HttpRequest.abort(HttpRequest.java:767) ~[jetty-client-9.4.12.v20180830.jar:9.4.12.v20180830]\r\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 at org.eclipse.jetty.client.http.HttpConnectionOverHTTP.abort(HttpConnectionOverHTTP.java:204) ~[jetty-client-9.4.12.v20180830.jar:9.4.12.v20180830]\r\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 at org.eclipse.jetty.client.http.HttpConnectionOverHTTP.close(HttpConnectionOverHTTP.java:190) ~[jetty-client-9.4.12.v20180830.jar:9.4.12.v20180830]\r\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 at org.eclipse.jetty.client.http.HttpConnectionOverHTTP.onIdleExpired(HttpConnectionOverHTTP.java:145) ~[jetty-client-9.4.12.v20180830.jar:9.4.12.v20180830]\r\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 at org.eclipse.jetty.io.ssl.SslConnection.onIdleExpired(SslConnection.java:286) ~[jetty-io-9.4.12.v20180830.jar:9.4.12.v20180830]\r\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 at org.eclipse.jetty.io.AbstractEndPoint.onIdleExpired(AbstractEndPoint.java:401) ~[jetty-io-9.4.12.v20180830.jar:9.4.12.v20180830]\r\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 at org.eclipse.jetty.io.IdleTimeout.checkIdleTimeout(IdleTimeout.java:166) ~[jetty-io-9.4.12.v20180830.jar:9.4.12.v20180830]\r\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 at org.eclipse.jetty.io.IdleTimeout$1.run(IdleTimeout.java:50) ~[jetty-io-9.4.12.v20180830.jar:9.4.12.v20180830]\r\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511) ~[?:1.8.0_201]\r\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 at java.util.concurrent.FutureTask.run(FutureTask.java:266) ~[?:1.8.0_201]\r\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.access$201(ScheduledThreadPoolExecutor.java:180) ~[?:1.8.0_201]\r\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:293) ~[?:1.8.0_201]\r\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149) ~[?:1.8.0_201]\r\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624) ~[?:1.8.0_201]\r\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 ... 1 more\r\n\r\n\r\n*Caused by: java.util.concurrent.TimeoutException: Idle timeout 5000 ms*\r\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 at org.eclipse.jetty.client.http.HttpConnectionOverHTTP.onIdleExpired(HttpConnectionOverHTTP.java:145) ~[jetty-client-9.4.12.v20180830.jar:9.4.12.v20180830]\r\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 at org.eclipse.jetty.io.ssl.SslConnection.onIdleExpired(SslConnection.java:286) ~[jetty-io-9.4.12.v20180830.jar:9.4.12.v20180830]\r\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 at org.eclipse.jetty.io.AbstractEndPoint.onIdleExpired(AbstractEndPoint.java:401) ~[jetty-io-9.4.12.v20180830.jar:9.4.12.v20180830]\r\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 at org.eclipse.jetty.io.IdleTimeout.checkIdleTimeout(IdleTimeout.java:166) ~[jetty-io-9.4.12.v20180830.jar:9.4.12.v20180830]\r\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 at org.eclipse.jetty.io.IdleTimeout$1.run(IdleTimeout.java:50) ~[jetty-io-9.4.12.v20180830.jar:9.4.12.v20180830]\r\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511) ~[?:1.8.0_201]\r\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 at java.util.concurrent.FutureTask.run(FutureTask.java:266) ~[?:1.8.0_201]\r\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.access$201(ScheduledThreadPoolExecutor.java:180) ~[?:1.8.0_201]\r\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:293) ~[?:1.8.0_201]\r\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149) ~[?:1.8.0_201]\r\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624) ~[?:1.8.0_201]\r\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 ... 1 more\r\n\r\n\u00a0\r\n\r\nNote that as IDLE_TIMEOUT is static, it cannot be set via Spring, and the httpClientProperties map is [never used to set any timeouts|https:\/\/github.com\/apache\/camel\/blob\/master\/components\/camel-salesforce\/camel-salesforce-component\/src\/main\/java\/org\/apache\/camel\/component\/salesforce\/SalesforceComponent.java#L714], instead opting to take the [hardcoded defaults|https:\/\/github.com\/apache\/camel\/blob\/master\/components\/camel-salesforce\/camel-salesforce-component\/src\/main\/java\/org\/apache\/camel\/component\/salesforce\/SalesforceComponent.java#L707].\r\n\r\n\u00a0",
      "assignee":"davsclaus",
      "type":"Bug",
      "priority":"Minor",
      "status":"Closed",
      "text":"Salesforce Component IDLE_TIMEOUT Blocks Async Request Responses Bulk, Composite Batch, etc. all throw an exception when trying to return on more than a few records due to [static final IDLE_TIMEOUT|https:\/\/github.com\/apache\/camel\/blob\/master\/components\/camel-salesforce\/camel-salesforce-component\/src\/main\/java\/org\/apache\/camel\/component\/salesforce\/SalesforceComponent.java#L80] on the instantiated salesforce component httpClient:\r\n\r\n \r\n\r\nCaused by: org.apache.camel.component.salesforce.api.SalesforceException: Unexpected error \\{0:null} executing \\{POST:https:\/\/genericSFDCInstance.salesforce.com\/services\/data\/v38.0\/composite\/batch}\r\n        at org.apache.camel.component.salesforce.internal.client.AbstractClientBase$1.onComplete(AbstractClientBase.java:199) ~[camel-salesforce-2.23.0.jar:2.23.0]\r\n        at org.eclipse.jetty.client.ResponseNotifier.notifyComplete(ResponseNotifier.java:202) ~[jetty-client-9.4.12.v20180830.jar:9.4.12.v20180830]\r\n        at org.eclipse.jetty.client.ResponseNotifier.notifyComplete(ResponseNotifier.java:194) ~[jetty-client-9.4.12.v20180830.jar:9.4.12.v20180830]\r\n        at org.eclipse.jetty.client.HttpReceiver.terminateResponse(HttpReceiver.java:470) ~[jetty-client-9.4.12.v20180830.jar:9.4.12.v20180830]\r\n        at org.eclipse.jetty.client.HttpReceiver.abort(HttpReceiver.java:552) ~[jetty-client-9.4.12.v20180830.jar:9.4.12.v20180830]\r\n        at org.eclipse.jetty.client.HttpChannel.abortResponse(HttpChannel.java:156) ~[jetty-client-9.4.12.v20180830.jar:9.4.12.v20180830]\r\n        at org.eclipse.jetty.client.HttpChannel.abort(HttpChannel.java:149) ~[jetty-client-9.4.12.v20180830.jar:9.4.12.v20180830]\r\n        at org.eclipse.jetty.client.HttpExchange.abort(HttpExchange.java:257) ~[jetty-client-9.4.12.v20180830.jar:9.4.12.v20180830]\r\n        at org.eclipse.jetty.client.HttpConversation.abort(HttpConversation.java:141) ~[jetty-client-9.4.12.v20180830.jar:9.4.12.v20180830]\r\n        at org.eclipse.jetty.client.HttpRequest.abort(HttpRequest.java:767) ~[jetty-client-9.4.12.v20180830.jar:9.4.12.v20180830]\r\n        at org.eclipse.jetty.client.http.HttpConnectionOverHTTP.abort(HttpConnectionOverHTTP.java:204) ~[jetty-client-9.4.12.v20180830.jar:9.4.12.v20180830]\r\n        at org.eclipse.jetty.client.http.HttpConnectionOverHTTP.close(HttpConnectionOverHTTP.java:190) ~[jetty-client-9.4.12.v20180830.jar:9.4.12.v20180830]\r\n        at org.eclipse.jetty.client.http.HttpConnectionOverHTTP.onIdleExpired(HttpConnectionOverHTTP.java:145) ~[jetty-client-9.4.12.v20180830.jar:9.4.12.v20180830]\r\n        at org.eclipse.jetty.io.ssl.SslConnection.onIdleExpired(SslConnection.java:286) ~[jetty-io-9.4.12.v20180830.jar:9.4.12.v20180830]\r\n        at org.eclipse.jetty.io.AbstractEndPoint.onIdleExpired(AbstractEndPoint.java:401) ~[jetty-io-9.4.12.v20180830.jar:9.4.12.v20180830]\r\n        at org.eclipse.jetty.io.IdleTimeout.checkIdleTimeout(IdleTimeout.java:166) ~[jetty-io-9.4.12.v20180830.jar:9.4.12.v20180830]\r\n        at org.eclipse.jetty.io.IdleTimeout$1.run(IdleTimeout.java:50) ~[jetty-io-9.4.12.v20180830.jar:9.4.12.v20180830]\r\n        at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511) ~[?:1.8.0_201]\r\n        at java.util.concurrent.FutureTask.run(FutureTask.java:266) ~[?:1.8.0_201]\r\n        at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.access$201(ScheduledThreadPoolExecutor.java:180) ~[?:1.8.0_201]\r\n        at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:293) ~[?:1.8.0_201]\r\n        at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149) ~[?:1.8.0_201]\r\n        at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624) ~[?:1.8.0_201]\r\n        ... 1 more\r\n\r\n\r\n*Caused by: java.util.concurrent.TimeoutException: Idle timeout 5000 ms*\r\n        at org.eclipse.jetty.client.http.HttpConnectionOverHTTP.onIdleExpired(HttpConnectionOverHTTP.java:145) ~[jetty-client-9.4.12.v20180830.jar:9.4.12.v20180830]\r\n        at org.eclipse.jetty.io.ssl.SslConnection.onIdleExpired(SslConnection.java:286) ~[jetty-io-9.4.12.v20180830.jar:9.4.12.v20180830]\r\n        at org.eclipse.jetty.io.AbstractEndPoint.onIdleExpired(AbstractEndPoint.java:401) ~[jetty-io-9.4.12.v20180830.jar:9.4.12.v20180830]\r\n        at org.eclipse.jetty.io.IdleTimeout.checkIdleTimeout(IdleTimeout.java:166) ~[jetty-io-9.4.12.v20180830.jar:9.4.12.v20180830]\r\n        at org.eclipse.jetty.io.IdleTimeout$1.run(IdleTimeout.java:50) ~[jetty-io-9.4.12.v20180830.jar:9.4.12.v20180830]\r\n        at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511) ~[?:1.8.0_201]\r\n        at java.util.concurrent.FutureTask.run(FutureTask.java:266) ~[?:1.8.0_201]\r\n        at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.access$201(ScheduledThreadPoolExecutor.java:180) ~[?:1.8.0_201]\r\n        at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:293) ~[?:1.8.0_201]\r\n        at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149) ~[?:1.8.0_201]\r\n        at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624) ~[?:1.8.0_201]\r\n        ... 1 more\r\n\r\n \r\n\r\nNote that as IDLE_TIMEOUT is static, it cannot be set via Spring, and the httpClientProperties map is [never used to set any timeouts|https:\/\/github.com\/apache\/camel\/blob\/master\/components\/camel-salesforce\/camel-salesforce-component\/src\/main\/java\/org\/apache\/camel\/component\/salesforce\/SalesforceComponent.java#L714], instead opting to take the [hardcoded defaults|https:\/\/github.com\/apache\/camel\/blob\/master\/components\/camel-salesforce\/camel-salesforce-component\/src\/main\/java\/org\/apache\/camel\/component\/salesforce\/SalesforceComponent.java#L707].\r\n\r\n "
    },
    {
      "key":"CAMEL-13795",
      "title":"TokenXMLExpressionIterator\u00a0with inheritNamespaceToken creates duplicate default namespace definition",
      "description":"\u00a0If a sub-item also contains the default namespace definition the splitter will duplicate it.\r\n\r\n\u00a0\r\n{code:java|title=route definition}\r\nfrom(\"file:target\/pair?initialDelay=0&delay=10\")\r\n                    \/\/ split the order child tags, and inherit namespaces from the orders root tag\r\n                    .split().tokenizeXML(\"order\", \"orders\")\r\n                        .to(\"mock:split\");\r\n{code}\r\n\u00a0\r\n\r\n\u00a0\r\n{code:xml|title=input}\r\n<orders xmlns=\"http:acme.com\">\u00a0\r\n <order xmlns=\"http:acme.com\" id=\"1\">Camel in Action<\/order>\r\n <order id=\"2\">ActiveMQ in Action<\/order>\r\n <order id=\"3\">DSL in Action<\/order>\r\n<\/orders>\"\r\n{code}\r\n{code:xml|title=output[1]}\r\n<order xmlns=\"http:acme.com\" id=\"1\" xmlns=\"http:acme.com\">Camel in Action<\/order>\r\n{code}\r\n{code:xml|title=expected[1]}\r\n <order xmlns=\"http:acme.com\" id=\"1\">Camel in Action<\/order>\r\n{code}",
      "assignee":"davsclaus",
      "type":"Bug",
      "priority":"Minor",
      "status":"Resolved",
      "text":"TokenXMLExpressionIterator with inheritNamespaceToken creates duplicate default namespace definition  If a sub-item also contains the default namespace definition the splitter will duplicate it.\r\n\r\n \r\n{code:java|title=route definition}\r\nfrom(\"file:target\/pair?initialDelay=0&delay=10\")\r\n                    \/\/ split the order child tags, and inherit namespaces from the orders root tag\r\n                    .split().tokenizeXML(\"order\", \"orders\")\r\n                        .to(\"mock:split\");\r\n{code}\r\n \r\n\r\n \r\n{code:xml|title=input}\r\n<orders xmlns=\"http:acme.com\"> \r\n <order xmlns=\"http:acme.com\" id=\"1\">Camel in Action<\/order>\r\n <order id=\"2\">ActiveMQ in Action<\/order>\r\n <order id=\"3\">DSL in Action<\/order>\r\n<\/orders>\"\r\n{code}\r\n{code:xml|title=output[1]}\r\n<order xmlns=\"http:acme.com\" id=\"1\" xmlns=\"http:acme.com\">Camel in Action<\/order>\r\n{code}\r\n{code:xml|title=expected[1]}\r\n <order xmlns=\"http:acme.com\" id=\"1\">Camel in Action<\/order>\r\n{code}"
    },
    {
      "key":"CAMEL-13793",
      "title":"camel3 - Camel annotations with context ids should be deprecated",
      "description":"We do not recommend having 2+ camel contexts per application \/ deployment unit. So we should deprecate these on these annotations as they should be for the current context only.\r\n\r\n",
      "assignee":"davsclaus",
      "type":"Improvement",
      "priority":"Major",
      "status":"Resolved",
      "text":"camel3 - Camel annotations with context ids should be deprecated We do not recommend having 2+ camel contexts per application \/ deployment unit. So we should deprecate these on these annotations as they should be for the current context only.\r\n\r\n"
    },
    {
      "key":"CAMEL-13788",
      "title":"camel3 - Message API - Deprecate OUT",
      "description":"http:\/\/mail-archives.apache.org\/mod_mbox\/camel-dev\/201907.mbox\/%3CCAGB5yNkyx9LYk40UwGQdq_%2BiZH%3DOrqOifnqp%2BNL7vmv2TSJvnw%40mail.gmail.com%3E",
      "assignee":"davsclaus",
      "type":"Improvement",
      "priority":"Major",
      "status":"Resolved",
      "text":"camel3 - Message API - Deprecate OUT http:\/\/mail-archives.apache.org\/mod_mbox\/camel-dev\/201907.mbox\/%3CCAGB5yNkyx9LYk40UwGQdq_%2BiZH%3DOrqOifnqp%2BNL7vmv2TSJvnw%40mail.gmail.com%3E"
    },
    {
      "key":"CAMEL-13783",
      "title":"Fix the camel-archetype-component to inherit from DefaultConsumer instead of ScheduledPollConsumer",
      "description":"Currently the {{[camel-archetype-component|https:\/\/github.com\/apache\/camel\/blob\/master\/archetypes\/camel-archetype-component\/src\/main\/resources\/archetype-resources\/src\/main\/java\/__name__Consumer.java#L28]}} inherits from {{ScheduledPollConsumer}}, since this consumer is less used, it will make sense to change the consumer to {{DefaultConsumer}} instead. ",
      "assignee":"davsclaus",
      "type":"Bug",
      "priority":"Minor",
      "status":"Resolved",
      "text":"Fix the camel-archetype-component to inherit from DefaultConsumer instead of ScheduledPollConsumer Currently the {{[camel-archetype-component|https:\/\/github.com\/apache\/camel\/blob\/master\/archetypes\/camel-archetype-component\/src\/main\/resources\/archetype-resources\/src\/main\/java\/__name__Consumer.java#L28]}} inherits from {{ScheduledPollConsumer}}, since this consumer is less used, it will make sense to change the consumer to {{DefaultConsumer}} instead. "
    },
    {
      "key":"CAMEL-13774",
      "title":"camel-zipfile - Accept an iterator as body for zip",
      "description":"Accept iterator or Java 8 Stream as body to produce a zip file this will avoid to use the memory for big file (for some use case we can't get an inputStream)\r\n\r\nFor example it would be very nice to be able to do this:\r\n\r\n\r\n{code:java}\r\nfrom(\"timer:foo?repeatCount=1\")\r\n                .setBody(constant(Stream.of(\"v1\", \"v2\")))\r\n                .setHeader(Exchange.FILE_NAME, constant(\"report.txt\"))\r\n                .marshal().zipFile()\r\n                .to(\"file:output\/directory\");\r\n{code}\r\n\r\n(https:\/\/stackoverflow.com\/questions\/50295432\/zip-and-unzip-a-large-file-without-loading-the-entire-file-in-memory-in-apache-c)\r\n",
      "assignee":"davsclaus",
      "type":"Improvement",
      "priority":"Major",
      "status":"Resolved",
      "text":"camel-zipfile - Accept an iterator as body for zip Accept iterator or Java 8 Stream as body to produce a zip file this will avoid to use the memory for big file (for some use case we can't get an inputStream)\r\n\r\nFor example it would be very nice to be able to do this:\r\n\r\n\r\n{code:java}\r\nfrom(\"timer:foo?repeatCount=1\")\r\n                .setBody(constant(Stream.of(\"v1\", \"v2\")))\r\n                .setHeader(Exchange.FILE_NAME, constant(\"report.txt\"))\r\n                .marshal().zipFile()\r\n                .to(\"file:output\/directory\");\r\n{code}\r\n\r\n(https:\/\/stackoverflow.com\/questions\/50295432\/zip-and-unzip-a-large-file-without-loading-the-entire-file-in-memory-in-apache-c)\r\n"
    },
    {
      "key":"CAMEL-13770",
      "title":"Properties of class Map does not work with Spring Boot 2.x",
      "description":"From version 2.22.0 onwards spring-boot version is upgraded to 2.x\r\nAfter that all Map properties are not working\r\n\r\nFor example in application.properties\r\ncamel.component.salesforce.http-client-properties is treated as string instead of Map and whatever value we provide to it, the Map is initialize as null\r\n\r\n",
      "assignee":"davsclaus",
      "type":"Bug",
      "priority":"Major",
      "status":"Resolved",
      "text":"Properties of class Map does not work with Spring Boot 2.x From version 2.22.0 onwards spring-boot version is upgraded to 2.x\r\nAfter that all Map properties are not working\r\n\r\nFor example in application.properties\r\ncamel.component.salesforce.http-client-properties is treated as string instead of Map and whatever value we provide to it, the Map is initialize as null\r\n\r\n"
    },
    {
      "key":"CAMEL-13763",
      "title":"elasticsearch-rest producer closes connection when route is reloaded from xml and stays closed",
      "description":"When setting\u00a0camel.springboot.xmlRoutesReloadDirectory, any route using the Elasticsearch rest producer will cause a shutdown of the http client. When reloading a route, the route will be stopped and client.close() is being called on RestClient. The shared http client will not be able to handle new requets because the reactor status is STOPPED.",
      "assignee":"davsclaus",
      "type":"Improvement",
      "priority":"Critical",
      "status":"Resolved",
      "text":"elasticsearch-rest producer closes connection when route is reloaded from xml and stays closed When setting camel.springboot.xmlRoutesReloadDirectory, any route using the Elasticsearch rest producer will cause a shutdown of the http client. When reloading a route, the route will be stopped and client.close() is being called on RestClient. The shared http client will not be able to handle new requets because the reactor status is STOPPED."
    },
    {
      "key":"CAMEL-13761",
      "title":"StartupListener runs before routes are started, contrary to Javadoc",
      "description":"The Javadoc ([https:\/\/static.javadoc.io\/org.apache.camel\/camel-core\/2.23.3\/org\/apache\/camel\/StartupListener.html]) for StartupListener is misleading (italics for emphasis):\r\n{quote}This can be used to perform any custom work when the entire\u00a0[{{CamelContext}}|https:\/\/static.javadoc.io\/org.apache.camel\/camel-core\/2.23.3\/org\/apache\/camel\/CamelContext.html]\u00a0has been initialized and\u00a0*almost*\u00a0started. _For example this ensures that all Camel routes have been started and are up and running, before this callback is invoked._\r\n{quote}\r\nHowever, routes are not started within the callback. The following code, for example,\u00a0\r\n{code:java}\r\nDefaultCamelContext context = new DefaultCamelContext();\r\n\r\ncontext.addStartupListener((c, alreadyStarted) -> {\r\n    c.createProducerTemplate().sendBody(\"direct:doesNotExistYet\", new Object());\r\n});\r\n\r\ncontext.addRoutes(new RouteBuilder() {\r\n    @Override\r\n    public void configure() {\r\n        from(\"direct:doesNotExistYet\").bean((Consumer<Object>) System.out::println);\r\n    }\r\n});\r\ncontext.start();{code}\r\n\r\nfails with\r\n{code}\r\nCaused by: org.apache.camel.component.direct.DirectConsumerNotAvailableException: No consumers available on endpoint: direct:\/\/doesNotExistYet. Exchange[ID-x-1563396556957-0-1]\r\n\tat org.apache.camel.component.direct.DirectProducer.process(DirectProducer.java:69)\r\n\tat org.apache.camel.processor.SharedCamelInternalProcessor.process(SharedCamelInternalProcessor.java:186)\r\n\tat org.apache.camel.processor.SharedCamelInternalProcessor.process(SharedCamelInternalProcessor.java:86)\r\n\tat org.apache.camel.impl.ProducerCache$1.doInProducer(ProducerCache.java:541)\r\n\tat org.apache.camel.impl.ProducerCache$1.doInProducer(ProducerCache.java:506)\r\n\tat org.apache.camel.impl.ProducerCache.doInProducer(ProducerCache.java:369)\r\n\tat org.apache.camel.impl.ProducerCache.sendExchange(ProducerCache.java:506)\r\n\tat org.apache.camel.impl.ProducerCache.send(ProducerCache.java:229)\r\n\tat org.apache.camel.impl.DefaultProducerTemplate.send(DefaultProducerTemplate.java:144)\r\n\tat org.apache.camel.impl.DefaultProducerTemplate.sendBody(DefaultProducerTemplate.java:161)\r\n\t... 12 more\r\n{code}\r\n\r\nI am aware that using ExtendedStartupListener or an EventNotifier makes this work, but it would be great if the Javadoc was updated (assuming this is intended behavior, I am not sure).",
      "assignee":"davsclaus",
      "type":"Improvement",
      "priority":"Trivial",
      "status":"Resolved",
      "text":"StartupListener runs before routes are started, contrary to Javadoc The Javadoc ([https:\/\/static.javadoc.io\/org.apache.camel\/camel-core\/2.23.3\/org\/apache\/camel\/StartupListener.html]) for StartupListener is misleading (italics for emphasis):\r\n{quote}This can be used to perform any custom work when the entire [{{CamelContext}}|https:\/\/static.javadoc.io\/org.apache.camel\/camel-core\/2.23.3\/org\/apache\/camel\/CamelContext.html] has been initialized and *almost* started. _For example this ensures that all Camel routes have been started and are up and running, before this callback is invoked._\r\n{quote}\r\nHowever, routes are not started within the callback. The following code, for example, \r\n{code:java}\r\nDefaultCamelContext context = new DefaultCamelContext();\r\n\r\ncontext.addStartupListener((c, alreadyStarted) -> {\r\n    c.createProducerTemplate().sendBody(\"direct:doesNotExistYet\", new Object());\r\n});\r\n\r\ncontext.addRoutes(new RouteBuilder() {\r\n    @Override\r\n    public void configure() {\r\n        from(\"direct:doesNotExistYet\").bean((Consumer<Object>) System.out::println);\r\n    }\r\n});\r\ncontext.start();{code}\r\n\r\nfails with\r\n{code}\r\nCaused by: org.apache.camel.component.direct.DirectConsumerNotAvailableException: No consumers available on endpoint: direct:\/\/doesNotExistYet. Exchange[ID-x-1563396556957-0-1]\r\n\tat org.apache.camel.component.direct.DirectProducer.process(DirectProducer.java:69)\r\n\tat org.apache.camel.processor.SharedCamelInternalProcessor.process(SharedCamelInternalProcessor.java:186)\r\n\tat org.apache.camel.processor.SharedCamelInternalProcessor.process(SharedCamelInternalProcessor.java:86)\r\n\tat org.apache.camel.impl.ProducerCache$1.doInProducer(ProducerCache.java:541)\r\n\tat org.apache.camel.impl.ProducerCache$1.doInProducer(ProducerCache.java:506)\r\n\tat org.apache.camel.impl.ProducerCache.doInProducer(ProducerCache.java:369)\r\n\tat org.apache.camel.impl.ProducerCache.sendExchange(ProducerCache.java:506)\r\n\tat org.apache.camel.impl.ProducerCache.send(ProducerCache.java:229)\r\n\tat org.apache.camel.impl.DefaultProducerTemplate.send(DefaultProducerTemplate.java:144)\r\n\tat org.apache.camel.impl.DefaultProducerTemplate.sendBody(DefaultProducerTemplate.java:161)\r\n\t... 12 more\r\n{code}\r\n\r\nI am aware that using ExtendedStartupListener or an EventNotifier makes this work, but it would be great if the Javadoc was updated (assuming this is intended behavior, I am not sure)."
    },
    {
      "key":"CAMEL-13760",
      "title":"camel3 - Property placeholder - Deprecate changing prefix\/suffix tokens",
      "description":"This causes some issues and its better we stick to one model the default of using {{ }} which is the Camel style.",
      "assignee":"davsclaus",
      "type":"Improvement",
      "priority":"Major",
      "status":"Resolved",
      "text":"camel3 - Property placeholder - Deprecate changing prefix\/suffix tokens This causes some issues and its better we stick to one model the default of using {{ }} which is the Camel style."
    },
    {
      "key":"CAMEL-13759",
      "title":"camel3 - Remove poor mans debugger",
      "description":"We have an old debugger implementation that just have callbacks before|after a processor in the routes which you can then from camel-test override the before\/after methods to have debugging in the editor.\r\n\r\nWe should remove this as its using the intercept strategy which is intended not to be so much in use. So lets cleanup a bit of cruft. There is already the newer backlog debugger that hawtio and other tools uses for debugging.",
      "assignee":"davsclaus",
      "type":"Improvement",
      "priority":"Major",
      "status":"Resolved",
      "text":"camel3 - Remove poor mans debugger We have an old debugger implementation that just have callbacks before|after a processor in the routes which you can then from camel-test override the before\/after methods to have debugging in the editor.\r\n\r\nWe should remove this as its using the intercept strategy which is intended not to be so much in use. So lets cleanup a bit of cruft. There is already the newer backlog debugger that hawtio and other tools uses for debugging."
    },
    {
      "key":"CAMEL-13758",
      "title":"Unable to parse $simple{}, when you have prefixToken=\"${\" suffixToken=\"}\" in the propertyPlaceholder",
      "description":"Unable to parse $simple{}, when you have prefixToken={color:#14892c}\"$\\{\"{color} suffixToken={color:#14892c}\"}{color}\" in the propertyPlaceholder.\r\n\r\nFor example -\r\n\r\n{{<camelContext xmlns=\"http:\/\/camel.apache.org\/schema\/spring\"> <propertyPlaceholder id=\"ignoreId\" location=\"classpath:props.properties\" prefixToken=\"${\" suffixToken=\"}\"\/> <route id=\"sendNotification\"> <from uri=\"jms:queue:queue.sendNotification\"\/> <to uri=\"file:${OnDemand.output.url}?fileName=L2W.$simple\\{in.header.accountNum}-${date:now:yyyyMMddHHmmssSSS}.csv\"\/> <\/route> <\/camelContext>}}\r\n\r\n\u00a0\r\n\r\nIn the above route\u00a0${OnDemand.output.url}\u00a0{color:#333333}is a Spring property placeholders and\u00a0$simple\\{in.header.accountNum}{color} is a camel property placeholder.\r\n\r\n{{{color:#205081}Note:- This route configuration used to work till Camel 2.12{color}}}\r\n\r\n{{According to\u00a0[https:\/\/github.com\/apache\/camel\/blob\/master\/docs\/user-manual\/modules\/ROOT\/pages\/using-propertyplaceholder.adoc]-\u00a0one should be able to refer to Camel's properties using\u00a0$simple\\{...}\u00a0like this:}}\r\n\r\n\u00a0\r\n\r\n{{<setHeader headerName=\"Exchange.FILE_NAME\"> <simple>{{file.rootdir}}{{\/$simple\\{in.header.CamelFileName}<\/simple <\/setHeader>}}\r\n\r\n\u00a0\r\n\r\n{{Replication - camel-test.zip attached. Main class -\u00a0CamelHelloWorldSpringExample.java}}",
      "assignee":"davsclaus",
      "type":"Bug",
      "priority":"Minor",
      "status":"Resolved",
      "text":"Unable to parse $simple{}, when you have prefixToken=\"${\" suffixToken=\"}\" in the propertyPlaceholder Unable to parse $simple{}, when you have prefixToken={color:#14892c}\"$\\{\"{color} suffixToken={color:#14892c}\"}{color}\" in the propertyPlaceholder.\r\n\r\nFor example -\r\n\r\n{{<camelContext xmlns=\"http:\/\/camel.apache.org\/schema\/spring\"> <propertyPlaceholder id=\"ignoreId\" location=\"classpath:props.properties\" prefixToken=\"${\" suffixToken=\"}\"\/> <route id=\"sendNotification\"> <from uri=\"jms:queue:queue.sendNotification\"\/> <to uri=\"file:${OnDemand.output.url}?fileName=L2W.$simple\\{in.header.accountNum}-${date:now:yyyyMMddHHmmssSSS}.csv\"\/> <\/route> <\/camelContext>}}\r\n\r\n \r\n\r\nIn the above route ${OnDemand.output.url} {color:#333333}is a Spring property placeholders and $simple\\{in.header.accountNum}{color} is a camel property placeholder.\r\n\r\n{{{color:#205081}Note:- This route configuration used to work till Camel 2.12{color}}}\r\n\r\n{{According to [https:\/\/github.com\/apache\/camel\/blob\/master\/docs\/user-manual\/modules\/ROOT\/pages\/using-propertyplaceholder.adoc]- one should be able to refer to Camel's properties using $simple\\{...} like this:}}\r\n\r\n \r\n\r\n{{<setHeader headerName=\"Exchange.FILE_NAME\"> <simple>{{file.rootdir}}{{\/$simple\\{in.header.CamelFileName}<\/simple <\/setHeader>}}\r\n\r\n \r\n\r\n{{Replication - camel-test.zip attached. Main class - CamelHelloWorldSpringExample.java}}"
    },
    {
      "key":"CAMEL-13740",
      "title":"Document for XStream JSON not proper",
      "description":"The document of Json Xtream [https:\/\/github.com\/apache\/camel\/blob\/master\/components\/camel-xstream\/src\/main\/docs\/json-xstream-dataformat.adoc] is exactly identical to Xstream [https:\/\/github.com\/apache\/camel\/blob\/master\/components\/camel-xstream\/src\/main\/docs\/xstream-dataformat.adoc.]\r\n\r\n\u00a0\r\n\r\nAlthough both uses same component, but JSON xtream document should have document on how to convert JSON to object and vis versa. But it also talks about XML. This needs to be improved.",
      "assignee":"davsclaus",
      "type":"Improvement",
      "priority":"Minor",
      "status":"Resolved",
      "text":"Document for XStream JSON not proper The document of Json Xtream [https:\/\/github.com\/apache\/camel\/blob\/master\/components\/camel-xstream\/src\/main\/docs\/json-xstream-dataformat.adoc] is exactly identical to Xstream [https:\/\/github.com\/apache\/camel\/blob\/master\/components\/camel-xstream\/src\/main\/docs\/xstream-dataformat.adoc.]\r\n\r\n \r\n\r\nAlthough both uses same component, but JSON xtream document should have document on how to convert JSON to object and vis versa. But it also talks about XML. This needs to be improved."
    },
    {
      "key":"CAMEL-13738",
      "title":"parent\/pom.xml - use dash in version properties",
      "description":"We should only use dashes in the names, eg \r\n\r\n        <javax.el-api-version>2.2.5<\/javax.el-api-version>\r\n        <javax.el-version>2.2.5<\/javax.el-version>\r\n        <javax.el3-version>3.0.0<\/javax.el3-version>\r\n        <javax.el-api-hibernate-validator-version>3.0.1-b04<\/javax.el-api-hibernate-validator-version>\r\n        <javax.el-hibernate-validator-version>3.0.1-b10<\/javax.el-hibernate-validator-version>\r\n\r\n\r\nShould be\r\n\r\njavax-el-version and so forth. Also check if all of them are still in use?\r\n\r\n\r\nContributions is welcome",
      "assignee":"davsclaus",
      "type":"Task",
      "priority":"Minor",
      "status":"Resolved",
      "text":"parent\/pom.xml - use dash in version properties We should only use dashes in the names, eg \r\n\r\n        <javax.el-api-version>2.2.5<\/javax.el-api-version>\r\n        <javax.el-version>2.2.5<\/javax.el-version>\r\n        <javax.el3-version>3.0.0<\/javax.el3-version>\r\n        <javax.el-api-hibernate-validator-version>3.0.1-b04<\/javax.el-api-hibernate-validator-version>\r\n        <javax.el-hibernate-validator-version>3.0.1-b10<\/javax.el-hibernate-validator-version>\r\n\r\n\r\nShould be\r\n\r\njavax-el-version and so forth. Also check if all of them are still in use?\r\n\r\n\r\nContributions is welcome"
    },
    {
      "key":"CAMEL-13736",
      "title":"Camel main - Support bean post processing on @BindToRegistry",
      "description":"When creating a new bean such as\r\n\r\n@BindToRegistry\r\npublic MyBean myBean() {\r\n  return new MyBean();\r\n}\r\n\r\nWe can have a way to support bean post processing so we can do ioc injection on the created bean.\r\n\r\nThere can maybe be an option on camel main you can turn on | off. \r\n\r\nAlso we can support this for fields only, if you dont need to do any customization\r\n\r\n@BindToRegistry\r\nprivate MyBean myBean\r\n",
      "assignee":"davsclaus",
      "type":"Improvement",
      "priority":"Major",
      "status":"Resolved",
      "text":"Camel main - Support bean post processing on @BindToRegistry When creating a new bean such as\r\n\r\n@BindToRegistry\r\npublic MyBean myBean() {\r\n  return new MyBean();\r\n}\r\n\r\nWe can have a way to support bean post processing so we can do ioc injection on the created bean.\r\n\r\nThere can maybe be an option on camel main you can turn on | off. \r\n\r\nAlso we can support this for fields only, if you dont need to do any customization\r\n\r\n@BindToRegistry\r\nprivate MyBean myBean\r\n"
    },
    {
      "key":"CAMEL-13732",
      "title":"Converting to boolean should always be strict",
      "description":"When converting to boolean (primitive) we should be strict and only allow this for a set of known types and values.",
      "assignee":"davsclaus",
      "type":"Improvement",
      "priority":"Major",
      "status":"Resolved",
      "text":"Converting to boolean should always be strict When converting to boolean (primitive) we should be strict and only allow this for a set of known types and values."
    },
    {
      "key":"CAMEL-13730",
      "title":"NotifyBuilder MockComponent methods are deprecated and there is no replacement",
      "description":"Several methods of the\u00a0NotifyBuilder that receive MockComponent as a parameter are deprecated and are going to be removed from version 3+, but there is no viable replacement at the moment.\r\n\r\nFrom related email conversation ([http:\/\/mail-archives.apache.org\/mod_mbox\/camel-users\/201907.mbox\/%3CMWHPR11MB138984E7FFB0DA82C043F4F395FA0%40MWHPR11MB1389.namprd11.prod.outlook.com%3E]):\r\n\r\nClaus>\u00a0Well we can take a look at adding some kind of SPI interface that advice with can use and then mock implement that.\r\n\r\nAnd then potentially other components can be used too (in theory).",
      "assignee":"davsclaus",
      "type":"Task",
      "priority":"Major",
      "status":"Resolved",
      "text":"NotifyBuilder MockComponent methods are deprecated and there is no replacement Several methods of the NotifyBuilder that receive MockComponent as a parameter are deprecated and are going to be removed from version 3+, but there is no viable replacement at the moment.\r\n\r\nFrom related email conversation ([http:\/\/mail-archives.apache.org\/mod_mbox\/camel-users\/201907.mbox\/%3CMWHPR11MB138984E7FFB0DA82C043F4F395FA0%40MWHPR11MB1389.namprd11.prod.outlook.com%3E]):\r\n\r\nClaus> Well we can take a look at adding some kind of SPI interface that advice with can use and then mock implement that.\r\n\r\nAnd then potentially other components can be used too (in theory)."
    },
    {
      "key":"CAMEL-13727",
      "title":"Endpoint DSL - Do not generate path parameters as they cannot be set individually",
      "description":"For example\r\n\r\nbean(\"\").beanName(\"myBean\")\r\n\r\nis not working, you should do\r\n\r\nbean(\"myBean\");\r\n\r\nFor the former to work we need to allow to do\r\n\r\nbean().beanName()...\r\n\r\nAnd have the endpoint DSL know its a path parameter and built the uri correctly which is hard as this requires camel-catalog to build the uri as it knows all the complexity of building with path parameters. ",
      "assignee":"davsclaus",
      "type":"Improvement",
      "priority":"Major",
      "status":"Resolved",
      "text":"Endpoint DSL - Do not generate path parameters as they cannot be set individually For example\r\n\r\nbean(\"\").beanName(\"myBean\")\r\n\r\nis not working, you should do\r\n\r\nbean(\"myBean\");\r\n\r\nFor the former to work we need to allow to do\r\n\r\nbean().beanName()...\r\n\r\nAnd have the endpoint DSL know its a path parameter and built the uri correctly which is hard as this requires camel-catalog to build the uri as it knows all the complexity of building with path parameters. "
    },
    {
      "key":"CAMEL-13725",
      "title":"Endpoint DSL - Add to javadoc if an option is required",
      "description":"When an option has required=true in the metadata we should add that to the endpoint DSL javadoc, eg\r\n\r\n{code}\r\n        \/**\r\n         * Whether the topic is persistent or non-persistent.\r\n         * The option is a <code>java.lang.String<\/code> type.\r\n         * @group common\r\n         *\/\r\n        default PulsarEndpointConsumerBuilder persistence(String persistence) {\r\n            setProperty(\"persistence\", persistence);\r\n            return this;\r\n        }\r\n{code}\r\n\r\nThis option is required. Also not sure if @group is a valid javadoc syntax\r\n",
      "assignee":"davsclaus",
      "type":"Improvement",
      "priority":"Major",
      "status":"Resolved",
      "text":"Endpoint DSL - Add to javadoc if an option is required When an option has required=true in the metadata we should add that to the endpoint DSL javadoc, eg\r\n\r\n{code}\r\n        \/**\r\n         * Whether the topic is persistent or non-persistent.\r\n         * The option is a <code>java.lang.String<\/code> type.\r\n         * @group common\r\n         *\/\r\n        default PulsarEndpointConsumerBuilder persistence(String persistence) {\r\n            setProperty(\"persistence\", persistence);\r\n            return this;\r\n        }\r\n{code}\r\n\r\nThis option is required. Also not sure if @group is a valid javadoc syntax\r\n"
    },
    {
      "key":"CAMEL-13721",
      "title":"Properties component - Make it simpler by removing not often used stuff",
      "description":"We can remove the properties component that is using uris, eg\r\n\r\nproperties:myKey\r\n\r\nWhich would create an endpoint with myKey as the url (eg delegate). But you can do that today with {{myKey}}.\r\n\r\nAlso we can remove the support for using location paths that has not been pre-configured, as that makes it more complex in terms of init logic. As we want to be able to optimize for property placeholders during build time and whatnot",
      "assignee":"davsclaus",
      "type":"Improvement",
      "priority":"Major",
      "status":"Resolved",
      "text":"Properties component - Make it simpler by removing not often used stuff We can remove the properties component that is using uris, eg\r\n\r\nproperties:myKey\r\n\r\nWhich would create an endpoint with myKey as the url (eg delegate). But you can do that today with {{myKey}}.\r\n\r\nAlso we can remove the support for using location paths that has not been pre-configured, as that makes it more complex in terms of init logic. As we want to be able to optimize for property placeholders during build time and whatnot"
    },
    {
      "key":"CAMEL-13720",
      "title":"Properties component - Remove complexity of augemented properties parser",
      "description":"The need for CAMEL-4520 is not needed and makes the logic too complex. Lets remove this stuff and just use the simpler parser",
      "assignee":"davsclaus",
      "type":"Improvement",
      "priority":"Major",
      "status":"Resolved",
      "text":"Properties component - Remove complexity of augemented properties parser The need for CAMEL-4520 is not needed and makes the logic too complex. Lets remove this stuff and just use the simpler parser"
    },
    {
      "key":"CAMEL-13718",
      "title":"Fix syntax for pulsar component",
      "description":"Replace\r\n\r\n\u00a0\r\n{noformat}\r\npulsar:persistence:\/\/tenant\/namespace\/topic{noformat}\r\n\u00a0\r\n\r\nwith\r\n{noformat}\r\npulsar:configuration{noformat}\r\nor\r\n{noformat}\r\npulsar:uri{noformat}\r\n\u00a0\r\n\r\nThere is currently only a single property of kind \"path\" for this component which is called \"topic\". The description of that parameter suggests that is should hold type, tenant and topic values for the endpoint which makes the name \"topic\" for this parameter a bad choice. I would rather suggest to rename it to something more fitting like \"configuration\" or \"uri\" instead.\r\n\r\n\u00a0",
      "assignee":"davsclaus",
      "type":"Bug",
      "priority":"Major",
      "status":"Resolved",
      "text":"Fix syntax for pulsar component Replace\r\n\r\n \r\n{noformat}\r\npulsar:persistence:\/\/tenant\/namespace\/topic{noformat}\r\n \r\n\r\nwith\r\n{noformat}\r\npulsar:configuration{noformat}\r\nor\r\n{noformat}\r\npulsar:uri{noformat}\r\n \r\n\r\nThere is currently only a single property of kind \"path\" for this component which is called \"topic\". The description of that parameter suggests that is should hold type, tenant and topic values for the endpoint which makes the name \"topic\" for this parameter a bad choice. I would rather suggest to rename it to something more fitting like \"configuration\" or \"uri\" instead.\r\n\r\n "
    },
    {
      "key":"CAMEL-13712",
      "title":"If a javax.mail.Session gets referred to using the \"session\" URL parameter, Apache Camel Mail ignored its hostnames.",
      "description":"{color:#658aba}A javax.mail.Session injected using JNDI can refer to one host per protocol. Referring to such a session using the URL query string parameter session=#jndiName seems to ignore the hosts the session is bound to:{color}\r\n\r\n{color:#658aba}My first try was simply e.g. \"smtp:\/\/?session=#jndiName\". Now Apache Camel Mail complains about a missing hostname.{color}\r\n\r\n{color:#658aba}So I tried \"smtp:\/\/localhost?session=#jndiName\" expecting that \"localhost\" would have been overridden using the SMTP host the session refers to, which is not the case. Camel complains that no SMTP server was listening on the host named \"localhost\".{color}\r\n\r\n{color:#658aba}The workaround that works \u2013 but is somehow redundant in my opinion \u2013 is:{color}\r\n\r\n{{{color:#3381ff}@Resource{color}(mappedName = {color:#658aba}\"jndiName\"{color})}}\r\n {{ {color:#000080}private {color}Session {color:#1948a6}mySession{color};}}\r\n\r\n{{{color:#658aba}...to(\"smtp:\/\/\"+{color}{color:#1948a6}mySession{color}.getProperty({color:#658aba}\"mail.smtp.host\"{color})+\"{color:#658aba}?session=#jndiName\")...{color}}}\r\n\r\n{color:#658aba}The same also applies to the IMAP server (and likely to the other protocols supported by Java Mail as well).{color}\r\n\r\n{color:#658aba}It would be nice iff referring to a JNDI injected session would take the session as-is to simplify the URL.{color}\r\n\r\n{color:#658aba}I found an example for using the \"session\" parameter: \"MailUsingCustomSessionTest\". It would be helpful to have another example at hand that either takes the hostname from the session as my example above or that does not contain a hostname at all, given, Apache Camel Mail will support that in the future.{color}",
      "assignee":"davsclaus",
      "type":"Improvement",
      "priority":"Minor",
      "status":"Resolved",
      "text":"If a javax.mail.Session gets referred to using the \"session\" URL parameter, Apache Camel Mail ignored its hostnames. {color:#658aba}A javax.mail.Session injected using JNDI can refer to one host per protocol. Referring to such a session using the URL query string parameter session=#jndiName seems to ignore the hosts the session is bound to:{color}\r\n\r\n{color:#658aba}My first try was simply e.g. \"smtp:\/\/?session=#jndiName\". Now Apache Camel Mail complains about a missing hostname.{color}\r\n\r\n{color:#658aba}So I tried \"smtp:\/\/localhost?session=#jndiName\" expecting that \"localhost\" would have been overridden using the SMTP host the session refers to, which is not the case. Camel complains that no SMTP server was listening on the host named \"localhost\".{color}\r\n\r\n{color:#658aba}The workaround that works - but is somehow redundant in my opinion - is:{color}\r\n\r\n{{{color:#3381ff}@Resource{color}(mappedName = {color:#658aba}\"jndiName\"{color})}}\r\n {{ {color:#000080}private {color}Session {color:#1948a6}mySession{color};}}\r\n\r\n{{{color:#658aba}...to(\"smtp:\/\/\"+{color}{color:#1948a6}mySession{color}.getProperty({color:#658aba}\"mail.smtp.host\"{color})+\"{color:#658aba}?session=#jndiName\")...{color}}}\r\n\r\n{color:#658aba}The same also applies to the IMAP server (and likely to the other protocols supported by Java Mail as well).{color}\r\n\r\n{color:#658aba}It would be nice iff referring to a JNDI injected session would take the session as-is to simplify the URL.{color}\r\n\r\n{color:#658aba}I found an example for using the \"session\" parameter: \"MailUsingCustomSessionTest\". It would be helpful to have another example at hand that either takes the hostname from the session as my example above or that does not contain a hostname at all, given, Apache Camel Mail will support that in the future.{color}"
    },
    {
      "key":"CAMEL-13709",
      "title":"Properties component - Optimise to not call loadProperties to frequently",
      "description":"The camel-properties calls loadProperties to load all the properties. But it tend to do this for each parseUri for custom PropertiesSource and other means which can be optimised.\r\n\r\nThe cache is based on properties location only.",
      "assignee":"davsclaus",
      "type":"Improvement",
      "priority":"Major",
      "status":"Resolved",
      "text":"Properties component - Optimise to not call loadProperties to frequently The camel-properties calls loadProperties to load all the properties. But it tend to do this for each parseUri for custom PropertiesSource and other means which can be optimised.\r\n\r\nThe cache is based on properties location only."
    },
    {
      "key":"CAMEL-13708",
      "title":"PropertiesSource to resolve a single property",
      "description":"CAMEL-13705 introduces support for property sources such as MP Config and others and at the moment it does require to load all the properties upfront on source initialization.\r\n\r\nIt would be nice to have an additional method to resolve a single property as some back-and may perform some I\/O to resolve properties and get alll of them could be expensive.\r\n\r\nSo the properties component should:\r\n\r\n- leverage PropertiesSource::loadPropertiers() when is is required to know all the properties (i.e. when auto configure components in camel main)\r\n- leverage a new PropertiesSource::resolveProperty(String) when it just need to resolve a single property\r\n",
      "assignee":"davsclaus",
      "type":"Improvement",
      "priority":"Minor",
      "status":"Resolved",
      "text":"PropertiesSource to resolve a single property CAMEL-13705 introduces support for property sources such as MP Config and others and at the moment it does require to load all the properties upfront on source initialization.\r\n\r\nIt would be nice to have an additional method to resolve a single property as some back-and may perform some I\/O to resolve properties and get alll of them could be expensive.\r\n\r\nSo the properties component should:\r\n\r\n- leverage PropertiesSource::loadPropertiers() when is is required to know all the properties (i.e. when auto configure components in camel main)\r\n- leverage a new PropertiesSource::resolveProperty(String) when it just need to resolve a single property\r\n"
    },
    {
      "key":"CAMEL-13705",
      "title":"Properties component should work with Eclipse MicroProfile Config",
      "description":"We should integrate with MP Config so you can build MP apps and have Camel's properties component use their properties.\r\n\r\nWe should allow to auto-detect this if eg a camel-microprofile-config is on the classpath and then setup this bridge automatic.\r\n\r\n",
      "assignee":"davsclaus",
      "type":"New Feature",
      "priority":"Major",
      "status":"Resolved",
      "text":"Properties component should work with Eclipse MicroProfile Config We should integrate with MP Config so you can build MP apps and have Camel's properties component use their properties.\r\n\r\nWe should allow to auto-detect this if eg a camel-microprofile-config is on the classpath and then setup this bridge automatic.\r\n\r\n"
    },
    {
      "key":"CAMEL-13702",
      "title":"camel-main-maven-plugin - Only download sources JAR if really neesed",
      "description":"We can improve the logic to detect if there are new components and then only if so, download sources jar if needed for options that need documentation.",
      "assignee":"davsclaus",
      "type":"Improvement",
      "priority":"Major",
      "status":"Resolved",
      "text":"camel-main-maven-plugin - Only download sources JAR if really neesed We can improve the logic to detect if there are new components and then only if so, download sources jar if needed for options that need documentation."
    },
    {
      "key":"CAMEL-13697",
      "title":"URISupport - Mask accessToken and clientSecret in uri logging",
      "description":"We should also mask accessToken and clientSecret in uri outputs as they are sensitive data.",
      "assignee":"davsclaus",
      "type":"Improvement",
      "priority":"Major",
      "status":"Resolved",
      "text":"URISupport - Mask accessToken and clientSecret in uri logging We should also mask accessToken and clientSecret in uri outputs as they are sensitive data."
    },
    {
      "key":"CAMEL-13695",
      "title":"camel-core - Injector allow to create beans via static factory methods",
      "description":"We should support creating beans via static factory methods that they sometime have instead of constructors, such as\r\n\r\ncamel.component.quartz2.scheduler-factory=#class:org.quartz.impl.DirectSchedulerFactory#getInstance\r\n\r\n",
      "assignee":"davsclaus",
      "type":"Improvement",
      "priority":"Major",
      "status":"Resolved",
      "text":"camel-core - Injector allow to create beans via static factory methods We should support creating beans via static factory methods that they sometime have instead of constructors, such as\r\n\r\ncamel.component.quartz2.scheduler-factory=#class:org.quartz.impl.DirectSchedulerFactory#getInstance\r\n\r\n"
    },
    {
      "key":"CAMEL-13694",
      "title":"Easier way to extend PropertiesComponent",
      "description":"The current implementation of the PropertiesComponent is very oriented to paths and location and it is not very easy to provide alternative back-ends i.e MP Config or HashiCorp Vault.\r\n\r\nWe may need to re-think the PropertiesComponent interface and reason in term of ordered \"property sources\", like:\r\n\r\n{code}\r\nProertiesComponent cp = new ProertiesComponent()\r\ncp.addSource(new ValutPropertiesSource())\r\ncp.addSource(new PathPropertiesSource())\r\ncp.addSource(PropertiesSource.wrap(properties))\r\n...\r\n{code}\r\n\r\n\r\n",
      "assignee":"davsclaus",
      "type":"Improvement",
      "priority":"Minor",
      "status":"Resolved",
      "text":"Easier way to extend PropertiesComponent The current implementation of the PropertiesComponent is very oriented to paths and location and it is not very easy to provide alternative back-ends i.e MP Config or HashiCorp Vault.\r\n\r\nWe may need to re-think the PropertiesComponent interface and reason in term of ordered \"property sources\", like:\r\n\r\n{code}\r\nProertiesComponent cp = new ProertiesComponent()\r\ncp.addSource(new ValutPropertiesSource())\r\ncp.addSource(new PathPropertiesSource())\r\ncp.addSource(PropertiesSource.wrap(properties))\r\n...\r\n{code}\r\n\r\n\r\n"
    },
    {
      "key":"CAMEL-13690",
      "title":"camel-main - Add option to ignore unknown options",
      "description":"For example if you have OS ENV variables set that will not be in use because a component is not being used or something. \r\n",
      "assignee":"davsclaus",
      "type":"Improvement",
      "priority":"Major",
      "status":"Resolved",
      "text":"camel-main - Add option to ignore unknown options For example if you have OS ENV variables set that will not be in use because a component is not being used or something. \r\n"
    },
    {
      "key":"CAMEL-13688",
      "title":"Camel main - Setting boolean option should have strict conversition",
      "description":"If you set an option like\r\n\r\ncamel.main.allow-use-original-message=123\r\n\r\nThen its set as false, because we do a Boolean.valueOf convertion which just checks if its \"true\" or not. Instead we should only allow string values of \"true\" or \"false\" otherwise its a invalid value.",
      "assignee":"davsclaus",
      "type":"Improvement",
      "priority":"Major",
      "status":"Resolved",
      "text":"Camel main - Setting boolean option should have strict conversition If you set an option like\r\n\r\ncamel.main.allow-use-original-message=123\r\n\r\nThen its set as false, because we do a Boolean.valueOf convertion which just checks if its \"true\" or not. Instead we should only allow string values of \"true\" or \"false\" otherwise its a invalid value."
    },
    {
      "key":"CAMEL-13687",
      "title":"NotifyBuilder not working as expected",
      "description":"am trying to test an error handling route. The {{NotificationBuilder}} does not work as expected (it always returns false).\r\n\r\nCreated a main route and a test route to test the main route. I used Spring Boot - all other tests work fine, so there is no problem with the setup I guess.\r\n\r\n\u00a0\r\n\r\nI have attached the sample project. Please uncomment the @Ignore method to test the method. Please read the README.md attached in the project",
      "assignee":"davsclaus",
      "type":"Bug",
      "priority":"Major",
      "status":"Resolved",
      "text":"NotifyBuilder not working as expected am trying to test an error handling route. The {{NotificationBuilder}} does not work as expected (it always returns false).\r\n\r\nCreated a main route and a test route to test the main route. I used Spring Boot - all other tests work fine, so there is no problem with the setup I guess.\r\n\r\n \r\n\r\nI have attached the sample project. Please uncomment the @Ignore method to test the method. Please read the README.md attached in the project"
    },
    {
      "key":"CAMEL-13686",
      "title":"camel-main - Add option for verbose logging of configuration",
      "description":"So end users can just set an option\r\n\r\ncamel.main.configuration-logging=true\r\n\r\nOr something like that to get verbose INFO logging of how all these configurations are computed so you can use that to track if something seems not correct.",
      "assignee":"davsclaus",
      "type":"Improvement",
      "priority":"Major",
      "status":"Resolved",
      "text":"camel-main - Add option for verbose logging of configuration So end users can just set an option\r\n\r\ncamel.main.configuration-logging=true\r\n\r\nOr something like that to get verbose INFO logging of how all these configurations are computed so you can use that to track if something seems not correct."
    },
    {
      "key":"CAMEL-13685",
      "title":"camel-rabbitmq  Thread name for route set to endpoint uri",
      "description":"change thread name of rabbitmq routes from \"RabbitMQConsumer\" to\u00a0 its endpoint uri",
      "assignee":"davsclaus",
      "type":"Improvement",
      "priority":"Minor",
      "status":"Resolved",
      "text":"camel-rabbitmq  Thread name for route set to endpoint uri change thread name of rabbitmq routes from \"RabbitMQConsumer\" to  its endpoint uri"
    },
    {
      "key":"CAMEL-13683",
      "title":"camel-main - configuring properties report better error if missing JARs on classpath",
      "description":"Look into if we are not reporting a good error if you configure an option for a component that is not on the classpath etc.",
      "assignee":"davsclaus",
      "type":"Improvement",
      "priority":"Major",
      "status":"Resolved",
      "text":"camel-main - configuring properties report better error if missing JARs on classpath Look into if we are not reporting a good error if you configure an option for a component that is not on the classpath etc."
    },
    {
      "key":"CAMEL-13681",
      "title":"camel-main - Allow ENV variables to configure any option",
      "description":"Any of the options you can configure via application.properties such as:\r\ncamel.main.name\r\ncamel.component.xxx=yyy\r\n\r\nAnd so on should be configurable via ENV variables which will override any existing configuration. This is good practice in containers and also how SB can do etc.\r\n\r\n",
      "assignee":"davsclaus",
      "type":"New Feature",
      "priority":"Major",
      "status":"Resolved",
      "text":"camel-main - Allow ENV variables to configure any option Any of the options you can configure via application.properties such as:\r\ncamel.main.name\r\ncamel.component.xxx=yyy\r\n\r\nAnd so on should be configurable via ENV variables which will override any existing configuration. This is good practice in containers and also how SB can do etc.\r\n\r\n"
    },
    {
      "key":"CAMEL-13680",
      "title":"camel-file - From file to file with readLock=fileLock dont work on windows",
      "description":"You can get errors like\r\n{code}\r\nStacktrace\r\n---------------------------------------------------------------------------------------------------------------------------------------\r\norg.apache.camel.component.file.GenericFileOperationFailedException: Cannot store file: work\\cbr\\output\\ID-WIN-JTA8KU4EF9D-1561426618994-0-2\r\n\tat org.apache.camel.component.file.FileOperations.storeFile(FileOperations.java:352)\r\n\tat org.apache.camel.component.file.GenericFileProducer.writeFile(GenericFileProducer.java:305)\r\n\tat org.apache.camel.component.file.GenericFileProducer.processExchange(GenericFileProducer.java:169)\r\n\tat org.apache.camel.component.file.GenericFileProducer.process(GenericFileProducer.java:80)\r\n\tat org.apache.camel.util.AsyncProcessorConverterHelper$ProcessorToAsyncProcessorBridge.process(AsyncProcessorConverterHelper.java:61)\r\n\tat org.apache.camel.processor.SendProcessor.process(SendProcessor.java:148)\r\n\tat org.apache.camel.processor.RedeliveryErrorHandler.process(RedeliveryErrorHandler.java:548)\r\n\tat org.apache.camel.processor.CamelInternalProcessor.process(CamelInternalProcessor.java:201)\r\n\tat org.apache.camel.processor.Pipeline.process(Pipeline.java:138)\r\n\tat org.apache.camel.processor.Pipeline.process(Pipeline.java:101)\r\n\tat org.apache.camel.processor.CamelInternalProcessor.process(CamelInternalProcessor.java:201)\r\n\tat org.apache.camel.component.file.GenericFileConsumer.processExchange(GenericFileConsumer.java:452)\r\n\tat org.apache.camel.component.file.GenericFileConsumer.processBatch(GenericFileConsumer.java:219)\r\n\tat org.apache.camel.component.file.GenericFileConsumer.poll(GenericFileConsumer.java:183)\r\n\tat org.apache.camel.impl.ScheduledPollConsumer.doRun(ScheduledPollConsumer.java:174)\r\n\tat org.apache.camel.impl.ScheduledPollConsumer.run(ScheduledPollConsumer.java:101)\r\n\tat java.util.concurrent.Executors$RunnableAdapter.call(Unknown Source)\r\n\tat java.util.concurrent.FutureTask.runAndReset(Unknown Source)\r\n\tat java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.access$301(Unknown Source)\r\n\tat java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(Unknown Source)\r\n\tat java.util.concurrent.ThreadPoolExecutor.runWorker(Unknown Source)\r\n\tat java.util.concurrent.ThreadPoolExecutor$Worker.run(Unknown Source)\r\n\tat java.lang.Thread.run(Unknown Source)\r\nCaused by: java.nio.file.FileSystemException: work\\cbr\\input\\ID-WIN-JTA8KU4EF9D-1561426618994-0-2 -> work\\cbr\\output\\ID-WIN-JTA8KU4EF9D-1561426618994-0-2: The process cannot access the file because it is being used by another process\r\n\tat sun.nio.fs.WindowsException.translateToIOException(Unknown Source)\r\n\tat sun.nio.fs.WindowsException.rethrowAsIOException(Unknown Source)\r\n\tat sun.nio.fs.WindowsFileCopy.copy(Unknown Source)\r\n\tat sun.nio.fs.WindowsFileSystemProvider.copy(Unknown Source)\r\n\tat java.nio.file.Files.copy(Unknown Source)\r\n{code}",
      "assignee":"davsclaus",
      "type":"Bug",
      "priority":"Minor",
      "status":"Resolved",
      "text":"camel-file - From file to file with readLock=fileLock dont work on windows You can get errors like\r\n{code}\r\nStacktrace\r\n---------------------------------------------------------------------------------------------------------------------------------------\r\norg.apache.camel.component.file.GenericFileOperationFailedException: Cannot store file: work\\cbr\\output\\ID-WIN-JTA8KU4EF9D-1561426618994-0-2\r\n\tat org.apache.camel.component.file.FileOperations.storeFile(FileOperations.java:352)\r\n\tat org.apache.camel.component.file.GenericFileProducer.writeFile(GenericFileProducer.java:305)\r\n\tat org.apache.camel.component.file.GenericFileProducer.processExchange(GenericFileProducer.java:169)\r\n\tat org.apache.camel.component.file.GenericFileProducer.process(GenericFileProducer.java:80)\r\n\tat org.apache.camel.util.AsyncProcessorConverterHelper$ProcessorToAsyncProcessorBridge.process(AsyncProcessorConverterHelper.java:61)\r\n\tat org.apache.camel.processor.SendProcessor.process(SendProcessor.java:148)\r\n\tat org.apache.camel.processor.RedeliveryErrorHandler.process(RedeliveryErrorHandler.java:548)\r\n\tat org.apache.camel.processor.CamelInternalProcessor.process(CamelInternalProcessor.java:201)\r\n\tat org.apache.camel.processor.Pipeline.process(Pipeline.java:138)\r\n\tat org.apache.camel.processor.Pipeline.process(Pipeline.java:101)\r\n\tat org.apache.camel.processor.CamelInternalProcessor.process(CamelInternalProcessor.java:201)\r\n\tat org.apache.camel.component.file.GenericFileConsumer.processExchange(GenericFileConsumer.java:452)\r\n\tat org.apache.camel.component.file.GenericFileConsumer.processBatch(GenericFileConsumer.java:219)\r\n\tat org.apache.camel.component.file.GenericFileConsumer.poll(GenericFileConsumer.java:183)\r\n\tat org.apache.camel.impl.ScheduledPollConsumer.doRun(ScheduledPollConsumer.java:174)\r\n\tat org.apache.camel.impl.ScheduledPollConsumer.run(ScheduledPollConsumer.java:101)\r\n\tat java.util.concurrent.Executors$RunnableAdapter.call(Unknown Source)\r\n\tat java.util.concurrent.FutureTask.runAndReset(Unknown Source)\r\n\tat java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.access$301(Unknown Source)\r\n\tat java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(Unknown Source)\r\n\tat java.util.concurrent.ThreadPoolExecutor.runWorker(Unknown Source)\r\n\tat java.util.concurrent.ThreadPoolExecutor$Worker.run(Unknown Source)\r\n\tat java.lang.Thread.run(Unknown Source)\r\nCaused by: java.nio.file.FileSystemException: work\\cbr\\input\\ID-WIN-JTA8KU4EF9D-1561426618994-0-2 -> work\\cbr\\output\\ID-WIN-JTA8KU4EF9D-1561426618994-0-2: The process cannot access the file because it is being used by another process\r\n\tat sun.nio.fs.WindowsException.translateToIOException(Unknown Source)\r\n\tat sun.nio.fs.WindowsException.rethrowAsIOException(Unknown Source)\r\n\tat sun.nio.fs.WindowsFileCopy.copy(Unknown Source)\r\n\tat sun.nio.fs.WindowsFileSystemProvider.copy(Unknown Source)\r\n\tat java.nio.file.Files.copy(Unknown Source)\r\n{code}"
    },
    {
      "key":"CAMEL-13678",
      "title":"Attachments API on Message - Deprecate and remove",
      "description":"We should consider making the Camel Message API more simpler and remove stuff that are seldom in use, or can be component specific.\r\n\r\nThe javax.attachment is removed from JDK11 onwards and its not really much in use in the future.\r\n\r\n",
      "assignee":"davsclaus",
      "type":"Improvement",
      "priority":"Major",
      "status":"Resolved",
      "text":"Attachments API on Message - Deprecate and remove We should consider making the Camel Message API more simpler and remove stuff that are seldom in use, or can be component specific.\r\n\r\nThe javax.attachment is removed from JDK11 onwards and its not really much in use in the future.\r\n\r\n"
    },
    {
      "key":"CAMEL-13677",
      "title":"Move AttachmentConverterLoader out of camel-core",
      "description":"The javax.attachments API are not standard in Java 11. We should make this converter optional from camel-core and move to somewhere else.",
      "assignee":"davsclaus",
      "type":"Improvement",
      "priority":"Major",
      "status":"Resolved",
      "text":"Move AttachmentConverterLoader out of camel-core The javax.attachments API are not standard in Java 11. We should make this converter optional from camel-core and move to somewhere else."
    },
    {
      "key":"CAMEL-13675",
      "title":"camel-main - Optimise main configurer",
      "description":"This method takes approx 60 millis on my laptop\r\norg.apache.camel.main.DefaultConfigurationConfigurer#afterPropertiesSet\r\n\r\nI suspects its all those lambda's that are loaded on classpath and only in use if there is a bean to lookup. The logic can be improved to use old fashioned code with some if != null\r\n\r\nIf I disable all of those then its down to 4 millis on my laptop",
      "assignee":"davsclaus",
      "type":"Improvement",
      "priority":"Minor",
      "status":"Resolved",
      "text":"camel-main - Optimise main configurer This method takes approx 60 millis on my laptop\r\norg.apache.camel.main.DefaultConfigurationConfigurer#afterPropertiesSet\r\n\r\nI suspects its all those lambda's that are loaded on classpath and only in use if there is a bean to lookup. The logic can be improved to use old fashioned code with some if != null\r\n\r\nIf I disable all of those then its down to 4 millis on my laptop"
    },
    {
      "key":"CAMEL-13674",
      "title":"Simple language - Body as one line",
      "description":"Add function to return the message body as a one line string. This can be useful in some situations where you want to be able to do this from logging point of view via Log EIP",
      "assignee":"davsclaus",
      "type":"New Feature",
      "priority":"Minor",
      "status":"Resolved",
      "text":"Simple language - Body as one line Add function to return the message body as a one line string. This can be useful in some situations where you want to be able to do this from logging point of view via Log EIP"
    },
    {
      "key":"CAMEL-13672",
      "title":"camel-main-maven-plugin - Add groups to tooling metadata",
      "description":"We can add groups as documented in SB metamodel\r\nhttps:\/\/docs.spring.io\/spring-boot\/docs\/current\/reference\/html\/configuration-metadata.html#configuration-metadata-format\r\n\r\nThen we can have groups for\r\n- main\r\n- per component\r\n\r\nWith a description of each group, eg the component description etc. This gives a little bit more documentation for the end users.",
      "assignee":"davsclaus",
      "type":"Improvement",
      "priority":"Major",
      "status":"Resolved",
      "text":"camel-main-maven-plugin - Add groups to tooling metadata We can add groups as documented in SB metamodel\r\nhttps:\/\/docs.spring.io\/spring-boot\/docs\/current\/reference\/html\/configuration-metadata.html#configuration-metadata-format\r\n\r\nThen we can have groups for\r\n- main\r\n- per component\r\n\r\nWith a description of each group, eg the component description etc. This gives a little bit more documentation for the end users."
    },
    {
      "key":"CAMEL-13665",
      "title":"camel3 - SPI classpath discovery - Combine into a single lookup",
      "description":"We do a bunch of SPI classpath discover for 3rd party plugins and even for components like camel-bean and whatnot. (its those resolvers).\r\n\r\nFor a quicker startup we can group these standard lookups into a single classpath scan (notice Camel only does that if you have not set an explicit SPI vis its setter).",
      "assignee":"davsclaus",
      "type":"Improvement",
      "priority":"Minor",
      "status":"Resolved",
      "text":"camel3 - SPI classpath discovery - Combine into a single lookup We do a bunch of SPI classpath discover for 3rd party plugins and even for components like camel-bean and whatnot. (its those resolvers).\r\n\r\nFor a quicker startup we can group these standard lookups into a single classpath scan (notice Camel only does that if you have not set an explicit SPI vis its setter)."
    },
    {
      "key":"CAMEL-13663",
      "title":"camel-main-maven-plugin - Generate tooling metadata",
      "description":"To assist editing Camel Main and eg application.properties then we could \"fool\" tooling by generating Spring Boot metadata json files, so tools see these files and offer their code completions.\r\n\r\nThen you can use ctrl + space for type completions when typing\r\n\r\ncamel.component.jms\r\n\r\n",
      "assignee":"davsclaus",
      "type":"New Feature",
      "priority":"Major",
      "status":"Resolved",
      "text":"camel-main-maven-plugin - Generate tooling metadata To assist editing Camel Main and eg application.properties then we could \"fool\" tooling by generating Spring Boot metadata json files, so tools see these files and offer their code completions.\r\n\r\nThen you can use ctrl + space for type completions when typing\r\n\r\ncamel.component.jms\r\n\r\n"
    },
    {
      "key":"CAMEL-13658",
      "title":"Refine ProcessorDefinition output handling",
      "description":"The ProcessDefinition class is the base class for most of the DSL \/ Definitions and defines a  number of methods related to outputs such as:\r\n\r\n{code:java}\r\npublic abstract List<ProcessorDefinition<?>> getOutputs();\r\npublic abstract boolean isOutputSupported();\r\n{code}\r\n\r\nThe information about the ability to handle outputs is thus available at runtime only which complicates the creation of alternative DSLs (i.e https:\/\/github.com\/apache\/camel-k-runtime\/issues\/80)",
      "assignee":"davsclaus",
      "type":"Improvement",
      "priority":"Minor",
      "status":"Resolved",
      "text":"Refine ProcessorDefinition output handling The ProcessDefinition class is the base class for most of the DSL \/ Definitions and defines a  number of methods related to outputs such as:\r\n\r\n{code:java}\r\npublic abstract List<ProcessorDefinition<?>> getOutputs();\r\npublic abstract boolean isOutputSupported();\r\n{code}\r\n\r\nThe information about the ability to handle outputs is thus available at runtime only which complicates the creation of alternative DSLs (i.e https:\/\/github.com\/apache\/camel-k-runtime\/issues\/80)"
    },
    {
      "key":"CAMEL-13657",
      "title":"Simpler attribute names in the XML DSL",
      "description":"Some part of the DSL expose verbose properties as example, the set header definition, has ha setHeaderName property which leads to an XML like:\r\n\r\n{code:xml}\r\n<setHeader headerName=\"Something\"\/>\r\n{code}\r\n\r\nThis is not wrong but the context gives enough information so it can be rewritten as:\r\n\r\n{code:xml}\r\n<setHeader name=\"Something\"\/>\r\n{code}\r\n\r\nWhich makes it shorter and does not impact comprehension. \r\n",
      "assignee":"davsclaus",
      "type":"Improvement",
      "priority":"Major",
      "status":"Resolved",
      "text":"Simpler attribute names in the XML DSL Some part of the DSL expose verbose properties as example, the set header definition, has ha setHeaderName property which leads to an XML like:\r\n\r\n{code:xml}\r\n<setHeader headerName=\"Something\"\/>\r\n{code}\r\n\r\nThis is not wrong but the context gives enough information so it can be rewritten as:\r\n\r\n{code:xml}\r\n<setHeader name=\"Something\"\/>\r\n{code}\r\n\r\nWhich makes it shorter and does not impact comprehension. \r\n"
    },
    {
      "key":"CAMEL-13656",
      "title":"reifiers classes should be public",
      "description":"Refiers classes are now package private that make it impossible to reuse them for example in a custom processor factory like what it is done by Hystrix: https:\/\/github.com\/apache\/camel\/blob\/master\/components\/camel-hystrix\/src\/main\/java\/org\/apache\/camel\/component\/hystrix\/processor\/HystrixProcessorFactory.java",
      "assignee":"davsclaus",
      "type":"Improvement",
      "priority":"Minor",
      "status":"Resolved",
      "text":"reifiers classes should be public Refiers classes are now package private that make it impossible to reuse them for example in a custom processor factory like what it is done by Hystrix: https:\/\/github.com\/apache\/camel\/blob\/master\/components\/camel-hystrix\/src\/main\/java\/org\/apache\/camel\/component\/hystrix\/processor\/HystrixProcessorFactory.java"
    },
    {
      "key":"CAMEL-13650",
      "title":"Properties component - loadProperties to return properties in order",
      "description":"The API\r\n\r\n    Properties loadProperties();\r\n\r\n    Properties loadProperties(String... locations);\r\n\r\nBut the Properties is a Hashtable that is unordered, but it would be better if we could get this as Map so we can use LinkedHashMap so they are in order. This would work better with the order the end users may define in their application.properties files etc\r\n\r\ncamel.component.jms.configuration.connectionFactory=#class:org.apache.activemq.artemis.jms.client.ActiveMQJMSConnectionFactory\r\ncamel.component.jms.configuration.connectionFactory.brokerUrl=localhost:61616\r\n\r\n",
      "assignee":"davsclaus",
      "type":"Improvement",
      "priority":"Major",
      "status":"Resolved",
      "text":"Properties component - loadProperties to return properties in order The API\r\n\r\n    Properties loadProperties();\r\n\r\n    Properties loadProperties(String... locations);\r\n\r\nBut the Properties is a Hashtable that is unordered, but it would be better if we could get this as Map so we can use LinkedHashMap so they are in order. This would work better with the order the end users may define in their application.properties files etc\r\n\r\ncamel.component.jms.configuration.connectionFactory=#class:org.apache.activemq.artemis.jms.client.ActiveMQJMSConnectionFactory\r\ncamel.component.jms.configuration.connectionFactory.brokerUrl=localhost:61616\r\n\r\n"
    },
    {
      "key":"CAMEL-13647",
      "title":"camel-main - Add support for auto binding to components by interface type and discover impl class on classpath",
      "description":"This can make convention over configuration nicer. For example some components requires a ConnectionFactory etc and if we can auto-discover that on the classpath there is only 1 implementation of such interface, we can try to auto create the instance and configure it on the component.\r\n\r\nThis should be an option you can turn on|off.",
      "assignee":"davsclaus",
      "type":"New Feature",
      "priority":"Major",
      "status":"Resolved",
      "text":"camel-main - Add support for auto binding to components by interface type and discover impl class on classpath This can make convention over configuration nicer. For example some components requires a ConnectionFactory etc and if we can auto-discover that on the classpath there is only 1 implementation of such interface, we can try to auto create the instance and configure it on the component.\r\n\r\nThis should be an option you can turn on|off."
    },
    {
      "key":"CAMEL-13645",
      "title":"camel-spring - NPE in NotifyBuilder during testing",
      "description":"Just noticed some NPEs while doing test of camel-spring\r\n\r\n019-06-13 15:02:08,902 WARN  EventHelper - Error notifying event ID-davsclaus-pro-local-1560430811107-235-1 exchange created: Exchange[ID-davsclaus-pro-local-1560430811107-235-1]. This exception will be ignored.  \r\njava.lang.NullPointerException: null\r\n\tat org.apache.camel.builder.NotifyBuilder$3.onExchange(NotifyBuilder.java:194) ~[camel-core-3.0.0-SNAPSHOT.jar:3.0.0-SNAPSHOT]\r\n\tat org.apache.camel.builder.NotifyBuilder$EventPredicateSupport.onExchangeCreated(NotifyBuilder.java:1293) ~[camel-core-3.0.0-SNAPSHOT.jar:3.0.0-SNAPSHOT]\r\n\tat org.apache.camel.builder.NotifyBuilder$CompoundEventPredicate.onExchangeCreated(NotifyBuilder.java:1381) ~[camel-core-3.0.0-SNAPSHOT.jar:3.0.0-SNAPSHOT]\r\n\tat org.apache.camel.builder.NotifyBuilder$ExchangeNotifier.onExchangeCreated(NotifyBuilder.java:1154) ~[camel-core-3.0.0-SNAPSHOT.jar:3.0.0-SNAPSHOT]\r\n\tat org.apache.camel.builder.NotifyBuilder$ExchangeNotifier.notify(NotifyBuilder.java:1135) ~[camel-core-3.0.0-SNAPSHOT.jar:3.0.0-SNAPSHOT]\r\n\tat org.apache.camel.support.EventHelper.doNotifyEvent(EventHelper.java:288) [camel-support-3.0.0-SNAPSHOT.jar:3.0.0-SNAPSHOT]\r\n\tat org.apache.camel.support.EventHelper.doNotify(EventHelper.java:27",
      "assignee":"davsclaus",
      "type":"Test",
      "priority":"Major",
      "status":"Resolved",
      "text":"camel-spring - NPE in NotifyBuilder during testing Just noticed some NPEs while doing test of camel-spring\r\n\r\n019-06-13 15:02:08,902 WARN  EventHelper - Error notifying event ID-davsclaus-pro-local-1560430811107-235-1 exchange created: Exchange[ID-davsclaus-pro-local-1560430811107-235-1]. This exception will be ignored.  \r\njava.lang.NullPointerException: null\r\n\tat org.apache.camel.builder.NotifyBuilder$3.onExchange(NotifyBuilder.java:194) ~[camel-core-3.0.0-SNAPSHOT.jar:3.0.0-SNAPSHOT]\r\n\tat org.apache.camel.builder.NotifyBuilder$EventPredicateSupport.onExchangeCreated(NotifyBuilder.java:1293) ~[camel-core-3.0.0-SNAPSHOT.jar:3.0.0-SNAPSHOT]\r\n\tat org.apache.camel.builder.NotifyBuilder$CompoundEventPredicate.onExchangeCreated(NotifyBuilder.java:1381) ~[camel-core-3.0.0-SNAPSHOT.jar:3.0.0-SNAPSHOT]\r\n\tat org.apache.camel.builder.NotifyBuilder$ExchangeNotifier.onExchangeCreated(NotifyBuilder.java:1154) ~[camel-core-3.0.0-SNAPSHOT.jar:3.0.0-SNAPSHOT]\r\n\tat org.apache.camel.builder.NotifyBuilder$ExchangeNotifier.notify(NotifyBuilder.java:1135) ~[camel-core-3.0.0-SNAPSHOT.jar:3.0.0-SNAPSHOT]\r\n\tat org.apache.camel.support.EventHelper.doNotifyEvent(EventHelper.java:288) [camel-support-3.0.0-SNAPSHOT.jar:3.0.0-SNAPSHOT]\r\n\tat org.apache.camel.support.EventHelper.doNotify(EventHelper.java:27"
    },
    {
      "key":"CAMEL-13636",
      "title":"camel3 - SPI for ReactiveHelper so we can plugin different reactive engines",
      "description":"Today we use ReactiveHelper.callback(callback) to execute works in Camel routing engine. We should have a SPI so we can plugin 3rd party.",
      "assignee":"davsclaus",
      "type":"Improvement",
      "priority":"Major",
      "status":"Resolved",
      "text":"camel3 - SPI for ReactiveHelper so we can plugin different reactive engines Today we use ReactiveHelper.callback(callback) to execute works in Camel routing engine. We should have a SPI so we can plugin 3rd party."
    },
    {
      "key":"CAMEL-13634",
      "title":"Camel main - Allow to configure rest dsl configuration",
      "description":"So you can configure in application.properties etc, some of the rest dsl configuration you would otherwise have to configure with restConfiguration() in the java dsl",
      "assignee":"davsclaus",
      "type":"Improvement",
      "priority":"Major",
      "status":"Resolved",
      "text":"Camel main - Allow to configure rest dsl configuration So you can configure in application.properties etc, some of the rest dsl configuration you would otherwise have to configure with restConfiguration() in the java dsl"
    },
    {
      "key":"CAMEL-13632",
      "title":"Deprecate and remove ReloadStrategy",
      "description":"This should be deprecated in camel 2.x and removed in 3.0.\r\n\r\nThis makes the modularization of camel 3 better, and its also only used as a developer\/demo thing and not for production usage. And today there are better alternatives with camel k, and camel-quarkus etc, for hot re-load that can load the entire app and not only a xml route.",
      "assignee":"davsclaus",
      "type":"Improvement",
      "priority":"Major",
      "status":"Resolved",
      "text":"Deprecate and remove ReloadStrategy This should be deprecated in camel 2.x and removed in 3.0.\r\n\r\nThis makes the modularization of camel 3 better, and its also only used as a developer\/demo thing and not for production usage. And today there are better alternatives with camel k, and camel-quarkus etc, for hot re-load that can load the entire app and not only a xml route."
    },
    {
      "key":"CAMEL-13625",
      "title":"Quartz2 firenow doesn't work consistently",
      "description":"Hi Colleagues,\r\n\r\nWe have an interesting bug in the camel-quartz2 where the firenow doesn't work consistently.\r\n\r\nit works sometimes and sometimes it doesn't. On debug i found that the problem occurs when Scheduler starts\u00a0it invokes\u00a0*CamleJob,*\u00a0 *CamleJob*\u00a0starts executing and tries to read from\u00a0*getProcessors()* method of *LoadBalancerSupport* class. sometimes\u00a0*getProcessors()* method returns empty list as a result routes doesn't get executed.\r\n\r\n*StartupListener* (QuartzComponent) gets notified much before the *QuartzConsumer* starts, as a result it is not able to get the\u00a0List<Processor> from\u00a0*getProcessors()* method of\u00a0*LoadBalancerSupport* class.\r\n\r\n\u00a0\r\n\r\nAnalysis of the problem\r\n\r\n--------------------------------------------------------------------------------------------------\r\n # *DefaultCamelContext* method\u00a0*safelyStartRouteServices()* notifies QuartzComponent's\u00a0*onCamelContextStarted()* method.\r\n # The above step starts the scheduler which then calls *execute()* method in *CamelJob* class.\r\n # In the execute() method it invokes\u00a0*getProcessors()*\u00a0method of\u00a0*LoadBalancerSupport*\u00a0class to get the List<Processor>.\r\n # Sometimes\u00a0*getProcessors()*\u00a0 returns empty list.\r\n # The reason is\u00a0\u00a0List<Processor> in\u00a0*LoadBalancerSupport* class is populated by *QuartzConsumer* on start of consumer. but\u00a0 it is started after\u00a0QuartzComponent's\u00a0*onCamelContextStarted()* method is called in *DefaultCamelContext*.\r\n # When i checked the older version of camel which we are using in our organization 2.17.0 i see the order is different.\r\n # Consumer starts first then the classes that implements\u00a0*StartupListener*.\r\n\r\nTo Summarize\r\n\r\n-------------------------------------------------------------------------------------------------------\r\n # The order in which\u00a0*StartupListener* and *Consumer* is started in *DefaultCamelContext* is causing race condition.\r\n # The older version of camel 2.17.0 order is first *Consumer* starts followed by classes that implement\u00a0*StartupListener*\r\n\r\n\u00a0\r\n\r\nI have attached the junit with quartz2, since it is intermittent issue, i made the junit to run 1000 times and it fails randomly which proves existence of the problem.\r\n\r\nI have also attached by proposed solution in DefaultCamelContext in the attachment.\r\n\r\n\u00a0\r\n\r\n\u00a0",
      "assignee":"davsclaus",
      "type":"Bug",
      "priority":"Major",
      "status":"Resolved",
      "text":"Quartz2 firenow doesn't work consistently Hi Colleagues,\r\n\r\nWe have an interesting bug in the camel-quartz2 where the firenow doesn't work consistently.\r\n\r\nit works sometimes and sometimes it doesn't. On debug i found that the problem occurs when Scheduler starts it invokes *CamleJob,*  *CamleJob* starts executing and tries to read from *getProcessors()* method of *LoadBalancerSupport* class. sometimes *getProcessors()* method returns empty list as a result routes doesn't get executed.\r\n\r\n*StartupListener* (QuartzComponent) gets notified much before the *QuartzConsumer* starts, as a result it is not able to get the List<Processor> from *getProcessors()* method of *LoadBalancerSupport* class.\r\n\r\n \r\n\r\nAnalysis of the problem\r\n\r\n--------------------------------------------------------------------------------------------------\r\n # *DefaultCamelContext* method *safelyStartRouteServices()* notifies QuartzComponent's *onCamelContextStarted()* method.\r\n # The above step starts the scheduler which then calls *execute()* method in *CamelJob* class.\r\n # In the execute() method it invokes *getProcessors()* method of *LoadBalancerSupport* class to get the List<Processor>.\r\n # Sometimes *getProcessors()*  returns empty list.\r\n # The reason is  List<Processor> in *LoadBalancerSupport* class is populated by *QuartzConsumer* on start of consumer. but  it is started after QuartzComponent's *onCamelContextStarted()* method is called in *DefaultCamelContext*.\r\n # When i checked the older version of camel which we are using in our organization 2.17.0 i see the order is different.\r\n # Consumer starts first then the classes that implements *StartupListener*.\r\n\r\nTo Summarize\r\n\r\n-------------------------------------------------------------------------------------------------------\r\n # The order in which *StartupListener* and *Consumer* is started in *DefaultCamelContext* is causing race condition.\r\n # The older version of camel 2.17.0 order is first *Consumer* starts followed by classes that implement *StartupListener*\r\n\r\n \r\n\r\nI have attached the junit with quartz2, since it is intermittent issue, i made the junit to run 1000 times and it fails randomly which proves existence of the problem.\r\n\r\nI have also attached by proposed solution in DefaultCamelContext in the attachment.\r\n\r\n \r\n\r\n "
    },
    {
      "key":"CAMEL-13620",
      "title":"Camel Main - Move to camel-main ccomponent",
      "description":"Lets see if we can move the main classes from camel-core to camel-main so they get more separated and become more reusable in other parts.\r\n\r\nWe have a common set of options to configure on camel context itself, and all the configuration of components etc. That logic can be more shared for camel main, camel k, camel spring boot, and others etc.",
      "assignee":"davsclaus",
      "type":"Improvement",
      "priority":"Major",
      "status":"Resolved",
      "text":"Camel Main - Move to camel-main ccomponent Lets see if we can move the main classes from camel-core to camel-main so they get more separated and become more reusable in other parts.\r\n\r\nWe have a common set of options to configure on camel context itself, and all the configuration of components etc. That logic can be more shared for camel main, camel k, camel spring boot, and others etc."
    },
    {
      "key":"CAMEL-13618",
      "title":"camel3 - Move FileWatcherReloadStrategy out of camel-core",
      "description":"For example to camel-support etc",
      "assignee":"davsclaus",
      "type":"Improvement",
      "priority":"Major",
      "status":"Resolved",
      "text":"camel3 - Move FileWatcherReloadStrategy out of camel-core For example to camel-support etc"
    },
    {
      "key":"CAMEL-13612",
      "title":"camel-rest - Should separate consumer and producer component names",
      "description":"You may end up with using rest-dsl and rest component together, and have a rest endpoint that is shared among them. Then the endpoint will have a componentName option set to the consumer, such as jetty. And then when the same endpoint is used for creating the rest producer (eg to rest) then it would fail. We should separate these two options.",
      "assignee":"davsclaus",
      "type":"Improvement",
      "priority":"Major",
      "status":"Resolved",
      "text":"camel-rest - Should separate consumer and producer component names You may end up with using rest-dsl and rest component together, and have a rest endpoint that is shared among them. Then the endpoint will have a componentName option set to the consumer, such as jetty. And then when the same endpoint is used for creating the rest producer (eg to rest) then it would fail. We should separate these two options."
    },
    {
      "key":"CAMEL-13608",
      "title":"camel-spring-boot - Add option to include\/exclude routes based on their ids",
      "description":"So you can for example do an unit test where you want to only test a specific route and then filter out everyone else. Currently you can filter on route builder and xml files level, but not on route ids.",
      "assignee":"davsclaus",
      "type":"New Feature",
      "priority":"Major",
      "status":"Resolved",
      "text":"camel-spring-boot - Add option to include\/exclude routes based on their ids So you can for example do an unit test where you want to only test a specific route and then filter out everyone else. Currently you can filter on route builder and xml files level, but not on route ids."
    },
    {
      "key":"CAMEL-13605",
      "title":"Support setup proxy host and port on Telegram",
      "description":"As we may run the camel-telegram application behind a proxy, it could be handy if camel-telegram support setting http proxy. ",
      "assignee":"njiang",
      "type":"Improvement",
      "priority":"Minor",
      "status":"Resolved",
      "text":"Support setup proxy host and port on Telegram As we may run the camel-telegram application behind a proxy, it could be handy if camel-telegram support setting http proxy. "
    },
    {
      "key":"CAMEL-13599",
      "title":"Claim check - Allow to use dynamic key via simple language",
      "description":"Asked on user forum\r\nhttp:\/\/camel.465427.n5.nabble.com\/Using-dynamic-expression-as-claimCheck-key-tp5835356.html",
      "assignee":"davsclaus",
      "type":"Improvement",
      "priority":"Major",
      "status":"Resolved",
      "text":"Claim check - Allow to use dynamic key via simple language Asked on user forum\r\nhttp:\/\/camel.465427.n5.nabble.com\/Using-dynamic-expression-as-claimCheck-key-tp5835356.html"
    },
    {
      "key":"CAMEL-13597",
      "title":"Splitter tokenize doesn't really accept every regex",
      "description":"Hi,\u00a0\r\n\r\nNeither\r\n{code:java}\r\n.split().tokenize(\"\\r?\\n\", true, 2, true){code}\r\nnor\u00a0\r\n{code:java}\r\n.split().tokenize(\"\\r\\n|\\n\", true, 2, true){code}\r\nwork.\r\n\r\n\u00a0\r\n\r\nThe latter expression insert a \"|\" instead of correctly split rows on \\r\\n or \\n.\r\n\r\n\u00a0\r\n\r\n\u00a0\r\n\r\n\u00a0\r\n\r\n\u00a0\r\n\r\n\u00a0\r\n\r\n\u00a0",
      "assignee":"davsclaus",
      "type":"Improvement",
      "priority":"Minor",
      "status":"Resolved",
      "text":"Splitter tokenize doesn't really accept every regex Hi, \r\n\r\nNeither\r\n{code:java}\r\n.split().tokenize(\"\\r?\\n\", true, 2, true){code}\r\nnor \r\n{code:java}\r\n.split().tokenize(\"\\r\\n|\\n\", true, 2, true){code}\r\nwork.\r\n\r\n \r\n\r\nThe latter expression insert a \"|\" instead of correctly split rows on \\r\\n or \\n.\r\n\r\n \r\n\r\n \r\n\r\n \r\n\r\n \r\n\r\n \r\n\r\n "
    },
    {
      "key":"CAMEL-13594",
      "title":"camel apt - Avoid generating TypeConverter META-INF file when we generate TypeConverterLoader",
      "description":"We can optimize this to only have the newer TypeConverterLoader file which has all the type converters that are optimized. And then in tooling\/apt avoid generate both TypeConverter and TypeConverterLoaded meta files.",
      "assignee":"davsclaus",
      "type":"Improvement",
      "priority":"Major",
      "status":"Resolved",
      "text":"camel apt - Avoid generating TypeConverter META-INF file when we generate TypeConverterLoader We can optimize this to only have the newer TypeConverterLoader file which has all the type converters that are optimized. And then in tooling\/apt avoid generate both TypeConverter and TypeConverterLoaded meta files."
    },
    {
      "key":"CAMEL-13592",
      "title":"camel-sql - Repeated parameters in URI are not treated correctly",
      "description":"When constructing Camel SQL component with the following URI:\r\n{code:java}\r\nsql:INSERT INTO TABLE ....?batch=true&...&batch=true{code}\r\nResulting camel endpoint ends up with batch == false. The reason for this is found in\u00a0\r\n{code:java}\r\nprivate static void addParameter \/\/ this is in UriSupport.java{code}\r\nThis method adds values into a list and then setting the parameter does not work correctly. I believe that Camel should be more linient for such \"errors\" (which can occur if you construct URI programatically).\u00a0\r\n\r\nI suggest parameter value detection. If\r\n{code:java}\r\nexisting.equals(value) \/\/ to use actual names of variables from the code{code}\r\nthen just ignore. DO NOT do the following (list construction; current behavior):\r\n{code:java}\r\nif (existing instanceof List) {\r\n    list = CastUtils.cast((List<?>) existing);\r\n} else {\r\n    \/\/ create a new list to hold the multiple values\r\n    list = new ArrayList<String>();\r\n    String s = existing != null ? existing.toString() : null;\r\n    if (s != null) {\r\n        list.add(s);\r\n    }\r\n}\r\nlist.add(value);\r\n{code}\r\nIn the end the URI shown in the beginning will result in Component with batch equal to false. Which is really hard to determine why and what happened.\u00a0\r\n\r\n\u00a0\r\n\r\nI believe this is a generic problem tho",
      "assignee":"davsclaus",
      "type":"Bug",
      "priority":"Minor",
      "status":"Resolved",
      "text":"camel-sql - Repeated parameters in URI are not treated correctly When constructing Camel SQL component with the following URI:\r\n{code:java}\r\nsql:INSERT INTO TABLE ....?batch=true&...&batch=true{code}\r\nResulting camel endpoint ends up with batch == false. The reason for this is found in \r\n{code:java}\r\nprivate static void addParameter \/\/ this is in UriSupport.java{code}\r\nThis method adds values into a list and then setting the parameter does not work correctly. I believe that Camel should be more linient for such \"errors\" (which can occur if you construct URI programatically). \r\n\r\nI suggest parameter value detection. If\r\n{code:java}\r\nexisting.equals(value) \/\/ to use actual names of variables from the code{code}\r\nthen just ignore. DO NOT do the following (list construction; current behavior):\r\n{code:java}\r\nif (existing instanceof List) {\r\n    list = CastUtils.cast((List<?>) existing);\r\n} else {\r\n    \/\/ create a new list to hold the multiple values\r\n    list = new ArrayList<String>();\r\n    String s = existing != null ? existing.toString() : null;\r\n    if (s != null) {\r\n        list.add(s);\r\n    }\r\n}\r\nlist.add(value);\r\n{code}\r\nIn the end the URI shown in the beginning will result in Component with batch equal to false. Which is really hard to determine why and what happened. \r\n\r\n \r\n\r\nI believe this is a generic problem tho"
    },
    {
      "key":"CAMEL-13587",
      "title":"InflightRepository, InflightEntry getElapsed is 0",
      "description":"Hi,\r\n\r\nI made a camel-route\u00a0that checks about inflight messages on other server through JMX connection.\r\nIt was working fine in 2.17.x but now we upgrade to 2.22.1 and I always obtain a result of 0 millisecond for the elapsed field.\r\n\r\nI use the browse() operation of JMX bean. You can use jconsole to run a simple test.\r\n\r\n!image-2019-05-27-17-04-12-319.png!\r\n\r\nThis is a major bug for us, since we use the code to monitoring production\u00a0routes. Is there any workaround like get the echange historymessage from the exchage id?\r\n\r\nThank you",
      "assignee":"davsclaus",
      "type":"Bug",
      "priority":"Major",
      "status":"Resolved",
      "text":"InflightRepository, InflightEntry getElapsed is 0 Hi,\r\n\r\nI made a camel-route that checks about inflight messages on other server through JMX connection.\r\nIt was working fine in 2.17.x but now we upgrade to 2.22.1 and I always obtain a result of 0 millisecond for the elapsed field.\r\n\r\nI use the browse() operation of JMX bean. You can use jconsole to run a simple test.\r\n\r\n!image-2019-05-27-17-04-12-319.png!\r\n\r\nThis is a major bug for us, since we use the code to monitoring production routes. Is there any workaround like get the echange historymessage from the exchage id?\r\n\r\nThank you"
    },
    {
      "key":"CAMEL-13584",
      "title":"Camel main - Calling init should initialize as much as possible",
      "description":"So we can eager init as much as possible when running Camel Main, by calling main.init() method. This can be used to warmup Camel.",
      "assignee":"davsclaus",
      "type":"Improvement",
      "priority":"Major",
      "status":"Resolved",
      "text":"Camel main - Calling init should initialize as much as possible So we can eager init as much as possible when running Camel Main, by calling main.init() method. This can be used to warmup Camel."
    },
    {
      "key":"CAMEL-13583",
      "title":"Camel Injector - Add method for creating a new instance without bean processing",
      "description":"There are use-cases where we for example loads the type converter loaded that creates an instance of the class, but we use the injector which does bean post processing by scanning methods for injecting fields \/ and other autowriting via those Camel annotations. But these type converters are basic and dont need this. There can be some other factory classes too, so lets have a basic injector method so you can choose.",
      "assignee":"davsclaus",
      "type":"Improvement",
      "priority":"Minor",
      "status":"Resolved",
      "text":"Camel Injector - Add method for creating a new instance without bean processing There are use-cases where we for example loads the type converter loaded that creates an instance of the class, but we use the injector which does bean post processing by scanning methods for injecting fields \/ and other autowriting via those Camel annotations. But these type converters are basic and dont need this. There can be some other factory classes too, so lets have a basic injector method so you can choose."
    },
    {
      "key":"CAMEL-13582",
      "title":"Camel main - Configuration class should support automatic autowire by type",
      "description":"In such a configuration class\r\n{code}\r\npublic class MyConfiguration {\r\n\r\n    @BindToRegistry\r\n    public ClientConfiguration myClientConfig() {\r\n        ClientConfiguration cc = new ClientConfiguration();\r\n        cc.setMaxConnections(5);\r\n        return cc;\r\n    }\r\n\r\n    @BindToRegistry\r\n    public MyBean myBean(@PropertyInject(\"hi\") String hi, @PropertyInject(\"bye\") String bye) {\r\n        \/\/ this will create an instance of this bean with the name of the method (eg myBean)\r\n        return new MyBean(hi, bye);\r\n    }\r\n\r\n    @BindToRegistry\r\n    public AmazonS3 myAmazon(@BeanInject(\"myClientConfig\") ClientConfiguration config) {\r\n        return AmazonS3Client.builder().withRegion(\"US-EAST-1\").withClientConfiguration(config).build();\r\n    }\r\n\r\n    public void configure() {\r\n        \/\/ this method is optional and can be removed if no additional configuration is needed.\r\n    }\r\n\r\n}\r\n{code}\r\n\r\nWe could detect that the myAmazon method has a parameter of type ClientConfiguration which we can attempt to lookup as singleton bean. Then you can do\r\n\r\n{code}\r\n    @BindToRegistry\r\n    public AmazonS3 myAmazon(ClientConfiguration config) \r\n{code}",
      "assignee":"davsclaus",
      "type":"Improvement",
      "priority":"Major",
      "status":"Resolved",
      "text":"Camel main - Configuration class should support automatic autowire by type In such a configuration class\r\n{code}\r\npublic class MyConfiguration {\r\n\r\n    @BindToRegistry\r\n    public ClientConfiguration myClientConfig() {\r\n        ClientConfiguration cc = new ClientConfiguration();\r\n        cc.setMaxConnections(5);\r\n        return cc;\r\n    }\r\n\r\n    @BindToRegistry\r\n    public MyBean myBean(@PropertyInject(\"hi\") String hi, @PropertyInject(\"bye\") String bye) {\r\n        \/\/ this will create an instance of this bean with the name of the method (eg myBean)\r\n        return new MyBean(hi, bye);\r\n    }\r\n\r\n    @BindToRegistry\r\n    public AmazonS3 myAmazon(@BeanInject(\"myClientConfig\") ClientConfiguration config) {\r\n        return AmazonS3Client.builder().withRegion(\"US-EAST-1\").withClientConfiguration(config).build();\r\n    }\r\n\r\n    public void configure() {\r\n        \/\/ this method is optional and can be removed if no additional configuration is needed.\r\n    }\r\n\r\n}\r\n{code}\r\n\r\nWe could detect that the myAmazon method has a parameter of type ClientConfiguration which we can attempt to lookup as singleton bean. Then you can do\r\n\r\n{code}\r\n    @BindToRegistry\r\n    public AmazonS3 myAmazon(ClientConfiguration config) \r\n{code}"
    },
    {
      "key":"CAMEL-13581",
      "title":"camel-blueprint - Many WARNs about overriding type converters",
      "description":"Noticed these during testing CiA2 book\r\n\r\n2019-05-27 06:47:06,045 [main           ] WARN  DefaultTypeConverter           - Overriding type converter from: org.apache.camel.support.SimpleTypeConverter@659f226a to: StaticMethodTypeConverter: public static org.restlet.data.Method org.apache.camel.component.restlet.converter.RestletConverter.toMethod(java.lang.String)\r\n2019-05-27 06:47:06,045 [main           ] WARN  DefaultTypeConverter           - Overriding type converter from: org.apache.camel.support.SimpleTypeConverter@2e463f4 to: StaticMethodTypeConverter: public static org.restlet.data.Method[] org.apache.camel.component.restlet.converter.RestletConverter.toMethods(java.lang.String)\r\n2019-05-27 06:47:06,045 [main           ] WARN  DefaultTypeConverter           - Overriding type converter from: org.apache.camel.support.SimpleTypeConverter@32ec9c90 to: StaticMethodTypeConverter: public static org.restlet.data.MediaType[] org.apache.camel.component.restlet.converter.RestletConverter.toMediaTypes(java.lang.String)\r\n2019-05-27 06:47:06,046 [main           ] WARN  DefaultTypeConverter           - Overriding type converter from: org.apache.camel.support.SimpleTypeConverter@36ab3814 to: StaticMethodTypeConverter: public static org.restlet.data.MediaType org.apache.camel.component.restlet.converter.RestletConverter.toMediaType(java.lang.String)\r\n2019-05-27 06:47:06,046 [main           ] WARN  DefaultTypeConverter           - Overriding type converter from: org.apache.camel.support.SimpleTypeConverter@467233e4 to: StaticMethodTypeConverter: public static java.io.InputStream org.apache.camel.http.common.HttpConverter.toInputStream(org.apache.camel.http.common.HttpMessage,org.apache.camel.Exchange) throws java.lang.Exception\r\n2019-05-27 06:47:06,046 [main           ] WARN  DefaultTypeConverter           - Overriding type converter from: org.apache.camel.support.SimpleTypeConverter@427a12b6 to: StaticMethodTypeConverter: public static java.io.InputStream org.apache.camel.http.common.HttpConverter.toInputStream(javax.servlet.http.HttpServletRequest,org.apache.camel.Exchange) throws java.io.IOException\r\n2019-05-27 06:47:06,046 [main           ] WARN  DefaultTypeConverter           - Overriding type converter from: org.apache.camel.support.SimpleTypeConverter@6025d790 to: StaticMethodTypeConverter: public static java.io.BufferedReader org.apache.camel.http.common.HttpConverter.toReader(org.apache.camel.http.common.HttpMessage) throws java.io.IOException\r\n2019-05-27 06:47:06,046 [main           ] WARN  DefaultTypeConverter           - Overriding type converter from: org.apache.camel.support.SimpleTypeConverter@af7e376 to: StaticMethodTypeConverter: public static javax.servlet.http.HttpServletResponse org.apache.camel.http.common.HttpConverter.toServletResponse(org.apache.camel.Message)\r\n2019-05-27 06:47:06,046 [main           ] WARN  DefaultTypeConverter           - Overriding type converter from: org.apache.camel.support.SimpleTypeConverter@5dcd0cdf to: StaticMethodTypeConverter: public static javax.servlet.http.HttpServletRequest org.apache.camel.http.common.HttpConverter.toServletRequest(org.apache.camel.Message)\r\n2019-05-27 06:47:06,047 [main           ] WARN  DefaultTypeConverter           - Overriding type converter from: org.apache.camel.support.SimpleTypeConverter@4fb04a72 to: StaticMethodTypeConverter: public static javax.servlet.ServletInputStream org.apache.camel.http.common.HttpConverter.toServletInputStream(org.apache.camel.http.common.HttpMessage) throws java.io.IOException\r\n2019-05-27 06:47:06,047 [main           ] WARN  DefaultTypeConverter           - Overriding type converter from: org.apache.camel.support.SimpleTypeConverter@1a07bf6 to: StaticMethodTypeConverter: public static java.io.InputStream org.apache.camel.spring.converter.ResourceConverter.convertToInputStream(org.springframework.core.io.Resource) throws java.io.IOException\r\n2019-05-27 06:47:06,047 [main           ] WARN  DefaultTypeConverter           - Overriding type converter from: org.apache.camel.support.SimpleTypeConverter@34d713a2 to: StaticMethodTypeConverter: public static java.lang.Object[] org.apache.camel.component.cxf.converter.CxfConverter.toArray(java.lang.Object)\r\n2019-05-27 06:47:06,047 [main           ] WARN  DefaultTypeConverter           - Overriding type converter from: org.apache.camel.support.SimpleTypeConverter@36aab105 to: StaticMethodTypeConverter: public static java.io.InputStream org.apache.camel.component.cxf.converter.CxfConverter.toInputStream(javax.ws.rs.core.Response,org.apache.camel.Exchange)\r\n2019-05-27 06:47:06,047 [main           ] WARN  DefaultTypeConverter           - Overriding type converter from: org.apache.camel.support.SimpleTypeConverter@889a8a8 to: StaticMethodTypeConverter: public static javax.xml.namespace.QName org.apache.camel.component.cxf.converter.CxfConverter.toQName(java.lang.String)\r\n2019-05-27 06:47:06,047 [main           ] WARN  DefaultTypeConverter           - Overriding type converter from: org.apache.camel.support.SimpleTypeConverter@f29353f to: StaticMethodTypeConverter: public static org.apache.cxf.message.MessageContentsList org.apache.camel.component.cxf.converter.CxfConverter.toMessageContentsList(java.lang.Object[])\r\n2019-05-27 06:47:06,047 [main           ] WARN  DefaultTypeConverter           - Overriding type converter from: org.apache.camel.support.SimpleTypeConverter@36f7d7b to: StaticMethodTypeConverter: public static org.apache.camel.component.cxf.DataFormat org.apache.camel.component.cxf.converter.CxfConverter.toDataFormat(java.lang.String)\r\n2019-05-27 06:47:06,047 [main           ] WARN  DefaultTypeConverter           - Overriding type converter from: org.apache.camel.support.SimpleTypeConverter@60aec68a to: StaticMethodTypeConverter: public static java.lang.String org.apache.camel.component.cxf.converter.CxfConverter.soapMessageToString(javax.xml.soap.SOAPMessage,org.apache.camel.Exchange) throws javax.xml.soap.SOAPException,java.io.IOException\r\n2019-05-27 06:47:06,047 [main           ] WARN  DefaultTypeConverter           - Overriding type converter from: org.apache.camel.support.SimpleTypeConverter@25a7fedf to: StaticMethodTypeConverter: public static java.io.InputStream org.apache.camel.component.cxf.converter.CxfConverter.soapMessageToInputStream(javax.xml.soap.SOAPMessage,org.apache.camel.Exchange) throws javax.xml.soap.SOAPException,java.io.IOException\r\n2019-05-27 06:47:06,047 [main           ] WARN  DefaultTypeConverter           - Overriding type converter from: org.apache.camel.support.SimpleTypeConverter@6361b799 to: StaticMethodTypeConverter: public static org.w3c.dom.NodeList org.apache.camel.component.cxf.converter.CxfPayloadConverter.cxfPayloadToNodeList(org.apache.camel.component.cxf.CxfPayload,org.apache.camel.Exchange)\r\n2019-05-27 06:47:06,047 [main           ] WARN  DefaultTypeConverter           - Overriding type converter from: org.apache.camel.support.SimpleTypeConverter@1b9d9a2b to: StaticMethodTypeConverter: public static org.w3c.dom.Node org.apache.camel.component.cxf.converter.CxfPayloadConverter.cxfPayLoadToNode(org.apache.camel.component.cxf.CxfPayload,org.apache.camel.Exchange)\r\n2019-05-27 06:47:06,047 [main           ] WARN  DefaultTypeConverter           - Overriding type converter from: org.apache.camel.support.SimpleTypeConverter@d919544 to: StaticMethodTypeConverter: public static org.apache.camel.component.cxf.CxfPayload org.apache.camel.component.cxf.converter.CxfPayloadConverter.nodeListToCxfPayload(org.w3c.dom.NodeList,org.apache.camel.Exchange)\r\n2019-05-27 06:47:06,047 [main           ] WARN  DefaultTypeConverter           - Overriding type converter from: org.apache.camel.support.SimpleTypeConverter@17dad32f to: StaticMethodTypeConverter: public static org.apache.camel.component.cxf.CxfPayload org.apache.camel.component.cxf.converter.CxfPayloadConverter.elementToCxfPayload(org.w3c.dom.Element,org.apache.camel.Exchange)\r\n2019-05-27 06:47:06,047 [main           ] WARN  DefaultTypeConverter           - Overriding type converter from: org.apache.camel.support.SimpleTypeConverter@79696332 to: StaticMethodTypeConverter: public static org.apache.camel.component.cxf.CxfPayload org.apache.camel.component.cxf.converter.CxfPayloadConverter.documentToCxfPayload(org.w3c.dom.Document,org.apache.camel.Exchange)\r\n2019-05-27 06:47:06,048 [main           ] WARN  DefaultTypeConverter           - Overriding type converter from: org.apache.camel.support.SimpleTypeConverter@ed2f2f6 to: StaticMethodTypeConverter: public static org.apache.camel.component.cxf.CxfPayload org.apache.camel.component.cxf.converter.CxfPayloadConverter.sourceToCxfPayload(javax.xml.transform.Source,org.apache.camel.Exchange)\r\n2019-05-27 06:47:06,048 [main           ] WARN  DefaultTypeConverter           - Overriding type converter from: org.apache.camel.support.SimpleTypeConverter@fe87ddd to: StaticMethodTypeConverter: public static org.apache.camel.StreamCache org.apache.camel.component.cxf.converter.CxfPayloadConverter.cxfPayLoadToStreamCache(org.apache.camel.component.cxf.CxfPayload,org.apache.camel.Exchange)\r\n2019-05-27 06:47:06,048 [main           ] WARN  DefaultTypeConverter           - Overriding type converter from: org.apache.camel.support.SimpleTypeConverter@4eea94a4 to: StaticMethodTypeConverter: public static javax.xml.transform.Source org.apache.camel.component.cxf.converter.CxfPayloadConverter.cxfPayLoadToSource(org.apache.camel.component.cxf.CxfPayload,org.apache.camel.Exchange)\r\n2019-05-27 06:47:06,048 [main           ] WARN  DefaultTypeConverter           - Overriding type converter from: org.apache.camel.support.SimpleTypeConverter@29be997f to: StaticMethodTypeConverter: public static java.io.InputStream org.apache.camel.component.file.GenericFileConverter.genericFileToInputStream(org.apache.camel.component.file.GenericFile,org.apache.camel.Exchange) throws java.io.IOException\r\n2019-05-27 06:47:06,048 [main           ] WARN  DefaultTypeConverter           - Overriding type converter from: org.apache.camel.support.SimpleTypeConverter@33eb6758 to: StaticMethodTypeConverter: public static java.lang.String org.apache.camel.component.file.GenericFileConverter.genericFileToString(org.apache.camel.component.file.GenericFile,org.apache.camel.Exchange) throws java.io.IOException,org.apache.camel.NoTypeConversionAvailableException\r\n2019-05-27 06:47:06,048 [main           ] WARN  DefaultTypeConverter           - Overriding type converter from: org.apache.camel.support.SimpleTypeConverter@f8a6243 to: StaticMethodTypeConverter: public static java.io.Serializable org.apache.camel.component.file.GenericFileConverter.genericFileToSerializable(org.apache.camel.component.file.GenericFile,org.apache.camel.Exchange) throws java.io.IOException\r\n2019-05-27 06:47:06,048 [main           ] WARN  DefaultTypeConverter           - Overriding type converter from: org.apache.camel.support.SimpleTypeConverter@7f9e8421 to: StaticMethodTypeConverter: public static org.apache.camel.StreamCache org.apache.camel.converter.stream.StreamCacheConverter.convertToStreamCache(java.io.ByteArrayInputStream,org.apache.camel.Exchange) throws java.io.IOException\r\n2019-05-27 06:47:06,048 [main           ] WARN  DefaultTypeConverter           - Overriding type converter from: org.apache.camel.support.SimpleTypeConverter@23da79eb to: StaticMethodTypeConverter: public static org.apache.camel.StreamCache org.apache.camel.converter.stream.StreamCacheConverter.convertToStreamCache(java.io.InputStream,org.apache.camel.Exchange) throws java.io.IOException\r\n2019-05-27 06:47:06,048 [main           ] WARN  DefaultTypeConverter           - Overriding type converter from: org.apache.camel.support.SimpleTypeConverter@168b4cb0 to: StaticMethodTypeConverter: public static org.apache.camel.StreamCache org.apache.camel.converter.stream.StreamCacheConverter.convertToStreamCache(org.apache.camel.converter.stream.CachedOutputStream,org.apache.camel.Exchange) throws java.io.IOException\r\n2019-05-27 06:47:06,048 [main           ] WARN  DefaultTypeConverter           - Overriding type converter from: org.apache.camel.support.SimpleTypeConverter@3e05586b to: StaticMethodTypeConverter: public static org.apache.camel.StreamCache org.apache.camel.converter.stream.StreamCacheConverter.convertToStreamCache(java.io.Reader,org.apache.camel.Exchange) throws java.io.IOException\r\n2019-05-27 06:47:06,048 [main           ] WARN  DefaultTypeConverter           - Overriding type converter from: org.apache.camel.support.SimpleTypeConverter@35b17c06 to: StaticMethodTypeConverter: public static org.apache.camel.StreamCache org.apache.camel.converter.stream.StreamCacheConverter.convertToStreamCache(javax.xml.transform.stream.StreamSource,org.apache.camel.Exchange) throws java.io.IOException\r\n2019-05-27 06:47:06,048 [main           ] WARN  DefaultTypeConverter           - Overriding type converter from: org.apache.camel.support.SimpleTypeConverter@45545e7a to: StaticMethodTypeConverter: public static org.apache.camel.StreamCache org.apache.camel.converter.stream.StreamCacheConverter.convertToStreamCache(org.apache.camel.StringSource)\r\n2019-05-27 06:47:06,048 [main           ] WARN  DefaultTypeConverter           - Overriding type converter from: org.apache.camel.support.SimpleTypeConverter@9f674ac to: StaticMethodTypeConverter: public static org.apache.camel.StreamCache org.apache.camel.converter.stream.StreamCacheConverter.convertToStreamCache(org.apache.camel.BytesSource)\r\n2019-05-27 06:47:06,048 [main           ] WARN  DefaultTypeConverter           - Overriding type converter from: org.apache.camel.support.SimpleTypeConverter@1da4b3f9 to: StaticMethodTypeConverter: public static org.apache.camel.StreamCache org.apache.camel.converter.stream.StreamCacheConverter.convertToStreamCache(javax.xml.transform.sax.SAXSource,org.apache.camel.Exchange) throws javax.xml.transform.TransformerException\r\n2019-05-27 06:47:06,048 [main           ] WARN  DefaultTypeConverter           - Overriding type converter from: org.apache.camel.support.SimpleTypeConverter@23cbbd07 to: StaticMethodTypeConverter: public static java.nio.ByteBuffer org.apache.camel.converter.stream.StreamCacheConverter.convertToByteBuffer(org.apache.camel.StreamCache,org.apache.camel.Exchange) throws java.io.IOException\r\n2019-05-27 06:47:06,048 [main           ] WARN  DefaultTypeConverter           - Overriding type converter from: org.apache.camel.support.SimpleTypeConverter@448b808a to: StaticMethodTypeConverter: public static java.io.Serializable org.apache.camel.converter.stream.StreamCacheConverter.convertToSerializable(org.apache.camel.StreamCache,org.apache.camel.Exchange) throws java.io.IOException\r\n2019-05-27 06:47:06,048 [main           ] WARN  DefaultTypeConverter           - Overriding type converter from: org.apache.camel.support.SimpleTypeConverter@7e62cfa3 to: StaticMethodTypeConverter: public static byte[] org.apache.camel.converter.stream.StreamCacheConverter.convertToByteArray(org.apache.camel.StreamCache,org.apache.camel.Exchange) throws java.io.IOException\r\n2019-05-27 06:47:06,049 [main           ] WARN  DefaultTypeConverter           - Overriding type converter from: StaticMethodTypeConverter: public static org.apache.camel.StreamCache org.apache.camel.converter.stream.StreamCacheConverter.convertToStreamCache(java.io.ByteArrayInputStream,org.apache.camel.Exchange) throws java.io.IOException to: StaticMethodTypeConverter: public static org.apache.camel.StreamCache org.apache.camel.converter.stream.StreamCacheConverter.convertToStreamCache(java.io.ByteArrayInputStream,org.apache.camel.Exchange) throws java.io.IOException\r\n2019-05-27 06:47:06,049 [main           ] WARN  DefaultTypeConverter           - Overriding type converter from: StaticMethodTypeConverter: public static org.apache.camel.StreamCache org.apache.camel.converter.stream.StreamCacheConverter.convertToStreamCache(java.io.InputStream,org.apache.camel.Exchange) throws java.io.IOException to: StaticMethodTypeConverter: public static org.apache.camel.StreamCache org.apache.camel.converter.stream.StreamCacheConverter.convertToStreamCache(java.io.InputStream,org.apache.camel.Exchange) throws java.io.IOException\r\n2019-05-27 06:47:06,049 [main           ] WARN  DefaultTypeConverter           - Overriding type converter from: StaticMethodTypeConverter: public static org.apache.camel.StreamCache org.apache.camel.converter.stream.StreamCacheConverter.convertToStreamCache(org.apache.camel.converter.stream.CachedOutputStream,org.apache.camel.Exchange) throws java.io.IOException to: StaticMethodTypeConverter: public static org.apache.camel.StreamCache org.apache.camel.converter.stream.StreamCacheConverter.convertToStreamCache(org.apache.camel.converter.stream.CachedOutputStream,org.apache.camel.Exchange) throws java.io.IOException\r\n2019-05-27 06:47:06,049 [main           ] WARN  DefaultTypeConverter           - Overriding type converter from: StaticMethodTypeConverter: public static org.apache.camel.StreamCache org.apache.camel.converter.stream.StreamCacheConverter.convertToStreamCache(java.io.Reader,org.apache.camel.Exchange) throws java.io.IOException to: StaticMethodTypeConverter: public static org.apache.camel.StreamCache org.apache.camel.converter.stream.StreamCacheConverter.convertToStreamCache(java.io.Reader,org.apache.camel.Exchange) throws java.io.IOException\r\n2019-05-27 06:47:06,049 [main           ] WARN  DefaultTypeConverter           - Overriding type converter from: StaticMethodTypeConverter: public static org.apache.camel.StreamCache org.apache.camel.converter.stream.StreamCacheConverter.convertToStreamCache(javax.xml.transform.stream.StreamSource,org.apache.camel.Exchange) throws java.io.IOException to: StaticMethodTypeConverter: public static org.apache.camel.StreamCache org.apache.camel.converter.stream.StreamCacheConverter.convertToStreamCache(javax.xml.transform.stream.StreamSource,org.apache.camel.Exchange) throws java.io.IOException\r\n2019-05-27 06:47:06,049 [main           ] WARN  DefaultTypeConverter           - Overriding type converter from: StaticMethodTypeConverter: public static org.apache.camel.StreamCache org.apache.camel.converter.stream.StreamCacheConverter.convertToStreamCache(org.apache.camel.StringSource) to: StaticMethodTypeConverter: public static org.apache.camel.StreamCache org.apache.camel.converter.stream.StreamCacheConverter.convertToStreamCache(org.apache.camel.StringSource)\r\n2019-05-27 06:47:06,049 [main           ] WARN  DefaultTypeConverter           - Overriding type converter from: StaticMethodTypeConverter: public static org.apache.camel.StreamCache org.apache.camel.converter.stream.StreamCacheConverter.convertToStreamCache(org.apache.camel.BytesSource) to: StaticMethodTypeConverter: public static org.apache.camel.StreamCache org.apache.camel.converter.stream.StreamCacheConverter.convertToStreamCache(org.apache.camel.BytesSource)\r\n2019-05-27 06:47:06,050 [main           ] WARN  DefaultTypeConverter           - Overriding type converter from: StaticMethodTypeConverter: public static org.apache.camel.StreamCache org.apache.camel.converter.stream.StreamCacheConverter.convertToStreamCache(javax.xml.transform.sax.SAXSource,org.apache.camel.Exchange) throws javax.xml.transform.TransformerException to: StaticMethodTypeConverter: public static org.apache.camel.StreamCache org.apache.camel.converter.stream.StreamCacheConverter.convertToStreamCache(javax.xml.transform.sax.SAXSource,org.apache.camel.Exchange) throws javax.xml.transform.TransformerException\r\n2019-05-27 06:47:06,050 [main           ] WARN  DefaultTypeConverter           - Overriding type converter from: StaticMethodTypeConverter: public static java.nio.ByteBuffer org.apache.camel.converter.stream.StreamCacheConverter.convertToByteBuffer(org.apache.camel.StreamCache,org.apache.camel.Exchange) throws java.io.IOException to: StaticMethodTypeConverter: public static java.nio.ByteBuffer org.apache.camel.converter.stream.StreamCacheConverter.convertToByteBuffer(org.apache.camel.StreamCache,org.apache.camel.Exchange) throws java.io.IOException\r\n2019-05-27 06:47:06,050 [main           ] WARN  DefaultTypeConverter           - Overriding type converter from: StaticMethodTypeConverter: public static java.io.Serializable org.apache.camel.converter.stream.StreamCacheConverter.convertToSerializable(org.apache.camel.StreamCache,org.apache.camel.Exchange) throws java.io.IOException to: StaticMethodTypeConverter: public static java.io.Serializable org.apache.camel.converter.stream.StreamCacheConverter.convertToSerializable(org.apache.camel.StreamCache,org.apache.camel.Exchange) throws java.io.IOException\r\n2019-05-27 06:47:06,050 [main           ] WARN  DefaultTypeConverter           - Overriding type converter from: StaticMethodTypeConverter: public static byte[] org.apache.camel.converter.stream.StreamCacheConverter.convertToByteArray(org.apache.camel.StreamCache,org.apache.camel.Exchange) throws java.io.IOException to: StaticMethodTypeConverter: public static byte[] org.apache.camel.converter.stream.StreamCacheConverter.convertToByteArray(org.apache.camel.StreamCache,org.apache.camel.Exchange) throws java.io.IOException",
      "assignee":"davsclaus",
      "type":"Task",
      "priority":"Minor",
      "status":"Resolved",
      "text":"camel-blueprint - Many WARNs about overriding type converters Noticed these during testing CiA2 book\r\n\r\n2019-05-27 06:47:06,045 [main           ] WARN  DefaultTypeConverter           - Overriding type converter from: org.apache.camel.support.SimpleTypeConverter@659f226a to: StaticMethodTypeConverter: public static org.restlet.data.Method org.apache.camel.component.restlet.converter.RestletConverter.toMethod(java.lang.String)\r\n2019-05-27 06:47:06,045 [main           ] WARN  DefaultTypeConverter           - Overriding type converter from: org.apache.camel.support.SimpleTypeConverter@2e463f4 to: StaticMethodTypeConverter: public static org.restlet.data.Method[] org.apache.camel.component.restlet.converter.RestletConverter.toMethods(java.lang.String)\r\n2019-05-27 06:47:06,045 [main           ] WARN  DefaultTypeConverter           - Overriding type converter from: org.apache.camel.support.SimpleTypeConverter@32ec9c90 to: StaticMethodTypeConverter: public static org.restlet.data.MediaType[] org.apache.camel.component.restlet.converter.RestletConverter.toMediaTypes(java.lang.String)\r\n2019-05-27 06:47:06,046 [main           ] WARN  DefaultTypeConverter           - Overriding type converter from: org.apache.camel.support.SimpleTypeConverter@36ab3814 to: StaticMethodTypeConverter: public static org.restlet.data.MediaType org.apache.camel.component.restlet.converter.RestletConverter.toMediaType(java.lang.String)\r\n2019-05-27 06:47:06,046 [main           ] WARN  DefaultTypeConverter           - Overriding type converter from: org.apache.camel.support.SimpleTypeConverter@467233e4 to: StaticMethodTypeConverter: public static java.io.InputStream org.apache.camel.http.common.HttpConverter.toInputStream(org.apache.camel.http.common.HttpMessage,org.apache.camel.Exchange) throws java.lang.Exception\r\n2019-05-27 06:47:06,046 [main           ] WARN  DefaultTypeConverter           - Overriding type converter from: org.apache.camel.support.SimpleTypeConverter@427a12b6 to: StaticMethodTypeConverter: public static java.io.InputStream org.apache.camel.http.common.HttpConverter.toInputStream(javax.servlet.http.HttpServletRequest,org.apache.camel.Exchange) throws java.io.IOException\r\n2019-05-27 06:47:06,046 [main           ] WARN  DefaultTypeConverter           - Overriding type converter from: org.apache.camel.support.SimpleTypeConverter@6025d790 to: StaticMethodTypeConverter: public static java.io.BufferedReader org.apache.camel.http.common.HttpConverter.toReader(org.apache.camel.http.common.HttpMessage) throws java.io.IOException\r\n2019-05-27 06:47:06,046 [main           ] WARN  DefaultTypeConverter           - Overriding type converter from: org.apache.camel.support.SimpleTypeConverter@af7e376 to: StaticMethodTypeConverter: public static javax.servlet.http.HttpServletResponse org.apache.camel.http.common.HttpConverter.toServletResponse(org.apache.camel.Message)\r\n2019-05-27 06:47:06,046 [main           ] WARN  DefaultTypeConverter           - Overriding type converter from: org.apache.camel.support.SimpleTypeConverter@5dcd0cdf to: StaticMethodTypeConverter: public static javax.servlet.http.HttpServletRequest org.apache.camel.http.common.HttpConverter.toServletRequest(org.apache.camel.Message)\r\n2019-05-27 06:47:06,047 [main           ] WARN  DefaultTypeConverter           - Overriding type converter from: org.apache.camel.support.SimpleTypeConverter@4fb04a72 to: StaticMethodTypeConverter: public static javax.servlet.ServletInputStream org.apache.camel.http.common.HttpConverter.toServletInputStream(org.apache.camel.http.common.HttpMessage) throws java.io.IOException\r\n2019-05-27 06:47:06,047 [main           ] WARN  DefaultTypeConverter           - Overriding type converter from: org.apache.camel.support.SimpleTypeConverter@1a07bf6 to: StaticMethodTypeConverter: public static java.io.InputStream org.apache.camel.spring.converter.ResourceConverter.convertToInputStream(org.springframework.core.io.Resource) throws java.io.IOException\r\n2019-05-27 06:47:06,047 [main           ] WARN  DefaultTypeConverter           - Overriding type converter from: org.apache.camel.support.SimpleTypeConverter@34d713a2 to: StaticMethodTypeConverter: public static java.lang.Object[] org.apache.camel.component.cxf.converter.CxfConverter.toArray(java.lang.Object)\r\n2019-05-27 06:47:06,047 [main           ] WARN  DefaultTypeConverter           - Overriding type converter from: org.apache.camel.support.SimpleTypeConverter@36aab105 to: StaticMethodTypeConverter: public static java.io.InputStream org.apache.camel.component.cxf.converter.CxfConverter.toInputStream(javax.ws.rs.core.Response,org.apache.camel.Exchange)\r\n2019-05-27 06:47:06,047 [main           ] WARN  DefaultTypeConverter           - Overriding type converter from: org.apache.camel.support.SimpleTypeConverter@889a8a8 to: StaticMethodTypeConverter: public static javax.xml.namespace.QName org.apache.camel.component.cxf.converter.CxfConverter.toQName(java.lang.String)\r\n2019-05-27 06:47:06,047 [main           ] WARN  DefaultTypeConverter           - Overriding type converter from: org.apache.camel.support.SimpleTypeConverter@f29353f to: StaticMethodTypeConverter: public static org.apache.cxf.message.MessageContentsList org.apache.camel.component.cxf.converter.CxfConverter.toMessageContentsList(java.lang.Object[])\r\n2019-05-27 06:47:06,047 [main           ] WARN  DefaultTypeConverter           - Overriding type converter from: org.apache.camel.support.SimpleTypeConverter@36f7d7b to: StaticMethodTypeConverter: public static org.apache.camel.component.cxf.DataFormat org.apache.camel.component.cxf.converter.CxfConverter.toDataFormat(java.lang.String)\r\n2019-05-27 06:47:06,047 [main           ] WARN  DefaultTypeConverter           - Overriding type converter from: org.apache.camel.support.SimpleTypeConverter@60aec68a to: StaticMethodTypeConverter: public static java.lang.String org.apache.camel.component.cxf.converter.CxfConverter.soapMessageToString(javax.xml.soap.SOAPMessage,org.apache.camel.Exchange) throws javax.xml.soap.SOAPException,java.io.IOException\r\n2019-05-27 06:47:06,047 [main           ] WARN  DefaultTypeConverter           - Overriding type converter from: org.apache.camel.support.SimpleTypeConverter@25a7fedf to: StaticMethodTypeConverter: public static java.io.InputStream org.apache.camel.component.cxf.converter.CxfConverter.soapMessageToInputStream(javax.xml.soap.SOAPMessage,org.apache.camel.Exchange) throws javax.xml.soap.SOAPException,java.io.IOException\r\n2019-05-27 06:47:06,047 [main           ] WARN  DefaultTypeConverter           - Overriding type converter from: org.apache.camel.support.SimpleTypeConverter@6361b799 to: StaticMethodTypeConverter: public static org.w3c.dom.NodeList org.apache.camel.component.cxf.converter.CxfPayloadConverter.cxfPayloadToNodeList(org.apache.camel.component.cxf.CxfPayload,org.apache.camel.Exchange)\r\n2019-05-27 06:47:06,047 [main           ] WARN  DefaultTypeConverter           - Overriding type converter from: org.apache.camel.support.SimpleTypeConverter@1b9d9a2b to: StaticMethodTypeConverter: public static org.w3c.dom.Node org.apache.camel.component.cxf.converter.CxfPayloadConverter.cxfPayLoadToNode(org.apache.camel.component.cxf.CxfPayload,org.apache.camel.Exchange)\r\n2019-05-27 06:47:06,047 [main           ] WARN  DefaultTypeConverter           - Overriding type converter from: org.apache.camel.support.SimpleTypeConverter@d919544 to: StaticMethodTypeConverter: public static org.apache.camel.component.cxf.CxfPayload org.apache.camel.component.cxf.converter.CxfPayloadConverter.nodeListToCxfPayload(org.w3c.dom.NodeList,org.apache.camel.Exchange)\r\n2019-05-27 06:47:06,047 [main           ] WARN  DefaultTypeConverter           - Overriding type converter from: org.apache.camel.support.SimpleTypeConverter@17dad32f to: StaticMethodTypeConverter: public static org.apache.camel.component.cxf.CxfPayload org.apache.camel.component.cxf.converter.CxfPayloadConverter.elementToCxfPayload(org.w3c.dom.Element,org.apache.camel.Exchange)\r\n2019-05-27 06:47:06,047 [main           ] WARN  DefaultTypeConverter           - Overriding type converter from: org.apache.camel.support.SimpleTypeConverter@79696332 to: StaticMethodTypeConverter: public static org.apache.camel.component.cxf.CxfPayload org.apache.camel.component.cxf.converter.CxfPayloadConverter.documentToCxfPayload(org.w3c.dom.Document,org.apache.camel.Exchange)\r\n2019-05-27 06:47:06,048 [main           ] WARN  DefaultTypeConverter           - Overriding type converter from: org.apache.camel.support.SimpleTypeConverter@ed2f2f6 to: StaticMethodTypeConverter: public static org.apache.camel.component.cxf.CxfPayload org.apache.camel.component.cxf.converter.CxfPayloadConverter.sourceToCxfPayload(javax.xml.transform.Source,org.apache.camel.Exchange)\r\n2019-05-27 06:47:06,048 [main           ] WARN  DefaultTypeConverter           - Overriding type converter from: org.apache.camel.support.SimpleTypeConverter@fe87ddd to: StaticMethodTypeConverter: public static org.apache.camel.StreamCache org.apache.camel.component.cxf.converter.CxfPayloadConverter.cxfPayLoadToStreamCache(org.apache.camel.component.cxf.CxfPayload,org.apache.camel.Exchange)\r\n2019-05-27 06:47:06,048 [main           ] WARN  DefaultTypeConverter           - Overriding type converter from: org.apache.camel.support.SimpleTypeConverter@4eea94a4 to: StaticMethodTypeConverter: public static javax.xml.transform.Source org.apache.camel.component.cxf.converter.CxfPayloadConverter.cxfPayLoadToSource(org.apache.camel.component.cxf.CxfPayload,org.apache.camel.Exchange)\r\n2019-05-27 06:47:06,048 [main           ] WARN  DefaultTypeConverter           - Overriding type converter from: org.apache.camel.support.SimpleTypeConverter@29be997f to: StaticMethodTypeConverter: public static java.io.InputStream org.apache.camel.component.file.GenericFileConverter.genericFileToInputStream(org.apache.camel.component.file.GenericFile,org.apache.camel.Exchange) throws java.io.IOException\r\n2019-05-27 06:47:06,048 [main           ] WARN  DefaultTypeConverter           - Overriding type converter from: org.apache.camel.support.SimpleTypeConverter@33eb6758 to: StaticMethodTypeConverter: public static java.lang.String org.apache.camel.component.file.GenericFileConverter.genericFileToString(org.apache.camel.component.file.GenericFile,org.apache.camel.Exchange) throws java.io.IOException,org.apache.camel.NoTypeConversionAvailableException\r\n2019-05-27 06:47:06,048 [main           ] WARN  DefaultTypeConverter           - Overriding type converter from: org.apache.camel.support.SimpleTypeConverter@f8a6243 to: StaticMethodTypeConverter: public static java.io.Serializable org.apache.camel.component.file.GenericFileConverter.genericFileToSerializable(org.apache.camel.component.file.GenericFile,org.apache.camel.Exchange) throws java.io.IOException\r\n2019-05-27 06:47:06,048 [main           ] WARN  DefaultTypeConverter           - Overriding type converter from: org.apache.camel.support.SimpleTypeConverter@7f9e8421 to: StaticMethodTypeConverter: public static org.apache.camel.StreamCache org.apache.camel.converter.stream.StreamCacheConverter.convertToStreamCache(java.io.ByteArrayInputStream,org.apache.camel.Exchange) throws java.io.IOException\r\n2019-05-27 06:47:06,048 [main           ] WARN  DefaultTypeConverter           - Overriding type converter from: org.apache.camel.support.SimpleTypeConverter@23da79eb to: StaticMethodTypeConverter: public static org.apache.camel.StreamCache org.apache.camel.converter.stream.StreamCacheConverter.convertToStreamCache(java.io.InputStream,org.apache.camel.Exchange) throws java.io.IOException\r\n2019-05-27 06:47:06,048 [main           ] WARN  DefaultTypeConverter           - Overriding type converter from: org.apache.camel.support.SimpleTypeConverter@168b4cb0 to: StaticMethodTypeConverter: public static org.apache.camel.StreamCache org.apache.camel.converter.stream.StreamCacheConverter.convertToStreamCache(org.apache.camel.converter.stream.CachedOutputStream,org.apache.camel.Exchange) throws java.io.IOException\r\n2019-05-27 06:47:06,048 [main           ] WARN  DefaultTypeConverter           - Overriding type converter from: org.apache.camel.support.SimpleTypeConverter@3e05586b to: StaticMethodTypeConverter: public static org.apache.camel.StreamCache org.apache.camel.converter.stream.StreamCacheConverter.convertToStreamCache(java.io.Reader,org.apache.camel.Exchange) throws java.io.IOException\r\n2019-05-27 06:47:06,048 [main           ] WARN  DefaultTypeConverter           - Overriding type converter from: org.apache.camel.support.SimpleTypeConverter@35b17c06 to: StaticMethodTypeConverter: public static org.apache.camel.StreamCache org.apache.camel.converter.stream.StreamCacheConverter.convertToStreamCache(javax.xml.transform.stream.StreamSource,org.apache.camel.Exchange) throws java.io.IOException\r\n2019-05-27 06:47:06,048 [main           ] WARN  DefaultTypeConverter           - Overriding type converter from: org.apache.camel.support.SimpleTypeConverter@45545e7a to: StaticMethodTypeConverter: public static org.apache.camel.StreamCache org.apache.camel.converter.stream.StreamCacheConverter.convertToStreamCache(org.apache.camel.StringSource)\r\n2019-05-27 06:47:06,048 [main           ] WARN  DefaultTypeConverter           - Overriding type converter from: org.apache.camel.support.SimpleTypeConverter@9f674ac to: StaticMethodTypeConverter: public static org.apache.camel.StreamCache org.apache.camel.converter.stream.StreamCacheConverter.convertToStreamCache(org.apache.camel.BytesSource)\r\n2019-05-27 06:47:06,048 [main           ] WARN  DefaultTypeConverter           - Overriding type converter from: org.apache.camel.support.SimpleTypeConverter@1da4b3f9 to: StaticMethodTypeConverter: public static org.apache.camel.StreamCache org.apache.camel.converter.stream.StreamCacheConverter.convertToStreamCache(javax.xml.transform.sax.SAXSource,org.apache.camel.Exchange) throws javax.xml.transform.TransformerException\r\n2019-05-27 06:47:06,048 [main           ] WARN  DefaultTypeConverter           - Overriding type converter from: org.apache.camel.support.SimpleTypeConverter@23cbbd07 to: StaticMethodTypeConverter: public static java.nio.ByteBuffer org.apache.camel.converter.stream.StreamCacheConverter.convertToByteBuffer(org.apache.camel.StreamCache,org.apache.camel.Exchange) throws java.io.IOException\r\n2019-05-27 06:47:06,048 [main           ] WARN  DefaultTypeConverter           - Overriding type converter from: org.apache.camel.support.SimpleTypeConverter@448b808a to: StaticMethodTypeConverter: public static java.io.Serializable org.apache.camel.converter.stream.StreamCacheConverter.convertToSerializable(org.apache.camel.StreamCache,org.apache.camel.Exchange) throws java.io.IOException\r\n2019-05-27 06:47:06,048 [main           ] WARN  DefaultTypeConverter           - Overriding type converter from: org.apache.camel.support.SimpleTypeConverter@7e62cfa3 to: StaticMethodTypeConverter: public static byte[] org.apache.camel.converter.stream.StreamCacheConverter.convertToByteArray(org.apache.camel.StreamCache,org.apache.camel.Exchange) throws java.io.IOException\r\n2019-05-27 06:47:06,049 [main           ] WARN  DefaultTypeConverter           - Overriding type converter from: StaticMethodTypeConverter: public static org.apache.camel.StreamCache org.apache.camel.converter.stream.StreamCacheConverter.convertToStreamCache(java.io.ByteArrayInputStream,org.apache.camel.Exchange) throws java.io.IOException to: StaticMethodTypeConverter: public static org.apache.camel.StreamCache org.apache.camel.converter.stream.StreamCacheConverter.convertToStreamCache(java.io.ByteArrayInputStream,org.apache.camel.Exchange) throws java.io.IOException\r\n2019-05-27 06:47:06,049 [main           ] WARN  DefaultTypeConverter           - Overriding type converter from: StaticMethodTypeConverter: public static org.apache.camel.StreamCache org.apache.camel.converter.stream.StreamCacheConverter.convertToStreamCache(java.io.InputStream,org.apache.camel.Exchange) throws java.io.IOException to: StaticMethodTypeConverter: public static org.apache.camel.StreamCache org.apache.camel.converter.stream.StreamCacheConverter.convertToStreamCache(java.io.InputStream,org.apache.camel.Exchange) throws java.io.IOException\r\n2019-05-27 06:47:06,049 [main           ] WARN  DefaultTypeConverter           - Overriding type converter from: StaticMethodTypeConverter: public static org.apache.camel.StreamCache org.apache.camel.converter.stream.StreamCacheConverter.convertToStreamCache(org.apache.camel.converter.stream.CachedOutputStream,org.apache.camel.Exchange) throws java.io.IOException to: StaticMethodTypeConverter: public static org.apache.camel.StreamCache org.apache.camel.converter.stream.StreamCacheConverter.convertToStreamCache(org.apache.camel.converter.stream.CachedOutputStream,org.apache.camel.Exchange) throws java.io.IOException\r\n2019-05-27 06:47:06,049 [main           ] WARN  DefaultTypeConverter           - Overriding type converter from: StaticMethodTypeConverter: public static org.apache.camel.StreamCache org.apache.camel.converter.stream.StreamCacheConverter.convertToStreamCache(java.io.Reader,org.apache.camel.Exchange) throws java.io.IOException to: StaticMethodTypeConverter: public static org.apache.camel.StreamCache org.apache.camel.converter.stream.StreamCacheConverter.convertToStreamCache(java.io.Reader,org.apache.camel.Exchange) throws java.io.IOException\r\n2019-05-27 06:47:06,049 [main           ] WARN  DefaultTypeConverter           - Overriding type converter from: StaticMethodTypeConverter: public static org.apache.camel.StreamCache org.apache.camel.converter.stream.StreamCacheConverter.convertToStreamCache(javax.xml.transform.stream.StreamSource,org.apache.camel.Exchange) throws java.io.IOException to: StaticMethodTypeConverter: public static org.apache.camel.StreamCache org.apache.camel.converter.stream.StreamCacheConverter.convertToStreamCache(javax.xml.transform.stream.StreamSource,org.apache.camel.Exchange) throws java.io.IOException\r\n2019-05-27 06:47:06,049 [main           ] WARN  DefaultTypeConverter           - Overriding type converter from: StaticMethodTypeConverter: public static org.apache.camel.StreamCache org.apache.camel.converter.stream.StreamCacheConverter.convertToStreamCache(org.apache.camel.StringSource) to: StaticMethodTypeConverter: public static org.apache.camel.StreamCache org.apache.camel.converter.stream.StreamCacheConverter.convertToStreamCache(org.apache.camel.StringSource)\r\n2019-05-27 06:47:06,049 [main           ] WARN  DefaultTypeConverter           - Overriding type converter from: StaticMethodTypeConverter: public static org.apache.camel.StreamCache org.apache.camel.converter.stream.StreamCacheConverter.convertToStreamCache(org.apache.camel.BytesSource) to: StaticMethodTypeConverter: public static org.apache.camel.StreamCache org.apache.camel.converter.stream.StreamCacheConverter.convertToStreamCache(org.apache.camel.BytesSource)\r\n2019-05-27 06:47:06,050 [main           ] WARN  DefaultTypeConverter           - Overriding type converter from: StaticMethodTypeConverter: public static org.apache.camel.StreamCache org.apache.camel.converter.stream.StreamCacheConverter.convertToStreamCache(javax.xml.transform.sax.SAXSource,org.apache.camel.Exchange) throws javax.xml.transform.TransformerException to: StaticMethodTypeConverter: public static org.apache.camel.StreamCache org.apache.camel.converter.stream.StreamCacheConverter.convertToStreamCache(javax.xml.transform.sax.SAXSource,org.apache.camel.Exchange) throws javax.xml.transform.TransformerException\r\n2019-05-27 06:47:06,050 [main           ] WARN  DefaultTypeConverter           - Overriding type converter from: StaticMethodTypeConverter: public static java.nio.ByteBuffer org.apache.camel.converter.stream.StreamCacheConverter.convertToByteBuffer(org.apache.camel.StreamCache,org.apache.camel.Exchange) throws java.io.IOException to: StaticMethodTypeConverter: public static java.nio.ByteBuffer org.apache.camel.converter.stream.StreamCacheConverter.convertToByteBuffer(org.apache.camel.StreamCache,org.apache.camel.Exchange) throws java.io.IOException\r\n2019-05-27 06:47:06,050 [main           ] WARN  DefaultTypeConverter           - Overriding type converter from: StaticMethodTypeConverter: public static java.io.Serializable org.apache.camel.converter.stream.StreamCacheConverter.convertToSerializable(org.apache.camel.StreamCache,org.apache.camel.Exchange) throws java.io.IOException to: StaticMethodTypeConverter: public static java.io.Serializable org.apache.camel.converter.stream.StreamCacheConverter.convertToSerializable(org.apache.camel.StreamCache,org.apache.camel.Exchange) throws java.io.IOException\r\n2019-05-27 06:47:06,050 [main           ] WARN  DefaultTypeConverter           - Overriding type converter from: StaticMethodTypeConverter: public static byte[] org.apache.camel.converter.stream.StreamCacheConverter.convertToByteArray(org.apache.camel.StreamCache,org.apache.camel.Exchange) throws java.io.IOException to: StaticMethodTypeConverter: public static byte[] org.apache.camel.converter.stream.StreamCacheConverter.convertToByteArray(org.apache.camel.StreamCache,org.apache.camel.Exchange) throws java.io.IOException"
    },
    {
      "key":"CAMEL-13580",
      "title":"camel-zookeeper - Deprecate route master\/slave policy",
      "description":"As the camel-zookeeper-master component is better at handling this. So lets deprecate this in Camel 2.x, and remove in 3.0",
      "assignee":"davsclaus",
      "type":"Improvement",
      "priority":"Major",
      "status":"Resolved",
      "text":"camel-zookeeper - Deprecate route master\/slave policy As the camel-zookeeper-master component is better at handling this. So lets deprecate this in Camel 2.x, and remove in 3.0"
    },
    {
      "key":"CAMEL-13569",
      "title":"JndiContext - Remove old bean binding",
      "description":"There is some old code that allows to define in jndi.properties beans with .class etc to create these beans via basic class loading that was from Camel 1.x time and nobody uses.\r\n\r\nThis should be removed",
      "assignee":"davsclaus",
      "type":"Improvement",
      "priority":"Major",
      "status":"Resolved",
      "text":"JndiContext - Remove old bean binding There is some old code that allows to define in jndi.properties beans with .class etc to create these beans via basic class loading that was from Camel 1.x time and nobody uses.\r\n\r\nThis should be removed"
    },
    {
      "key":"CAMEL-13566",
      "title":"IntrospectionSupport - Remove old legacy JDK PropertyEditor",
      "description":"There is some old code using JDK\r\n\r\nPropertyEditor editor = PropertyEditorManager.findEditor(type);\r\n\r\nBut this is no longer in use as we really use camel's type converter. That above is also slow and not thread safe and was intended for java swing\/beans stuff and some cruft from very old times. Lets try to get rid of it.",
      "assignee":"davsclaus",
      "type":"Improvement",
      "priority":"Major",
      "status":"Resolved",
      "text":"IntrospectionSupport - Remove old legacy JDK PropertyEditor There is some old code using JDK\r\n\r\nPropertyEditor editor = PropertyEditorManager.findEditor(type);\r\n\r\nBut this is no longer in use as we really use camel's type converter. That above is also slow and not thread safe and was intended for java swing\/beans stuff and some cruft from very old times. Lets try to get rid of it."
    },
    {
      "key":"CAMEL-13561",
      "title":"camel-hystrix - HystrixBadRequestException is swallowed",
      "description":"CAMEL-13066 fixed a problem\u00a0that HystrixBadRequestExceptions caused the fallback processor being executed.\r\n\r\nHowever, it seems that\u00a0due to this fix the exception is simply thrown away and the route proceeds as if no error has occurred. This is certainly not the intended behavior.\r\n\r\nAs I understand it, the\u00a0HystrixBadRequestExceptions should simply be thrown out of the HystrixProcessor, but without any fallback processor being triggered or circuit being opened",
      "assignee":"davsclaus",
      "type":"Bug",
      "priority":"Major",
      "status":"Resolved",
      "text":"camel-hystrix - HystrixBadRequestException is swallowed CAMEL-13066 fixed a problem that HystrixBadRequestExceptions caused the fallback processor being executed.\r\n\r\nHowever, it seems that due to this fix the exception is simply thrown away and the route proceeds as if no error has occurred. This is certainly not the intended behavior.\r\n\r\nAs I understand it, the HystrixBadRequestExceptions should simply be thrown out of the HystrixProcessor, but without any fallback processor being triggered or circuit being opened"
    },
    {
      "key":"CAMEL-13557",
      "title":"Support for nested properties binding",
      "description":"As today properties binding does not work for nested objects so assuming I have a class like:\r\n\r\n{code:java}\r\nclass MyComponent {\r\n    \r\n    public void setFoo(String foo) {\r\n        this.foo = foo;\r\n    }\r\n\r\n    public String getFoo() {\r\n        return foo;\r\n    }\r\n\r\n    public void setConfiguration(Configuration conf) {\r\n        this.conf = conf;\r\n    }\r\n\r\n    public Configuration getConfiguration() {\r\n        return conf;\r\n    }\r\n\r\n    static class Configuration {\r\n    \r\n        public void setBar(String bar) {\r\n            this.bar = bar\r\n        }\r\n\r\n        public String getBar() {\r\n            return bar\r\n        }\r\n    }\r\n}\r\n{code}\r\n\r\nAnd a set of properties like:\r\n\r\n{code}\r\nmyComponent.foo = \"foo\"\r\nmyComponent.conf.bar = \"bar\"\r\n{code}\r\n\r\nThen only MyComponent.foo will be set but it would be nice if the binding framework could navigate the property using dot notation and set any dependent object.\r\n",
      "assignee":"davsclaus",
      "type":"New Feature",
      "priority":"Major",
      "status":"Resolved",
      "text":"Support for nested properties binding As today properties binding does not work for nested objects so assuming I have a class like:\r\n\r\n{code:java}\r\nclass MyComponent {\r\n    \r\n    public void setFoo(String foo) {\r\n        this.foo = foo;\r\n    }\r\n\r\n    public String getFoo() {\r\n        return foo;\r\n    }\r\n\r\n    public void setConfiguration(Configuration conf) {\r\n        this.conf = conf;\r\n    }\r\n\r\n    public Configuration getConfiguration() {\r\n        return conf;\r\n    }\r\n\r\n    static class Configuration {\r\n    \r\n        public void setBar(String bar) {\r\n            this.bar = bar\r\n        }\r\n\r\n        public String getBar() {\r\n            return bar\r\n        }\r\n    }\r\n}\r\n{code}\r\n\r\nAnd a set of properties like:\r\n\r\n{code}\r\nmyComponent.foo = \"foo\"\r\nmyComponent.conf.bar = \"bar\"\r\n{code}\r\n\r\nThen only MyComponent.foo will be set but it would be nice if the binding framework could navigate the property using dot notation and set any dependent object.\r\n"
    },
    {
      "key":"CAMEL-13556",
      "title":"Camel main - Duration max messages may not work",
      "description":"Looks like max duration = 1 will not shutdown the jvm. Also the idle checker background thread is stopping camel from the same thread as itself so its own thread pool cannot shutdown nicely.",
      "assignee":"davsclaus",
      "type":"Bug",
      "priority":"Major",
      "status":"Resolved",
      "text":"Camel main - Duration max messages may not work Looks like max duration = 1 will not shutdown the jvm. Also the idle checker background thread is stopping camel from the same thread as itself so its own thread pool cannot shutdown nicely."
    },
    {
      "key":"CAMEL-13555",
      "title":"Producer and consumer template\/cache should check if camel is started when being used",
      "description":"When sending via producer template etc then you can send to endpoints even if camel is stopped \/ not started etc. We should add a check for this as camel would ideally need to be started first to ensure the sending works correctly.\r\n\r\n",
      "assignee":"davsclaus",
      "type":"Improvement",
      "priority":"Major",
      "status":"Resolved",
      "text":"Producer and consumer template\/cache should check if camel is started when being used When sending via producer template etc then you can send to endpoints even if camel is stopped \/ not started etc. We should add a check for this as camel would ideally need to be started first to ensure the sending works correctly.\r\n\r\n"
    },
    {
      "key":"CAMEL-13554",
      "title":"Using \"route1\" as a route id produces infinite loop",
      "description":"Steps:\r\n# Start a Camel context.\r\n# Add a route through RouteBuilder with id *\"route1\"* (reserved id).\r\n# Attempt to add a second route with no id. The method enters an infinite loop.\u00a0\r\n\r\nExample code that reproduces the problem:\r\n{code:java}\r\npackage com.paytrue.swakka;\r\n\r\nimport org.apache.camel.builder.RouteBuilder;\r\nimport org.apache.camel.impl.DefaultCamelContext;\r\n\r\npublic class InfLoopMain {\r\n\r\n\u00a0\u00a0\u00a0 public static void main(final String[] args) throws Exception {\r\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 final DefaultCamelContext camelContext = new DefaultCamelContext();\r\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 camelContext.start();\r\n\r\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 final RouteBuilder route1 = new RouteBuilder() {\r\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 @Override\r\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 public void configure() {\r\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 from(\"direct:in1\")\r\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 .id(\"route1\") \/\/ Note the name\r\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 .to(\"mock:test1\");\r\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 }\r\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 };\r\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 camelContext.addRoutes(route1);\r\n\r\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 final RouteBuilder route2 = new RouteBuilder() {\r\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 @Override\r\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 public void configure() {\r\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 from(\"direct:in2\")\r\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 .to(\"mock:test2\");\r\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 }\r\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 };\r\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 \/\/ Infinite loop\r\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 camelContext.addRoutes(route2);\r\n\u00a0\u00a0\u00a0 }\r\n}\r\n{code}\r\n\u00a0",
      "assignee":"davsclaus",
      "type":"Bug",
      "priority":"Minor",
      "status":"Resolved",
      "text":"Using \"route1\" as a route id produces infinite loop Steps:\r\n# Start a Camel context.\r\n# Add a route through RouteBuilder with id *\"route1\"* (reserved id).\r\n# Attempt to add a second route with no id. The method enters an infinite loop. \r\n\r\nExample code that reproduces the problem:\r\n{code:java}\r\npackage com.paytrue.swakka;\r\n\r\nimport org.apache.camel.builder.RouteBuilder;\r\nimport org.apache.camel.impl.DefaultCamelContext;\r\n\r\npublic class InfLoopMain {\r\n\r\n    public static void main(final String[] args) throws Exception {\r\n        final DefaultCamelContext camelContext = new DefaultCamelContext();\r\n        camelContext.start();\r\n\r\n        final RouteBuilder route1 = new RouteBuilder() {\r\n            @Override\r\n            public void configure() {\r\n                from(\"direct:in1\")\r\n                    .id(\"route1\") \/\/ Note the name\r\n                    .to(\"mock:test1\");\r\n            }\r\n        };\r\n        camelContext.addRoutes(route1);\r\n\r\n        final RouteBuilder route2 = new RouteBuilder() {\r\n            @Override\r\n            public void configure() {\r\n                from(\"direct:in2\")\r\n                    .to(\"mock:test2\");\r\n            }\r\n        };\r\n        \/\/ Infinite loop\r\n        camelContext.addRoutes(route2);\r\n    }\r\n}\r\n{code}\r\n "
    },
    {
      "key":"CAMEL-13551",
      "title":"camel3 - Some of the SPI can be static services when there can only be one configured",
      "description":"A number of configurations for packagescan class resolver and node id factory and whatnot are essentially a single instance that can be configured, so we can leverage this fact and make them StaticService if they are just defined as a Service today.",
      "assignee":"davsclaus",
      "type":"Improvement",
      "priority":"Major",
      "status":"Resolved",
      "text":"camel3 - Some of the SPI can be static services when there can only be one configured A number of configurations for packagescan class resolver and node id factory and whatnot are essentially a single instance that can be configured, so we can leverage this fact and make them StaticService if they are just defined as a Service today."
    },
    {
      "key":"CAMEL-13549",
      "title":"expectedHeaderReceived should failed when no message is received",
      "description":"This test should fail:\r\n{code:java}\r\nimport org.apache.camel.RoutesBuilder;\r\nimport org.apache.camel.builder.RouteBuilder;\r\nimport org.apache.camel.component.mock.MockEndpoint;\r\nimport org.apache.camel.test.junit4.CamelTestSupport;\r\nimport org.assertj.core.api.Assertions;\r\nimport org.junit.Test;\r\n\r\npublic class MyRouteTest extends CamelTestSupport {\r\n\r\n  private static final String ROUTE_ID = \"mytest\";\r\n\r\n  @Override\r\n  public RoutesBuilder createRouteBuilder() throws Exception {\r\n    return new RouteBuilder() {\r\n\r\n      @Override\r\n      public void configure() throws Exception {\r\n        from(\"direct:foo\")\r\n          .id(ROUTE_ID)\r\n          .to(\"mock:extract\");\r\n      }\r\n    };\r\n  }\r\n\r\n  @Test\r\n  public void shouldFail() throws InterruptedException {\r\n    \/\/ given\r\n    final MockEndpoint mock = getMockEndpoint(\"mock:extract\");\r\n\r\n    \/\/ declare\r\n    mock.expectedHeaderReceived(\"foo\", \"bar\");\r\n\r\n    \/\/ when\r\n\/\/template.sendBody(\"direct:foo\", \"test\");\r\n\r\n    \/\/ then\r\n    mock.assertIsSatisfied();\r\n  }\r\n}\r\n{code}\r\n\r\nBecause we were expecting some headers, but none headers were received",
      "assignee":"davsclaus",
      "type":"Bug",
      "priority":"Minor",
      "status":"Resolved",
      "text":"expectedHeaderReceived should failed when no message is received This test should fail:\r\n{code:java}\r\nimport org.apache.camel.RoutesBuilder;\r\nimport org.apache.camel.builder.RouteBuilder;\r\nimport org.apache.camel.component.mock.MockEndpoint;\r\nimport org.apache.camel.test.junit4.CamelTestSupport;\r\nimport org.assertj.core.api.Assertions;\r\nimport org.junit.Test;\r\n\r\npublic class MyRouteTest extends CamelTestSupport {\r\n\r\n  private static final String ROUTE_ID = \"mytest\";\r\n\r\n  @Override\r\n  public RoutesBuilder createRouteBuilder() throws Exception {\r\n    return new RouteBuilder() {\r\n\r\n      @Override\r\n      public void configure() throws Exception {\r\n        from(\"direct:foo\")\r\n          .id(ROUTE_ID)\r\n          .to(\"mock:extract\");\r\n      }\r\n    };\r\n  }\r\n\r\n  @Test\r\n  public void shouldFail() throws InterruptedException {\r\n    \/\/ given\r\n    final MockEndpoint mock = getMockEndpoint(\"mock:extract\");\r\n\r\n    \/\/ declare\r\n    mock.expectedHeaderReceived(\"foo\", \"bar\");\r\n\r\n    \/\/ when\r\n\/\/template.sendBody(\"direct:foo\", \"test\");\r\n\r\n    \/\/ then\r\n    mock.assertIsSatisfied();\r\n  }\r\n}\r\n{code}\r\n\r\nBecause we were expecting some headers, but none headers were received"
    },
    {
      "key":"CAMEL-13544",
      "title":"adviceWith in test should be fired before routes are started",
      "description":"This test should pass:\r\n{code:java}\r\nimport java.util.concurrent.atomic.AtomicInteger;\r\n\r\nimport org.apache.camel.CamelContext;\r\nimport org.apache.camel.RoutesBuilder;\r\nimport org.apache.camel.builder.AdviceWithRouteBuilder;\r\nimport org.apache.camel.builder.RouteBuilder;\r\nimport org.apache.camel.component.mock.MockEndpoint;\r\nimport org.apache.camel.test.junit4.CamelTestSupport;\r\nimport org.assertj.core.api.Assertions;\r\nimport org.junit.Test;\r\n\r\npublic class MyRouteTest extends CamelTestSupport {\r\n\r\n  private static final String ROUTE_ID = \"mytest\";\r\n\r\n  private final AtomicInteger counter = new AtomicInteger(0);\r\n\r\n  @Override\r\n  public RoutesBuilder createRouteBuilder() throws Exception {\r\n    return new RouteBuilder() {\r\n\r\n      @Override\r\n      public void configure() throws Exception {\r\n        from(\"quartz2:\/\/test?cron=0\/1+*+*+*+*+?\")\r\n          .id(ROUTE_ID)\r\n          .bean(counter, \"incrementAndGet\", false)\r\n          .to(\"stream:out\");\r\n      }\r\n    };\r\n  }\r\n\r\n  @Override\r\n  public void setUp() throws Exception {\r\n      super.setUp();\r\n      final CamelContext camelContext = context();\r\n      camelContext.getRouteDefinition(ROUTE_ID)\r\n        .adviceWith(camelContext, new AdviceWithRouteBuilder() {\r\n          @Override\r\n          public void configure() throws Exception {\r\n            replaceFromWith(\"direct:quartz\");\r\n            weaveAddLast().to(\"mock:extract\");\r\n          }\r\n        });\r\n  }\r\n\r\n  @Test\r\n  public void shouldReceive2Messages() throws InterruptedException {\r\n    \/\/ given\r\n    final MockEndpoint quartzMock = getMockEndpoint(\"mock:extract\");\r\n\r\n    \/\/ declare\r\n    quartzMock.expectedMessageCount(2);\r\n\r\n    \/\/ when\r\n    template.sendBody(\"direct:quartz\", \"tick\");\r\n    template.sendBody(\"direct:quartz\", \"tick\");\r\n\r\n    \/\/ then\r\n    quartzMock.assertIsSatisfied();\r\n    Assertions.assertThat(counter).hasValue(2);\r\n  }\r\n}\r\n{code}\r\n\r\nUnfortunatelly, before adviceWith is invoked, quartz sends already two messages",
      "assignee":"davsclaus",
      "type":"Bug",
      "priority":"Major",
      "status":"Resolved",
      "text":"adviceWith in test should be fired before routes are started This test should pass:\r\n{code:java}\r\nimport java.util.concurrent.atomic.AtomicInteger;\r\n\r\nimport org.apache.camel.CamelContext;\r\nimport org.apache.camel.RoutesBuilder;\r\nimport org.apache.camel.builder.AdviceWithRouteBuilder;\r\nimport org.apache.camel.builder.RouteBuilder;\r\nimport org.apache.camel.component.mock.MockEndpoint;\r\nimport org.apache.camel.test.junit4.CamelTestSupport;\r\nimport org.assertj.core.api.Assertions;\r\nimport org.junit.Test;\r\n\r\npublic class MyRouteTest extends CamelTestSupport {\r\n\r\n  private static final String ROUTE_ID = \"mytest\";\r\n\r\n  private final AtomicInteger counter = new AtomicInteger(0);\r\n\r\n  @Override\r\n  public RoutesBuilder createRouteBuilder() throws Exception {\r\n    return new RouteBuilder() {\r\n\r\n      @Override\r\n      public void configure() throws Exception {\r\n        from(\"quartz2:\/\/test?cron=0\/1+*+*+*+*+?\")\r\n          .id(ROUTE_ID)\r\n          .bean(counter, \"incrementAndGet\", false)\r\n          .to(\"stream:out\");\r\n      }\r\n    };\r\n  }\r\n\r\n  @Override\r\n  public void setUp() throws Exception {\r\n      super.setUp();\r\n      final CamelContext camelContext = context();\r\n      camelContext.getRouteDefinition(ROUTE_ID)\r\n        .adviceWith(camelContext, new AdviceWithRouteBuilder() {\r\n          @Override\r\n          public void configure() throws Exception {\r\n            replaceFromWith(\"direct:quartz\");\r\n            weaveAddLast().to(\"mock:extract\");\r\n          }\r\n        });\r\n  }\r\n\r\n  @Test\r\n  public void shouldReceive2Messages() throws InterruptedException {\r\n    \/\/ given\r\n    final MockEndpoint quartzMock = getMockEndpoint(\"mock:extract\");\r\n\r\n    \/\/ declare\r\n    quartzMock.expectedMessageCount(2);\r\n\r\n    \/\/ when\r\n    template.sendBody(\"direct:quartz\", \"tick\");\r\n    template.sendBody(\"direct:quartz\", \"tick\");\r\n\r\n    \/\/ then\r\n    quartzMock.assertIsSatisfied();\r\n    Assertions.assertThat(counter).hasValue(2);\r\n  }\r\n}\r\n{code}\r\n\r\nUnfortunatelly, before adviceWith is invoked, quartz sends already two messages"
    },
    {
      "key":"CAMEL-13540",
      "title":"isUseAdviceWith causes test to hang",
      "description":"Having this test:\r\n{code:java}\r\nimport org.apache.camel.CamelContext;\r\nimport org.apache.camel.RoutesBuilder;\r\nimport org.apache.camel.builder.AdviceWithRouteBuilder;\r\nimport org.apache.camel.builder.RouteBuilder;\r\nimport org.apache.camel.component.mock.MockEndpoint;\r\nimport org.apache.camel.test.junit4.CamelTestSupport;\r\nimport org.junit.Test;\r\n\r\npublic class MyRouteTest extends CamelTestSupport {\r\n\r\n  private static final String ROUTE_ID = \"mytest\";\r\n\r\n  @Override\r\n  public RoutesBuilder createRouteBuilder() throws Exception {\r\n    return new RouteBuilder() {\r\n\r\n      @Override\r\n      public void configure() throws Exception {\r\n        from(\"direct:mytest\")\r\n          .id(ROUTE_ID)\r\n          .to(\"stream:out\");\r\n      }\r\n    };\r\n  }\r\n\r\n  @Override\r\n  public void setUp() throws Exception {\r\n      super.setUp();\r\n      final CamelContext camelContext = context();\r\n      camelContext.getRouteDefinition(ROUTE_ID)\r\n        .adviceWith(camelContext, new AdviceWithRouteBuilder() {\r\n          @Override\r\n          public void configure() throws Exception {\r\n            weaveAddLast().to(\"mock:extract\");\r\n          }\r\n        });\r\n  }\r\n\r\n  @Override\r\n  public boolean isUseAdviceWith() {\r\n      return true; \/\/ <- here is the problem\r\n  }\r\n\r\n  @Test\r\n  public void shouldFire() throws InterruptedException {\r\n    \/\/ given\r\n    final MockEndpoint myMock = getMockEndpoint(\"mock:extract\");\r\n\r\n    myMock.expectedMessageCount(1);\r\n    myMock.expectedBodiesReceived(\"test\");\r\n\r\n    \/\/ when\r\n    template.sendBody(\"direct:mytest\", \"test\");\r\n\r\n    \/\/ then\r\n    myMock.assertIsSatisfied();\r\n  }\r\n}\r\n{code}\r\n\u00a0Causes Camel to hang",
      "assignee":"davsclaus",
      "type":"Improvement",
      "priority":"Minor",
      "status":"Resolved",
      "text":"isUseAdviceWith causes test to hang Having this test:\r\n{code:java}\r\nimport org.apache.camel.CamelContext;\r\nimport org.apache.camel.RoutesBuilder;\r\nimport org.apache.camel.builder.AdviceWithRouteBuilder;\r\nimport org.apache.camel.builder.RouteBuilder;\r\nimport org.apache.camel.component.mock.MockEndpoint;\r\nimport org.apache.camel.test.junit4.CamelTestSupport;\r\nimport org.junit.Test;\r\n\r\npublic class MyRouteTest extends CamelTestSupport {\r\n\r\n  private static final String ROUTE_ID = \"mytest\";\r\n\r\n  @Override\r\n  public RoutesBuilder createRouteBuilder() throws Exception {\r\n    return new RouteBuilder() {\r\n\r\n      @Override\r\n      public void configure() throws Exception {\r\n        from(\"direct:mytest\")\r\n          .id(ROUTE_ID)\r\n          .to(\"stream:out\");\r\n      }\r\n    };\r\n  }\r\n\r\n  @Override\r\n  public void setUp() throws Exception {\r\n      super.setUp();\r\n      final CamelContext camelContext = context();\r\n      camelContext.getRouteDefinition(ROUTE_ID)\r\n        .adviceWith(camelContext, new AdviceWithRouteBuilder() {\r\n          @Override\r\n          public void configure() throws Exception {\r\n            weaveAddLast().to(\"mock:extract\");\r\n          }\r\n        });\r\n  }\r\n\r\n  @Override\r\n  public boolean isUseAdviceWith() {\r\n      return true; \/\/ <- here is the problem\r\n  }\r\n\r\n  @Test\r\n  public void shouldFire() throws InterruptedException {\r\n    \/\/ given\r\n    final MockEndpoint myMock = getMockEndpoint(\"mock:extract\");\r\n\r\n    myMock.expectedMessageCount(1);\r\n    myMock.expectedBodiesReceived(\"test\");\r\n\r\n    \/\/ when\r\n    template.sendBody(\"direct:mytest\", \"test\");\r\n\r\n    \/\/ then\r\n    myMock.assertIsSatisfied();\r\n  }\r\n}\r\n{code}\r\n Causes Camel to hang"
    },
    {
      "key":"CAMEL-13536",
      "title":"StackOverflow when using bean(this)",
      "description":"This testcase\r\n{code:java}\r\nimport org.apache.camel.CamelContext;\r\nimport org.apache.camel.Exchange;\r\nimport org.apache.camel.RoutesBuilder;\r\nimport org.apache.camel.builder.AdviceWithRouteBuilder;\r\nimport org.apache.camel.builder.RouteBuilder;\r\nimport org.apache.camel.component.mock.MockEndpoint;\r\nimport org.apache.camel.test.junit4.CamelTestSupport;\r\nimport org.junit.Test;\r\n\r\npublic class MyRouteTest extends CamelTestSupport {\r\n\r\nprivate static final String ROUTE_ID = \"mytest\";\r\n\r\n@Override\r\nprotected RoutesBuilder createRouteBuilder() throws Exception {\r\n  return new RouteBuilder() {\r\n\r\n    @Override\r\n    public void configure() throws Exception {\r\n      from(\"direct:mytest\")\r\n      .id(ROUTE_ID)\r\n      .bean(this, \"hello\", false) \/\/ <- here is the problem\r\n      .to(\"stream:out\");\r\n    }\r\n\r\n    public void hello(final Exchange exchange) {\r\n    }\r\n  };\r\n}\r\n\r\n@Override\r\npublic void setUp() throws Exception {\r\n  super.setUp();\r\n  final CamelContext camelContext = context();\r\n  camelContext.getRouteDefinition(ROUTE_ID)\r\n    .adviceWith(camelContext, new AdviceWithRouteBuilder() {\r\n    @Override\r\n    public void configure() throws Exception {\r\n  \u00a0 \u00a0 weaveAddLast().to(\"mock:extract\");\r\n    }\r\n  });\r\n}\r\n\r\n@Override\r\npublic boolean isUseAdviceWith() {\r\n  return true;\r\n}\r\n\r\n@Test\r\npublic void shouldFire() throws InterruptedException {\r\n  \/\/ given\r\n  final MockEndpoint myMock = getMockEndpoint(\"mock:extract\");\r\n\r\n  myMock.expectedMessageCount(1);\r\n\r\n  \/\/ when\r\n  template.sendBody(\"direct:mytest\", \"test\");\r\n\r\n  \/\/ then\r\n  myMock.assertIsSatisfied();\r\n}\r\n}\r\n{code}\r\nThrows\r\n{code:java}\r\njava.lang.StackOverflowError\r\nat java.util.AbstractCollection.toString(Unknown Source)\r\nat java.lang.String.valueOf(Unknown Source)\r\nat java.lang.StringBuilder.append(Unknown Source)\r\nat org.apache.camel.model.RoutesDefinition.toString(RoutesDefinition.java:64)\r\nat org.apache.camel.builder.RouteBuilder.toString(RouteBuilder.java:74)\r\nat org.apache.camel.model.BeanDefinition.description(BeanDefinition.java:89)\r\nat org.apache.camel.model.BeanDefinition.toString(BeanDefinition.java:78)\r\nat java.lang.String.valueOf(Unknown Source)\r\n{code}\r\n\u00a0",
      "assignee":"davsclaus",
      "type":"Bug",
      "priority":"Minor",
      "status":"Resolved",
      "text":"StackOverflow when using bean(this) This testcase\r\n{code:java}\r\nimport org.apache.camel.CamelContext;\r\nimport org.apache.camel.Exchange;\r\nimport org.apache.camel.RoutesBuilder;\r\nimport org.apache.camel.builder.AdviceWithRouteBuilder;\r\nimport org.apache.camel.builder.RouteBuilder;\r\nimport org.apache.camel.component.mock.MockEndpoint;\r\nimport org.apache.camel.test.junit4.CamelTestSupport;\r\nimport org.junit.Test;\r\n\r\npublic class MyRouteTest extends CamelTestSupport {\r\n\r\nprivate static final String ROUTE_ID = \"mytest\";\r\n\r\n@Override\r\nprotected RoutesBuilder createRouteBuilder() throws Exception {\r\n  return new RouteBuilder() {\r\n\r\n    @Override\r\n    public void configure() throws Exception {\r\n      from(\"direct:mytest\")\r\n      .id(ROUTE_ID)\r\n      .bean(this, \"hello\", false) \/\/ <- here is the problem\r\n      .to(\"stream:out\");\r\n    }\r\n\r\n    public void hello(final Exchange exchange) {\r\n    }\r\n  };\r\n}\r\n\r\n@Override\r\npublic void setUp() throws Exception {\r\n  super.setUp();\r\n  final CamelContext camelContext = context();\r\n  camelContext.getRouteDefinition(ROUTE_ID)\r\n    .adviceWith(camelContext, new AdviceWithRouteBuilder() {\r\n    @Override\r\n    public void configure() throws Exception {\r\n      weaveAddLast().to(\"mock:extract\");\r\n    }\r\n  });\r\n}\r\n\r\n@Override\r\npublic boolean isUseAdviceWith() {\r\n  return true;\r\n}\r\n\r\n@Test\r\npublic void shouldFire() throws InterruptedException {\r\n  \/\/ given\r\n  final MockEndpoint myMock = getMockEndpoint(\"mock:extract\");\r\n\r\n  myMock.expectedMessageCount(1);\r\n\r\n  \/\/ when\r\n  template.sendBody(\"direct:mytest\", \"test\");\r\n\r\n  \/\/ then\r\n  myMock.assertIsSatisfied();\r\n}\r\n}\r\n{code}\r\nThrows\r\n{code:java}\r\njava.lang.StackOverflowError\r\nat java.util.AbstractCollection.toString(Unknown Source)\r\nat java.lang.String.valueOf(Unknown Source)\r\nat java.lang.StringBuilder.append(Unknown Source)\r\nat org.apache.camel.model.RoutesDefinition.toString(RoutesDefinition.java:64)\r\nat org.apache.camel.builder.RouteBuilder.toString(RouteBuilder.java:74)\r\nat org.apache.camel.model.BeanDefinition.description(BeanDefinition.java:89)\r\nat org.apache.camel.model.BeanDefinition.toString(BeanDefinition.java:78)\r\nat java.lang.String.valueOf(Unknown Source)\r\n{code}\r\n "
    },
    {
      "key":"CAMEL-13535",
      "title":"Camel main - Allow to configure supervising route controller",
      "description":"Like you can do in SB to setup advanced route startup where Camel can retry starting routes etc.",
      "assignee":"davsclaus",
      "type":"Improvement",
      "priority":"Major",
      "status":"Resolved",
      "text":"Camel main - Allow to configure supervising route controller Like you can do in SB to setup advanced route startup where Camel can retry starting routes etc."
    },
    {
      "key":"CAMEL-13534",
      "title":"Simple language - Add colon as alternative syntax style",
      "description":"The simple syntax can maybe be improved a bit when its a function such as env or sysenv or other functions vs OGNL method calls on body, headers etc that uses dot style.\r\n\r\nEg \r\n{code}\r\n${sysenv.FOO}\r\n{code}\r\nvs\r\n{code}\r\n${env:FOO}\r\n{code}\r\n\r\nIt may feel a bit more natural to use colon in these situations, and dot when using\r\n\r\n{code}\r\n${body.someGetter}\r\n{code}\r\n\r\nAnd to refer to a header you can use both\r\n{code}\r\n${header.foo}\r\n{code}\r\n\r\n{code}\r\n${header:foo}\r\n{code}\r\n\r\nhttps:\/\/github.com\/apache\/camel\/blob\/master\/core\/camel-core\/src\/main\/docs\/simple-language.adoc",
      "assignee":"davsclaus",
      "type":"Improvement",
      "priority":"Major",
      "status":"Resolved",
      "text":"Simple language - Add colon as alternative syntax style The simple syntax can maybe be improved a bit when its a function such as env or sysenv or other functions vs OGNL method calls on body, headers etc that uses dot style.\r\n\r\nEg \r\n{code}\r\n${sysenv.FOO}\r\n{code}\r\nvs\r\n{code}\r\n${env:FOO}\r\n{code}\r\n\r\nIt may feel a bit more natural to use colon in these situations, and dot when using\r\n\r\n{code}\r\n${body.someGetter}\r\n{code}\r\n\r\nAnd to refer to a header you can use both\r\n{code}\r\n${header.foo}\r\n{code}\r\n\r\n{code}\r\n${header:foo}\r\n{code}\r\n\r\nhttps:\/\/github.com\/apache\/camel\/blob\/master\/core\/camel-core\/src\/main\/docs\/simple-language.adoc"
    },
    {
      "key":"CAMEL-13532",
      "title":"file2: pollEnrich with sendEmptyMessageWhenIdle does not send correct Exchanges",
      "description":"I use the file component in pollEnrich with sendEmptyMessageWhenIdle=true and readLock=changed\r\n\r\nIn 2.20.4 and before the attached test case worked, from 2.21.0 on it fails.\r\n\r\nMy test writes several characters delayed into a file so that the component runs into a timeout after 10000ms on the first call. This is correct.\r\n\r\nOn the second call the writing of the file is finished within the 10000ms, my expectation is the correct processing of the file in my route, but it fails because the Exchange has an empty body.\r\n\r\nI debugged the thing an saw that in the variable GenericFilePollingConsumer.queue there are two exchanges instead of one. The first one sems to be the \"empty\" message from the first call without a GenericFile in the In-Body, and the second Exchange in the queue is the correct one with the GenericFile from the second call.\r\n\r\nBecause it's a FiFo, only the first, empty one is returned (in EventDrivenPollingConsumer.receive()) so that the route states that there is nothing to do.\r\n\r\nI suspect an error in the processing of the empty message, so that it is not cleared or taken properly from the queue so that it remains there and conflicts with later calls.",
      "assignee":"davsclaus",
      "type":"Bug",
      "priority":"Major",
      "status":"Resolved",
      "text":"file2: pollEnrich with sendEmptyMessageWhenIdle does not send correct Exchanges I use the file component in pollEnrich with sendEmptyMessageWhenIdle=true and readLock=changed\r\n\r\nIn 2.20.4 and before the attached test case worked, from 2.21.0 on it fails.\r\n\r\nMy test writes several characters delayed into a file so that the component runs into a timeout after 10000ms on the first call. This is correct.\r\n\r\nOn the second call the writing of the file is finished within the 10000ms, my expectation is the correct processing of the file in my route, but it fails because the Exchange has an empty body.\r\n\r\nI debugged the thing an saw that in the variable GenericFilePollingConsumer.queue there are two exchanges instead of one. The first one sems to be the \"empty\" message from the first call without a GenericFile in the In-Body, and the second Exchange in the queue is the correct one with the GenericFile from the second call.\r\n\r\nBecause it's a FiFo, only the first, empty one is returned (in EventDrivenPollingConsumer.receive()) so that the route states that there is nothing to do.\r\n\r\nI suspect an error in the processing of the empty message, so that it is not cleared or taken properly from the queue so that it remains there and conflicts with later calls."
    },
    {
      "key":"CAMEL-13531",
      "title":"Simple language - Add env as function to lookup system env variable",
      "description":"You have to use sysenv to lookup OS env variable. But most people would know it as env, so lets add that as an alias so you can use both of them.",
      "assignee":"davsclaus",
      "type":"Improvement",
      "priority":"Major",
      "status":"Resolved",
      "text":"Simple language - Add env as function to lookup system env variable You have to use sysenv to lookup OS env variable. But most people would know it as env, so lets add that as an alias so you can use both of them."
    },
    {
      "key":"CAMEL-13528",
      "title":"Rename chiper to cipher",
      "description":"Fix the typo in the API in camel-core",
      "assignee":"davsclaus",
      "type":"Task",
      "priority":"Major",
      "status":"Resolved",
      "text":"Rename chiper to cipher Fix the typo in the API in camel-core"
    },
    {
      "key":"CAMEL-13527",
      "title":"Implement missing optimisation for DelimiterBasedFrameDecoder",
      "description":"See pretty nice analysis on SO\u00a0[https:\/\/stackoverflow.com\/questions\/56110408\/memory-leak-in-camel-netty-tcp-client-when-consuming-lines-with-windows-line-bre]\r\n\r\n*io.netty.handler.codec.DelimiterBasedFrameDecoder* internally delegates decoding to\u00a0*io.netty.handler.codec.LineBasedFrameDecoder*.\u00a0This delegation is not working with Camel, because Netty internally checks for condition\r\n{code:java}\r\nthis.getClass() != DelimiterBasedFrameDecoder.class \/\/ io.netty.handler.codec.DelimiterBasedFrameDecoder line 174 - !isSubclass()\r\n{code}\r\nWe can recreate similar optimisation inside\u00a0*org.apache.camel.component.netty4.codec.DelimiterBasedFrameDecoder*\u00a0and get (according to SO post) significant performance improvement.",
      "assignee":"davsclaus",
      "type":"Improvement",
      "priority":"Minor",
      "status":"Resolved",
      "text":"Implement missing optimisation for DelimiterBasedFrameDecoder See pretty nice analysis on SO [https:\/\/stackoverflow.com\/questions\/56110408\/memory-leak-in-camel-netty-tcp-client-when-consuming-lines-with-windows-line-bre]\r\n\r\n*io.netty.handler.codec.DelimiterBasedFrameDecoder* internally delegates decoding to *io.netty.handler.codec.LineBasedFrameDecoder*. This delegation is not working with Camel, because Netty internally checks for condition\r\n{code:java}\r\nthis.getClass() != DelimiterBasedFrameDecoder.class \/\/ io.netty.handler.codec.DelimiterBasedFrameDecoder line 174 - !isSubclass()\r\n{code}\r\nWe can recreate similar optimisation inside *org.apache.camel.component.netty4.codec.DelimiterBasedFrameDecoder* and get (according to SO post) significant performance improvement."
    },
    {
      "key":"CAMEL-13525",
      "title":"camel - Only allow setting routeId once per route in Java DSL",
      "description":"1 route = 1 route id, what you did in that unit test \/ JIRA ticket was wrong and not intended to be supported, eg .routeId will override each other, a route has 1 route id. So do only set .routeId once per route!\r\n\r\nFrom gitter chat",
      "assignee":"davsclaus",
      "type":"Improvement",
      "priority":"Minor",
      "status":"Resolved",
      "text":"camel - Only allow setting routeId once per route in Java DSL 1 route = 1 route id, what you did in that unit test \/ JIRA ticket was wrong and not intended to be supported, eg .routeId will override each other, a route has 1 route id. So do only set .routeId once per route!\r\n\r\nFrom gitter chat"
    },
    {
      "key":"CAMEL-13524",
      "title":"RuntimeCamelCatalog#asEndpointUri strips dash from url with toD and netty4-http",
      "description":"[https:\/\/stackoverflow.com\/questions\/56136857\/how-to-use-camel-tod-and-netty4-http-component-problem-with-optimization-of-din]\r\n\r\nThis\u00a0is very similar to\u00a0CAMEL-12705, but in this case\u00a0it affects url with dashes. Tested with current master.\r\n\r\n*{{url}}*\r\n{code:java}\r\nnetty4-http:http:\/\/a-b-c.hostname.tld:8080\/anything{code}\r\n*results in*\u00a0\r\n{code:java}\r\nnetty4-http:http:a-b:8080\/path{code}\r\nUnit test in attachment.\r\n\r\n\u00a0\r\n\r\n-Maybe-\r\n\r\n-_AbstractCamelCatalog#SYNTAX_PATTERN_ should be changed to-\u00a0\r\n{code:java}\r\n([\\w.-]+)\r\n{code}\r\n-Or is there reason, why is dash excluded from regexp?-\r\n\r\nI have tried to edit regexp and it broke test too, it\u00a0results in resolved = \"netty4-http:http:a-b-c.hostname.tld-8080\"",
      "assignee":"davsclaus",
      "type":"Bug",
      "priority":"Major",
      "status":"Resolved",
      "text":"RuntimeCamelCatalog#asEndpointUri strips dash from url with toD and netty4-http [https:\/\/stackoverflow.com\/questions\/56136857\/how-to-use-camel-tod-and-netty4-http-component-problem-with-optimization-of-din]\r\n\r\nThis is very similar to CAMEL-12705, but in this case it affects url with dashes. Tested with current master.\r\n\r\n*{{url}}*\r\n{code:java}\r\nnetty4-http:http:\/\/a-b-c.hostname.tld:8080\/anything{code}\r\n*results in* \r\n{code:java}\r\nnetty4-http:http:a-b:8080\/path{code}\r\nUnit test in attachment.\r\n\r\n \r\n\r\n-Maybe-\r\n\r\n-_AbstractCamelCatalog#SYNTAX_PATTERN_ should be changed to- \r\n{code:java}\r\n([\\w.-]+)\r\n{code}\r\n-Or is there reason, why is dash excluded from regexp?-\r\n\r\nI have tried to edit regexp and it broke test too, it results in resolved = \"netty4-http:http:a-b-c.hostname.tld-8080\""
    },
    {
      "key":"CAMEL-13522",
      "title":"camel3 - The various Camel exceptions should favour extending runtime exception",
      "description":"This makes using the APIs in Camel easier, and most of them are runtime based anyway. So lets align to be more non checked exceptions",
      "assignee":"davsclaus",
      "type":"Improvement",
      "priority":"Major",
      "status":"Resolved",
      "text":"camel3 - The various Camel exceptions should favour extending runtime exception This makes using the APIs in Camel easier, and most of them are runtime based anyway. So lets align to be more non checked exceptions"
    },
    {
      "key":"CAMEL-13516",
      "title":"camel-webhook - Consumer polish",
      "description":"Should extend ServiceSupport and do its startup stop in doStart\/doStop etc.",
      "assignee":"davsclaus",
      "type":"Improvement",
      "priority":"Major",
      "status":"Resolved",
      "text":"camel-webhook - Consumer polish Should extend ServiceSupport and do its startup stop in doStart\/doStop etc."
    },
    {
      "key":"CAMEL-13515",
      "title":"Allow producer to lazy start until first message",
      "description":"We could add option to DefaultProducer so any producer allows to defer its startup (doStart) to when the first message is being processed. The danger is that the startup logic has to be thread-safe and if there are concurrent messages then they would need to hold back until the startup is done. This is a trade-off that the user would need to accept if enabled.\r\n\r\nBut this can make it easier to let Camel startup routes even if some remote server is not available when a producer startup as part of route startup.",
      "assignee":"davsclaus",
      "type":"Improvement",
      "priority":"Major",
      "status":"Resolved",
      "text":"Allow producer to lazy start until first message We could add option to DefaultProducer so any producer allows to defer its startup (doStart) to when the first message is being processed. The danger is that the startup logic has to be thread-safe and if there are concurrent messages then they would need to hold back until the startup is done. This is a trade-off that the user would need to accept if enabled.\r\n\r\nBut this can make it easier to let Camel startup routes even if some remote server is not available when a producer startup as part of route startup."
    },
    {
      "key":"CAMEL-13514",
      "title":"camel3 - Service start\/stop should use unchecked exceptions",
      "description":"The API for org.apache.camel.Service has throws Exception for its start\/stop methods. It would be great to remove those, as they throw runtime exceptions when failing, and this makes using these APIs easier for end users, so they dont have the burden of checked exceptions.",
      "assignee":"davsclaus",
      "type":"Improvement",
      "priority":"Major",
      "status":"Resolved",
      "text":"camel3 - Service start\/stop should use unchecked exceptions The API for org.apache.camel.Service has throws Exception for its start\/stop methods. It would be great to remove those, as they throw runtime exceptions when failing, and this makes using these APIs easier for end users, so they dont have the burden of checked exceptions."
    },
    {
      "key":"CAMEL-13505",
      "title":"Camel-Tracer: New implementation",
      "description":"We deprecated the 2.x one and removed it, hence we need a new implementation in Camel 3.",
      "assignee":"davsclaus",
      "type":"Task",
      "priority":"Major",
      "status":"Resolved",
      "text":"Camel-Tracer: New implementation We deprecated the 2.x one and removed it, hence we need a new implementation in Camel 3."
    },
    {
      "key":"CAMEL-13503",
      "title":"Camel main - Allow to configure global and common options ala camel-spring-boot have",
      "description":"So you can set context name, shutdown timeout, and other options etc.",
      "assignee":"davsclaus",
      "type":"Improvement",
      "priority":"Major",
      "status":"Resolved",
      "text":"Camel main - Allow to configure global and common options ala camel-spring-boot have So you can set context name, shutdown timeout, and other options etc."
    },
    {
      "key":"CAMEL-13502",
      "title":"Properties component - Let OS environment variable take precedence by having it in override mode by default",
      "description":"See SO\r\nhttps:\/\/stackoverflow.com\/questions\/56081583\/camel-standalone-configuration-of-propertiescomponent-does-not-work-on-beanin\r\n\r\nIt makes sense to let OS env variables by default to let them override any existing property values. This is natural in cloud platforms and also how Spring Boot would work etc.\r\n\r\n",
      "assignee":"davsclaus",
      "type":"Improvement",
      "priority":"Major",
      "status":"Resolved",
      "text":"Properties component - Let OS environment variable take precedence by having it in override mode by default See SO\r\nhttps:\/\/stackoverflow.com\/questions\/56081583\/camel-standalone-configuration-of-propertiescomponent-does-not-work-on-beanin\r\n\r\nIt makes sense to let OS env variables by default to let them override any existing property values. This is natural in cloud platforms and also how Spring Boot would work etc.\r\n\r\n"
    },
    {
      "key":"CAMEL-13500",
      "title":"Component configuration - Allow to use dot to refer to nested options",
      "description":"For example some Camel components has nested options like camel-netty4 which has a NettyConfiguration class. \r\n\r\nSo when you want to set some of its options you cannot easily do this via component configuration. We have some special support for spring boot that generated these nested options, but its also needed for other use-cases such as the Camel Main and just in general.\r\n\r\nFor example with SB we can do\r\ncamel.component.netty4-http.configuration.max-header-size\r\n\r\nWe should add support for doing this via Camel Main and in general also",
      "assignee":"davsclaus",
      "type":"Task",
      "priority":"Major",
      "status":"Resolved",
      "text":"Component configuration - Allow to use dot to refer to nested options For example some Camel components has nested options like camel-netty4 which has a NettyConfiguration class. \r\n\r\nSo when you want to set some of its options you cannot easily do this via component configuration. We have some special support for spring boot that generated these nested options, but its also needed for other use-cases such as the Camel Main and just in general.\r\n\r\nFor example with SB we can do\r\ncamel.component.netty4-http.configuration.max-header-size\r\n\r\nWe should add support for doing this via Camel Main and in general also"
    },
    {
      "key":"CAMEL-13491",
      "title":"CamelTestSupport.isCreateCamelContextPerClass no longer works for junit4 tests",
      "description":"With the changes in\u00a0\r\n\r\norg.apache.camel.test.junit4.CamelTestSupport done during the work on\u00a0https:\/\/issues.apache.org\/jira\/browse\/CAMEL-12534\u00a0the camel context is now recreated for every test regardless of the return value from\r\n\r\nisCreateCamelContextPerClass()\r\n\r\n. Since junit4 creates a new instance of the class for every test the variable tests will be recreated and initialized to 0 for every test.\r\n\r\nThis condition in tearDown will always be true\r\n{code:java}\r\n\/\/ code placeholder\r\nif (tests.compareAndSet(v, v - 1)) {\r\n\u00a0 \u00a0 if (v == 1) {\r\n{code}\r\nwhich stops the camel context after every test.",
      "assignee":"davsclaus",
      "type":"Bug",
      "priority":"Major",
      "status":"Resolved",
      "text":"CamelTestSupport.isCreateCamelContextPerClass no longer works for junit4 tests With the changes in \r\n\r\norg.apache.camel.test.junit4.CamelTestSupport done during the work on https:\/\/issues.apache.org\/jira\/browse\/CAMEL-12534 the camel context is now recreated for every test regardless of the return value from\r\n\r\nisCreateCamelContextPerClass()\r\n\r\n. Since junit4 creates a new instance of the class for every test the variable tests will be recreated and initialized to 0 for every test.\r\n\r\nThis condition in tearDown will always be true\r\n{code:java}\r\n\/\/ code placeholder\r\nif (tests.compareAndSet(v, v - 1)) {\r\n    if (v == 1) {\r\n{code}\r\nwhich stops the camel context after every test."
    },
    {
      "key":"CAMEL-13483",
      "title":"File Component: Add option to fail startup when not having read permission on folder",
      "description":"When starting a file consumer you configure a folder to poll.\r\nWhen the camel context does not have read access on the folder, there is\u00a0no error (or even warning), that route just starts.\r\nBut when saving files into the folder, they are not picked up and there is no further message.\r\n\r\nThis issue was raised on stackoverflow:\u00a0[https:\/\/stackoverflow.com\/questions\/55920217\/camel-file-consumer-when-folder-is-not-accessible]\r\n\r\n\u00a0\r\n\r\nIdeally, the file consumer would check at startup if it has access to the folder (we should propably check for write access here, but read access\u00a0could also be enough?)\r\n\r\nIf the component (\/context) does not have the required access to the folder, it should throw the error and exit the context (so it isn't started in a failure state).\r\n\r\nThis option should be disabled by default.\r\n\r\nAlso we should think about a way to configure the behavior:\r\n1. For what permission should the consumer check (read \/ read-write)\r\n2. What should happen when the permission is not given? (just an error \/ error + stop route \/ error + stop context)\r\nAs always, we should\u00a0make this configurable via\u00a0a custom bean.",
      "assignee":"davsclaus",
      "type":"New Feature",
      "priority":"Major",
      "status":"Resolved",
      "text":"File Component: Add option to fail startup when not having read permission on folder When starting a file consumer you configure a folder to poll.\r\nWhen the camel context does not have read access on the folder, there is no error (or even warning), that route just starts.\r\nBut when saving files into the folder, they are not picked up and there is no further message.\r\n\r\nThis issue was raised on stackoverflow: [https:\/\/stackoverflow.com\/questions\/55920217\/camel-file-consumer-when-folder-is-not-accessible]\r\n\r\n \r\n\r\nIdeally, the file consumer would check at startup if it has access to the folder (we should propably check for write access here, but read access could also be enough?)\r\n\r\nIf the component (\/context) does not have the required access to the folder, it should throw the error and exit the context (so it isn't started in a failure state).\r\n\r\nThis option should be disabled by default.\r\n\r\nAlso we should think about a way to configure the behavior:\r\n1. For what permission should the consumer check (read \/ read-write)\r\n2. What should happen when the permission is not given? (just an error \/ error + stop route \/ error + stop context)\r\nAs always, we should make this configurable via a custom bean."
    },
    {
      "key":"CAMEL-13477",
      "title":"KafkaConfiguration puts truststore password into keystore password property",
      "description":"If you create a component-level KafkaConfiguration, and set SslContextParameters on it that includes a truststore password, then when creating consumer or producer properties, the KafkaConfiguration puts the truststore password into the keystore password field, resulting in errors such as:\r\n\r\n{{Caused by: org.apache.kafka.common.KafkaException: SSL key store is not specified, but key store password is specified.}}\r\n{{ at org.apache.kafka.common.security.ssl.SslFactory.createKeystore(SslFactory.java:283)}}\r\n{{ at org.apache.kafka.common.security.ssl.SslFactory.configure(SslFactory.java:126)}}\r\n{{ at org.apache.kafka.common.network.SaslChannelBuilder.configure(SaslChannelBuilder.java:149)}}\r\n\r\n\u00a0\r\n\r\nPR available here:\r\n\r\n[https:\/\/github.com\/apache\/camel\/pull\/2899]",
      "assignee":"davsclaus",
      "type":"Bug",
      "priority":"Major",
      "status":"Resolved",
      "text":"KafkaConfiguration puts truststore password into keystore password property If you create a component-level KafkaConfiguration, and set SslContextParameters on it that includes a truststore password, then when creating consumer or producer properties, the KafkaConfiguration puts the truststore password into the keystore password field, resulting in errors such as:\r\n\r\n{{Caused by: org.apache.kafka.common.KafkaException: SSL key store is not specified, but key store password is specified.}}\r\n{{ at org.apache.kafka.common.security.ssl.SslFactory.createKeystore(SslFactory.java:283)}}\r\n{{ at org.apache.kafka.common.security.ssl.SslFactory.configure(SslFactory.java:126)}}\r\n{{ at org.apache.kafka.common.network.SaslChannelBuilder.configure(SaslChannelBuilder.java:149)}}\r\n\r\n \r\n\r\nPR available here:\r\n\r\n[https:\/\/github.com\/apache\/camel\/pull\/2899]"
    },
    {
      "key":"CAMEL-13476",
      "title":"QuartzScheduledPollConsumerScheduler should not remove trigger when quartz is clustered",
      "description":"When using ftp component with quartz scheduler, like following sample\r\n\r\n\"ftp:\"+sftpUsername+\"@\"+sftpHost+\":\"+sftpPort+\"\/3G?password=\"+sftpPw+\"&binary=true&delay=5s&delete=true&scheduler=quartz2&scheduler.cron=\\{{cron.3G.processing}}&scheduler.triggerId=3G_Trigger\"\r\n\r\n\u00a0\r\n\r\nDuring shutdown, camel will remove all triggers without check quartz is running in cluster mode or not. Since we config quartz is cluster means there can be other instances running, so does it make sense we should check\u00a0quartz cluster state to decide triggers should remove or keep?\r\n\r\n\u00a0\r\n\r\n!QuartzScheduledPollConsumerScheduler.java \u2014 camel-quartz2 2019-05-02 15-46-49.jpg!\r\n\r\n\u00a0",
      "assignee":"davsclaus",
      "type":"Improvement",
      "priority":"Major",
      "status":"Resolved",
      "text":"QuartzScheduledPollConsumerScheduler should not remove trigger when quartz is clustered When using ftp component with quartz scheduler, like following sample\r\n\r\n\"ftp:\"+sftpUsername+\"@\"+sftpHost+\":\"+sftpPort+\"\/3G?password=\"+sftpPw+\"&binary=true&delay=5s&delete=true&scheduler=quartz2&scheduler.cron=\\{{cron.3G.processing}}&scheduler.triggerId=3G_Trigger\"\r\n\r\n \r\n\r\nDuring shutdown, camel will remove all triggers without check quartz is running in cluster mode or not. Since we config quartz is cluster means there can be other instances running, so does it make sense we should check quartz cluster state to decide triggers should remove or keep?\r\n\r\n \r\n\r\n!QuartzScheduledPollConsumerScheduler.java -- camel-quartz2 2019-05-02 15-46-49.jpg!\r\n\r\n "
    },
    {
      "key":"CAMEL-13475",
      "title":"Camel with Olingo4 not shutting down",
      "description":"I'm using the Olingo4 component and I want my Camel to run as a cron job. After my exchange is completed I stop the camel context, but the jvm doesn\u2019t close and keeps running. I found out that there still was a thread running with a httpAsyncClient.\r\n\r\nI checked the code for the component and found in the class Olingo4AppImpl that there by default a CloseableHttpAsyncClient is started, but not closed when camel is being shut down.\r\n\r\nI added this to close method and now the jvm process is stopping:\r\n\r\n@Override\r\npublic void close() {\r\n\u00a0\u00a0\u00a0if (client instanceof CloseableHttpAsyncClient) {\r\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0try {\r\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0client.close();\r\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}\r\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0catch (IOException e) {\r\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0throw new RuntimeException(e);\r\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}\r\n\u00a0\u00a0\u00a0}\r\n}\r\n\r\nNot sure what should happen when somebody uses their own httpAsyncClientBuilder.",
      "assignee":"davsclaus",
      "type":"Bug",
      "priority":"Minor",
      "status":"Resolved",
      "text":"Camel with Olingo4 not shutting down I'm using the Olingo4 component and I want my Camel to run as a cron job. After my exchange is completed I stop the camel context, but the jvm doesn't close and keeps running. I found out that there still was a thread running with a httpAsyncClient.\r\n\r\nI checked the code for the component and found in the class Olingo4AppImpl that there by default a CloseableHttpAsyncClient is started, but not closed when camel is being shut down.\r\n\r\nI added this to close method and now the jvm process is stopping:\r\n\r\n@Override\r\npublic void close() {\r\n   if (client instanceof CloseableHttpAsyncClient) {\r\n       try {\r\n           client.close();\r\n       }\r\n       catch (IOException e) {\r\n           throw new RuntimeException(e);\r\n       }\r\n   }\r\n}\r\n\r\nNot sure what should happen when somebody uses their own httpAsyncClientBuilder."
    },
    {
      "key":"CAMEL-13474",
      "title":"Move dataformats out of camel-core",
      "description":"We should deprecate string\/seriazliation dataformats as they dont bring value, and java object serialization is a bad design and also often a security vulnerability (many issues reported against this functionality in java).\r\n\r\nAnd then we can move zip\/gzip into camel-deflater. ",
      "assignee":"davsclaus",
      "type":"Task",
      "priority":"Major",
      "status":"Resolved",
      "text":"Move dataformats out of camel-core We should deprecate string\/seriazliation dataformats as they dont bring value, and java object serialization is a bad design and also often a security vulnerability (many issues reported against this functionality in java).\r\n\r\nAnd then we can move zip\/gzip into camel-deflater. "
    },
    {
      "key":"CAMEL-13473",
      "title":"camel3 - build system - dataformats from camel-core no longer generated in readme files",
      "description":"Likely because they were moved from camel-core to camel-base etc.",
      "assignee":"davsclaus",
      "type":"Task",
      "priority":"Major",
      "status":"Resolved",
      "text":"camel3 - build system - dataformats from camel-core no longer generated in readme files Likely because they were moved from camel-core to camel-base etc."
    },
    {
      "key":"CAMEL-13468",
      "title":"Exception tag is missing when Camel Java DSL is converted into XML using dumpRouteAsXml() operation",
      "description":"Exception tag is missing when Camel Java DSL is converted into XML using dumpRouteAsXml() operation\r\n\r\n#Java DSL route\r\n{code:java}\r\npublic void configure() {\r\n\tonException(Exception.class).log(\"${exception.stacktrace}\").logStackTrace(true)\r\n\t\t\t.handled(true);\r\n\r\n\tfrom(\"timer:\/\/foo?fixedRate=true&period=10000&repeatCount=101\").routeId(\"test\")\r\n\t\t\t.log(\"Hello World\");\r\n}\r\n{code}\r\n#XML converted by dumpRouteAsXml() operation(*<exception>java.lang.Exception<\/exception>* tag is missing)\r\n{code:java}\r\n<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"yes\"?>\r\n<route xmlns=\"http:\/\/camel.apache.org\/schema\/spring\" customId=\"true\" id=\"test\">\r\n    <from uri=\"timer:\/\/foo?fixedRate=true&amp;period=10000&amp;repeatCount=101\"\/>\r\n    <onException id=\"onException1\">\r\n        <redeliveryPolicy logStackTrace=\"true\"\/>\r\n        <log id=\"log1\" message=\"${exception.stacktrace}\"\/>\r\n    <\/onException>\r\n    <log id=\"log2\" message=\"Hello World\"\/>\r\n<\/route>\r\n{code}",
      "assignee":"davsclaus",
      "type":"Bug",
      "priority":"Minor",
      "status":"Resolved",
      "text":"Exception tag is missing when Camel Java DSL is converted into XML using dumpRouteAsXml() operation Exception tag is missing when Camel Java DSL is converted into XML using dumpRouteAsXml() operation\r\n\r\n#Java DSL route\r\n{code:java}\r\npublic void configure() {\r\n\tonException(Exception.class).log(\"${exception.stacktrace}\").logStackTrace(true)\r\n\t\t\t.handled(true);\r\n\r\n\tfrom(\"timer:\/\/foo?fixedRate=true&period=10000&repeatCount=101\").routeId(\"test\")\r\n\t\t\t.log(\"Hello World\");\r\n}\r\n{code}\r\n#XML converted by dumpRouteAsXml() operation(*<exception>java.lang.Exception<\/exception>* tag is missing)\r\n{code:java}\r\n<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"yes\"?>\r\n<route xmlns=\"http:\/\/camel.apache.org\/schema\/spring\" customId=\"true\" id=\"test\">\r\n    <from uri=\"timer:\/\/foo?fixedRate=true&amp;period=10000&amp;repeatCount=101\"\/>\r\n    <onException id=\"onException1\">\r\n        <redeliveryPolicy logStackTrace=\"true\"\/>\r\n        <log id=\"log1\" message=\"${exception.stacktrace}\"\/>\r\n    <\/onException>\r\n    <log id=\"log2\" message=\"Hello World\"\/>\r\n<\/route>\r\n{code}"
    },
    {
      "key":"CAMEL-13460",
      "title":"camel3 - DefaultEndpoint - Should be singleton by default",
      "description":"We should\r\n{code}\r\n    @Override\r\n    public boolean isSingleton() {\r\n        \/\/ lets be singleton by default as otherwise end-users may mistakenly write components\r\n        \/\/ which are not singleton. Only in very rare situations would you need to be non-singletons.\r\n        return true;\r\n    }\r\n{code}\r\n\r\nin DefaultEndpoint, and then remove it from all the components that are also singleton. I think its possible only camel-ftp that may not be.",
      "assignee":"davsclaus",
      "type":"Improvement",
      "priority":"Major",
      "status":"Resolved",
      "text":"camel3 - DefaultEndpoint - Should be singleton by default We should\r\n{code}\r\n    @Override\r\n    public boolean isSingleton() {\r\n        \/\/ lets be singleton by default as otherwise end-users may mistakenly write components\r\n        \/\/ which are not singleton. Only in very rare situations would you need to be non-singletons.\r\n        return true;\r\n    }\r\n{code}\r\n\r\nin DefaultEndpoint, and then remove it from all the components that are also singleton. I think its possible only camel-ftp that may not be."
    },
    {
      "key":"CAMEL-13459",
      "title":"camel3 - Move language annotations for bean parameter bindings into their own package",
      "description":"We have @Simple @Constant and @SpEL that are in the root package of language. They should be moved to their sub package, and @SpEL moved to camel-spring",
      "assignee":"davsclaus",
      "type":"Improvement",
      "priority":"Minor",
      "status":"Resolved",
      "text":"camel3 - Move language annotations for bean parameter bindings into their own package We have @Simple @Constant and @SpEL that are in the root package of language. They should be moved to their sub package, and @SpEL moved to camel-spring"
    },
    {
      "key":"CAMEL-13457",
      "title":"ProxyHelper - Remove binding option",
      "description":"binding is always default true and setting it to false is no longer supported on Camel 3",
      "assignee":"davsclaus",
      "type":"Improvement",
      "priority":"Major",
      "status":"Resolved",
      "text":"ProxyHelper - Remove binding option binding is always default true and setting it to false is no longer supported on Camel 3"
    },
    {
      "key":"CAMEL-13456",
      "title":"CamelContext - Move API that are not related to end users to an ExtendedCamelContext",
      "description":"Lets cleanup a bit more on CamelContext and move APIs that are more useable for component developers and internally to Camel itself to an ExtendedCamelContext, so the API the end user see on CamelContext is more limited and mostly relevant to what he\/she needs to use.\r\n\r\nWe already have some for model CamelContext and JMX etc today. ",
      "assignee":"davsclaus",
      "type":"Improvement",
      "priority":"Major",
      "status":"Resolved",
      "text":"CamelContext - Move API that are not related to end users to an ExtendedCamelContext Lets cleanup a bit more on CamelContext and move APIs that are more useable for component developers and internally to Camel itself to an ExtendedCamelContext, so the API the end user see on CamelContext is more limited and mostly relevant to what he\/she needs to use.\r\n\r\nWe already have some for model CamelContext and JMX etc today. "
    },
    {
      "key":"CAMEL-13449",
      "title":"camel3 - Move bean component out of camel-core",
      "description":"It seems there are only a few tangles left to make it possible to move bean component and language out of camel-core",
      "assignee":"davsclaus",
      "type":"Improvement",
      "priority":"Major",
      "status":"Resolved",
      "text":"camel3 - Move bean component out of camel-core It seems there are only a few tangles left to make it possible to move bean component and language out of camel-core"
    },
    {
      "key":"CAMEL-13446",
      "title":"camel-xpath does not build",
      "description":"I think due to CAMEL-13442 refactoring, there's a generated sources path that's looking in the wrong place when camel-xpath tries to build.\u00a0 Here's the stacktrace:\r\n\r\n\r\n{code:java}\r\n[INFO] Scanning for projects...\r\n[INFO] \r\n[INFO] ------------------------------------------------------------------------\r\n[INFO] Building Camel :: XPath 3.0.0-SNAPSHOT\r\n[INFO] ------------------------------------------------------------------------\r\n[INFO] \r\n[INFO] --- maven-bundle-plugin:4.1.0:cleanVersions (versions) @ camel-xpath ---\r\n[INFO] \r\n[INFO] --- maven-resources-plugin:3.1.0:resources (default-resources) @ camel-xpath ---\r\n[INFO] Using 'UTF-8' encoding to copy filtered resources.\r\n[INFO] skip non existing resourceDirectory \/home\/tdalbo\/Programming\/upstream\/apache\/camel\/components\/camel-xpath\/src\/main\/resources\r\n[INFO] \r\n[INFO] --- flatten-maven-plugin:1.1.0:flatten (default-cli) @ camel-xpath ---\r\n[INFO] Generating flattened POM of project org.apache.camel:camel-xpath:jar:3.0.0-SNAPSHOT...\r\n[INFO] \r\n[INFO] --- maven-compiler-plugin:3.8.0:compile (default-compile) @ camel-xpath ---\r\n[INFO] Changes detected - recompiling the module!\r\n[INFO] Compiling 8 source files to \/home\/tdalbo\/Programming\/upstream\/apache\/camel\/components\/camel-xpath\/target\/classes\r\n[INFO] \r\n[INFO] --- camel-package-maven-plugin:3.0.0-SNAPSHOT:prepare-components (generate) @ camel-xpath ---\r\n[INFO] ------------------------------------------------------------------------\r\n[INFO] BUILD FAILURE\r\n[INFO] ------------------------------------------------------------------------\r\n[INFO] Total time: 3.298 s\r\n[INFO] Finished at: 2019-04-23T07:42:30-06:00\r\n[INFO] Final Memory: 24M\/78M\r\n[INFO] ------------------------------------------------------------------------\r\n[ERROR] Failed to execute goal org.apache.camel:camel-package-maven-plugin:3.0.0-SNAPSHOT:prepare-components (generate) on project camel-xpath: Error loading language model from camel-core. Reason: java.io.FileNotFoundException: \/home\/tdalbo\/Programming\/upstream\/apache\/camel\/core\/camel-core\/target\/classes\/org\/apache\/camel\/model\/language\/xpath.json (No such file or directory) -> [Help 1]\r\n[ERROR] \r\n[ERROR] To see the full stack trace of the errors, re-run Maven with the -e switch.\r\n[ERROR] Re-run Maven using the -X switch to enable full debug logging.\r\n[ERROR] \r\n[ERROR] For more information about the errors and possible solutions, please read the following articles:\r\n[ERROR] [Help 1] http:\/\/cwiki.apache.org\/confluence\/display\/MAVEN\/MojoExecutionException\r\n{code}\r\n",
      "assignee":"davsclaus",
      "type":"Task",
      "priority":"Major",
      "status":"Resolved",
      "text":"camel-xpath does not build I think due to CAMEL-13442 refactoring, there's a generated sources path that's looking in the wrong place when camel-xpath tries to build.  Here's the stacktrace:\r\n\r\n\r\n{code:java}\r\n[INFO] Scanning for projects...\r\n[INFO] \r\n[INFO] ------------------------------------------------------------------------\r\n[INFO] Building Camel :: XPath 3.0.0-SNAPSHOT\r\n[INFO] ------------------------------------------------------------------------\r\n[INFO] \r\n[INFO] --- maven-bundle-plugin:4.1.0:cleanVersions (versions) @ camel-xpath ---\r\n[INFO] \r\n[INFO] --- maven-resources-plugin:3.1.0:resources (default-resources) @ camel-xpath ---\r\n[INFO] Using 'UTF-8' encoding to copy filtered resources.\r\n[INFO] skip non existing resourceDirectory \/home\/tdalbo\/Programming\/upstream\/apache\/camel\/components\/camel-xpath\/src\/main\/resources\r\n[INFO] \r\n[INFO] --- flatten-maven-plugin:1.1.0:flatten (default-cli) @ camel-xpath ---\r\n[INFO] Generating flattened POM of project org.apache.camel:camel-xpath:jar:3.0.0-SNAPSHOT...\r\n[INFO] \r\n[INFO] --- maven-compiler-plugin:3.8.0:compile (default-compile) @ camel-xpath ---\r\n[INFO] Changes detected - recompiling the module!\r\n[INFO] Compiling 8 source files to \/home\/tdalbo\/Programming\/upstream\/apache\/camel\/components\/camel-xpath\/target\/classes\r\n[INFO] \r\n[INFO] --- camel-package-maven-plugin:3.0.0-SNAPSHOT:prepare-components (generate) @ camel-xpath ---\r\n[INFO] ------------------------------------------------------------------------\r\n[INFO] BUILD FAILURE\r\n[INFO] ------------------------------------------------------------------------\r\n[INFO] Total time: 3.298 s\r\n[INFO] Finished at: 2019-04-23T07:42:30-06:00\r\n[INFO] Final Memory: 24M\/78M\r\n[INFO] ------------------------------------------------------------------------\r\n[ERROR] Failed to execute goal org.apache.camel:camel-package-maven-plugin:3.0.0-SNAPSHOT:prepare-components (generate) on project camel-xpath: Error loading language model from camel-core. Reason: java.io.FileNotFoundException: \/home\/tdalbo\/Programming\/upstream\/apache\/camel\/core\/camel-core\/target\/classes\/org\/apache\/camel\/model\/language\/xpath.json (No such file or directory) -> [Help 1]\r\n[ERROR] \r\n[ERROR] To see the full stack trace of the errors, re-run Maven with the -e switch.\r\n[ERROR] Re-run Maven using the -X switch to enable full debug logging.\r\n[ERROR] \r\n[ERROR] For more information about the errors and possible solutions, please read the following articles:\r\n[ERROR] [Help 1] http:\/\/cwiki.apache.org\/confluence\/display\/MAVEN\/MojoExecutionException\r\n{code}\r\n"
    },
    {
      "key":"CAMEL-13442",
      "title":"camel3 - Move xpath out of camel-core",
      "description":"We can move more xml stuff out of camel-core such as the xpath language",
      "assignee":"davsclaus",
      "type":"Improvement",
      "priority":"Major",
      "status":"Resolved",
      "text":"camel3 - Move xpath out of camel-core We can move more xml stuff out of camel-core such as the xpath language"
    },
    {
      "key":"CAMEL-13439",
      "title":"camel3 - DataFormatResolver should be able to lookup from model",
      "description":"When you have data formats defined via ids, such as\r\n{code}\r\n    <dataFormats>\r\n        <json library=\"Jackson\" id=\"myjson\"\/>\r\n        <jaxb contextPath=\"org.apache.camel.component.dozer.example.abc\" id=\"myjaxb\"\/>\r\n    <\/dataFormats>\r\n{code}\r\n\r\n",
      "assignee":"davsclaus",
      "type":"Improvement",
      "priority":"Major",
      "status":"Resolved",
      "text":"camel3 - DataFormatResolver should be able to lookup from model When you have data formats defined via ids, such as\r\n{code}\r\n    <dataFormats>\r\n        <json library=\"Jackson\" id=\"myjson\"\/>\r\n        <jaxb contextPath=\"org.apache.camel.component.dozer.example.abc\" id=\"myjaxb\"\/>\r\n    <\/dataFormats>\r\n{code}\r\n\r\n"
    },
    {
      "key":"CAMEL-13432",
      "title":"Simple language - Deprecate and remove change its start\/end token",
      "description":"We should rely on simple tokens being ${ } or $simple{ } for its functions. There is some code that would allow to change those but its not really in use and may not actually work in 100% situations. So lets cleanup this for camel 3. So deprecate in camel 2.x and remove in 3.",
      "assignee":"davsclaus",
      "type":"Improvement",
      "priority":"Major",
      "status":"Resolved",
      "text":"Simple language - Deprecate and remove change its start\/end token We should rely on simple tokens being ${ } or $simple{ } for its functions. There is some code that would allow to change those but its not really in use and may not actually work in 100% situations. So lets cleanup this for camel 3. So deprecate in camel 2.x and remove in 3."
    },
    {
      "key":"CAMEL-13430",
      "title":"Simple language - Functions with space should use camelCase style",
      "description":"Lets avoid having functions such as\r\n\r\nstarts with\r\nnot contains\r\n\r\nwhere there are space as that makes it a bit less obvious its a function name, and can also lead to: https:\/\/stackoverflow.com\/questions\/55705150\/camel-simple-expression-inside-jsonpath-language\r\n\r\nSo instead if we use\r\n\r\nstartsWith\r\nnotContains\r\n\r\n",
      "assignee":"davsclaus",
      "type":"Improvement",
      "priority":"Major",
      "status":"Resolved",
      "text":"Simple language - Functions with space should use camelCase style Lets avoid having functions such as\r\n\r\nstarts with\r\nnot contains\r\n\r\nwhere there are space as that makes it a bit less obvious its a function name, and can also lead to: https:\/\/stackoverflow.com\/questions\/55705150\/camel-simple-expression-inside-jsonpath-language\r\n\r\nSo instead if we use\r\n\r\nstartsWith\r\nnotContains\r\n\r\n"
    },
    {
      "key":"CAMEL-13425",
      "title":"Add possibility to invalidate cache for PropertiesComponent",
      "description":"Currently I can only enable\/disable cache for\u00a0PropertiesComponent.\r\n\r\nI'd like to be able to enable caching, but programmatically invalidate cache on demand.\r\n\r\nThis should be rather simeple to implemet, something like:\r\n{code:java}\r\npublic void invalidateCache() {\r\n  this.cacheMap.clear();\r\n}\r\n{code}",
      "assignee":"davsclaus",
      "type":"Improvement",
      "priority":"Major",
      "status":"Resolved",
      "text":"Add possibility to invalidate cache for PropertiesComponent Currently I can only enable\/disable cache for PropertiesComponent.\r\n\r\nI'd like to be able to enable caching, but programmatically invalidate cache on demand.\r\n\r\nThis should be rather simeple to implemet, something like:\r\n{code:java}\r\npublic void invalidateCache() {\r\n  this.cacheMap.clear();\r\n}\r\n{code}"
    },
    {
      "key":"CAMEL-13422",
      "title":"Remove camel-rmi",
      "description":"Its bad design to use Java RMI and the work on CAMEL-13421 makes it better to remove this component as well, and deprecate it in 2.x",
      "assignee":"davsclaus",
      "type":"Improvement",
      "priority":"Major",
      "status":"Resolved",
      "text":"Remove camel-rmi Its bad design to use Java RMI and the work on CAMEL-13421 makes it better to remove this component as well, and deprecate it in 2.x"
    },
    {
      "key":"CAMEL-13421",
      "title":"Remove BeanInvocation from camel-bean",
      "description":"Doing remote RPC calls via java bean serialization is a bad design and its not really much in use. Lets use the chance to get this removed for 3.x and deprecated in 2.x.",
      "assignee":"davsclaus",
      "type":"Improvement",
      "priority":"Major",
      "status":"Resolved",
      "text":"Remove BeanInvocation from camel-bean Doing remote RPC calls via java bean serialization is a bad design and its not really much in use. Lets use the chance to get this removed for 3.x and deprecated in 2.x."
    },
    {
      "key":"CAMEL-13417",
      "title":"Move mock component out of camel-core",
      "description":"Now that we got a bit more moved out, its maybe a bit easier to move out the mock.",
      "assignee":"davsclaus",
      "type":"Improvement",
      "priority":"Major",
      "status":"Resolved",
      "text":"Move mock component out of camel-core Now that we got a bit more moved out, its maybe a bit easier to move out the mock."
    },
    {
      "key":"CAMEL-13416",
      "title":"Please add camel-core-osgi to Camel Karaf feature repo",
      "description":"I was following this documentation\u00a0[http:\/\/camel.apache.org\/karaf.html]\u00a0in order to make Camel work in Karaf.\r\n\r\nMany tutorials point to this configuration:\r\n{code:java}\r\n@Override\r\npublic void start(final BundleContext bundleContext) throws Exception {\r\n  camelContext = new OsgiDefaultCamelContext(bundleContext);\r\n  registrationCamelContext = bundleContext.registerService(CamelContext.class, camelContext, null);\r\n  camelContext.start();\r\n}\r\n{code}\r\nUnfortunately, when I install Camel in karaf:\r\n{code:java}\r\nkaraf@root> feature:repo-add camel 2.23.1\r\n{code}\r\nonly camel-core can be installed, while camel-core-osgi is missing.\r\n\r\nUnfortunately\u00a0camel-core contains only\u00a0\r\n{code:java}\r\nDefaultCamelContext{code}\r\nwhich causes classpath problems in Karaf. For example I import camel-http4, but I get:\r\n{code:java}\r\nCaused by: org.apache.camel.ResolveEndpointFailedException: Failed to resolve endpoint: http4:\/\/my.site due to: No component found with scheme: http4\r\n{code}\r\nor I import camel-jackson, but I get:\r\n{code:java}\r\nCaused by: java.lang.IllegalArgumentException: Data format 'json-jackson' could not be created. Ensure that the data format is valid and the associated Camel component is present on the classpath\r\n{code}\r\nThe solution is to use:\r\n{code:java}\r\nOsgiDefaultCamelContext{code}\r\nwhich is located in camel-core-osgi, which is unavailable in Camel Karaf repo.\r\n\r\n\u00a0",
      "assignee":"davsclaus",
      "type":"Improvement",
      "priority":"Major",
      "status":"Resolved",
      "text":"Please add camel-core-osgi to Camel Karaf feature repo I was following this documentation [http:\/\/camel.apache.org\/karaf.html] in order to make Camel work in Karaf.\r\n\r\nMany tutorials point to this configuration:\r\n{code:java}\r\n@Override\r\npublic void start(final BundleContext bundleContext) throws Exception {\r\n  camelContext = new OsgiDefaultCamelContext(bundleContext);\r\n  registrationCamelContext = bundleContext.registerService(CamelContext.class, camelContext, null);\r\n  camelContext.start();\r\n}\r\n{code}\r\nUnfortunately, when I install Camel in karaf:\r\n{code:java}\r\nkaraf@root> feature:repo-add camel 2.23.1\r\n{code}\r\nonly camel-core can be installed, while camel-core-osgi is missing.\r\n\r\nUnfortunately camel-core contains only \r\n{code:java}\r\nDefaultCamelContext{code}\r\nwhich causes classpath problems in Karaf. For example I import camel-http4, but I get:\r\n{code:java}\r\nCaused by: org.apache.camel.ResolveEndpointFailedException: Failed to resolve endpoint: http4:\/\/my.site due to: No component found with scheme: http4\r\n{code}\r\nor I import camel-jackson, but I get:\r\n{code:java}\r\nCaused by: java.lang.IllegalArgumentException: Data format 'json-jackson' could not be created. Ensure that the data format is valid and the associated Camel component is present on the classpath\r\n{code}\r\nThe solution is to use:\r\n{code:java}\r\nOsgiDefaultCamelContext{code}\r\nwhich is located in camel-core-osgi, which is unavailable in Camel Karaf repo.\r\n\r\n "
    },
    {
      "key":"CAMEL-13414",
      "title":"Date.getTime() can be changed to System.currentTimeMillis()",
      "description":"Hello,\r\nI found that System.currentTimeMillis() can be used here instead of new Date.getTime().\r\nSince new Date() is a thin wrapper of light method System.currentTimeMillis(). The performance will be greatly damaged if it is invoked too much times.\r\nAccording to my local testing at the same environment, System.currentTimeMillis() can achieve a speedup to 5 times (435 ms vs 2073 ms), when these two methods are invoked 5,000,000 times.",
      "assignee":"davsclaus",
      "type":"Improvement",
      "priority":"Minor",
      "status":"Resolved",
      "text":"Date.getTime() can be changed to System.currentTimeMillis() Hello,\r\nI found that System.currentTimeMillis() can be used here instead of new Date.getTime().\r\nSince new Date() is a thin wrapper of light method System.currentTimeMillis(). The performance will be greatly damaged if it is invoked too much times.\r\nAccording to my local testing at the same environment, System.currentTimeMillis() can achieve a speedup to 5 times (435 ms vs 2073 ms), when these two methods are invoked 5,000,000 times."
    },
    {
      "key":"CAMEL-13403",
      "title":"Default allowUseOriginalMessage=\"false\" prevent clearing inflightRepository using jms with transferExchange=\"true\"",
      "description":"When using transferExchange=\"true\" in a JMS consumer (assuming producer also did), camel is breaking the match between key and exchange in inflightRepository if allowUseOriginalMessage=\"true\" is not set in camel context.\r\n\r\nThis can lead to java heap space out of memory because camel is not able to clear the inflightRepository from old Exchange.\r\n\r\nIdentified behaviour :\r\n # Camel receive the JMS message\r\n ## If allowUseOriginalMessage=true : parse JMS message to build Exchange instance\r\n ## If not : generate a new Instance\r\n # Camel add the Exchange to inflightRepository\r\n # On accessing the ExchangeBody, if it was not parsed\u00a0 yet camel rebuild the Exchange but do not change the key(exchangeId) in the inflightRepository\r\n # When the route process is over the message is not disposed if the key has been changed in the Exchange but not inflightRepository\r\n # Sooner or later the heap space if full and application crash.\r\n\r\nThe problem appeared in 2.18.0 and is present up until 2.23.1 (tested with attached test case). Release note of 2.18.0 says :\r\n\r\n\"Optimize Camel to only enable AllowUseOriginalMessage if in use by error handler or OnCompletion<[http:\/\/camel.apache.org\/oncompletion.html]>. End user who manually access the original message using the Java API must configure AllowUseOriginalMessage=true.\"\r\n\r\nProblem is transferExchange=\"true\" case also needs allowUseOriginalMessage=\"true\" even if the not accessing original message by Java API an other way.\r\n\r\nEasy work around : set allowUseOriginalMessage=\"true\" in camel context configuration",
      "assignee":"davsclaus",
      "type":"Bug",
      "priority":"Minor",
      "status":"Resolved",
      "text":"Default allowUseOriginalMessage=\"false\" prevent clearing inflightRepository using jms with transferExchange=\"true\" When using transferExchange=\"true\" in a JMS consumer (assuming producer also did), camel is breaking the match between key and exchange in inflightRepository if allowUseOriginalMessage=\"true\" is not set in camel context.\r\n\r\nThis can lead to java heap space out of memory because camel is not able to clear the inflightRepository from old Exchange.\r\n\r\nIdentified behaviour :\r\n # Camel receive the JMS message\r\n ## If allowUseOriginalMessage=true : parse JMS message to build Exchange instance\r\n ## If not : generate a new Instance\r\n # Camel add the Exchange to inflightRepository\r\n # On accessing the ExchangeBody, if it was not parsed  yet camel rebuild the Exchange but do not change the key(exchangeId) in the inflightRepository\r\n # When the route process is over the message is not disposed if the key has been changed in the Exchange but not inflightRepository\r\n # Sooner or later the heap space if full and application crash.\r\n\r\nThe problem appeared in 2.18.0 and is present up until 2.23.1 (tested with attached test case). Release note of 2.18.0 says :\r\n\r\n\"Optimize Camel to only enable AllowUseOriginalMessage if in use by error handler or OnCompletion<[http:\/\/camel.apache.org\/oncompletion.html]>. End user who manually access the original message using the Java API must configure AllowUseOriginalMessage=true.\"\r\n\r\nProblem is transferExchange=\"true\" case also needs allowUseOriginalMessage=\"true\" even if the not accessing original message by Java API an other way.\r\n\r\nEasy work around : set allowUseOriginalMessage=\"true\" in camel context configuration"
    },
    {
      "key":"CAMEL-13400",
      "title":"Camel FTP Cannot list directory with 'File not found' prepending additional '\/' in front of directory automatically",
      "description":"I need to poll files form a dynamic folder based on a specific date, so I have provided the parent directory in endpoint URI, enabled recursive flag and add filterDirectory accordingly. But It is not able to poll from the directory, it says file not found for that directory. It is trying with an addition '\/' while listing\u00a0{{listFor(\/XXXX)}}\r\n\r\n*Endpoint URI*\r\n\r\n{{sftp:\/\/XXXX:22051?connectTimeout=90000&disconnect=true&filterDirectory=%24%7Bfile%3Aname%7D+starts+with+%27%24%7Bbean%3AdateofExchange%3Fmethod%3DforLoc%28%22MY%22%29%7D%27&flatten=true&include=.*IMG&knownHostsFile=C%3A%5Cprogram+files%5Cascertain%5CI2R-MystiQ-Engine%5Cknown_hosts&noop=true&password=xxxxxx&preferredAuthentications=password&reconnectDelay=30000&recursive=true&scheduler=quartz2&scheduler.cron=0+0%2F5+*+*+*+%3F&stepwise=false&username=XXXX_ftpuser }}\r\n\r\n*TRACE LOG*\r\n\r\n{{TRACE 2019-04-05T15:25:03,389 [org.apache.camel.component.file.remote.SftpConsumer] - Polling directory: TRACE 2019-04-05T15:25:03,389 [org.apache.camel.component.file.remote.SftpOperations] - listFiles() TRACE 2019-04-05T15:25:03,712 [org.apache.camel.component.file.remote.SftpConsumer] - Found 12 in directory: TRACE 2019-04-05T15:25:03,712 [org.apache.camel.component.file.remote.SftpConsumer] - SftpFile[fileName=., longName=dr-x------ 2 ftpadmin ftpadmin 0 Mar 12 05:27 ., dir=true] TRACE 2019-04-05T15:25:03,712 [org.apache.camel.component.file.remote.SftpConsumer] - File did not match. Will skip this file: RemoteFile[.] TRACE 2019-04-05T15:25:03,712 [org.apache.camel.component.file.remote.SftpConsumer] - SftpFile[fileName=.., longName=dr-x------ 2 ftpadmin ftpadmin 0 Mar 12 03:04 .., dir=true] TRACE 2019-04-05T15:25:03,712 [org.apache.camel.component.file.remote.SftpConsumer] - File did not match. Will skip this file: RemoteFile[..] TRACE 2019-04-05T15:25:03,728 [org.apache.camel.component.file.remote.SftpConsumer] - SftpFile[fileName=20170526, longName=dr-x------ 2 ftpadmin ftpadmin 0 Mar 12 02:16 20170526, dir=true] TRACE 2019-04-05T15:25:04,413 [org.apache.camel.component.file.remote.SftpConsumer] - File did not match. Will skip this file: RemoteFile[20170526] TRACE 2019-04-05T15:25:04,413 [org.apache.camel.component.file.remote.SftpConsumer] - SftpFile[fileName=20181119, longName=dr-x------ 2 ftpadmin ftpadmin 0 Mar 12 05:24 20181119, dir=true] TRACE 2019-04-05T15:25:05,117 [org.apache.camel.component.file.remote.SftpConsumer] - File did not match. Will skip this file: RemoteFile[20181119] TRACE 2019-04-05T15:25:05,117 [org.apache.camel.component.file.remote.SftpConsumer] - SftpFile[fileName=20181121, longName=dr-x------ 2 ftpadmin ftpadmin 0 Mar 12 05:25 20181121, dir=true] TRACE 2019-04-05T15:25:05,837 [org.apache.camel.component.file.remote.SftpConsumer] - File did not match. Will skip this file: RemoteFile[20181121] TRACE 2019-04-05T15:25:05,840 [org.apache.camel.component.file.remote.SftpConsumer] - SftpFile[fileName=20181122, longName=dr-x------ 2 ftpadmin ftpadmin 0 Mar 12 05:26 20181122, dir=true] TRACE 2019-04-05T15:25:06,561 [org.apache.camel.component.file.remote.SftpConsumer] - File did not match. Will skip this file: RemoteFile[20181122] TRACE 2019-04-05T15:25:06,563 [org.apache.camel.component.file.remote.SftpConsumer] - SftpFile[fileName=20181123, longName=dr-x------ 2 ftpadmin ftpadmin 0 Mar 12 05:27 20181123, dir=true] TRACE 2019-04-05T15:25:07,258 [org.apache.camel.component.file.remote.SftpConsumer] - Polling sub directory: \/20181123 from: sftp:\/\/XXXX:22051?connectTimeout=90000&disconnect=true&filterDirectory=%24%7Bfile%3Aname%7D+starts+with+%27%24%7Bbean%3AdateofExchange%3Fmethod%3DforLoc%28%22MY%22%29%7D%27&flatten=true&include=.*IMG&knownHostsFile=C%3A%5Cprogram+files%5Cascertain%5CI2R-MystiQ-Engine%5Cknown_hosts&noop=true&password=xxxxxx&preferredAuthentications=password&reconnectDelay=30000&recursive=true&scheduler=quartz2&scheduler.cron=0+0%2F5+*+*+*+%3F&stepwise=false&username=XXXX_ftpuser TRACE 2019-04-05T15:25:07,260 [org.apache.camel.component.file.remote.SftpConsumer] - doPollDirectory from absolutePath: \/20181123, dirName: 20181123 TRACE 2019-04-05T15:25:07,263 [org.apache.camel.component.file.remote.SftpConsumer] - Polling directory: \/20181123 TRACE 2019-04-05T15:25:07,265 [org.apache.camel.component.file.remote.SftpOperations] - listFiles(\/20181123) DEBUG 2019-04-05T15:25:07,281 [org.apache.camel.component.file.remote.SftpConsumer] - Caught exception Cannot list directory: \/20181123 TRACE 2019-04-05T15:25:07,297 [org.apache.camel.component.file.remote.SftpConsumer] - Not ignoring file error Cannot list directory: \/20181123 for \/20181123 DEBUG 2019-04-05T15:25:07,297 [org.apache.camel.component.file.remote.SftpConsumer] - Error occurred during poll directory: due Cannot list directory: \/20181123. Removing 0 files marked as in-progress. WARN 2019-04-05T15:25:07,297 [org.apache.camel.component.file.remote.RemoteFilePollingConsumerPollStrategy] - Trying to recover by force disconnecting from remote server and re-connecting at next poll: sftp:\/\/XXX@1XXXX:22051 DEBUG 2019-04-05T15:25:07,297 [org.apache.camel.component.file.remote.SftpConsumer] - Force disconnecting from: sftp:\/\/XXX@XXXX:22051 WARN 2019-04-05T15:25:07,297 [org.apache.camel.component.file.remote.SftpConsumer] - Consumer SftpConsumer[sftp:\/\/XXXX:22051?connectTimeout=90000&disconnect=true&filterDirectory=%24%7Bfile%3Aname%7D+starts+with+%27%24%7Bbean%3AdateofExchange%3Fmethod%3DforLoc%28%22MY%22%29%7D%27&flatten=true&include=.*IMG&knownHostsFile=C%3A%5Cprogram+files%5Cascertain%5CI2R-MystiQ-Engine%5Cknown_hosts&noop=true&password=xxxxxx&preferredAuthentications=password&reconnectDelay=30000&recursive=true&scheduler=quartz2&scheduler.cron=0+0%2F5+*+*+*+%3F&stepwise=false&username=XXXX_ftpuser] failed polling endpoint: sftp:\/\/XXXX:22051?connectTimeout=90000&disconnect=true&filterDirectory=%24%7Bfile%3Aname%7D+starts+with+%27%24%7Bbean%3AdateofExchange%3Fmethod%3DforLoc%28%22MY%22%29%7D%27&flatten=true&include=.*IMG&knownHostsFile=C%3A%5Cprogram+files%5Cascertain%5CI2R-MystiQ-Engine%5Cknown_hosts&noop=true&password=xxxxxx&preferredAuthentications=password&reconnectDelay=30000&recursive=true&scheduler=quartz2&scheduler.cron=0+0%2F5+*+*+*+%3F&stepwise=false&username=XXXX_ftpuser. Will try again at next poll. Caused by: [org.apache.camel.component.file.GenericFileOperationFailedException - Cannot list directory: \/20181123] org.apache.camel.component.file.GenericFileOperationFailedException: Cannot list directory: \/20181123 at org.apache.camel.component.file.remote.SftpOperations.listFiles(SftpOperations.java:660) ~[camel-ftp-2.21.1.jar!\/:2.21.1] at org.apache.camel.component.file.remote.SftpConsumer.doPollDirectory(SftpConsumer.java:128) ~[camel-ftp-2.21.1.jar!\/:2.21.1] at org.apache.camel.component.file.remote.RemoteFileConsumer.doSafePollSubDirectory(RemoteFileConsumer.java:260) ~[camel-ftp-2.21.1.jar!\/:2.21.1] at org.apache.camel.component.file.remote.SftpConsumer.pollSubDirectory(SftpConsumer.java:96) ~[camel-ftp-2.21.1.jar!\/:2.21.1] at org.apache.camel.component.file.remote.SftpConsumer.doPollDirectory(SftpConsumer.java:178) ~[camel-ftp-2.21.1.jar!\/:2.21.1] at org.apache.camel.component.file.remote.SftpConsumer.pollDirectory(SftpConsumer.java:87) ~[camel-ftp-2.21.1.jar!\/:2.21.1] at org.apache.camel.component.file.GenericFileConsumer.poll(GenericFileConsumer.java:124) ~[camel-core-2.21.1.jar!\/:2.21.1] at org.apache.camel.impl.ScheduledPollConsumer.doRun(ScheduledPollConsumer.java:174) [camel-core-2.21.1.jar!\/:2.21.1] at org.apache.camel.impl.ScheduledPollConsumer.run(ScheduledPollConsumer.java:101) [camel-core-2.21.1.jar!\/:2.21.1] at org.apache.camel.pollconsumer.quartz2.QuartzScheduledPollConsumerJob.execute(QuartzScheduledPollConsumerJob.java:61) [camel-quartz2-2.21.1.jar!\/:2.21.1] at org.quartz.core.JobRunShell.run(JobRunShell.java:202) [quartz-2.3.0.jar!\/:?] at org.quartz.simpl.SimpleThreadPool$WorkerThread.run(SimpleThreadPool.java:573) [quartz-2.3.0.jar!\/:?] Caused by: com.jcraft.jsch.SftpException: File not found: \/20181123 at com.jcraft.jsch.ChannelSftp.throwStatusError(ChannelSftp.java:2873) ~[jsch-0.1.54.jar!\/:?] at com.jcraft.jsch.ChannelSftp._stat(ChannelSftp.java:2225) ~[jsch-0.1.54.jar!\/:?] at com.jcraft.jsch.ChannelSftp._stat(ChannelSftp.java:2242) ~[jsch-0.1.54.jar!\/:?] at com.jcraft.jsch.ChannelSftp.ls(ChannelSftp.java:1592) ~[jsch-0.1.54.jar!\/:?] at com.jcraft.jsch.ChannelSftp.ls(ChannelSftp.java:1553) ~[jsch-0.1.54.jar!\/:?] at org.apache.camel.component.file.remote.SftpOperations.listFiles(SftpOperations.java:651) ~[camel-ftp-2.21.1.jar!\/:2.21.1] ... 11 more }}\r\n\r\nWhen I try to hardcode that folder along with endpint URI, it simply can list that directory and poll files. This time there is no '\/' before the directory while listing\u00a0{{listFor(XXXX)}}\r\n\r\n*Endpoint URI*\r\n\r\n{{sftp:\/\/XXXX:22051\/20181123?connectTimeout=90000&disconnect=true&flatten=true&include=.*IMG&knownHostsFile=C%3A%5Cprogram+files%5Cascertain%5CI2R-MystiQ-Engine%5Cknown_hosts&noop=true&password=xxxxxx&preferredAuthentications=password&reconnectDelay=30000&recursive=true&scheduler=quartz2&scheduler.cron=0+0%2F5+*+*+*+%3F&separator=Auto&stepwise=false&username=XXXX_ftpuser }}\r\n\r\n*TRACE LOG*\r\n\r\n{{TRACE 2019-04-05T18:40:00,009 [org.apache.camel.component.file.remote.SftpConsumer] - prePollCheck on sftp:\/\/XXX@XXXX:22051 DEBUG 2019-04-05T18:40:00,009 [org.apache.camel.component.file.remote.SftpConsumer] - Not connected\/logged in, connecting to: sftp:\/\/XXX@XXXX:22051 TRACE 2019-04-05T18:40:00,009 [org.apache.camel.component.file.remote.SftpOperations] - Session isn't connected, trying to recreate and connect. DEBUG 2019-04-05T18:40:00,009 [org.apache.camel.component.file.remote.SftpOperations] - Using knownhosts file: C:\\program files\\ascertain\\I2R-MystiQ-Engine\\known_hosts DEBUG 2019-04-05T18:40:00,009 [org.apache.camel.component.file.remote.SftpOperations] - Using known hosts information from file: C:\\program files\\ascertain\\I2R-MystiQ-Engine\\known_hosts DEBUG 2019-04-05T18:40:00,025 [org.apache.camel.component.file.remote.SftpOperations] - Using StrickHostKeyChecking: no DEBUG 2019-04-05T18:40:00,025 [org.apache.camel.component.file.remote.SftpOperations] - Using PreferredAuthentications: password TRACE 2019-04-05T18:40:00,025 [org.apache.camel.component.file.remote.SftpOperations] - Connecting use connectTimeout: 90000 ... TRACE 2019-04-05T18:40:00,465 [org.apache.camel.component.file.remote.SftpOperations] - Channel isn't connected, trying to recreate and connect. TRACE 2019-04-05T18:40:00,465 [org.apache.camel.component.file.remote.SftpOperations] - Connecting use connectTimeout: 90000 ... DEBUG 2019-04-05T18:40:01,215 [org.apache.camel.component.file.remote.SftpOperations] - Connected to sftp:\/\/XXX@XXXX:22051 DEBUG 2019-04-05T18:40:01,215 [org.apache.camel.component.file.remote.SftpConsumer] - Connected and logged in to: sftp:\/\/XXX@XXXX:22051 TRACE 2019-04-05T18:40:01,215 [org.apache.camel.component.file.remote.SftpConsumer] - doPollDirectory from absolutePath: 20181123, dirName: null TRACE 2019-04-05T18:40:01,215 [org.apache.camel.component.file.remote.SftpConsumer] - Polling directory: 20181123 TRACE 2019-04-05T18:40:01,215 [org.apache.camel.component.file.remote.SftpOperations] - listFiles(20181123) TRACE 2019-04-05T18:40:02,621 [org.apache.camel.component.file.remote.SftpConsumer] - Found 6 in directory: 20181123 TRACE 2019-04-05T18:40:02,621 [org.apache.camel.component.file.remote.SftpConsumer] - SftpFile[fileName=., longName=dr-x------ 2 ftpadmin ftpadmin 0 Mar 12 05:27 ., dir=true] TRACE 2019-04-05T18:40:02,621 [org.apache.camel.component.file.remote.SftpConsumer] - File did not match. Will skip this file: RemoteFile[.] TRACE 2019-04-05T18:40:02,637 [org.apache.camel.component.file.remote.SftpConsumer] - SftpFile[fileName=.., longName=dr-x------ 2 ftpadmin ftpadmin 0 Mar 12 05:27 .., dir=true] TRACE 2019-04-05T18:40:02,637 [org.apache.camel.component.file.remote.SftpConsumer] - File did not match. Will skip this file: RemoteFile[..] TRACE 2019-04-05T18:40:02,637 [org.apache.camel.component.file.remote.SftpConsumer] - SftpFile[fileName=Consolidated, longName=dr-x------ 2 ftpadmin ftpadmin 0 Mar 12 05:26 Consolidated, dir=true] TRACE 2019-04-05T18:40:02,637 [org.apache.camel.component.file.remote.SftpConsumer] - Polling sub directory: 20181123\/Consolidated from: sftp:\/\/XXXX:22051\/20181123?connectTimeout=90000&disconnect=true&flatten=true&include=.*IMG&knownHostsFile=C%3A%5Cprogram+files%5Cascertain%5CI2R-MystiQ-Engine%5Cknown_hosts&noop=true&password=xxxxxx&preferredAuthentications=password&reconnectDelay=30000&recursive=true&scheduler=quartz2&scheduler.cron=0+0%2F5+*+*+*+%3F&separator=Auto&stepwise=false&username=XXXX_ftpuser TRACE 2019-04-05T18:40:02,637 [org.apache.camel.component.file.remote.SftpConsumer] - doPollDirectory from absolutePath: 20181123\/Consolidated, dirName: Consolidated TRACE 2019-04-05T18:40:02,637 [org.apache.camel.component.file.remote.SftpConsumer] - Polling directory: 20181123\/Consolidated TRACE 2019-04-05T18:40:02,637 [org.apache.camel.component.file.remote.SftpOperations] - listFiles(20181123\/Consolidated) TRACE 2019-04-05T18:40:02,715 [org.apache.camel.component.file.remote.SftpConsumer] - Found 5 in directory: 20181123\/Consolidated TRACE 2019-04-05T18:40:02,715 [org.apache.camel.component.file.remote.SftpConsumer] - SftpFile[fileName=., longName=dr-x------ 2 ftpadmin ftpadmin 0 Mar 12 05:26 ., dir=true] TRACE 2019-04-05T18:40:02,715 [org.apache.camel.component.file.remote.SftpConsumer] - File did not match. Will skip this file: RemoteFile[Consolidated\/.] TRACE 2019-04-05T18:40:02,715 [org.apache.camel.component.file.remote.SftpConsumer] - SftpFile[fileName=.., longName=dr-x------ 2 ftpadmin ftpadmin 0 Mar 12 05:27 .., dir=true] TRACE 2019-04-05T18:40:02,715 [org.apache.camel.component.file.remote.SftpConsumer] - File did not match. Will skip this file: RemoteFile[Consolidated\/..] TRACE 2019-04-05T18:40:02,715 [org.apache.camel.component.file.remote.SftpConsumer] - SftpFile[fileName=20181124020438943_021420181123INW.MYR, longName=-r-x------ 1 ftpadmin ftpadmin 408097 Nov 23 2018 20181124020438943_021420181123INW.MYR, dir=false] TRACE 2019-04-05T18:40:02,731 [org.apache.camel.component.file.remote.SftpConsumer] - File did not match. Will skip this file: RemoteFile[Consolidated\/20181124020438943_021420181123INW.MYR] TRACE 2019-04-05T18:40:02,731 [org.apache.camel.component.file.remote.SftpConsumer] - SftpFile[fileName=20181124020439099_035820181123INW.MYR, longName=-r-x------ 1 ftpadmin ftpadmin 21689 Nov 23 2018 20181124020439099_035820181123INW.MYR, dir=false] TRACE 2019-04-05T18:40:02,731 [org.apache.camel.component.file.remote.SftpConsumer] - File did not match. Will skip this file: RemoteFile[Consolidated\/20181124020439099_035820181123INW.MYR] TRACE 2019-04-05T18:40:02,731 [org.apache.camel.component.file.remote.SftpConsumer] - SftpFile[fileName=ToPPay, longName=dr-x------ 2 ftpadmin ftpadmin 0 Mar 12 06:41 ToPPay, dir=true] TRACE 2019-04-05T18:40:02,731 [org.apache.camel.component.file.remote.SftpConsumer] - Polling sub directory: 20181123\/Consolidated\/ToPPay from: sftp:\/\/XXXX:22051\/20181123?connectTimeout=90000&disconnect=true&flatten=true&include=.*IMG&knownHostsFile=C%3A%5Cprogram+files%5Cascertain%5CI2R-MystiQ-Engine%5Cknown_hosts&noop=true&password=xxxxxx&preferredAuthentications=password&reconnectDelay=30000&recursive=true&scheduler=quartz2&scheduler.cron=0+0%2F5+*+*+*+%3F&separator=Auto&stepwise=false&username=XXXX_ftpuser TRACE 2019-04-05T18:40:02,731 [org.apache.camel.component.file.remote.SftpConsumer] - doPollDirectory from absolutePath: 20181123\/Consolidated\/ToPPay, dirName: ToPPay TRACE 2019-04-05T18:40:02,731 [org.apache.camel.component.file.remote.SftpConsumer] - Polling directory: 20181123\/Consolidated\/ToPPay TRACE 2019-04-05T18:40:02,731 [org.apache.camel.component.file.remote.SftpOperations] - listFiles(20181123\/Consolidated\/ToPPay) TRACE 2019-04-05T18:40:02,777 [org.apache.camel.component.file.remote.SftpConsumer] - Found 8 in directory: 20181123\/Consolidated\/ToPPay TRACE 2019-04-05T18:40:02,777 [org.apache.camel.component.file.remote.SftpConsumer] - SftpFile[fileName=., longName=dr-x------ 2 ftpadmin ftpadmin 0 Mar 12 06:41 ., dir=true] TRACE 2019-04-05T18:40:02,777 [org.apache.camel.component.file.remote.SftpConsumer] - File did not match. Will skip this file: RemoteFile[Consolidated\/ToPPay\/.] TRACE 2019-04-05T18:40:02,777 [org.apache.camel.component.file.remote.SftpConsumer] - SftpFile[fileName=.., longName=dr-x------ 2 ftpadmin ftpadmin 0 Mar 12 05:26 .., dir=true] TRACE 2019-04-05T18:40:02,777 [org.apache.camel.component.file.remote.SftpConsumer] - File did not match. Will skip this file: RemoteFile[Consolidated\/ToPPay\/..] TRACE 2019-04-05T18:40:02,793 [org.apache.camel.component.file.remote.SftpConsumer] - SftpFile[fileName=021420181123INW.MYR, longName=-r-x------ 1 ftpadmin ftpadmin 408097 Nov 23 2018 021420181123INW.MYR, dir=false] TRACE 2019-04-05T18:40:02,793 [org.apache.camel.component.file.remote.SftpConsumer] - File did not match. Will skip this file: RemoteFile[Consolidated\/ToPPay\/021420181123INW.MYR] TRACE 2019-04-05T18:40:02,793 [org.apache.camel.component.file.remote.SftpConsumer] - SftpFile[fileName=021420181123INW1.MYR, longName=-r-x------ 1 ftpadmin ftpadmin 579829 Nov 23 2018 021420181123INW1.MYR, dir=false] TRACE 2019-04-05T18:40:02,793 [org.apache.camel.component.file.remote.SftpConsumer] - File did not match. Will skip this file: RemoteFile[Consolidated\/ToPPay\/021420181123INW1.MYR] TRACE 2019-04-05T18:40:02,793 [org.apache.camel.component.file.remote.SftpConsumer] - SftpFile[fileName=035820181123INW.MYR, longName=-r-x------ 1 ftpadmin ftpadmin 21689 Nov 23 2018 035820181123INW.MYR, dir=false] TRACE 2019-04-05T18:40:02,793 [org.apache.camel.component.file.remote.SftpConsumer] - File did not match. Will skip this file: RemoteFile[Consolidated\/ToPPay\/035820181123INW.MYR] TRACE 2019-04-05T18:40:02,793 [org.apache.camel.component.file.remote.SftpConsumer] - SftpFile[fileName=035820181123INW1.MYR, longName=-r-x------ 1 ftpadmin ftpadmin 30954 Nov 23 2018 035820181123INW1.MYR, dir=false] TRACE 2019-04-05T18:40:02,793 [org.apache.camel.component.file.remote.SftpConsumer] - File did not match. Will skip this file: RemoteFile[Consolidated\/ToPPay\/035820181123INW1.MYR] TRACE 2019-04-05T18:40:02,809 [org.apache.camel.component.file.remote.SftpConsumer] - SftpFile[fileName=20181124020438943_021420181123INW.MYR, longName=-r-x------ 1 ftpadmin ftpadmin 408097 Nov 23 2018 20181124020438943_021420181123INW.MYR, dir=false] TRACE 2019-04-05T18:40:02,809 [org.apache.camel.component.file.remote.SftpConsumer] - File did not match. Will skip this file: RemoteFile[Consolidated\/ToPPay\/20181124020438943_021420181123INW.MYR] TRACE 2019-04-05T18:40:02,809 [org.apache.camel.component.file.remote.SftpConsumer] - SftpFile[fileName=20181124020439099_035820181123INW.MYR, longName=-r-x------ 1 ftpadmin ftpadmin 21689 Nov 23 2018 20181124020439099_035820181123INW.MYR, dir=false] TRACE 2019-04-05T18:40:02,809 [org.apache.camel.component.file.remote.SftpConsumer] - File did not match. Will skip this file: RemoteFile[Consolidated\/ToPPay\/20181124020439099_035820181123INW.MYR] TRACE 2019-04-05T18:40:02,809 [org.apache.camel.component.file.remote.SftpConsumer] - SftpFile[fileName=Data, longName=dr-x------ 2 ftpadmin ftpadmin 0 Mar 12 05:26 Data, dir=true] TRACE 2019-04-05T18:40:02,809 [org.apache.camel.component.file.remote.SftpConsumer] - Polling sub directory: 20181123\/Data from: sftp:\/\/XXXX:22051\/20181123?connectTimeout=90000&disconnect=true&flatten=true&include=.*IMG&knownHostsFile=C%3A%5Cprogram+files%5Cascertain%5CI2R-MystiQ-Engine%5Cknown_hosts&noop=true&password=xxxxxx&preferredAuthentications=password&reconnectDelay=30000&recursive=true&scheduler=quartz2&scheduler.cron=0+0%2F5+*+*+*+%3F&separator=Auto&stepwise=false&username=XXXX_ftpuser TRACE 2019-04-05T18:40:02,809 [org.apache.camel.component.file.remote.SftpConsumer] - doPollDirectory from absolutePath: 20181123\/Data, dirName: Data TRACE 2019-04-05T18:40:02,809 [org.apache.camel.component.file.remote.SftpConsumer] - Polling directory: 20181123\/Data TRACE 2019-04-05T18:40:02,809 [org.apache.camel.component.file.remote.SftpOperations] - listFiles(20181123\/Data) TRACE 2019-04-05T18:40:02,871 [org.apache.camel.component.file.remote.SftpConsumer] - Found 501 in directory: 20181123\/Data TRACE 2019-04-05T18:40:02,871 [org.apache.camel.component.file.remote.SftpConsumer] - SftpFile[fileName=., longName=dr-x------ 2 ftpadmin ftpadmin 0 Mar 12 05:26 ., dir=true] TRACE 2019-04-05T18:40:02,871 [org.apache.camel.component.file.remote.SftpConsumer] - File did not match. Will skip this file: RemoteFile[Data\/.] TRACE 2019-04-05T18:40:02,871 [org.apache.camel.component.file.remote.SftpConsumer] - SftpFile[fileName=.., longName=dr-x------ 2 ftpadmin ftpadmin 0 Mar 12 05:27 .., dir=true] TRACE 2019-04-05T18:40:02,871 [org.apache.camel.component.file.remote.SftpConsumer] - File did not match. Will skip this file: RemoteFile[Data\/..] TRACE 2019-04-05T18:40:02,871 [org.apache.camel.component.file.remote.SftpConsumer] - SftpFile[fileName=20181123021401015101004323IWNM.MMYR, longName=-r-x------ 1 ftpadmin ftpadmin 14846 Nov 23 2018 20181123021401015101004323IWNM.MMYR, dir=false] TRACE 2019-04-05T18:40:02,871 [org.apache.camel.component.file.remote.SftpConsumer] - File did not match. Will skip this file: RemoteFile[Data\/20181123021401015101004323IWNM.MMYR] }}\r\n\r\nI am sure that the cause of the issue has to be the addition '\/' prepending with directory name while listing\u00a0{{listFor(\/XXXX)}}. How can I avoid it ! .. using\u00a0{{seperator}}\u00a0parameter didn't effect i suppose it is only for producing files and not for consuming. I need to resolve this issue as soon as possible. Please suggest me some solution :(\r\n\r\n*EDITED :*\r\n\r\nI can reproduce the issue in latest version as well,I suppose the issue is when there is no base path only the '\/' gets prepended which should not actually happen\r\n\r\nCode Snippet from SftpConsumer.java Camel 3.0.0.M1\r\n\r\n{{if (file.isDirectory()) \\{ RemoteFile<SftpRemoteFile> remote = asRemoteFile(absolutePath, file, getEndpoint().getCharset()); if (endpoint.isRecursive() && depth < endpoint.getMaxDepth() && isValidFile(remote, true, files)) { \/\/ recursive scan and add the sub files and folders String subDirectory = file.getFilename(); String path = absolutePath + \"\/\" + subDirectory; boolean canPollMore = pollSubDirectory(path, subDirectory, fileList, depth); if (!canPollMore) { return false; } } \/\/ we cannot use file.getAttrs().isLink on Windows, so we dont invoke the method \/\/ just assuming its a file we should poll } }}\r\n{quote}String path = absolutePath + \"\/\" + subDirectory;\r\n{quote}",
      "assignee":"davsclaus",
      "type":"Bug",
      "priority":"Major",
      "status":"Resolved",
      "text":"Camel FTP Cannot list directory with 'File not found' prepending additional '\/' in front of directory automatically I need to poll files form a dynamic folder based on a specific date, so I have provided the parent directory in endpoint URI, enabled recursive flag and add filterDirectory accordingly. But It is not able to poll from the directory, it says file not found for that directory. It is trying with an addition '\/' while listing {{listFor(\/XXXX)}}\r\n\r\n*Endpoint URI*\r\n\r\n{{sftp:\/\/XXXX:22051?connectTimeout=90000&disconnect=true&filterDirectory=%24%7Bfile%3Aname%7D+starts+with+%27%24%7Bbean%3AdateofExchange%3Fmethod%3DforLoc%28%22MY%22%29%7D%27&flatten=true&include=.*IMG&knownHostsFile=C%3A%5Cprogram+files%5Cascertain%5CI2R-MystiQ-Engine%5Cknown_hosts&noop=true&password=xxxxxx&preferredAuthentications=password&reconnectDelay=30000&recursive=true&scheduler=quartz2&scheduler.cron=0+0%2F5+*+*+*+%3F&stepwise=false&username=XXXX_ftpuser }}\r\n\r\n*TRACE LOG*\r\n\r\n{{TRACE 2019-04-05T15:25:03,389 [org.apache.camel.component.file.remote.SftpConsumer] - Polling directory: TRACE 2019-04-05T15:25:03,389 [org.apache.camel.component.file.remote.SftpOperations] - listFiles() TRACE 2019-04-05T15:25:03,712 [org.apache.camel.component.file.remote.SftpConsumer] - Found 12 in directory: TRACE 2019-04-05T15:25:03,712 [org.apache.camel.component.file.remote.SftpConsumer] - SftpFile[fileName=., longName=dr-x------ 2 ftpadmin ftpadmin 0 Mar 12 05:27 ., dir=true] TRACE 2019-04-05T15:25:03,712 [org.apache.camel.component.file.remote.SftpConsumer] - File did not match. Will skip this file: RemoteFile[.] TRACE 2019-04-05T15:25:03,712 [org.apache.camel.component.file.remote.SftpConsumer] - SftpFile[fileName=.., longName=dr-x------ 2 ftpadmin ftpadmin 0 Mar 12 03:04 .., dir=true] TRACE 2019-04-05T15:25:03,712 [org.apache.camel.component.file.remote.SftpConsumer] - File did not match. Will skip this file: RemoteFile[..] TRACE 2019-04-05T15:25:03,728 [org.apache.camel.component.file.remote.SftpConsumer] - SftpFile[fileName=20170526, longName=dr-x------ 2 ftpadmin ftpadmin 0 Mar 12 02:16 20170526, dir=true] TRACE 2019-04-05T15:25:04,413 [org.apache.camel.component.file.remote.SftpConsumer] - File did not match. Will skip this file: RemoteFile[20170526] TRACE 2019-04-05T15:25:04,413 [org.apache.camel.component.file.remote.SftpConsumer] - SftpFile[fileName=20181119, longName=dr-x------ 2 ftpadmin ftpadmin 0 Mar 12 05:24 20181119, dir=true] TRACE 2019-04-05T15:25:05,117 [org.apache.camel.component.file.remote.SftpConsumer] - File did not match. Will skip this file: RemoteFile[20181119] TRACE 2019-04-05T15:25:05,117 [org.apache.camel.component.file.remote.SftpConsumer] - SftpFile[fileName=20181121, longName=dr-x------ 2 ftpadmin ftpadmin 0 Mar 12 05:25 20181121, dir=true] TRACE 2019-04-05T15:25:05,837 [org.apache.camel.component.file.remote.SftpConsumer] - File did not match. Will skip this file: RemoteFile[20181121] TRACE 2019-04-05T15:25:05,840 [org.apache.camel.component.file.remote.SftpConsumer] - SftpFile[fileName=20181122, longName=dr-x------ 2 ftpadmin ftpadmin 0 Mar 12 05:26 20181122, dir=true] TRACE 2019-04-05T15:25:06,561 [org.apache.camel.component.file.remote.SftpConsumer] - File did not match. Will skip this file: RemoteFile[20181122] TRACE 2019-04-05T15:25:06,563 [org.apache.camel.component.file.remote.SftpConsumer] - SftpFile[fileName=20181123, longName=dr-x------ 2 ftpadmin ftpadmin 0 Mar 12 05:27 20181123, dir=true] TRACE 2019-04-05T15:25:07,258 [org.apache.camel.component.file.remote.SftpConsumer] - Polling sub directory: \/20181123 from: sftp:\/\/XXXX:22051?connectTimeout=90000&disconnect=true&filterDirectory=%24%7Bfile%3Aname%7D+starts+with+%27%24%7Bbean%3AdateofExchange%3Fmethod%3DforLoc%28%22MY%22%29%7D%27&flatten=true&include=.*IMG&knownHostsFile=C%3A%5Cprogram+files%5Cascertain%5CI2R-MystiQ-Engine%5Cknown_hosts&noop=true&password=xxxxxx&preferredAuthentications=password&reconnectDelay=30000&recursive=true&scheduler=quartz2&scheduler.cron=0+0%2F5+*+*+*+%3F&stepwise=false&username=XXXX_ftpuser TRACE 2019-04-05T15:25:07,260 [org.apache.camel.component.file.remote.SftpConsumer] - doPollDirectory from absolutePath: \/20181123, dirName: 20181123 TRACE 2019-04-05T15:25:07,263 [org.apache.camel.component.file.remote.SftpConsumer] - Polling directory: \/20181123 TRACE 2019-04-05T15:25:07,265 [org.apache.camel.component.file.remote.SftpOperations] - listFiles(\/20181123) DEBUG 2019-04-05T15:25:07,281 [org.apache.camel.component.file.remote.SftpConsumer] - Caught exception Cannot list directory: \/20181123 TRACE 2019-04-05T15:25:07,297 [org.apache.camel.component.file.remote.SftpConsumer] - Not ignoring file error Cannot list directory: \/20181123 for \/20181123 DEBUG 2019-04-05T15:25:07,297 [org.apache.camel.component.file.remote.SftpConsumer] - Error occurred during poll directory: due Cannot list directory: \/20181123. Removing 0 files marked as in-progress. WARN 2019-04-05T15:25:07,297 [org.apache.camel.component.file.remote.RemoteFilePollingConsumerPollStrategy] - Trying to recover by force disconnecting from remote server and re-connecting at next poll: sftp:\/\/XXX@1XXXX:22051 DEBUG 2019-04-05T15:25:07,297 [org.apache.camel.component.file.remote.SftpConsumer] - Force disconnecting from: sftp:\/\/XXX@XXXX:22051 WARN 2019-04-05T15:25:07,297 [org.apache.camel.component.file.remote.SftpConsumer] - Consumer SftpConsumer[sftp:\/\/XXXX:22051?connectTimeout=90000&disconnect=true&filterDirectory=%24%7Bfile%3Aname%7D+starts+with+%27%24%7Bbean%3AdateofExchange%3Fmethod%3DforLoc%28%22MY%22%29%7D%27&flatten=true&include=.*IMG&knownHostsFile=C%3A%5Cprogram+files%5Cascertain%5CI2R-MystiQ-Engine%5Cknown_hosts&noop=true&password=xxxxxx&preferredAuthentications=password&reconnectDelay=30000&recursive=true&scheduler=quartz2&scheduler.cron=0+0%2F5+*+*+*+%3F&stepwise=false&username=XXXX_ftpuser] failed polling endpoint: sftp:\/\/XXXX:22051?connectTimeout=90000&disconnect=true&filterDirectory=%24%7Bfile%3Aname%7D+starts+with+%27%24%7Bbean%3AdateofExchange%3Fmethod%3DforLoc%28%22MY%22%29%7D%27&flatten=true&include=.*IMG&knownHostsFile=C%3A%5Cprogram+files%5Cascertain%5CI2R-MystiQ-Engine%5Cknown_hosts&noop=true&password=xxxxxx&preferredAuthentications=password&reconnectDelay=30000&recursive=true&scheduler=quartz2&scheduler.cron=0+0%2F5+*+*+*+%3F&stepwise=false&username=XXXX_ftpuser. Will try again at next poll. Caused by: [org.apache.camel.component.file.GenericFileOperationFailedException - Cannot list directory: \/20181123] org.apache.camel.component.file.GenericFileOperationFailedException: Cannot list directory: \/20181123 at org.apache.camel.component.file.remote.SftpOperations.listFiles(SftpOperations.java:660) ~[camel-ftp-2.21.1.jar!\/:2.21.1] at org.apache.camel.component.file.remote.SftpConsumer.doPollDirectory(SftpConsumer.java:128) ~[camel-ftp-2.21.1.jar!\/:2.21.1] at org.apache.camel.component.file.remote.RemoteFileConsumer.doSafePollSubDirectory(RemoteFileConsumer.java:260) ~[camel-ftp-2.21.1.jar!\/:2.21.1] at org.apache.camel.component.file.remote.SftpConsumer.pollSubDirectory(SftpConsumer.java:96) ~[camel-ftp-2.21.1.jar!\/:2.21.1] at org.apache.camel.component.file.remote.SftpConsumer.doPollDirectory(SftpConsumer.java:178) ~[camel-ftp-2.21.1.jar!\/:2.21.1] at org.apache.camel.component.file.remote.SftpConsumer.pollDirectory(SftpConsumer.java:87) ~[camel-ftp-2.21.1.jar!\/:2.21.1] at org.apache.camel.component.file.GenericFileConsumer.poll(GenericFileConsumer.java:124) ~[camel-core-2.21.1.jar!\/:2.21.1] at org.apache.camel.impl.ScheduledPollConsumer.doRun(ScheduledPollConsumer.java:174) [camel-core-2.21.1.jar!\/:2.21.1] at org.apache.camel.impl.ScheduledPollConsumer.run(ScheduledPollConsumer.java:101) [camel-core-2.21.1.jar!\/:2.21.1] at org.apache.camel.pollconsumer.quartz2.QuartzScheduledPollConsumerJob.execute(QuartzScheduledPollConsumerJob.java:61) [camel-quartz2-2.21.1.jar!\/:2.21.1] at org.quartz.core.JobRunShell.run(JobRunShell.java:202) [quartz-2.3.0.jar!\/:?] at org.quartz.simpl.SimpleThreadPool$WorkerThread.run(SimpleThreadPool.java:573) [quartz-2.3.0.jar!\/:?] Caused by: com.jcraft.jsch.SftpException: File not found: \/20181123 at com.jcraft.jsch.ChannelSftp.throwStatusError(ChannelSftp.java:2873) ~[jsch-0.1.54.jar!\/:?] at com.jcraft.jsch.ChannelSftp._stat(ChannelSftp.java:2225) ~[jsch-0.1.54.jar!\/:?] at com.jcraft.jsch.ChannelSftp._stat(ChannelSftp.java:2242) ~[jsch-0.1.54.jar!\/:?] at com.jcraft.jsch.ChannelSftp.ls(ChannelSftp.java:1592) ~[jsch-0.1.54.jar!\/:?] at com.jcraft.jsch.ChannelSftp.ls(ChannelSftp.java:1553) ~[jsch-0.1.54.jar!\/:?] at org.apache.camel.component.file.remote.SftpOperations.listFiles(SftpOperations.java:651) ~[camel-ftp-2.21.1.jar!\/:2.21.1] ... 11 more }}\r\n\r\nWhen I try to hardcode that folder along with endpint URI, it simply can list that directory and poll files. This time there is no '\/' before the directory while listing {{listFor(XXXX)}}\r\n\r\n*Endpoint URI*\r\n\r\n{{sftp:\/\/XXXX:22051\/20181123?connectTimeout=90000&disconnect=true&flatten=true&include=.*IMG&knownHostsFile=C%3A%5Cprogram+files%5Cascertain%5CI2R-MystiQ-Engine%5Cknown_hosts&noop=true&password=xxxxxx&preferredAuthentications=password&reconnectDelay=30000&recursive=true&scheduler=quartz2&scheduler.cron=0+0%2F5+*+*+*+%3F&separator=Auto&stepwise=false&username=XXXX_ftpuser }}\r\n\r\n*TRACE LOG*\r\n\r\n{{TRACE 2019-04-05T18:40:00,009 [org.apache.camel.component.file.remote.SftpConsumer] - prePollCheck on sftp:\/\/XXX@XXXX:22051 DEBUG 2019-04-05T18:40:00,009 [org.apache.camel.component.file.remote.SftpConsumer] - Not connected\/logged in, connecting to: sftp:\/\/XXX@XXXX:22051 TRACE 2019-04-05T18:40:00,009 [org.apache.camel.component.file.remote.SftpOperations] - Session isn't connected, trying to recreate and connect. DEBUG 2019-04-05T18:40:00,009 [org.apache.camel.component.file.remote.SftpOperations] - Using knownhosts file: C:\\program files\\ascertain\\I2R-MystiQ-Engine\\known_hosts DEBUG 2019-04-05T18:40:00,009 [org.apache.camel.component.file.remote.SftpOperations] - Using known hosts information from file: C:\\program files\\ascertain\\I2R-MystiQ-Engine\\known_hosts DEBUG 2019-04-05T18:40:00,025 [org.apache.camel.component.file.remote.SftpOperations] - Using StrickHostKeyChecking: no DEBUG 2019-04-05T18:40:00,025 [org.apache.camel.component.file.remote.SftpOperations] - Using PreferredAuthentications: password TRACE 2019-04-05T18:40:00,025 [org.apache.camel.component.file.remote.SftpOperations] - Connecting use connectTimeout: 90000 ... TRACE 2019-04-05T18:40:00,465 [org.apache.camel.component.file.remote.SftpOperations] - Channel isn't connected, trying to recreate and connect. TRACE 2019-04-05T18:40:00,465 [org.apache.camel.component.file.remote.SftpOperations] - Connecting use connectTimeout: 90000 ... DEBUG 2019-04-05T18:40:01,215 [org.apache.camel.component.file.remote.SftpOperations] - Connected to sftp:\/\/XXX@XXXX:22051 DEBUG 2019-04-05T18:40:01,215 [org.apache.camel.component.file.remote.SftpConsumer] - Connected and logged in to: sftp:\/\/XXX@XXXX:22051 TRACE 2019-04-05T18:40:01,215 [org.apache.camel.component.file.remote.SftpConsumer] - doPollDirectory from absolutePath: 20181123, dirName: null TRACE 2019-04-05T18:40:01,215 [org.apache.camel.component.file.remote.SftpConsumer] - Polling directory: 20181123 TRACE 2019-04-05T18:40:01,215 [org.apache.camel.component.file.remote.SftpOperations] - listFiles(20181123) TRACE 2019-04-05T18:40:02,621 [org.apache.camel.component.file.remote.SftpConsumer] - Found 6 in directory: 20181123 TRACE 2019-04-05T18:40:02,621 [org.apache.camel.component.file.remote.SftpConsumer] - SftpFile[fileName=., longName=dr-x------ 2 ftpadmin ftpadmin 0 Mar 12 05:27 ., dir=true] TRACE 2019-04-05T18:40:02,621 [org.apache.camel.component.file.remote.SftpConsumer] - File did not match. Will skip this file: RemoteFile[.] TRACE 2019-04-05T18:40:02,637 [org.apache.camel.component.file.remote.SftpConsumer] - SftpFile[fileName=.., longName=dr-x------ 2 ftpadmin ftpadmin 0 Mar 12 05:27 .., dir=true] TRACE 2019-04-05T18:40:02,637 [org.apache.camel.component.file.remote.SftpConsumer] - File did not match. Will skip this file: RemoteFile[..] TRACE 2019-04-05T18:40:02,637 [org.apache.camel.component.file.remote.SftpConsumer] - SftpFile[fileName=Consolidated, longName=dr-x------ 2 ftpadmin ftpadmin 0 Mar 12 05:26 Consolidated, dir=true] TRACE 2019-04-05T18:40:02,637 [org.apache.camel.component.file.remote.SftpConsumer] - Polling sub directory: 20181123\/Consolidated from: sftp:\/\/XXXX:22051\/20181123?connectTimeout=90000&disconnect=true&flatten=true&include=.*IMG&knownHostsFile=C%3A%5Cprogram+files%5Cascertain%5CI2R-MystiQ-Engine%5Cknown_hosts&noop=true&password=xxxxxx&preferredAuthentications=password&reconnectDelay=30000&recursive=true&scheduler=quartz2&scheduler.cron=0+0%2F5+*+*+*+%3F&separator=Auto&stepwise=false&username=XXXX_ftpuser TRACE 2019-04-05T18:40:02,637 [org.apache.camel.component.file.remote.SftpConsumer] - doPollDirectory from absolutePath: 20181123\/Consolidated, dirName: Consolidated TRACE 2019-04-05T18:40:02,637 [org.apache.camel.component.file.remote.SftpConsumer] - Polling directory: 20181123\/Consolidated TRACE 2019-04-05T18:40:02,637 [org.apache.camel.component.file.remote.SftpOperations] - listFiles(20181123\/Consolidated) TRACE 2019-04-05T18:40:02,715 [org.apache.camel.component.file.remote.SftpConsumer] - Found 5 in directory: 20181123\/Consolidated TRACE 2019-04-05T18:40:02,715 [org.apache.camel.component.file.remote.SftpConsumer] - SftpFile[fileName=., longName=dr-x------ 2 ftpadmin ftpadmin 0 Mar 12 05:26 ., dir=true] TRACE 2019-04-05T18:40:02,715 [org.apache.camel.component.file.remote.SftpConsumer] - File did not match. Will skip this file: RemoteFile[Consolidated\/.] TRACE 2019-04-05T18:40:02,715 [org.apache.camel.component.file.remote.SftpConsumer] - SftpFile[fileName=.., longName=dr-x------ 2 ftpadmin ftpadmin 0 Mar 12 05:27 .., dir=true] TRACE 2019-04-05T18:40:02,715 [org.apache.camel.component.file.remote.SftpConsumer] - File did not match. Will skip this file: RemoteFile[Consolidated\/..] TRACE 2019-04-05T18:40:02,715 [org.apache.camel.component.file.remote.SftpConsumer] - SftpFile[fileName=20181124020438943_021420181123INW.MYR, longName=-r-x------ 1 ftpadmin ftpadmin 408097 Nov 23 2018 20181124020438943_021420181123INW.MYR, dir=false] TRACE 2019-04-05T18:40:02,731 [org.apache.camel.component.file.remote.SftpConsumer] - File did not match. Will skip this file: RemoteFile[Consolidated\/20181124020438943_021420181123INW.MYR] TRACE 2019-04-05T18:40:02,731 [org.apache.camel.component.file.remote.SftpConsumer] - SftpFile[fileName=20181124020439099_035820181123INW.MYR, longName=-r-x------ 1 ftpadmin ftpadmin 21689 Nov 23 2018 20181124020439099_035820181123INW.MYR, dir=false] TRACE 2019-04-05T18:40:02,731 [org.apache.camel.component.file.remote.SftpConsumer] - File did not match. Will skip this file: RemoteFile[Consolidated\/20181124020439099_035820181123INW.MYR] TRACE 2019-04-05T18:40:02,731 [org.apache.camel.component.file.remote.SftpConsumer] - SftpFile[fileName=ToPPay, longName=dr-x------ 2 ftpadmin ftpadmin 0 Mar 12 06:41 ToPPay, dir=true] TRACE 2019-04-05T18:40:02,731 [org.apache.camel.component.file.remote.SftpConsumer] - Polling sub directory: 20181123\/Consolidated\/ToPPay from: sftp:\/\/XXXX:22051\/20181123?connectTimeout=90000&disconnect=true&flatten=true&include=.*IMG&knownHostsFile=C%3A%5Cprogram+files%5Cascertain%5CI2R-MystiQ-Engine%5Cknown_hosts&noop=true&password=xxxxxx&preferredAuthentications=password&reconnectDelay=30000&recursive=true&scheduler=quartz2&scheduler.cron=0+0%2F5+*+*+*+%3F&separator=Auto&stepwise=false&username=XXXX_ftpuser TRACE 2019-04-05T18:40:02,731 [org.apache.camel.component.file.remote.SftpConsumer] - doPollDirectory from absolutePath: 20181123\/Consolidated\/ToPPay, dirName: ToPPay TRACE 2019-04-05T18:40:02,731 [org.apache.camel.component.file.remote.SftpConsumer] - Polling directory: 20181123\/Consolidated\/ToPPay TRACE 2019-04-05T18:40:02,731 [org.apache.camel.component.file.remote.SftpOperations] - listFiles(20181123\/Consolidated\/ToPPay) TRACE 2019-04-05T18:40:02,777 [org.apache.camel.component.file.remote.SftpConsumer] - Found 8 in directory: 20181123\/Consolidated\/ToPPay TRACE 2019-04-05T18:40:02,777 [org.apache.camel.component.file.remote.SftpConsumer] - SftpFile[fileName=., longName=dr-x------ 2 ftpadmin ftpadmin 0 Mar 12 06:41 ., dir=true] TRACE 2019-04-05T18:40:02,777 [org.apache.camel.component.file.remote.SftpConsumer] - File did not match. Will skip this file: RemoteFile[Consolidated\/ToPPay\/.] TRACE 2019-04-05T18:40:02,777 [org.apache.camel.component.file.remote.SftpConsumer] - SftpFile[fileName=.., longName=dr-x------ 2 ftpadmin ftpadmin 0 Mar 12 05:26 .., dir=true] TRACE 2019-04-05T18:40:02,777 [org.apache.camel.component.file.remote.SftpConsumer] - File did not match. Will skip this file: RemoteFile[Consolidated\/ToPPay\/..] TRACE 2019-04-05T18:40:02,793 [org.apache.camel.component.file.remote.SftpConsumer] - SftpFile[fileName=021420181123INW.MYR, longName=-r-x------ 1 ftpadmin ftpadmin 408097 Nov 23 2018 021420181123INW.MYR, dir=false] TRACE 2019-04-05T18:40:02,793 [org.apache.camel.component.file.remote.SftpConsumer] - File did not match. Will skip this file: RemoteFile[Consolidated\/ToPPay\/021420181123INW.MYR] TRACE 2019-04-05T18:40:02,793 [org.apache.camel.component.file.remote.SftpConsumer] - SftpFile[fileName=021420181123INW1.MYR, longName=-r-x------ 1 ftpadmin ftpadmin 579829 Nov 23 2018 021420181123INW1.MYR, dir=false] TRACE 2019-04-05T18:40:02,793 [org.apache.camel.component.file.remote.SftpConsumer] - File did not match. Will skip this file: RemoteFile[Consolidated\/ToPPay\/021420181123INW1.MYR] TRACE 2019-04-05T18:40:02,793 [org.apache.camel.component.file.remote.SftpConsumer] - SftpFile[fileName=035820181123INW.MYR, longName=-r-x------ 1 ftpadmin ftpadmin 21689 Nov 23 2018 035820181123INW.MYR, dir=false] TRACE 2019-04-05T18:40:02,793 [org.apache.camel.component.file.remote.SftpConsumer] - File did not match. Will skip this file: RemoteFile[Consolidated\/ToPPay\/035820181123INW.MYR] TRACE 2019-04-05T18:40:02,793 [org.apache.camel.component.file.remote.SftpConsumer] - SftpFile[fileName=035820181123INW1.MYR, longName=-r-x------ 1 ftpadmin ftpadmin 30954 Nov 23 2018 035820181123INW1.MYR, dir=false] TRACE 2019-04-05T18:40:02,793 [org.apache.camel.component.file.remote.SftpConsumer] - File did not match. Will skip this file: RemoteFile[Consolidated\/ToPPay\/035820181123INW1.MYR] TRACE 2019-04-05T18:40:02,809 [org.apache.camel.component.file.remote.SftpConsumer] - SftpFile[fileName=20181124020438943_021420181123INW.MYR, longName=-r-x------ 1 ftpadmin ftpadmin 408097 Nov 23 2018 20181124020438943_021420181123INW.MYR, dir=false] TRACE 2019-04-05T18:40:02,809 [org.apache.camel.component.file.remote.SftpConsumer] - File did not match. Will skip this file: RemoteFile[Consolidated\/ToPPay\/20181124020438943_021420181123INW.MYR] TRACE 2019-04-05T18:40:02,809 [org.apache.camel.component.file.remote.SftpConsumer] - SftpFile[fileName=20181124020439099_035820181123INW.MYR, longName=-r-x------ 1 ftpadmin ftpadmin 21689 Nov 23 2018 20181124020439099_035820181123INW.MYR, dir=false] TRACE 2019-04-05T18:40:02,809 [org.apache.camel.component.file.remote.SftpConsumer] - File did not match. Will skip this file: RemoteFile[Consolidated\/ToPPay\/20181124020439099_035820181123INW.MYR] TRACE 2019-04-05T18:40:02,809 [org.apache.camel.component.file.remote.SftpConsumer] - SftpFile[fileName=Data, longName=dr-x------ 2 ftpadmin ftpadmin 0 Mar 12 05:26 Data, dir=true] TRACE 2019-04-05T18:40:02,809 [org.apache.camel.component.file.remote.SftpConsumer] - Polling sub directory: 20181123\/Data from: sftp:\/\/XXXX:22051\/20181123?connectTimeout=90000&disconnect=true&flatten=true&include=.*IMG&knownHostsFile=C%3A%5Cprogram+files%5Cascertain%5CI2R-MystiQ-Engine%5Cknown_hosts&noop=true&password=xxxxxx&preferredAuthentications=password&reconnectDelay=30000&recursive=true&scheduler=quartz2&scheduler.cron=0+0%2F5+*+*+*+%3F&separator=Auto&stepwise=false&username=XXXX_ftpuser TRACE 2019-04-05T18:40:02,809 [org.apache.camel.component.file.remote.SftpConsumer] - doPollDirectory from absolutePath: 20181123\/Data, dirName: Data TRACE 2019-04-05T18:40:02,809 [org.apache.camel.component.file.remote.SftpConsumer] - Polling directory: 20181123\/Data TRACE 2019-04-05T18:40:02,809 [org.apache.camel.component.file.remote.SftpOperations] - listFiles(20181123\/Data) TRACE 2019-04-05T18:40:02,871 [org.apache.camel.component.file.remote.SftpConsumer] - Found 501 in directory: 20181123\/Data TRACE 2019-04-05T18:40:02,871 [org.apache.camel.component.file.remote.SftpConsumer] - SftpFile[fileName=., longName=dr-x------ 2 ftpadmin ftpadmin 0 Mar 12 05:26 ., dir=true] TRACE 2019-04-05T18:40:02,871 [org.apache.camel.component.file.remote.SftpConsumer] - File did not match. Will skip this file: RemoteFile[Data\/.] TRACE 2019-04-05T18:40:02,871 [org.apache.camel.component.file.remote.SftpConsumer] - SftpFile[fileName=.., longName=dr-x------ 2 ftpadmin ftpadmin 0 Mar 12 05:27 .., dir=true] TRACE 2019-04-05T18:40:02,871 [org.apache.camel.component.file.remote.SftpConsumer] - File did not match. Will skip this file: RemoteFile[Data\/..] TRACE 2019-04-05T18:40:02,871 [org.apache.camel.component.file.remote.SftpConsumer] - SftpFile[fileName=20181123021401015101004323IWNM.MMYR, longName=-r-x------ 1 ftpadmin ftpadmin 14846 Nov 23 2018 20181123021401015101004323IWNM.MMYR, dir=false] TRACE 2019-04-05T18:40:02,871 [org.apache.camel.component.file.remote.SftpConsumer] - File did not match. Will skip this file: RemoteFile[Data\/20181123021401015101004323IWNM.MMYR] }}\r\n\r\nI am sure that the cause of the issue has to be the addition '\/' prepending with directory name while listing {{listFor(\/XXXX)}}. How can I avoid it ! .. using {{seperator}} parameter didn't effect i suppose it is only for producing files and not for consuming. I need to resolve this issue as soon as possible. Please suggest me some solution :(\r\n\r\n*EDITED :*\r\n\r\nI can reproduce the issue in latest version as well,I suppose the issue is when there is no base path only the '\/' gets prepended which should not actually happen\r\n\r\nCode Snippet from SftpConsumer.java Camel 3.0.0.M1\r\n\r\n{{if (file.isDirectory()) \\{ RemoteFile<SftpRemoteFile> remote = asRemoteFile(absolutePath, file, getEndpoint().getCharset()); if (endpoint.isRecursive() && depth < endpoint.getMaxDepth() && isValidFile(remote, true, files)) { \/\/ recursive scan and add the sub files and folders String subDirectory = file.getFilename(); String path = absolutePath + \"\/\" + subDirectory; boolean canPollMore = pollSubDirectory(path, subDirectory, fileList, depth); if (!canPollMore) { return false; } } \/\/ we cannot use file.getAttrs().isLink on Windows, so we dont invoke the method \/\/ just assuming its a file we should poll } }}\r\n{quote}String path = absolutePath + \"\/\" + subDirectory;\r\n{quote}"
    },
    {
      "key":"CAMEL-13393",
      "title":"NullPointerException on opentracing example",
      "description":"When running service1 from of the opentracing example an NullPointerException is logged to the standard out:\r\n\r\n{code}\r\n2019-04-05 10:33:54.620  INFO 23268 --- [           main] o.a.camel.spring.boot.RoutesCollector    : Starting CamelMainRunController to ensure the main thread keeps running\r\n[WARNING] \r\njava.lang.RuntimeException: java.lang.NullPointerException\r\n    at org.apache.camel.spring.boot.CamelSpringBootApplicationController.run (CamelSpringBootApplicationController.java:83)\r\n    at org.apache.camel.spring.boot.CamelMainRunController$DaemonTask.run (1m2Cam20melM1ainRunController.java:53)9\r\n    -04-05 10:33:54.622  INFO at5m23268 java.lang.Thread.run --- [           main] o.a.c.impl.DefaultStreamCachingStrategy  : StreamCaching in use with spool directory: \/tmp\/camel\/camel-tmp-4e01e06f-baf2-4a4c-abce-89e2a14f7516 and rules: [Sp (Thread.java:748)\r\nool > 128K body size]\r\nCaused by: java.lang.NullPointerException\r\n    at org.apache.camel.main.MainSupport.postProcessCamelContext (MainSupport.java:745)\r\n    at org.apache.camel.main.MainSupport.initCamelContext (MainSupport.java:676)\r\n    at org.apache.camel.main.Main.doStart (Main.java:107)\r\n    at org.apache.camel.support.service.ServiceSupport.start (ServiceSupport.java:86)\r\n    at org.apache.camel.main.MainSupport.run (MainSupport.java:203)\r\n    at org.apache.camel.spring.boot.CamelSpringBootApplicationController.run (CamelSpringBootApplicationController.java:78)\r\n    at org.apache.camel.spring.boot.CamelMainRunController$DaemonTask.run (CamelMainRunController.java:53)\r\n    at java.lang.Thread.run (Thread.java:748)\r\n{code}\r\n\r\nTake a look at CAMEL-13386 on how to reproduce.",
      "assignee":"davsclaus",
      "type":"Bug",
      "priority":"Major",
      "status":"Resolved",
      "text":"NullPointerException on opentracing example When running service1 from of the opentracing example an NullPointerException is logged to the standard out:\r\n\r\n{code}\r\n2019-04-05 10:33:54.620  INFO 23268 --- [           main] o.a.camel.spring.boot.RoutesCollector    : Starting CamelMainRunController to ensure the main thread keeps running\r\n[WARNING] \r\njava.lang.RuntimeException: java.lang.NullPointerException\r\n    at org.apache.camel.spring.boot.CamelSpringBootApplicationController.run (CamelSpringBootApplicationController.java:83)\r\n    at org.apache.camel.spring.boot.CamelMainRunController$DaemonTask.run (1m2Cam20melM1ainRunController.java:53)9\r\n    -04-05 10:33:54.622  INFO at5m23268 java.lang.Thread.run --- [           main] o.a.c.impl.DefaultStreamCachingStrategy  : StreamCaching in use with spool directory: \/tmp\/camel\/camel-tmp-4e01e06f-baf2-4a4c-abce-89e2a14f7516 and rules: [Sp (Thread.java:748)\r\nool > 128K body size]\r\nCaused by: java.lang.NullPointerException\r\n    at org.apache.camel.main.MainSupport.postProcessCamelContext (MainSupport.java:745)\r\n    at org.apache.camel.main.MainSupport.initCamelContext (MainSupport.java:676)\r\n    at org.apache.camel.main.Main.doStart (Main.java:107)\r\n    at org.apache.camel.support.service.ServiceSupport.start (ServiceSupport.java:86)\r\n    at org.apache.camel.main.MainSupport.run (MainSupport.java:203)\r\n    at org.apache.camel.spring.boot.CamelSpringBootApplicationController.run (CamelSpringBootApplicationController.java:78)\r\n    at org.apache.camel.spring.boot.CamelMainRunController$DaemonTask.run (CamelMainRunController.java:53)\r\n    at java.lang.Thread.run (Thread.java:748)\r\n{code}\r\n\r\nTake a look at CAMEL-13386 on how to reproduce."
    },
    {
      "key":"CAMEL-13388",
      "title":"Wrong removing parameters logic in ServiceComponent.",
      "description":"Component: camel-service\r\n\r\nMistake in class :\u00a0org.apache.camel.component.service.ServiceComponent.java:83\r\n\r\nThis error prevents the delegating component from receiving URI parameters.\r\n\r\n*Have:*\r\n{code:java}\r\nparameters.keySet().removeAll(parameters.keySet());\r\n{code}\r\n*Must be:*\r\n{code:java}\r\nparameters.keySet().removeAll(params.keySet());\r\n{code}\r\n\u00a0",
      "assignee":"davsclaus",
      "type":"Bug",
      "priority":"Major",
      "status":"Resolved",
      "text":"Wrong removing parameters logic in ServiceComponent. Component: camel-service\r\n\r\nMistake in class : org.apache.camel.component.service.ServiceComponent.java:83\r\n\r\nThis error prevents the delegating component from receiving URI parameters.\r\n\r\n*Have:*\r\n{code:java}\r\nparameters.keySet().removeAll(parameters.keySet());\r\n{code}\r\n*Must be:*\r\n{code:java}\r\nparameters.keySet().removeAll(params.keySet());\r\n{code}\r\n "
    },
    {
      "key":"CAMEL-13387",
      "title":"camel-twitter-direct-message doesn't filter by filterOld parameter",
      "description":"DirectMessageConsumerHandler doesn't filter old messages when parameter filterOld=true",
      "assignee":"davsclaus",
      "type":"Bug",
      "priority":"Minor",
      "status":"Resolved",
      "text":"camel-twitter-direct-message doesn't filter by filterOld parameter DirectMessageConsumerHandler doesn't filter old messages when parameter filterOld=true"
    },
    {
      "key":"CAMEL-13383",
      "title":"maven plugi validation fails with 3.0.0m1\/m2",
      "description":"The camel plugin fails validation which passed fine in v2.latest.\r\nAlso from the error-message it is not easy to understand what is really the problem?\r\n\r\n{noformat}\r\nINFO] [jenkins-event-spy] Generated \/data\/jenkins\/workspace\/c-jfr-server_feature_camel3-Y6VPXEFM3D7D7C2V3GQRGLFL7QLPEWEFUJY6V6RFK46FIDVYQ7SQ@tmp\/withMavenca46cdd5\/maven-spy-20190401-102256-4351026941413226375350.log\r\n\r\n[ERROR] Failed to execute goal org.apache.camel:camel-report-maven-plugin:3.0.0-M2:validate (default) on project jfr-srv-batch: Endpoint validation success: (1 = passed, 0 = invalid, 1 = incapable, 0 = unknown components, 0 = deprecated options)\r\n\r\n[ERROR] Simple validation error: (0 = passed, 1 = invalid)\r\n\r\n[ERROR] Duplicate route id validation success (0 = ids)\r\n\r\n[ERROR] Endpoint pair (seda\/direct) validation success (0 = pairs)\r\n\r\n[ERROR] -> [Help 1]\r\n\r\norg.apache.maven.lifecycle.LifecycleExecutionException: Failed to execute goal org.apache.camel:camel-report-maven-plugin:3.0.0-M2:validate (default) on project jfr-srv-batch: Endpoint validation success: (1 = passed, 0 = invalid, 1 = incapable, 0 = unknown components, 0 = deprecated options)\r\n\r\nSimple validation error: (0 = passed, 1 = invalid)\r\n\r\nDuplicate route id validation success (0 = ids)\r\n\r\nEndpoint pair (seda\/direct) validation success (0 = pairs)\r\n\r\n    at org.apache.maven.lifecycle.internal.MojoExecutor.execute (MojoExecutor.java:215)\r\n\r\n    at org.apache.maven.lifecycle.internal.MojoExecutor.execute (MojoExecutor.java:156)\r\n\r\n    at org.apache.maven.lifecycle.internal.MojoExecutor.execute (MojoExecutor.java:148)\r\n\r\n    at org.apache.maven.lifecycle.internal.LifecycleModuleBuilder.buildProject (LifecycleModuleBuilder.java:117)\r\n\r\n    at org.apache.maven.lifecycle.internal.builder.multithreaded.MultiThreadedBuilder$1.call (MultiThreadedBuilder.java:200)\r\n\r\n    at org.apache.maven.lifecycle.internal.builder.multithreaded.MultiThreadedBuilder$1.call (MultiThreadedBuilder.java:196)\r\n\r\n    at java.util.concurrent.FutureTask.run (FutureTask.java:264)\r\n\r\n    at java.util.concurrent.Executors$RunnableAdapter.call (Executors.java:515)\r\n\r\n    at java.util.concurrent.FutureTask.run (FutureTask.java:264)\r\n\r\n    at java.util.concurrent.ThreadPoolExecutor.runWorker (ThreadPoolExecutor.java:1128)\r\n\r\n    at java.util.concurrent.ThreadPoolExecutor$Worker.run (ThreadPoolExecutor.java:628)\r\n\r\n    at java.lang.Thread.run (Thread.java:835)\r\n\r\nCaused by: org.apache.maven.plugin.MojoExecutionException: Endpoint validation success: (1 = passed, 0 = invalid, 1 = incapable, 0 = unknown components, 0 = deprecated options)\r\n\r\nSimple validation error: (0 = passed, 1 = invalid)\r\n\r\nDuplicate route id validation success (0 = ids)\r\n\r\nEndpoint pair (seda\/direct) validation success (0 = pairs)\r\n\r\n    at org.apache.camel.maven.ValidateMojo.execute (ValidateMojo.java:484)\r\n\r\n    at org.apache.maven.plugin.DefaultBuildPluginManager.executeMojo (DefaultBuildPluginManager.java:137)\r\n\r\n    at org.apache.maven.lifecycle.internal.MojoExecutor.execute (MojoExecutor.java:210)\r\n\r\n    at org.apache.maven.lifecycle.internal.MojoExecutor.execute (MojoExecutor.java:156)\r\n\r\n    at org.apache.maven.lifecycle.internal.MojoExecutor.execute (MojoExecutor.java:148)\r\n\r\n    at org.apache.maven.lifecycle.internal.LifecycleModuleBuilder.buildProject (LifecycleModuleBuilder.java:117)\r\n\r\n    at org.apache.maven.lifecycle.internal.builder.multithreaded.MultiThreadedBuilder$1.call (MultiThreadedBuilder.java:200)\r\n\r\n    at org.apache.maven.lifecycle.internal.builder.multithreaded.MultiThreadedBuilder$1.call (MultiThreadedBuilder.java:196)\r\n\r\n    at java.util.concurrent.FutureTask.run (FutureTask.java:264)\r\n\r\n    at java.util.concurrent.Executors$RunnableAdapter.call (Executors.java:515)\r\n\r\n    at java.util.concurrent.FutureTask.run (FutureTask.java:264)\r\n\r\n    at java.util.concurrent.ThreadPoolExecutor.runWorker (ThreadPoolExecutor.java:1128)\r\n\r\n    at java.util.concurrent.ThreadPoolExecutor$Worker.run (ThreadPoolExecutor.java:628)\r\n\r\n    at java.lang.Thread.run (Thread.java:835)\r\n{noformat}",
      "assignee":"davsclaus",
      "type":"Bug",
      "priority":"Major",
      "status":"Resolved",
      "text":"maven plugi validation fails with 3.0.0m1\/m2 The camel plugin fails validation which passed fine in v2.latest.\r\nAlso from the error-message it is not easy to understand what is really the problem?\r\n\r\n{noformat}\r\nINFO] [jenkins-event-spy] Generated \/data\/jenkins\/workspace\/c-jfr-server_feature_camel3-Y6VPXEFM3D7D7C2V3GQRGLFL7QLPEWEFUJY6V6RFK46FIDVYQ7SQ@tmp\/withMavenca46cdd5\/maven-spy-20190401-102256-4351026941413226375350.log\r\n\r\n[ERROR] Failed to execute goal org.apache.camel:camel-report-maven-plugin:3.0.0-M2:validate (default) on project jfr-srv-batch: Endpoint validation success: (1 = passed, 0 = invalid, 1 = incapable, 0 = unknown components, 0 = deprecated options)\r\n\r\n[ERROR] Simple validation error: (0 = passed, 1 = invalid)\r\n\r\n[ERROR] Duplicate route id validation success (0 = ids)\r\n\r\n[ERROR] Endpoint pair (seda\/direct) validation success (0 = pairs)\r\n\r\n[ERROR] -> [Help 1]\r\n\r\norg.apache.maven.lifecycle.LifecycleExecutionException: Failed to execute goal org.apache.camel:camel-report-maven-plugin:3.0.0-M2:validate (default) on project jfr-srv-batch: Endpoint validation success: (1 = passed, 0 = invalid, 1 = incapable, 0 = unknown components, 0 = deprecated options)\r\n\r\nSimple validation error: (0 = passed, 1 = invalid)\r\n\r\nDuplicate route id validation success (0 = ids)\r\n\r\nEndpoint pair (seda\/direct) validation success (0 = pairs)\r\n\r\n    at org.apache.maven.lifecycle.internal.MojoExecutor.execute (MojoExecutor.java:215)\r\n\r\n    at org.apache.maven.lifecycle.internal.MojoExecutor.execute (MojoExecutor.java:156)\r\n\r\n    at org.apache.maven.lifecycle.internal.MojoExecutor.execute (MojoExecutor.java:148)\r\n\r\n    at org.apache.maven.lifecycle.internal.LifecycleModuleBuilder.buildProject (LifecycleModuleBuilder.java:117)\r\n\r\n    at org.apache.maven.lifecycle.internal.builder.multithreaded.MultiThreadedBuilder$1.call (MultiThreadedBuilder.java:200)\r\n\r\n    at org.apache.maven.lifecycle.internal.builder.multithreaded.MultiThreadedBuilder$1.call (MultiThreadedBuilder.java:196)\r\n\r\n    at java.util.concurrent.FutureTask.run (FutureTask.java:264)\r\n\r\n    at java.util.concurrent.Executors$RunnableAdapter.call (Executors.java:515)\r\n\r\n    at java.util.concurrent.FutureTask.run (FutureTask.java:264)\r\n\r\n    at java.util.concurrent.ThreadPoolExecutor.runWorker (ThreadPoolExecutor.java:1128)\r\n\r\n    at java.util.concurrent.ThreadPoolExecutor$Worker.run (ThreadPoolExecutor.java:628)\r\n\r\n    at java.lang.Thread.run (Thread.java:835)\r\n\r\nCaused by: org.apache.maven.plugin.MojoExecutionException: Endpoint validation success: (1 = passed, 0 = invalid, 1 = incapable, 0 = unknown components, 0 = deprecated options)\r\n\r\nSimple validation error: (0 = passed, 1 = invalid)\r\n\r\nDuplicate route id validation success (0 = ids)\r\n\r\nEndpoint pair (seda\/direct) validation success (0 = pairs)\r\n\r\n    at org.apache.camel.maven.ValidateMojo.execute (ValidateMojo.java:484)\r\n\r\n    at org.apache.maven.plugin.DefaultBuildPluginManager.executeMojo (DefaultBuildPluginManager.java:137)\r\n\r\n    at org.apache.maven.lifecycle.internal.MojoExecutor.execute (MojoExecutor.java:210)\r\n\r\n    at org.apache.maven.lifecycle.internal.MojoExecutor.execute (MojoExecutor.java:156)\r\n\r\n    at org.apache.maven.lifecycle.internal.MojoExecutor.execute (MojoExecutor.java:148)\r\n\r\n    at org.apache.maven.lifecycle.internal.LifecycleModuleBuilder.buildProject (LifecycleModuleBuilder.java:117)\r\n\r\n    at org.apache.maven.lifecycle.internal.builder.multithreaded.MultiThreadedBuilder$1.call (MultiThreadedBuilder.java:200)\r\n\r\n    at org.apache.maven.lifecycle.internal.builder.multithreaded.MultiThreadedBuilder$1.call (MultiThreadedBuilder.java:196)\r\n\r\n    at java.util.concurrent.FutureTask.run (FutureTask.java:264)\r\n\r\n    at java.util.concurrent.Executors$RunnableAdapter.call (Executors.java:515)\r\n\r\n    at java.util.concurrent.FutureTask.run (FutureTask.java:264)\r\n\r\n    at java.util.concurrent.ThreadPoolExecutor.runWorker (ThreadPoolExecutor.java:1128)\r\n\r\n    at java.util.concurrent.ThreadPoolExecutor$Worker.run (ThreadPoolExecutor.java:628)\r\n\r\n    at java.lang.Thread.run (Thread.java:835)\r\n{noformat}"
    },
    {
      "key":"CAMEL-13380",
      "title":"camel-core - Move cloud out into camel-cloud component",
      "description":"Lets see if we can move the cloud parts out of camel-core into a new camel-cloud that some components uses, like camel-service, camel-ribbon etc.",
      "assignee":"davsclaus",
      "type":"Task",
      "priority":"Major",
      "status":"Resolved",
      "text":"camel-core - Move cloud out into camel-cloud component Lets see if we can move the cloud parts out of camel-core into a new camel-cloud that some components uses, like camel-service, camel-ribbon etc."
    },
    {
      "key":"CAMEL-13375",
      "title":"Remove the JMX explain APis and related",
      "description":"We have a set of explain APIs on JMX that can output \"catalog\" like information. However we dont really use it, and this can help remove functionality and complexity of camel-core.\r\n\r\nYou can get details via the camel-catalog and at runtime the runtime camel-catalog.",
      "assignee":"davsclaus",
      "type":"Task",
      "priority":"Major",
      "status":"Resolved",
      "text":"Remove the JMX explain APis and related We have a set of explain APIs on JMX that can output \"catalog\" like information. However we dont really use it, and this can help remove functionality and complexity of camel-core.\r\n\r\nYou can get details via the camel-catalog and at runtime the runtime camel-catalog."
    },
    {
      "key":"CAMEL-13373",
      "title":"camel-stax - FileInputStream not closed",
      "description":"The\u00a0StAXProcessor.java class does not close the stream it opens.\r\n\r\nI had to modify it like this:\u00a0\r\n\r\npublic void process(Exchange exchange) throws Exception {\r\n InputSource is = exchange.getIn().getMandatoryBody(InputSource.class);\r\n XMLStreamReader stream = exchange.getIn().getMandatoryBody(XMLStreamReader.class);\r\n \/\/ Fermeture de la inputstream ici, car dans la version originale de la classe la stream reste ouverte.\r\n *try(InputStream inputStreamToClose = is.getByteStream()) {*\r\n XMLReader reader = new StaxStreamXMLReader(stream);\r\n ContentHandler handler;\r\n if (this.contentHandlerClass != null)\r\n\r\n{ handler = (ContentHandler) this.contentHandlerClass.newInstance(); }\r\n\r\nelse\r\n\r\n{ handler = this.contentHandler; }\r\n\r\nreader.setContentHandler(handler);\r\n reader.parse(is);\r\n if (ExchangeHelper.isOutCapable(exchange))\r\n\r\n{ exchange.getOut().setHeaders(exchange.getIn().getHeaders()); exchange.getOut().setBody(handler); }\r\n\r\nelse\r\n\r\n{ exchange.getIn().setBody(handler); }\r\n\r\n} *finally*\r\n\r\n*{ \/\/ Fermeture de la strem ValidatingStreamReader validatingStreamReader = (ValidatingStreamReader)stream; validatingStreamReader.closeCompletely(); }*\r\n\r\n*}*",
      "assignee":"davsclaus",
      "type":"Bug",
      "priority":"Minor",
      "status":"Resolved",
      "text":"camel-stax - FileInputStream not closed The StAXProcessor.java class does not close the stream it opens.\r\n\r\nI had to modify it like this: \r\n\r\npublic void process(Exchange exchange) throws Exception {\r\n InputSource is = exchange.getIn().getMandatoryBody(InputSource.class);\r\n XMLStreamReader stream = exchange.getIn().getMandatoryBody(XMLStreamReader.class);\r\n \/\/ Fermeture de la inputstream ici, car dans la version originale de la classe la stream reste ouverte.\r\n *try(InputStream inputStreamToClose = is.getByteStream()) {*\r\n XMLReader reader = new StaxStreamXMLReader(stream);\r\n ContentHandler handler;\r\n if (this.contentHandlerClass != null)\r\n\r\n{ handler = (ContentHandler) this.contentHandlerClass.newInstance(); }\r\n\r\nelse\r\n\r\n{ handler = this.contentHandler; }\r\n\r\nreader.setContentHandler(handler);\r\n reader.parse(is);\r\n if (ExchangeHelper.isOutCapable(exchange))\r\n\r\n{ exchange.getOut().setHeaders(exchange.getIn().getHeaders()); exchange.getOut().setBody(handler); }\r\n\r\nelse\r\n\r\n{ exchange.getIn().setBody(handler); }\r\n\r\n} *finally*\r\n\r\n*{ \/\/ Fermeture de la strem ValidatingStreamReader validatingStreamReader = (ValidatingStreamReader)stream; validatingStreamReader.closeCompletely(); }*\r\n\r\n*}*"
    },
    {
      "key":"CAMEL-13370",
      "title":"resolve delegating endpoint when routes are dumped",
      "description":"As today the ModelHelper.dumpModelAsXml(..., ...) does not resolve delegating endpoint so in case an endpoint delegates to an additional endpoint, this delegated endpoint is not shown in the routes dump.\r\n\r\nIt would be nice to have an option to configure if the delegating endpoint should be replaced by the delegated one on dumpModelAsXml",
      "assignee":"davsclaus",
      "type":"Improvement",
      "priority":"Minor",
      "status":"Resolved",
      "text":"resolve delegating endpoint when routes are dumped As today the ModelHelper.dumpModelAsXml(..., ...) does not resolve delegating endpoint so in case an endpoint delegates to an additional endpoint, this delegated endpoint is not shown in the routes dump.\r\n\r\nIt would be nice to have an option to configure if the delegating endpoint should be replaced by the delegated one on dumpModelAsXml"
    },
    {
      "key":"CAMEL-13369",
      "title":"enhance message history eip ",
      "description":"The current message history eip is somehow limited as we cannot choose which nodes we want to take into account, as example if one creates routes using the new Step EIP, he may want to get the history to track step related activities only.\r\n\r\nAnother additional feature would be to have the message history pattern to keep a copy of the message being produced by the processor under monitor.",
      "assignee":"davsclaus",
      "type":"New Feature",
      "priority":"Minor",
      "status":"Resolved",
      "text":"enhance message history eip  The current message history eip is somehow limited as we cannot choose which nodes we want to take into account, as example if one creates routes using the new Step EIP, he may want to get the history to track step related activities only.\r\n\r\nAnother additional feature would be to have the message history pattern to keep a copy of the message being produced by the processor under monitor."
    },
    {
      "key":"CAMEL-13367",
      "title":"camel-jaxb - Error loading fallback type converter in Karaf",
      "description":"To reproduce then unit test cia2 source code chapter10-camel-cxf-rest-karaf",
      "assignee":"davsclaus",
      "type":"Bug",
      "priority":"Major",
      "status":"Resolved",
      "text":"camel-jaxb - Error loading fallback type converter in Karaf To reproduce then unit test cia2 source code chapter10-camel-cxf-rest-karaf"
    },
    {
      "key":"CAMEL-13366",
      "title":"MLLP Endpoint 'maxConcurrentConsumers' configuration support",
      "description":"If you provide 'maxConcurrentConsumers' query parameter on the endpoint URI, then, the route fails with error message \r\n\r\n_\"There are 1 parameters that couldn't be set on the endpoint. Check the uri\r\nif the parameters are spelt correctly and that they are properties of the endpoint. Unknown parameters=[{maxConcurrentConsumers=xx}] \"_\r\n\r\nAs per docs, it should be supported as query parameter.",
      "assignee":"davsclaus",
      "type":"Bug",
      "priority":"Minor",
      "status":"Resolved",
      "text":"MLLP Endpoint 'maxConcurrentConsumers' configuration support If you provide 'maxConcurrentConsumers' query parameter on the endpoint URI, then, the route fails with error message \r\n\r\n_\"There are 1 parameters that couldn't be set on the endpoint. Check the uri\r\nif the parameters are spelt correctly and that they are properties of the endpoint. Unknown parameters=[{maxConcurrentConsumers=xx}] \"_\r\n\r\nAs per docs, it should be supported as query parameter."
    },
    {
      "key":"CAMEL-13360",
      "title":"SEDA documentation does not track new bounded size value",
      "description":"SEDA component has a bounded limit again thanks on work done for:\r\n\"seda - Have a default queue size limit (CAMEL-12542)\"\r\n\r\n\u00a0the documentation here :\r\nhttps:\/\/cwiki.apache.org\/confluence\/display\/CAMEL\/SEDA\r\ndoes not reflect the change\r\n",
      "assignee":"davsclaus",
      "type":"Bug",
      "priority":"Minor",
      "status":"Resolved",
      "text":"SEDA documentation does not track new bounded size value SEDA component has a bounded limit again thanks on work done for:\r\n\"seda - Have a default queue size limit (CAMEL-12542)\"\r\n\r\n the documentation here :\r\nhttps:\/\/cwiki.apache.org\/confluence\/display\/CAMEL\/SEDA\r\ndoes not reflect the change\r\n"
    },
    {
      "key":"CAMEL-13358",
      "title":"Sometimes SedaConsumer does not start and remains stuck",
      "description":"Sometimes we notice that some of our routes get \"stuck\" and do not process anything.\u00a0 Looking at the stacktrace for such a route we see something like this:\r\n{code:java}\r\n\"Camel (SomeName) thread #648 - seda:\/\/someName\" #1287 daemon prio=5 os_prio=0 tid=0x00007f23880cf000 nid=0x25006 waiting on condition [0x00007f1f23530000]\r\n   java.lang.Thread.State: WAITING (parking)\r\n        at sun.misc.Unsafe.park(Native Method)\r\n        - parking to wait for  <0x00000006e4beb8e0> (a java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject)\r\n        at java.util.concurrent.locks.LockSupport.park(LockSupport.java:175)\r\n        at java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject.await(AbstractQueuedSynchronizer.java:2039)\r\n        at java.util.concurrent.LinkedBlockingQueue.take(LinkedBlockingQueue.java:442)\r\n        at java.util.concurrent.ThreadPoolExecutor.getTask(ThreadPoolExecutor.java:1067)\r\n        at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1127)\r\n        at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617)\r\n        at java.lang.Thread.run(Thread.java:748)\r\n{code}\r\nwhereas we would instead normally expect to see something like this:\r\n{code:java}\r\n\"Camel (SomeName) thread #840 - seda:\/\/someName\" #1577 daemon prio=5 os_prio=0 tid=0x00007f227c02b000 nid=0x256fe waiting on condition [0x00007f1f0ca20000]\r\n   java.lang.Thread.State: TIMED_WAITING (parking)\r\n        at sun.misc.Unsafe.park(Native Method)\r\n        - parking to wait for  <0x00000006eb69c1f8> (a java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject)\r\n        at java.util.concurrent.locks.LockSupport.parkNanos(LockSupport.java:215)\r\n        at java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject.awaitNanos(AbstractQueuedSynchronizer.java:2078)\r\n        at java.util.concurrent.LinkedBlockingQueue.poll(LinkedBlockingQueue.java:467)\r\n        at org.apache.camel.component.seda.SedaConsumer.doRun(SedaConsumer.java:198)\r\n        at org.apache.camel.component.seda.SedaConsumer.run(SedaConsumer.java:154)\r\n        at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142)\r\n        at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617)\r\n        at java.lang.Thread.run(Thread.java:748)\r\n{code}\r\n\r\nNote that whereas this latter example has SedaConsumer in the stacktrace polling for an exchange, the former example has no such SedaConsumer in the stacktrace and is stuck waiting for a new \"task\" to be given to the ThreadPoolExecutor.\r\n\r\nAfter adding debug logging, I see that the issue is as follows:\r\n\r\nThe code in ServiceSupport here writes to the starting and started flags using one thread (call it Thread W):\r\n{code}\r\n    public void start() throws Exception {\r\n        if (isStarting() || isStarted()) {\r\n            \/\/ only start service if not already started\r\n            LOG.trace(\"Service already started\");\r\n            return;\r\n        }\r\n        if (starting.compareAndSet(false, true)) {\r\n            LOG.trace(\"Starting service\");\r\n            try {\r\n                doStart();\r\n                started.set(true);\r\n                starting.set(false);\r\n{code}\r\nand on a different thread (call it thread R) this code in ServiceSupport reads the starting and started flags:\r\n{code}\r\n    public boolean isRunAllowed() {\r\n        \/\/ if we have not yet initialized, then all options is false\r\n        boolean unused1 = !started.get() && !starting.get() && !stopping.get() && !stopped.get();\r\n        boolean unused2 = !suspending.get() && !suspended.get() && !shutdown.get() && !shuttingdown.get();\r\n        if (unused1 && unused2) {\r\n            return false;\r\n        }\r\n        return !isStoppingOrStopped();\r\n    }\r\n{code}\r\n\r\nSo the order of events is:\r\n# Thread W: calls ServiceSupport.start()\r\n# Thread W: compareAndSet starting from false to true\r\n# Thread W: calls ServiceSupport.doStart() which eventually creates and starts Thread R\r\n# Thread R: calls SedaConsumer.doRun() which calls isRunAllowed()\r\n# Thread R: in isRunAllowed() reads started as false\r\n# Thread W: set started to true\r\n# Thread W: set starting to false\r\n# Thread R: in isRunAllowed() reads starting as false\r\n# Thread R: concludes that isRunAllowed is false\r\n# Thread R: the while loop in SedaConsumer.doRun is not executed and the thread will forever remain stuck waiting for a new \"task\" (on ThreadPoolExecutor.java:1067)\r\n\r\nOne fix would be to swap reading of starting and started so that starting is read first, then started.\r\n\r\nLooking at the latest code in Camel 3.0.x, this code has been refactored to use a single \"status\" field instead of multiple different AtomicBoolean fields.  That should also fix this bug.  However, for completeness, I thought it best to log this bug anyway.",
      "assignee":"davsclaus",
      "type":"Bug",
      "priority":"Major",
      "status":"Resolved",
      "text":"Sometimes SedaConsumer does not start and remains stuck Sometimes we notice that some of our routes get \"stuck\" and do not process anything.  Looking at the stacktrace for such a route we see something like this:\r\n{code:java}\r\n\"Camel (SomeName) thread #648 - seda:\/\/someName\" #1287 daemon prio=5 os_prio=0 tid=0x00007f23880cf000 nid=0x25006 waiting on condition [0x00007f1f23530000]\r\n   java.lang.Thread.State: WAITING (parking)\r\n        at sun.misc.Unsafe.park(Native Method)\r\n        - parking to wait for  <0x00000006e4beb8e0> (a java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject)\r\n        at java.util.concurrent.locks.LockSupport.park(LockSupport.java:175)\r\n        at java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject.await(AbstractQueuedSynchronizer.java:2039)\r\n        at java.util.concurrent.LinkedBlockingQueue.take(LinkedBlockingQueue.java:442)\r\n        at java.util.concurrent.ThreadPoolExecutor.getTask(ThreadPoolExecutor.java:1067)\r\n        at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1127)\r\n        at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617)\r\n        at java.lang.Thread.run(Thread.java:748)\r\n{code}\r\nwhereas we would instead normally expect to see something like this:\r\n{code:java}\r\n\"Camel (SomeName) thread #840 - seda:\/\/someName\" #1577 daemon prio=5 os_prio=0 tid=0x00007f227c02b000 nid=0x256fe waiting on condition [0x00007f1f0ca20000]\r\n   java.lang.Thread.State: TIMED_WAITING (parking)\r\n        at sun.misc.Unsafe.park(Native Method)\r\n        - parking to wait for  <0x00000006eb69c1f8> (a java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject)\r\n        at java.util.concurrent.locks.LockSupport.parkNanos(LockSupport.java:215)\r\n        at java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject.awaitNanos(AbstractQueuedSynchronizer.java:2078)\r\n        at java.util.concurrent.LinkedBlockingQueue.poll(LinkedBlockingQueue.java:467)\r\n        at org.apache.camel.component.seda.SedaConsumer.doRun(SedaConsumer.java:198)\r\n        at org.apache.camel.component.seda.SedaConsumer.run(SedaConsumer.java:154)\r\n        at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142)\r\n        at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617)\r\n        at java.lang.Thread.run(Thread.java:748)\r\n{code}\r\n\r\nNote that whereas this latter example has SedaConsumer in the stacktrace polling for an exchange, the former example has no such SedaConsumer in the stacktrace and is stuck waiting for a new \"task\" to be given to the ThreadPoolExecutor.\r\n\r\nAfter adding debug logging, I see that the issue is as follows:\r\n\r\nThe code in ServiceSupport here writes to the starting and started flags using one thread (call it Thread W):\r\n{code}\r\n    public void start() throws Exception {\r\n        if (isStarting() || isStarted()) {\r\n            \/\/ only start service if not already started\r\n            LOG.trace(\"Service already started\");\r\n            return;\r\n        }\r\n        if (starting.compareAndSet(false, true)) {\r\n            LOG.trace(\"Starting service\");\r\n            try {\r\n                doStart();\r\n                started.set(true);\r\n                starting.set(false);\r\n{code}\r\nand on a different thread (call it thread R) this code in ServiceSupport reads the starting and started flags:\r\n{code}\r\n    public boolean isRunAllowed() {\r\n        \/\/ if we have not yet initialized, then all options is false\r\n        boolean unused1 = !started.get() && !starting.get() && !stopping.get() && !stopped.get();\r\n        boolean unused2 = !suspending.get() && !suspended.get() && !shutdown.get() && !shuttingdown.get();\r\n        if (unused1 && unused2) {\r\n            return false;\r\n        }\r\n        return !isStoppingOrStopped();\r\n    }\r\n{code}\r\n\r\nSo the order of events is:\r\n# Thread W: calls ServiceSupport.start()\r\n# Thread W: compareAndSet starting from false to true\r\n# Thread W: calls ServiceSupport.doStart() which eventually creates and starts Thread R\r\n# Thread R: calls SedaConsumer.doRun() which calls isRunAllowed()\r\n# Thread R: in isRunAllowed() reads started as false\r\n# Thread W: set started to true\r\n# Thread W: set starting to false\r\n# Thread R: in isRunAllowed() reads starting as false\r\n# Thread R: concludes that isRunAllowed is false\r\n# Thread R: the while loop in SedaConsumer.doRun is not executed and the thread will forever remain stuck waiting for a new \"task\" (on ThreadPoolExecutor.java:1067)\r\n\r\nOne fix would be to swap reading of starting and started so that starting is read first, then started.\r\n\r\nLooking at the latest code in Camel 3.0.x, this code has been refactored to use a single \"status\" field instead of multiple different AtomicBoolean fields.  That should also fix this bug.  However, for completeness, I thought it best to log this bug anyway."
    },
    {
      "key":"CAMEL-13355",
      "title":"MLLP Component 'maxConcurrentConsumers' configuration is ignored",
      "description":"If you set 'maxConcurrentConsumers' property in the MllpConfiguration object and assign that to MllpComponent, then, during creation of MllpEndpoint instance, that property is ignored and default value of 5 is used.",
      "assignee":"davsclaus",
      "type":"Bug",
      "priority":"Minor",
      "status":"Resolved",
      "text":"MLLP Component 'maxConcurrentConsumers' configuration is ignored If you set 'maxConcurrentConsumers' property in the MllpConfiguration object and assign that to MllpComponent, then, during creation of MllpEndpoint instance, that property is ignored and default value of 5 is used."
    },
    {
      "key":"CAMEL-13354",
      "title":"Camel main - Allow to configure hystrix via application.properties",
      "description":"So you can easily configure hystrix from property placeholders in application.properties etc, which you can do with spring boot etc.",
      "assignee":"davsclaus",
      "type":"Improvement",
      "priority":"Major",
      "status":"Resolved",
      "text":"Camel main - Allow to configure hystrix via application.properties So you can easily configure hystrix from property placeholders in application.properties etc, which you can do with spring boot etc."
    },
    {
      "key":"CAMEL-13353",
      "title":"Re-enable the camel-lra integration tests",
      "description":"These camel-lra integration tests\u00a0were ignored due to the JBTM issues which have been fixed in the Narayana 5.9.0.Final release. So I think it could be useful to re-enable to verify if it works.",
      "assignee":"davsclaus",
      "type":"Test",
      "priority":"Major",
      "status":"Resolved",
      "text":"Re-enable the camel-lra integration tests These camel-lra integration tests were ignored due to the JBTM issues which have been fixed in the Narayana 5.9.0.Final release. So I think it could be useful to re-enable to verify if it works."
    },
    {
      "key":"CAMEL-13352",
      "title":"Update document of HostAddresses ",
      "description":"As the Host and Port options are removed, we need to update the HostAddresses document for it.",
      "assignee":"njiang",
      "type":"Improvement",
      "priority":"Minor",
      "status":"Resolved",
      "text":"Update document of HostAddresses  As the Host and Port options are removed, we need to update the HostAddresses document for it."
    },
    {
      "key":"CAMEL-13348",
      "title":"Camel elasticsearch support search without specifying the indexName and indexType",
      "description":"ElasticSearch support not to specify the indexName and indexType for search, so camel-elasticsearch search option don't need to specify the indexName and indexType",
      "assignee":"njiang",
      "type":"Task",
      "priority":"Minor",
      "status":"Resolved",
      "text":"Camel elasticsearch support search without specifying the indexName and indexType ElasticSearch support not to specify the indexName and indexType for search, so camel-elasticsearch search option don't need to specify the indexName and indexType"
    },
    {
      "key":"CAMEL-13346",
      "title":"Camel main - Allow to add extra properties to property component",
      "description":"To make it easier to add custom properties from java api. Currently you can only configure properties locations (eg file locations)",
      "assignee":"davsclaus",
      "type":"Improvement",
      "priority":"Major",
      "status":"Resolved",
      "text":"Camel main - Allow to add extra properties to property component To make it easier to add custom properties from java api. Currently you can only configure properties locations (eg file locations)"
    },
    {
      "key":"CAMEL-13345",
      "title":"route-coverage : Add option to generate a jacoco XML report",
      "description":"Would be good to have the route-coverage maven plugin to be able to generate a XML report using the jacoco XML report format, described in the jacoco documentation\u00a0[https:\/\/www.jacoco.org\/jacoco\/trunk\/doc\/]\r\n\r\n\u00a0\r\n\r\nThe benefit is that tools like SonarQube has support for handling these XML reports and they can then add this into the report.\r\n\r\n\u00a0\r\n\r\n\u00a0",
      "assignee":"davsclaus",
      "type":"New Feature",
      "priority":"Major",
      "status":"Resolved",
      "text":"route-coverage : Add option to generate a jacoco XML report Would be good to have the route-coverage maven plugin to be able to generate a XML report using the jacoco XML report format, described in the jacoco documentation [https:\/\/www.jacoco.org\/jacoco\/trunk\/doc\/]\r\n\r\n \r\n\r\nThe benefit is that tools like SonarQube has support for handling these XML reports and they can then add this into the report.\r\n\r\n \r\n\r\n "
    },
    {
      "key":"CAMEL-13344",
      "title":"camel-sql - stored procedure loaded from file\/classpath should skip comment lines",
      "description":"The template is loaded from a resource such a file on the classpath, then lines with comments (start with --) should be skipped.",
      "assignee":"davsclaus",
      "type":"Improvement",
      "priority":"Major",
      "status":"Resolved",
      "text":"camel-sql - stored procedure loaded from file\/classpath should skip comment lines The template is loaded from a resource such a file on the classpath, then lines with comments (start with --) should be skipped."
    },
    {
      "key":"CAMEL-13339",
      "title":"Partition revoke implemented to save offset state using KafkaConsumer.position API results in message loss",
      "description":"Current implementation of org.apache.camel.component.kafka.KafkaConsumer.KafkaFetchRecords's onPartitionsRevoked, uses org.apache.kafka.clients.consumer.KafkaConsumer.position(partition). This approach causes message loss when multiple processes listening to same topic for point to point messaging (like a QUEUE) type implementation.\r\n\r\n\u00a0\r\n\r\nIssue is noticed when partition gets assigned and then gets revoked in quick succession. Upon partition assignment, say at the beginning of processing offset is set to 0, and say there was no poll for this partition (may be due to earlier poll brought in bunch of records and they are still being processed). Subsequently, say partition got revoked, before polling.\r\n\r\nIn this case, as onPartitionsRevoked looks at org.apache.kafka.clients.consumer.KafkaConsumer.position(partition) to save offset state and so 0 gets saved in this case in StateRepository implementation. When the same partition get assigned again, StateRepository.getState returns 0. Since Camel KafkaConsumer treats this as last processed offset, it adds 1 to it moving pointer to offset 1. Because of this, message at offset 0 never gets processed.\r\n\r\n\u00a0\r\n\r\nTwo fixes might be needed\r\n # a) onPartitionsRevoked should look at last processed offset (possibly store 'last processed offset' for each topic\/partition in a memory map) and use it to save offset\r\n # b) Currently onPartitionsRevoked just saves offset state when an implementation of StateRepository configured. Ideally it should call KafkaFetchRecords.commitOffset so commitSync call goes through when partition revoked and no StateRepository implementation configured",
      "assignee":"davsclaus",
      "type":"Bug",
      "priority":"Major",
      "status":"Resolved",
      "text":"Partition revoke implemented to save offset state using KafkaConsumer.position API results in message loss Current implementation of org.apache.camel.component.kafka.KafkaConsumer.KafkaFetchRecords's onPartitionsRevoked, uses org.apache.kafka.clients.consumer.KafkaConsumer.position(partition). This approach causes message loss when multiple processes listening to same topic for point to point messaging (like a QUEUE) type implementation.\r\n\r\n \r\n\r\nIssue is noticed when partition gets assigned and then gets revoked in quick succession. Upon partition assignment, say at the beginning of processing offset is set to 0, and say there was no poll for this partition (may be due to earlier poll brought in bunch of records and they are still being processed). Subsequently, say partition got revoked, before polling.\r\n\r\nIn this case, as onPartitionsRevoked looks at org.apache.kafka.clients.consumer.KafkaConsumer.position(partition) to save offset state and so 0 gets saved in this case in StateRepository implementation. When the same partition get assigned again, StateRepository.getState returns 0. Since Camel KafkaConsumer treats this as last processed offset, it adds 1 to it moving pointer to offset 1. Because of this, message at offset 0 never gets processed.\r\n\r\n \r\n\r\nTwo fixes might be needed\r\n # a) onPartitionsRevoked should look at last processed offset (possibly store 'last processed offset' for each topic\/partition in a memory map) and use it to save offset\r\n # b) Currently onPartitionsRevoked just saves offset state when an implementation of StateRepository configured. Ideally it should call KafkaFetchRecords.commitOffset so commitSync call goes through when partition revoked and no StateRepository implementation configured"
    },
    {
      "key":"CAMEL-13338",
      "title":"ConsumerRebalanceListener is not registered when topicIsPattern is turned off. Causing message loss or too many duplicates",
      "description":"Not registering\u00a0ConsumerRebalanceListener when\u00a0topicIsPattern turned off, causes either too many duplicate messages getting delivered to message processing layer or causes message loss depending on\u00a0autoOffsetReset flag value.\r\n\u00a0\r\nIssue is noticed with below test scenario\r\nTopic: e.g. TestMessage\r\nNumber of partitions: 25 (this is not completely relevant to issue)\r\nConsumerUri: kafka:<kafka-broker-uris>?topic=TestMessage&groupId=TestMessage_GROUP&consumersCount=5&autoCommitEnable=false&offsetRepository=#<DB-state-repository>\r\nNumber processes running consumers: 2 or more; e.g. two instances of Docker containers listening from same topic each with 5 consumer threads\r\n\u00a0\r\nPlease note that offset management is done in DB with an implementation of Camel's StateRepository interface to eliminate too duplicate messages arriving at the message processor (at most one message processing needed for my use case)\r\n\u00a0\r\nWhen a second process instance (say second container) brought up, since ConsumerRebalanceListener is not registered, partitions start processing at earliest offsets if\u00a0autoOffsetReset is set to earliest as expected. In this case, too many duplicate messages arrive at the message processing layer. If\u00a0autoOffsetReset is set to latest, message loss occurs for certain partitions. If\u00a0autoOffsetReset is set to none, no valid offset exception thrown by broker\r\n\u00a0\r\nIssue would be noticed consistently when simulating slow message processing for the above test scenario\r\n\u00a0\r\n\u00a0",
      "assignee":"davsclaus",
      "type":"Bug",
      "priority":"Major",
      "status":"Resolved",
      "text":"ConsumerRebalanceListener is not registered when topicIsPattern is turned off. Causing message loss or too many duplicates Not registering ConsumerRebalanceListener when topicIsPattern turned off, causes either too many duplicate messages getting delivered to message processing layer or causes message loss depending on autoOffsetReset flag value.\r\n \r\nIssue is noticed with below test scenario\r\nTopic: e.g. TestMessage\r\nNumber of partitions: 25 (this is not completely relevant to issue)\r\nConsumerUri: kafka:<kafka-broker-uris>?topic=TestMessage&groupId=TestMessage_GROUP&consumersCount=5&autoCommitEnable=false&offsetRepository=#<DB-state-repository>\r\nNumber processes running consumers: 2 or more; e.g. two instances of Docker containers listening from same topic each with 5 consumer threads\r\n \r\nPlease note that offset management is done in DB with an implementation of Camel's StateRepository interface to eliminate too duplicate messages arriving at the message processor (at most one message processing needed for my use case)\r\n \r\nWhen a second process instance (say second container) brought up, since ConsumerRebalanceListener is not registered, partitions start processing at earliest offsets if autoOffsetReset is set to earliest as expected. In this case, too many duplicate messages arrive at the message processing layer. If autoOffsetReset is set to latest, message loss occurs for certain partitions. If autoOffsetReset is set to none, no valid offset exception thrown by broker\r\n \r\nIssue would be noticed consistently when simulating slow message processing for the above test scenario\r\n \r\n "
    },
    {
      "key":"CAMEL-13335",
      "title":"create camel-cloudevents data type",
      "description":"We should create a camel-cloudevents data type based on https:\/\/github.com\/cloudevents\/sdk-java",
      "assignee":"njiang",
      "type":"New Feature",
      "priority":"Minor",
      "status":"Open",
      "text":"create camel-cloudevents data type We should create a camel-cloudevents data type based on https:\/\/github.com\/cloudevents\/sdk-java"
    },
    {
      "key":"CAMEL-13334",
      "title":"Message parameter for log component",
      "description":"There does not seem to be a good way to log a message describing what is logged.\r\n\r\nImagine I have a route, where I want to be able to trace all the content. I could use .log() processor but log component is better for tracing all the exchange details and also provides showStreams option.\r\n\r\n\u00a0\r\n{code:java}\r\nfrom(direct:in)\r\n.to(log:MyTestClass?level=TRACE)\r\n.to(direct:step1)\r\n.to(log:MyTestClass?level=TRACE)\r\n.to(direct:step2)\r\n.to(log:MyTestClass?level=TRACE)\r\n.to(direct:step3)\r\n.to(log:MyTestClass?level=TRACE)\r\n.to(mock:result)\r\n{code}\r\n\u00a0\r\n\r\nIn the resulting log, it will be hard to see which line is produced by which log producer.\r\n\r\nSomething like\u00a0\r\n{code:java}\r\n.to(log:MyTestClass?level=TRACE&message=user before step1){code}\r\nwould be quite helpful. Wondering why it has not been implemented yet. I found only early requests from 2008.\u00a0\r\n\r\nBeeing able to use simple language would be even better:\u00a0\u00a0\r\n{code:java}\r\n.to(log:MyTestClass?level=TRACE&message=user before step1 - ${header.user.name}){code}\r\n\u00a0",
      "assignee":"davsclaus",
      "type":"Improvement",
      "priority":"Minor",
      "status":"Resolved",
      "text":"Message parameter for log component There does not seem to be a good way to log a message describing what is logged.\r\n\r\nImagine I have a route, where I want to be able to trace all the content. I could use .log() processor but log component is better for tracing all the exchange details and also provides showStreams option.\r\n\r\n \r\n{code:java}\r\nfrom(direct:in)\r\n.to(log:MyTestClass?level=TRACE)\r\n.to(direct:step1)\r\n.to(log:MyTestClass?level=TRACE)\r\n.to(direct:step2)\r\n.to(log:MyTestClass?level=TRACE)\r\n.to(direct:step3)\r\n.to(log:MyTestClass?level=TRACE)\r\n.to(mock:result)\r\n{code}\r\n \r\n\r\nIn the resulting log, it will be hard to see which line is produced by which log producer.\r\n\r\nSomething like \r\n{code:java}\r\n.to(log:MyTestClass?level=TRACE&message=user before step1){code}\r\nwould be quite helpful. Wondering why it has not been implemented yet. I found only early requests from 2008. \r\n\r\nBeeing able to use simple language would be even better:  \r\n{code:java}\r\n.to(log:MyTestClass?level=TRACE&message=user before step1 - ${header.user.name}){code}\r\n "
    },
    {
      "key":"CAMEL-13329",
      "title":"camel-core - BeanConverter should be in core static converters",
      "description":"This component is still in camel-core and its not part of the core static converters. We should include it - until (if possible) we move the bean component out of camel-core.",
      "assignee":"davsclaus",
      "type":"Improvement",
      "priority":"Major",
      "status":"Resolved",
      "text":"camel-core - BeanConverter should be in core static converters This component is still in camel-core and its not part of the core static converters. We should include it - until (if possible) we move the bean component out of camel-core."
    },
    {
      "key":"CAMEL-13326",
      "title":"apt compiler - Separate core vs component processors",
      "description":"We should make camel-core \/ camel-spring \/ camel-blueprint have their own set of apt compiler plugins. And then another set for the general components etc.\r\n\r\nThis avoids running some of these on modules they dont need to do.",
      "assignee":"davsclaus",
      "type":"New Feature",
      "priority":"Major",
      "status":"Resolved",
      "text":"apt compiler - Separate core vs component processors We should make camel-core \/ camel-spring \/ camel-blueprint have their own set of apt compiler plugins. And then another set for the general components etc.\r\n\r\nThis avoids running some of these on modules they dont need to do."
    },
    {
      "key":"CAMEL-13313",
      "title":"camel-core - Add alternative way of loading type converters without classpath scanning",
      "description":"We should make it possible to load and install all type converters without having to do\r\n- classpath scanning\r\n- loading TypeConverter file from META-INF\r\n\r\nFor example we do some apt compiler source code generation for the core type converter.\r\nIt would be good to have something similar or other means of loading and installing type converters that can be done fast and quick, which is needed for Camel K and graal like runtimes.",
      "assignee":"davsclaus",
      "type":"New Feature",
      "priority":"Major",
      "status":"Resolved",
      "text":"camel-core - Add alternative way of loading type converters without classpath scanning We should make it possible to load and install all type converters without having to do\r\n- classpath scanning\r\n- loading TypeConverter file from META-INF\r\n\r\nFor example we do some apt compiler source code generation for the core type converter.\r\nIt would be good to have something similar or other means of loading and installing type converters that can be done fast and quick, which is needed for Camel K and graal like runtimes."
    },
    {
      "key":"CAMEL-13312",
      "title":"ModelCamelContext loadRoutesDefinition\/loadRestsDefinition are misleading",
      "description":"We do have method like loadRoutesDefinition and loadRestsDefinition in the ModelCamelContext interface but they are a little bit misleading as they do not load a definition in the camel context but they are an helper that invoke\r\n\r\n{code}\r\nModelHelper.loadRoutesDefinition(this, is)\r\n{code}\r\n\r\nThe only advantage is that you do not need to pass the camel context but other that that they appear as pure utility.\r\n\r\nToproperly load a route one need to do something something like\r\n\r\n{code}\r\ncontext.addRouteDefinitions(context.loadRoutesDefinition(is).getRoutes())\r\n{code}\r\n\r\nwhich is a little ugly\r\n",
      "assignee":"davsclaus",
      "type":"Improvement",
      "priority":"Minor",
      "status":"Resolved",
      "text":"ModelCamelContext loadRoutesDefinition\/loadRestsDefinition are misleading We do have method like loadRoutesDefinition and loadRestsDefinition in the ModelCamelContext interface but they are a little bit misleading as they do not load a definition in the camel context but they are an helper that invoke\r\n\r\n{code}\r\nModelHelper.loadRoutesDefinition(this, is)\r\n{code}\r\n\r\nThe only advantage is that you do not need to pass the camel context but other that that they appear as pure utility.\r\n\r\nToproperly load a route one need to do something something like\r\n\r\n{code}\r\ncontext.addRouteDefinitions(context.loadRoutesDefinition(is).getRoutes())\r\n{code}\r\n\r\nwhich is a little ugly\r\n"
    },
    {
      "key":"CAMEL-13311",
      "title":"camel-cdi and camel-blueprint - Cleanup bean post processor",
      "description":"Looks like they do some custom code that likely is not longer needed and can rely on the default out of the box.",
      "assignee":"davsclaus",
      "type":"Task",
      "priority":"Major",
      "status":"Resolved",
      "text":"camel-cdi and camel-blueprint - Cleanup bean post processor Looks like they do some custom code that likely is not longer needed and can rely on the default out of the box."
    },
    {
      "key":"CAMEL-13309",
      "title":"@EndpointInject - Use value as uri",
      "description":"We should favour using value as attribute name so you can use shorthand syntax with @EndpointInject(\"jms:cheese\") instead of having to use uri = \"xxx\"\r\n\r\nThe same for @Produce and @Consume etc",
      "assignee":"davsclaus",
      "type":"Improvement",
      "priority":"Major",
      "status":"Resolved",
      "text":"@EndpointInject - Use value as uri We should favour using value as attribute name so you can use shorthand syntax with @EndpointInject(\"jms:cheese\") instead of having to use uri = \"xxx\"\r\n\r\nThe same for @Produce and @Consume etc"
    },
    {
      "key":"CAMEL-13308",
      "title":"Remove ref on @Consume as you should use ref in the uri instead",
      "description":"We removed this on <to ref=\"xxx\"> already in the DSL. We should remove this in other places like @Consume annotation",
      "assignee":"davsclaus",
      "type":"Improvement",
      "priority":"Major",
      "status":"Resolved",
      "text":"Remove ref on @Consume as you should use ref in the uri instead We removed this on <to ref=\"xxx\"> already in the DSL. We should remove this in other places like @Consume annotation"
    },
    {
      "key":"CAMEL-13307",
      "title":"Camel registry - Allow to bind anonymously by type",
      "description":"With the new bind api on registry we should also allow to bind with null id and by the type only, so you can bind anonymously.\r\n\r\nFor example for single resources in microservices \/ serverless, which Camel K uses.",
      "assignee":"davsclaus",
      "type":"New Feature",
      "priority":"Major",
      "status":"Resolved",
      "text":"Camel registry - Allow to bind anonymously by type With the new bind api on registry we should also allow to bind with null id and by the type only, so you can bind anonymously.\r\n\r\nFor example for single resources in microservices \/ serverless, which Camel K uses."
    },
    {
      "key":"CAMEL-13303",
      "title":"Camel with OSGi blueprint on Karaf should detect JMX",
      "description":"10:31:00.277 INFO [Blueprint Event Dispatcher: 1] Attempting to start CamelContext: camel-1\r\n10:31:00.279 INFO [Blueprint Event Dispatcher: 1] Apache Camel 3.0.0-SNAPSHOT (CamelContext: camel-1) is starting\r\n10:31:00.281 INFO [Blueprint Event Dispatcher: 1] JMX is disabled",
      "assignee":"davsclaus",
      "type":"Bug",
      "priority":"Major",
      "status":"Resolved",
      "text":"Camel with OSGi blueprint on Karaf should detect JMX 10:31:00.277 INFO [Blueprint Event Dispatcher: 1] Attempting to start CamelContext: camel-1\r\n10:31:00.279 INFO [Blueprint Event Dispatcher: 1] Apache Camel 3.0.0-SNAPSHOT (CamelContext: camel-1) is starting\r\n10:31:00.281 INFO [Blueprint Event Dispatcher: 1] JMX is disabled"
    },
    {
      "key":"CAMEL-13301",
      "title":"Move catalog apis from CamelContext into CatalogCamelContext",
      "description":"Lets move these catalog apis into a dedicated catalog camel context which you can then use the adapt api from camel context if you want to use it, like with model camel context",
      "assignee":"davsclaus",
      "type":"Improvement",
      "priority":"Major",
      "status":"Resolved",
      "text":"Move catalog apis from CamelContext into CatalogCamelContext Lets move these catalog apis into a dedicated catalog camel context which you can then use the adapt api from camel context if you want to use it, like with model camel context"
    },
    {
      "key":"CAMEL-13298",
      "title":"Allow bean component to invoke methods with package modifier in the same class",
      "description":"To make it easier to use methods from the same route builder class where you define the routes, then you may have helper methods, that are invoked via bean \/ method call language. And they can only see public methods as its via camel-core they are called. So we should look at opening up the visibility, like we do with field injection and other things.",
      "assignee":"davsclaus",
      "type":"Improvement",
      "priority":"Major",
      "status":"Resolved",
      "text":"Allow bean component to invoke methods with package modifier in the same class To make it easier to use methods from the same route builder class where you define the routes, then you may have helper methods, that are invoked via bean \/ method call language. And they can only see public methods as its via camel-core they are called. So we should look at opening up the visibility, like we do with field injection and other things."
    },
    {
      "key":"CAMEL-13297",
      "title":"camel-core tests fail if JAVA_HOME is not set",
      "description":"Test assumes that JAVA_HOME exists which is standard but not mandatory.\r\n{noformat}\r\n[ERROR] org.apache.camel.component.properties.PropertiesComponentDefaultFunctionsTest.testFunction(org.apache.camel.component.properties.PropertiesComponentDefaultFunctionsTest){noformat}",
      "assignee":"davsclaus",
      "type":"Test",
      "priority":"Trivial",
      "status":"Resolved",
      "text":"camel-core tests fail if JAVA_HOME is not set Test assumes that JAVA_HOME exists which is standard but not mandatory.\r\n{noformat}\r\n[ERROR] org.apache.camel.component.properties.PropertiesComponentDefaultFunctionsTest.testFunction(org.apache.camel.component.properties.PropertiesComponentDefaultFunctionsTest){noformat}"
    },
    {
      "key":"CAMEL-13296",
      "title":"Dump JMX stats for null timestamps should not use 1970-1-1 as date",
      "description":"Noticed this\r\nlastExchangeFailureTimestamp=\"1970-01-01T00:59:59.999+0100\" ",
      "assignee":"davsclaus",
      "type":"Bug",
      "priority":"Minor",
      "status":"Resolved",
      "text":"Dump JMX stats for null timestamps should not use 1970-1-1 as date Noticed this\r\nlastExchangeFailureTimestamp=\"1970-01-01T00:59:59.999+0100\" "
    },
    {
      "key":"CAMEL-13294",
      "title":"Properties component - Add easy method to lookup via key",
      "description":"Lets make this code a bit easier, and have a nicer API on the PropertiesComponent we have in camel-api now for Camel 3\r\n{code}\r\n                        \/\/ build key with default value included as this is supported during resolving\r\n                        String key = pi.value();\r\n                        if (!isEmpty(pi.defaultValue())) {\r\n                            key = key + \":\" + pi.defaultValue();\r\n                        }\r\n                        \/\/ need to force property lookup by having key enclosed in tokens\r\n                        key = camelContext.getPropertiesComponent().getPrefixToken() + key + camelContext.getPropertiesComponent().getSuffixToken();\r\n                        try {\r\n                            Object value = camelContext.resolvePropertyPlaceholders(key);\r\n                            parameters[i] = camelContext.getTypeConverter().convertTo(type, value);\r\n                        } catch (Exception e) {\r\n                            throw RuntimeCamelException.wrapRuntimeCamelException(e);\r\n                        }\r\n{code}",
      "assignee":"davsclaus",
      "type":"Improvement",
      "priority":"Major",
      "status":"Resolved",
      "text":"Properties component - Add easy method to lookup via key Lets make this code a bit easier, and have a nicer API on the PropertiesComponent we have in camel-api now for Camel 3\r\n{code}\r\n                        \/\/ build key with default value included as this is supported during resolving\r\n                        String key = pi.value();\r\n                        if (!isEmpty(pi.defaultValue())) {\r\n                            key = key + \":\" + pi.defaultValue();\r\n                        }\r\n                        \/\/ need to force property lookup by having key enclosed in tokens\r\n                        key = camelContext.getPropertiesComponent().getPrefixToken() + key + camelContext.getPropertiesComponent().getSuffixToken();\r\n                        try {\r\n                            Object value = camelContext.resolvePropertyPlaceholders(key);\r\n                            parameters[i] = camelContext.getTypeConverter().convertTo(type, value);\r\n                        } catch (Exception e) {\r\n                            throw RuntimeCamelException.wrapRuntimeCamelException(e);\r\n                        }\r\n{code}"
    },
    {
      "key":"CAMEL-13293",
      "title":"Camel-linkedin, switch HtmlUnit to JSoup to not rely on Jetty (and allow update to servlet api 4)",
      "description":"Component camel-linkedin depends on Jetty (see https:\/\/github.com\/apache\/camel\/blob\/master\/platforms\/karaf\/features\/src\/main\/resources\/features.xml#L1578)\r\n\r\nThis dependency doesn't allow update servlet-api to 4.0\r\n\r\nSolution is to refactor component to use JSoup instead.",
      "assignee":"davsclaus",
      "type":"Improvement",
      "priority":"Major",
      "status":"Resolved",
      "text":"Camel-linkedin, switch HtmlUnit to JSoup to not rely on Jetty (and allow update to servlet api 4) Component camel-linkedin depends on Jetty (see https:\/\/github.com\/apache\/camel\/blob\/master\/platforms\/karaf\/features\/src\/main\/resources\/features.xml#L1578)\r\n\r\nThis dependency doesn't allow update servlet-api to 4.0\r\n\r\nSolution is to refactor component to use JSoup instead."
    },
    {
      "key":"CAMEL-13291",
      "title":"camel-quartz - Allow to configure cron parameter with spaces",
      "description":"In the past we had to use + sign as separator in the cron\r\n{code}\r\n0\/2+*+*+*+*+?\r\n{code}\r\n\r\nWe should support also using spaces, so its like text-book cron\r\n{code}\r\n0\/2 * * * * ?\r\n{code}",
      "assignee":"davsclaus",
      "type":"Improvement",
      "priority":"Minor",
      "status":"Resolved",
      "text":"camel-quartz - Allow to configure cron parameter with spaces In the past we had to use + sign as separator in the cron\r\n{code}\r\n0\/2+*+*+*+*+?\r\n{code}\r\n\r\nWe should support also using spaces, so its like text-book cron\r\n{code}\r\n0\/2 * * * * ?\r\n{code}"
    },
    {
      "key":"CAMEL-13289",
      "title":"Properties component - Keys with dashes should lookup with underscores as well",
      "description":"On linux OS environment variables using dashes is not allowed, eg FOO-BAR, should be FOO_BAR. So we should automatic add support for looking up with underscores as fallback.",
      "assignee":"davsclaus",
      "type":"Improvement",
      "priority":"Major",
      "status":"Resolved",
      "text":"Properties component - Keys with dashes should lookup with underscores as well On linux OS environment variables using dashes is not allowed, eg FOO-BAR, should be FOO_BAR. So we should automatic add support for looking up with underscores as fallback."
    },
    {
      "key":"CAMEL-13288",
      "title":"Properties component - Add support for lookup exact by key, and mixed dashed vs camel case",
      "description":"So you can define property placeholders using a dashed style\r\n\r\nhttps:\/\/github.com\/apache\/camel\/blob\/master\/components\/camel-jms\/src\/main\/docs\/jms-component.adoc\r\n\r\nFor example to set the JMS component option you can do:\r\ncamel.component.jms.acceptMessagesWhileStopping=true\r\n\r\nBut would be nice to support dashed style too (ala spring boot)\r\ncamel.component.jms.accept-messages-while-stopping=true\r\n\r\nThis is needed for Camel standalone to make this easier \/ similar to spring-boot\r\n\r\n\r\n\r\n",
      "assignee":"davsclaus",
      "type":"New Feature",
      "priority":"Major",
      "status":"Resolved",
      "text":"Properties component - Add support for lookup exact by key, and mixed dashed vs camel case So you can define property placeholders using a dashed style\r\n\r\nhttps:\/\/github.com\/apache\/camel\/blob\/master\/components\/camel-jms\/src\/main\/docs\/jms-component.adoc\r\n\r\nFor example to set the JMS component option you can do:\r\ncamel.component.jms.acceptMessagesWhileStopping=true\r\n\r\nBut would be nice to support dashed style too (ala spring boot)\r\ncamel.component.jms.accept-messages-while-stopping=true\r\n\r\nThis is needed for Camel standalone to make this easier \/ similar to spring-boot\r\n\r\n\r\n\r\n"
    },
    {
      "key":"CAMEL-13287",
      "title":" AggregationStrategy - Access original exchange in aggregate method",
      "description":"For aggregation after multicast\/splitter the original exchange should optionally be available in the aggregate method.\r\n There are several use cases when we would like to go-on processing the original exchange after multicast, but we'd like to enrich it with the outcome of the called routes. For example:\r\n{code:java}\r\nrest()\r\n.get(\"orders\/{orderId}\")\r\n.route()\r\n  .to(\"direct:getOrderDetails\") \/\/get UserId, ItemId\r\n  .setBody(method(this,\"createResponsePojo\"))\r\n  .multicast(new MyAggregationStrategy())\r\n    .to(\"direct:getUserDetails\")\r\n    .to(\"direct:getDeliveryAddress\")\r\n    .to(\"direct:getItemDetails\")\r\n  .end()\r\n;\r\n{code}\r\nIf any of the called routes fail, we still would like return a partial response in our service (this is a common requirement in case of microservices). The MyAggregationStrategy should simply enrich the ResponePojo object from the original exchange somehow with the new exchanges coming from the sub-routes. See this example:\r\n{code:java}\r\npublic class MyAggregationStrategy implements AggregationStrategy {\r\n\r\npublic Exchange aggregateWithOriginal(Exchange oldExchange, Exchange newExchange, Exchange originalExchange) {\r\n  Exchange exchange = oldExchange != null ? oldExchange : originalExchange;\r\n  ResponsePojo response = exchange.getMessage().getBody(ResponsePojo.class);\r\n\r\n  if (! newExchange.isFailed()) {\r\n    \/\/ ... Add newExchange body somehow to ResponsePojo object...\r\n  }\r\n  return exchange;\r\n}\r\n...\r\n}\r\n{code}\r\nCurrently only the exchanges from the \"sub-routes\" are available during aggregation, so the exchange after the aggregate will be one (the first) of those. This comes with multiple problems:\r\n * Though the exchanges in the sub-routes are copies of the original exchange, sub routes make modifications: modify headers, modify properties, etc. Usually we don't want to see all these set by a sub-route on the final aggregated exchange. It's only noise. \"Whatever happens in the sub-route, should stay in the sub-route.\" - We only want to see on the aggregated exchange what we \"took\" intentionally from the sub-route exchanges.\r\n * If we use stopOnException(true) our life is simple because we usually don't have to worry about exceptions in aggregate, we will stop anyway. The aggregation logic can become complicated if we want to go on with processing in case of errors. The first time aggregate() is called the oldExchange is null, so we usually take the newExchange as the return value. If this exchange has an Exception, we need to \"clean\" it first, otherwise the error handler will kick in after aggregation. This is non-trivial.\r\n\r\nh3. Suggested approach\r\n\r\nLet's extend the AggregationStrategy interface with a new method that takes three exchanges. This should be called after Multicast EIP (Enrich EIP is simple, it only has two exchanges).\r\n\r\nWith a default implementations we can keep the interface compatible:\r\n{code:java}\r\npublic interface AggregationStrategy {\r\n\r\n\/**\r\n* Aggregates an old, a new and the original exchange together to create a single combined exchange.\r\n*\r\n* @param oldExchange the oldest exchange, which is the returned value of the previous aggregation on null.\r\n* @param newExchange the newest exchange\r\n* @param originalExchange the original exchange before Multicast or Splitter EIP. Null in case of Enrich EIP.\r\n* @return a combined exchange, favor returning the oldExchange\r\n*\/\r\ndefault Exchange aggregateWithOriginal(Exchange oldExchange, Exchange newExchange, Exchange originalExchange) {\r\n  return aggregate(oldExchange, newExchange);\r\n};\r\n\r\n\/\/Maybe we should have a default implementation here too so one can only implement aggregateWithOriginal()\r\nExchange aggregate(Exchange oldExchange, Exchange newExchange); \r\n... \r\n}\r\n{code}\r\n{code:java}\r\n\u00a0{code}",
      "assignee":"davsclaus",
      "type":"New Feature",
      "priority":"Major",
      "status":"Resolved",
      "text":" AggregationStrategy - Access original exchange in aggregate method For aggregation after multicast\/splitter the original exchange should optionally be available in the aggregate method.\r\n There are several use cases when we would like to go-on processing the original exchange after multicast, but we'd like to enrich it with the outcome of the called routes. For example:\r\n{code:java}\r\nrest()\r\n.get(\"orders\/{orderId}\")\r\n.route()\r\n  .to(\"direct:getOrderDetails\") \/\/get UserId, ItemId\r\n  .setBody(method(this,\"createResponsePojo\"))\r\n  .multicast(new MyAggregationStrategy())\r\n    .to(\"direct:getUserDetails\")\r\n    .to(\"direct:getDeliveryAddress\")\r\n    .to(\"direct:getItemDetails\")\r\n  .end()\r\n;\r\n{code}\r\nIf any of the called routes fail, we still would like return a partial response in our service (this is a common requirement in case of microservices). The MyAggregationStrategy should simply enrich the ResponePojo object from the original exchange somehow with the new exchanges coming from the sub-routes. See this example:\r\n{code:java}\r\npublic class MyAggregationStrategy implements AggregationStrategy {\r\n\r\npublic Exchange aggregateWithOriginal(Exchange oldExchange, Exchange newExchange, Exchange originalExchange) {\r\n  Exchange exchange = oldExchange != null ? oldExchange : originalExchange;\r\n  ResponsePojo response = exchange.getMessage().getBody(ResponsePojo.class);\r\n\r\n  if (! newExchange.isFailed()) {\r\n    \/\/ ... Add newExchange body somehow to ResponsePojo object...\r\n  }\r\n  return exchange;\r\n}\r\n...\r\n}\r\n{code}\r\nCurrently only the exchanges from the \"sub-routes\" are available during aggregation, so the exchange after the aggregate will be one (the first) of those. This comes with multiple problems:\r\n * Though the exchanges in the sub-routes are copies of the original exchange, sub routes make modifications: modify headers, modify properties, etc. Usually we don't want to see all these set by a sub-route on the final aggregated exchange. It's only noise. \"Whatever happens in the sub-route, should stay in the sub-route.\" - We only want to see on the aggregated exchange what we \"took\" intentionally from the sub-route exchanges.\r\n * If we use stopOnException(true) our life is simple because we usually don't have to worry about exceptions in aggregate, we will stop anyway. The aggregation logic can become complicated if we want to go on with processing in case of errors. The first time aggregate() is called the oldExchange is null, so we usually take the newExchange as the return value. If this exchange has an Exception, we need to \"clean\" it first, otherwise the error handler will kick in after aggregation. This is non-trivial.\r\n\r\nh3. Suggested approach\r\n\r\nLet's extend the AggregationStrategy interface with a new method that takes three exchanges. This should be called after Multicast EIP (Enrich EIP is simple, it only has two exchanges).\r\n\r\nWith a default implementations we can keep the interface compatible:\r\n{code:java}\r\npublic interface AggregationStrategy {\r\n\r\n\/**\r\n* Aggregates an old, a new and the original exchange together to create a single combined exchange.\r\n*\r\n* @param oldExchange the oldest exchange, which is the returned value of the previous aggregation on null.\r\n* @param newExchange the newest exchange\r\n* @param originalExchange the original exchange before Multicast or Splitter EIP. Null in case of Enrich EIP.\r\n* @return a combined exchange, favor returning the oldExchange\r\n*\/\r\ndefault Exchange aggregateWithOriginal(Exchange oldExchange, Exchange newExchange, Exchange originalExchange) {\r\n  return aggregate(oldExchange, newExchange);\r\n};\r\n\r\n\/\/Maybe we should have a default implementation here too so one can only implement aggregateWithOriginal()\r\nExchange aggregate(Exchange oldExchange, Exchange newExchange); \r\n... \r\n}\r\n{code}\r\n{code:java}\r\n {code}"
    },
    {
      "key":"CAMEL-13283",
      "title":"Add @BindRegistry annotation to allow binding a field\/class\/bean to the Camel registry",
      "description":"Now that we can bind to registry, lets add an annotation so users can define those as well, for example with Camel standalone.\r\n",
      "assignee":"davsclaus",
      "type":"New Feature",
      "priority":"Major",
      "status":"Resolved",
      "text":"Add @BindRegistry annotation to allow binding a field\/class\/bean to the Camel registry Now that we can bind to registry, lets add an annotation so users can define those as well, for example with Camel standalone.\r\n"
    },
    {
      "key":"CAMEL-13281",
      "title":"spring boot starter - Generated auto configuration should support exclude properties on component level",
      "description":"A few component inherit each other, and they may exclude some of the parent options, for example ftp\/netty4-http etc. Currently they only do that on endpoint level. We need something similar on component level so the SB auto generation dont include them.\r\n\r\n{code}\r\n        excludeProperties = \"textline,delimiter,autoAppendDelimiter,decoderMaxLineLength,encoding,allowDefaultCodec,udpConnectionlessSending,networkInterface\"\r\n                + \",clientMode,reconnect,reconnectInterval,useByteBuf,udpByteArrayCodec,broadcast,correlationManager\")\r\n{code}",
      "assignee":"davsclaus",
      "type":"Improvement",
      "priority":"Major",
      "status":"Resolved",
      "text":"spring boot starter - Generated auto configuration should support exclude properties on component level A few component inherit each other, and they may exclude some of the parent options, for example ftp\/netty4-http etc. Currently they only do that on endpoint level. We need something similar on component level so the SB auto generation dont include them.\r\n\r\n{code}\r\n        excludeProperties = \"textline,delimiter,autoAppendDelimiter,decoderMaxLineLength,encoding,allowDefaultCodec,udpConnectionlessSending,networkInterface\"\r\n                + \",clientMode,reconnect,reconnectInterval,useByteBuf,udpByteArrayCodec,broadcast,correlationManager\")\r\n{code}"
    },
    {
      "key":"CAMEL-13280",
      "title":"Properties component - Allow to access loaded properties",
      "description":"We should expose API on properties component so users and tooling can access the loaded properties. This can help with detecting which properties are available in the project.",
      "assignee":"davsclaus",
      "type":"New Feature",
      "priority":"Major",
      "status":"Resolved",
      "text":"Properties component - Allow to access loaded properties We should expose API on properties component so users and tooling can access the loaded properties. This can help with detecting which properties are available in the project."
    },
    {
      "key":"CAMEL-13273",
      "title":"Link missing in JMX Documentation",
      "description":"Reference: [https:\/\/github.com\/apache\/camel\/blob\/master\/components\/camel-jmx\/src\/main\/docs\/jmx-component.adoc#which-processors-are-registered]\r\n\r\n{{It mentions \"See this FAQ\". But there is no link for it.}}",
      "assignee":"davsclaus",
      "type":"Task",
      "priority":"Trivial",
      "status":"Resolved",
      "text":"Link missing in JMX Documentation Reference: [https:\/\/github.com\/apache\/camel\/blob\/master\/components\/camel-jmx\/src\/main\/docs\/jmx-component.adoc#which-processors-are-registered]\r\n\r\n{{It mentions \"See this FAQ\". But there is no link for it.}}"
    },
    {
      "key":"CAMEL-13272",
      "title":"File producer - Issue with toD when using moveExisting",
      "description":"See SO\r\nhttps:\/\/stackoverflow.com\/questions\/54890566\/camel-file-component-create-a-file-and-if-already-exist-move-it-and-renamed-i\/54910417#54910417\r\n\r\nAnd for the solution\/workaround to use to instead of toD",
      "assignee":"davsclaus",
      "type":"Bug",
      "priority":"Major",
      "status":"Resolved",
      "text":"File producer - Issue with toD when using moveExisting See SO\r\nhttps:\/\/stackoverflow.com\/questions\/54890566\/camel-file-component-create-a-file-and-if-already-exist-move-it-and-renamed-i\/54910417#54910417\r\n\r\nAnd for the solution\/workaround to use to instead of toD"
    },
    {
      "key":"CAMEL-13270",
      "title":"camel-rabbitmq - x-death header gets lost because of incorrect header value validation",
      "description":"In `RabbitMQMessageConverter.java`, some kind of header value validation is done:\r\n\r\n\r\n{code:java}\r\n    private Object getValidRabbitMQHeaderValue(Object headerValue) {\r\n        if (headerValue instanceof String) {\r\n            return headerValue;\r\n        } else if (headerValue instanceof Number) {\r\n            return headerValue;\r\n        } else if (headerValue instanceof Boolean) {\r\n            return headerValue;\r\n        } else if (headerValue instanceof Date) {\r\n            return headerValue;\r\n        } else if (headerValue instanceof byte[]) {\r\n            return headerValue;\r\n        } else if (headerValue instanceof LongString) {\r\n            return headerValue;\r\n        }\r\n\r\n        return null;\r\n    }\r\n{code}\r\n\r\nWhile this is correct for the listed typed, this is incomplete. An example of this is the `x-death` header, as explained on https:\/\/www.rabbitmq.com\/dlx.html#effects. This header is basically a `List<Map<String,Object>>`.\r\n\r\nIf a message with such header is consumed and then propagated to another queue, the header will be lost. An example use case is consuming a dead-letter queue and propagating the messages to another queue, possible after some delay, until the `count` field in the `x-death` header reached a certain threshold.\r\n\r\nI am happy to provide a self-contained example if this would be helpful.",
      "assignee":"davsclaus",
      "type":"Bug",
      "priority":"Minor",
      "status":"Resolved",
      "text":"camel-rabbitmq - x-death header gets lost because of incorrect header value validation In `RabbitMQMessageConverter.java`, some kind of header value validation is done:\r\n\r\n\r\n{code:java}\r\n    private Object getValidRabbitMQHeaderValue(Object headerValue) {\r\n        if (headerValue instanceof String) {\r\n            return headerValue;\r\n        } else if (headerValue instanceof Number) {\r\n            return headerValue;\r\n        } else if (headerValue instanceof Boolean) {\r\n            return headerValue;\r\n        } else if (headerValue instanceof Date) {\r\n            return headerValue;\r\n        } else if (headerValue instanceof byte[]) {\r\n            return headerValue;\r\n        } else if (headerValue instanceof LongString) {\r\n            return headerValue;\r\n        }\r\n\r\n        return null;\r\n    }\r\n{code}\r\n\r\nWhile this is correct for the listed typed, this is incomplete. An example of this is the `x-death` header, as explained on https:\/\/www.rabbitmq.com\/dlx.html#effects. This header is basically a `List<Map<String,Object>>`.\r\n\r\nIf a message with such header is consumed and then propagated to another queue, the header will be lost. An example use case is consuming a dead-letter queue and propagating the messages to another queue, possible after some delay, until the `count` field in the `x-death` header reached a certain threshold.\r\n\r\nI am happy to provide a self-contained example if this would be helpful."
    },
    {
      "key":"CAMEL-13267",
      "title":"Camel stops consuming queue after restart of RabbitMQ broker",
      "description":"I am consuming a RabbitMQ queue as following:\r\n\r\n\u00a0\r\n{code:java}\r\nfrom(\"rabbitmq:\/\/localhost:5672?username=test&password=test&declare=false&queue=q&autoAck=false&threadPoolSize=1&exclusiveConsumer=true\")\r\n   .to(\"log:receive\");{code}\r\n\u00a0\r\n\r\nWhen I restart the RabbitMQ broker, no messages are longer received in the log handler.\r\n\r\n\u00a0\r\n\r\nAccording the management interface, all pending messages are in UNACKED state. This means that they are transmitted to the consumer, but not acknowledged. In other words, Camel was able to restore the connection after the restart, but fails to deliver to the log handler and acknowledge them afterwards.\r\n\r\n\u00a0\r\n\r\nI did not test this, but I believe the\u00a0consumer will eventually crash due to OOM.\r\n\r\n\u00a0\r\n\r\n+*example*+\r\n\r\n\u00a0\r\n\r\nPlease find a self-contained example on [https:\/\/github.com\/pbillen\/playground-camel-13267|https:\/\/github.com\/pbillen\/playground-camel-13267].You need a (local) Docker daemon to run this. Use it as following:\r\n\r\n\u00a0\r\n # Start with `mvn clean install -U`.\r\n # You notice in the logging that every 500ms, a message is sent and received. You can also log into the administrator interface on [http:\/\/localhost:15672|http:\/\/localhost:15672\/]\u00a0with login\/password `test`. You will see the message pass through every 500ms. Great!\r\n # Now restart the RabbitMQ broker. Typically, find the container identifier with `docker ps` and then execute `docker restart <identifier>`.\r\n # After restart, you notice that every 500ms a message is sent, but not received. You can also log into the administrator interface and see that all messages are into the UNACKED state.",
      "assignee":"davsclaus",
      "type":"Bug",
      "priority":"Minor",
      "status":"Resolved",
      "text":"Camel stops consuming queue after restart of RabbitMQ broker I am consuming a RabbitMQ queue as following:\r\n\r\n \r\n{code:java}\r\nfrom(\"rabbitmq:\/\/localhost:5672?username=test&password=test&declare=false&queue=q&autoAck=false&threadPoolSize=1&exclusiveConsumer=true\")\r\n   .to(\"log:receive\");{code}\r\n \r\n\r\nWhen I restart the RabbitMQ broker, no messages are longer received in the log handler.\r\n\r\n \r\n\r\nAccording the management interface, all pending messages are in UNACKED state. This means that they are transmitted to the consumer, but not acknowledged. In other words, Camel was able to restore the connection after the restart, but fails to deliver to the log handler and acknowledge them afterwards.\r\n\r\n \r\n\r\nI did not test this, but I believe the consumer will eventually crash due to OOM.\r\n\r\n \r\n\r\n+*example*+\r\n\r\n \r\n\r\nPlease find a self-contained example on [https:\/\/github.com\/pbillen\/playground-camel-13267|https:\/\/github.com\/pbillen\/playground-camel-13267].You need a (local) Docker daemon to run this. Use it as following:\r\n\r\n \r\n # Start with `mvn clean install -U`.\r\n # You notice in the logging that every 500ms, a message is sent and received. You can also log into the administrator interface on [http:\/\/localhost:15672|http:\/\/localhost:15672\/] with login\/password `test`. You will see the message pass through every 500ms. Great!\r\n # Now restart the RabbitMQ broker. Typically, find the container identifier with `docker ps` and then execute `docker restart <identifier>`.\r\n # After restart, you notice that every 500ms a message is sent, but not received. You can also log into the administrator interface and see that all messages are into the UNACKED state."
    },
    {
      "key":"CAMEL-13266",
      "title":"camel-core-xml - Make JMX optional",
      "description":"This module requires camel-management-impl. We should try to make this optional, so the JMX agent is not needed via compile time, but loaded via some factory way. Then end users can run camel XML with and without JMX more easily.",
      "assignee":"davsclaus",
      "type":"Improvement",
      "priority":"Major",
      "status":"Resolved",
      "text":"camel-core-xml - Make JMX optional This module requires camel-management-impl. We should try to make this optional, so the JMX agent is not needed via compile time, but loaded via some factory way. Then end users can run camel XML with and without JMX more easily."
    },
    {
      "key":"CAMEL-13265",
      "title":"camel-core - Use camel-test for unit testing",
      "description":"We can now build camel-test before camel-core, and then use camel-test for testing camel-core instead of having its own ContextTestSupport and other base classes.",
      "assignee":"davsclaus",
      "type":"Improvement",
      "priority":"Major",
      "status":"Resolved",
      "text":"camel-core - Use camel-test for unit testing We can now build camel-test before camel-core, and then use camel-test for testing camel-core instead of having its own ContextTestSupport and other base classes."
    },
    {
      "key":"CAMEL-13264",
      "title":"Add release artifacts of camel-k-runtime project",
      "description":"We need to create the source release artifact for the camel-k-runtime project.",
      "assignee":"njiang",
      "type":"Task",
      "priority":"Major",
      "status":"Resolved",
      "text":"Add release artifacts of camel-k-runtime project We need to create the source release artifact for the camel-k-runtime project."
    },
    {
      "key":"CAMEL-13258",
      "title":"SimpleRegistry - Favour DefaultRegistry",
      "description":"The DefaultRegistry should be favoured to be used. \r\nThe simple registry is now more of an implementation detail as part of default registry.\r\nAnd you can now do bind on default registry so you dont need to add custom registry to camel context to bind a bean etc.",
      "assignee":"davsclaus",
      "type":"Improvement",
      "priority":"Major",
      "status":"Resolved",
      "text":"SimpleRegistry - Favour DefaultRegistry The DefaultRegistry should be favoured to be used. \r\nThe simple registry is now more of an implementation detail as part of default registry.\r\nAnd you can now do bind on default registry so you dont need to add custom registry to camel context to bind a bean etc."
    },
    {
      "key":"CAMEL-13252",
      "title":"camel-cdi - Remove OSGi support",
      "description":"OSGi with camel-cdi was hard to make stable and also not recommended to use. We only support OSGi blueprint on OSGi and for CDI then use plain CDI containers.",
      "assignee":"davsclaus",
      "type":"Task",
      "priority":"Major",
      "status":"Resolved",
      "text":"camel-cdi - Remove OSGi support OSGi with camel-cdi was hard to make stable and also not recommended to use. We only support OSGi blueprint on OSGi and for CDI then use plain CDI containers."
    },
    {
      "key":"CAMEL-13243",
      "title":"Camel Main - Make it have more functionality and convention out of the box",
      "description":"For users that just want a plain Camel standalone, and also for Camel K where running low-footprint is important.\r\n\r\nFor example to make properties component automatic load from application.properties from root classpath. And also allow to have those properties fallback to lookup via ENV variables, so containers can customize them that way too.\r\n\r\nAnd add other ideas here to this ticket",
      "assignee":"davsclaus",
      "type":"Improvement",
      "priority":"Major",
      "status":"Resolved",
      "text":"Camel Main - Make it have more functionality and convention out of the box For users that just want a plain Camel standalone, and also for Camel K where running low-footprint is important.\r\n\r\nFor example to make properties component automatic load from application.properties from root classpath. And also allow to have those properties fallback to lookup via ENV variables, so containers can customize them that way too.\r\n\r\nAnd add other ideas here to this ticket"
    },
    {
      "key":"CAMEL-13240",
      "title":"Don't ship the jars in the source artifacts",
      "description":"In Camel 3.0.0 M1 source release kit, there are some jars for testing, we need to clean them out.\r\n{code}\r\n.\/\/tests\/camel-itest\/lib\/org\/apache\/camel\/camel-validator-test-resources\/1.0.0\/camel-validator-test-resources-1.0.0.jar\r\n.\/\/components\/camel-spring\/src\/test\/resources\/package_scan_test.jar\r\n.\/\/components\/camel-spring\/src\/test\/resources\/package+scan+test.jar\r\n{code}\r\n",
      "assignee":"njiang",
      "type":"Task",
      "priority":"Major",
      "status":"Resolved",
      "text":"Don't ship the jars in the source artifacts In Camel 3.0.0 M1 source release kit, there are some jars for testing, we need to clean them out.\r\n{code}\r\n.\/\/tests\/camel-itest\/lib\/org\/apache\/camel\/camel-validator-test-resources\/1.0.0\/camel-validator-test-resources-1.0.0.jar\r\n.\/\/components\/camel-spring\/src\/test\/resources\/package_scan_test.jar\r\n.\/\/components\/camel-spring\/src\/test\/resources\/package+scan+test.jar\r\n{code}\r\n"
    },
    {
      "key":"CAMEL-13239",
      "title":"camel-rabbitmq - Using the  \"new URl syntax\" doesn't seem to work correctly",
      "description":"When using the deprecated URL format\r\n{noformat}\r\nrabbitmq:\/\/hostname[:port]\/exchange?[options]{noformat}\r\n(also still on the main page) the camel route works as expected.\u00a0 However, when listening to the warning and using the \"new syntax\" (only defined in the repo):\r\n{noformat}\r\nrabbitmq:exchange?[options]{noformat}\r\nit does NOT work, and will fail to connect to rabbitmq at all, giving address errors\r\n\r\nI have tried setting the hostname option (doesn't work, the component seems to ignore it), and tried setting springboot component parameters (doesn't seem to work, but I don't know of a way to test if they are even accessible.\r\n\r\nI can supply loglines on demand if needed.\r\n\r\nAlso, in case it matters, in this case the hostname is an IP address.",
      "assignee":"davsclaus",
      "type":"Bug",
      "priority":"Minor",
      "status":"Resolved",
      "text":"camel-rabbitmq - Using the  \"new URl syntax\" doesn't seem to work correctly When using the deprecated URL format\r\n{noformat}\r\nrabbitmq:\/\/hostname[:port]\/exchange?[options]{noformat}\r\n(also still on the main page) the camel route works as expected.  However, when listening to the warning and using the \"new syntax\" (only defined in the repo):\r\n{noformat}\r\nrabbitmq:exchange?[options]{noformat}\r\nit does NOT work, and will fail to connect to rabbitmq at all, giving address errors\r\n\r\nI have tried setting the hostname option (doesn't work, the component seems to ignore it), and tried setting springboot component parameters (doesn't seem to work, but I don't know of a way to test if they are even accessible.\r\n\r\nI can supply loglines on demand if needed.\r\n\r\nAlso, in case it matters, in this case the hostname is an IP address."
    },
    {
      "key":"CAMEL-13236",
      "title":"mock endpoint - Small glitch in logging excepted failure",
      "description":"We do\r\nlog.info(\"Caught expected failure: {}\", e);\r\n\r\nYou cannot do {} with an exception.",
      "assignee":"davsclaus",
      "type":"Bug",
      "priority":"Minor",
      "status":"Resolved",
      "text":"mock endpoint - Small glitch in logging excepted failure We do\r\nlog.info(\"Caught expected failure: {}\", e);\r\n\r\nYou cannot do {} with an exception."
    },
    {
      "key":"CAMEL-13232",
      "title":"Simple language - Backwards compatible parser on 2.x should WARN",
      "description":"We can make the old deprecated syntax of the simple language log a WARN when it has detected this style in Camel 2.24, so users can get more prepared for Camel 3.0 upgrade.",
      "assignee":"davsclaus",
      "type":"Task",
      "priority":"Major",
      "status":"Resolved",
      "text":"Simple language - Backwards compatible parser on 2.x should WARN We can make the old deprecated syntax of the simple language log a WARN when it has detected this style in Camel 2.24, so users can get more prepared for Camel 3.0 upgrade."
    },
    {
      "key":"CAMEL-13221",
      "title":"Upgrade jetty to latest 9.4.x",
      "description":"There is a newer release, but it may affect camel-cxf and others which tests with jetty. Jetty is always a bit problematic in their upgrades :(",
      "assignee":"davsclaus",
      "type":"Task",
      "priority":"Major",
      "status":"Resolved",
      "text":"Upgrade jetty to latest 9.4.x There is a newer release, but it may affect camel-cxf and others which tests with jetty. Jetty is always a bit problematic in their upgrades :("
    },
    {
      "key":"CAMEL-13220",
      "title":"camel-jetty - Remove deprecated producer",
      "description":"The producer of camel-jetty has been deprecated in Camel 2.x, and should be removed in 3.0.",
      "assignee":"davsclaus",
      "type":"Task",
      "priority":"Major",
      "status":"Resolved",
      "text":"camel-jetty - Remove deprecated producer The producer of camel-jetty has been deprecated in Camel 2.x, and should be removed in 3.0."
    },
    {
      "key":"CAMEL-13217",
      "title":"Merge camel-jetty9 back into camel-jetty",
      "description":"In the old days we had jetty 8 vs 9 problem, so we had to splitup it.\r\nNow we camel 3 we can move back camel-jetty9 into camel-jetty and have this single JAR.\r\n",
      "assignee":"davsclaus",
      "type":"Task",
      "priority":"Major",
      "status":"Resolved",
      "text":"Merge camel-jetty9 back into camel-jetty In the old days we had jetty 8 vs 9 problem, so we had to splitup it.\r\nNow we camel 3 we can move back camel-jetty9 into camel-jetty and have this single JAR.\r\n"
    },
    {
      "key":"CAMEL-13214",
      "title":"camel-mail: Add headerFilterStrategy option to component level",
      "description":"Currently it's not possible to\u00a0change\/customize\u00a0the\u00a0headerFilterStrategy for all camel-mail endpoints because it has to be configured on endpoint level.\r\n\r\nIn the cxf component it's possible to configure it on component level too, so it's possible to provide a global headerFilterStrategy:\r\n\r\nExample:\r\n{noformat}\r\n\t\tCxfComponent comp = camelContext.getComponent(\"cxf\",\r\n\t\t\t\tCxfComponent.class);\r\n\t\tCxfHeaderFilterStrategy strategy = new CxfHeaderFilterStrategy();\r\n\t\tstrategy.setOutFilterPattern(\r\n\t\t\t\t\"<customized>\");\r\n\t\tcomp.setHeaderFilterStrategy(strategy);{noformat}\r\nIt would be an\u00a0improvement to add the headerFilterStrategy\u00a0option also to\u00a0component level.",
      "assignee":"davsclaus",
      "type":"Improvement",
      "priority":"Minor",
      "status":"Resolved",
      "text":"camel-mail: Add headerFilterStrategy option to component level Currently it's not possible to change\/customize the headerFilterStrategy for all camel-mail endpoints because it has to be configured on endpoint level.\r\n\r\nIn the cxf component it's possible to configure it on component level too, so it's possible to provide a global headerFilterStrategy:\r\n\r\nExample:\r\n{noformat}\r\n\t\tCxfComponent comp = camelContext.getComponent(\"cxf\",\r\n\t\t\t\tCxfComponent.class);\r\n\t\tCxfHeaderFilterStrategy strategy = new CxfHeaderFilterStrategy();\r\n\t\tstrategy.setOutFilterPattern(\r\n\t\t\t\t\"<customized>\");\r\n\t\tcomp.setHeaderFilterStrategy(strategy);{noformat}\r\nIt would be an improvement to add the headerFilterStrategy option also to component level."
    },
    {
      "key":"CAMEL-13210",
      "title":"camel-test-spring - Add support for @ExcludeRoutes annotation when testing spring boot",
      "description":"Reported on user forum\r\nhttp:\/\/camel.465427.n5.nabble.com\/ExcludeRoutes-not-working-tp5830132.html",
      "assignee":"davsclaus",
      "type":"Improvement",
      "priority":"Major",
      "status":"Resolved",
      "text":"camel-test-spring - Add support for @ExcludeRoutes annotation when testing spring boot Reported on user forum\r\nhttp:\/\/camel.465427.n5.nabble.com\/ExcludeRoutes-not-working-tp5830132.html"
    },
    {
      "key":"CAMEL-13208",
      "title":"camel3 - camel-core - Should have management-impl out of the box",
      "description":"So its like in 2.x, where you have JMX out of the box.\r\n\r\nWe will for M2 work on a camel-core-tiny where you dont have that OOTB and other core components etc to have a minimal Camel.",
      "assignee":"davsclaus",
      "type":"Task",
      "priority":"Major",
      "status":"Resolved",
      "text":"camel3 - camel-core - Should have management-impl out of the box So its like in 2.x, where you have JMX out of the box.\r\n\r\nWe will for M2 work on a camel-core-tiny where you dont have that OOTB and other core components etc to have a minimal Camel."
    },
    {
      "key":"CAMEL-13202",
      "title":"camel3 - spring-boot-start - Auto configuration too many",
      "description":"we have still the ones that was in camel-core, but many has been moved out to its own component such as file, log, timer etc.",
      "assignee":"davsclaus",
      "type":"Task",
      "priority":"Major",
      "status":"Resolved",
      "text":"camel3 - spring-boot-start - Auto configuration too many we have still the ones that was in camel-core, but many has been moved out to its own component such as file, log, timer etc."
    },
    {
      "key":"CAMEL-13201",
      "title":"camel3 - camel-core-minimal - To have core with as few dependencies as possible",
      "description":"The camel-core includes all the core components from 2.x. However you may want to choose precisely only the core components you need.\r\n\r\nSo with a camel-core-minimal you can then add the ones afterwards, such as log,timer and file etc.",
      "assignee":"davsclaus",
      "type":"Task",
      "priority":"Major",
      "status":"Resolved",
      "text":"camel3 - camel-core-minimal - To have core with as few dependencies as possible The camel-core includes all the core components from 2.x. However you may want to choose precisely only the core components you need.\r\n\r\nSo with a camel-core-minimal you can then add the ones afterwards, such as log,timer and file etc."
    },
    {
      "key":"CAMEL-13200",
      "title":"camel3 - Caffeine jar is not shaded",
      "description":"It should be shaded into camel-core which I dont think happens",
      "assignee":"davsclaus",
      "type":"Task",
      "priority":"Major",
      "status":"Resolved",
      "text":"camel3 - Caffeine jar is not shaded It should be shaded into camel-core which I dont think happens"
    },
    {
      "key":"CAMEL-13199",
      "title":"Using @Produce as proxy for sending to endpoint does not emit sending\/sent events",
      "description":"Reported on user forum\r\nhttp:\/\/camel.465427.n5.nabble.com\/No-ExchangeSentEvent-in-Produce-but-is-in-ProducerTemplate-tp5830067.html",
      "assignee":"davsclaus",
      "type":"Improvement",
      "priority":"Major",
      "status":"Resolved",
      "text":"Using @Produce as proxy for sending to endpoint does not emit sending\/sent events Reported on user forum\r\nhttp:\/\/camel.465427.n5.nabble.com\/No-ExchangeSentEvent-in-Produce-but-is-in-ProducerTemplate-tp5830067.html"
    },
    {
      "key":"CAMEL-13194",
      "title":"camel3 - Karaf commands should use org.apache.camel as group id",
      "description":"So everything we do in Apache Camel is always org.apache.camel\r\n\r\n    <dependency>\r\n      <groupId>org.apache.camel.karaf<\/groupId>\r\n      <artifactId>camel-karaf-commands<\/artifactId>\r\n    <\/dependency>\r\n\r\nShould be\r\n\r\n    <dependency>\r\n      <groupId>org.apache.camel<\/groupId>\r\n      <artifactId>camel-karaf-commands<\/artifactId>\r\n    <\/dependency>",
      "assignee":"davsclaus",
      "type":"Task",
      "priority":"Major",
      "status":"Resolved",
      "text":"camel3 - Karaf commands should use org.apache.camel as group id So everything we do in Apache Camel is always org.apache.camel\r\n\r\n    <dependency>\r\n      <groupId>org.apache.camel.karaf<\/groupId>\r\n      <artifactId>camel-karaf-commands<\/artifactId>\r\n    <\/dependency>\r\n\r\nShould be\r\n\r\n    <dependency>\r\n      <groupId>org.apache.camel<\/groupId>\r\n      <artifactId>camel-karaf-commands<\/artifactId>\r\n    <\/dependency>"
    },
    {
      "key":"CAMEL-13193",
      "title":"camel3 - Remove deprecate jolokia commands",
      "description":"Just noticed it was there when I built locally.",
      "assignee":"davsclaus",
      "type":"Task",
      "priority":"Major",
      "status":"Resolved",
      "text":"camel3 - Remove deprecate jolokia commands Just noticed it was there when I built locally."
    },
    {
      "key":"CAMEL-13189",
      "title":"camel-catalog - Should be built after all Camel components",
      "description":"It should be built after all the camel components so it includes all the metadata of all components. Currently Maven builds it too early.",
      "assignee":"davsclaus",
      "type":"Task",
      "priority":"Blocker",
      "status":"Resolved",
      "text":"camel-catalog - Should be built after all Camel components It should be built after all the camel components so it includes all the metadata of all components. Currently Maven builds it too early."
    },
    {
      "key":"CAMEL-13178",
      "title":"Rename terser language to hl7terser",
      "description":"The language terser is not well know, and its confusing what it does. I think we should rename it to hl7terser to indicate its about hl7.\r\n\r\n\r\n\r\n",
      "assignee":"davsclaus",
      "type":"Improvement",
      "priority":"Major",
      "status":"Resolved",
      "text":"Rename terser language to hl7terser The language terser is not well know, and its confusing what it does. I think we should rename it to hl7terser to indicate its about hl7.\r\n\r\n\r\n\r\n"
    },
    {
      "key":"CAMEL-13176",
      "title":"camel yammer component is accessing non-existent page",
      "description":"When using camel-yammer component to receive relationships the component is (most likely) trying to access\u00a0[non-existent page|https:\/\/www.yammer.com\/api\/v1\/]\u00a0and results in returning null.",
      "assignee":"davsclaus",
      "type":"Bug",
      "priority":"Major",
      "status":"Resolved",
      "text":"camel yammer component is accessing non-existent page When using camel-yammer component to receive relationships the component is (most likely) trying to access [non-existent page|https:\/\/www.yammer.com\/api\/v1\/] and results in returning null."
    },
    {
      "key":"CAMEL-13175",
      "title":"Consider removing useOriginalMessage functionality",
      "description":"This feature is a bit more complex and its intention\/design was to in case of an error during routing, you could say, that the original incoming message should be restored as-is and used as \"result\", for example in case you want to move that message to some dead letter queue or log it etc.\r\n\r\nHowever people may mis-understand this, and think you can mix the original message BODY only and enrich it with any existing headers at the time of error - but that was not how it was designed\/intended.\r\n\r\nHowever a few EIPs and if you turned on shared unit of work, you could end up with situations where it would mix the original message with the message of error.\r\n\r\nIf the user wants to mix both the original message with the message at the error, then they should use a bean\/processor\/aggregation strategy etc to \"merge\" the data together as they want. NOT rely on just saying useOriginalMessage and \"hope for the best\". \r\n\r\nAlso the original message body, can when you transfer messages over Camel endpoints be stored at new endpoints such as JMS, direct-vm etc whom creates a new exchange. And if you use direct, and other internals it would not. So it can be a bit unclear where such original message would origin from.\r\n\r\nInstead we should let the user use the Claim Check EIP pattern where you can explict set safe points with the original message, and easily merge data back agains, such as the message body only etc.\r\n\r\nSee for example\r\nhttps:\/\/github.com\/apache\/camel\/blob\/camel-2.x\/camel-core\/src\/test\/java\/org\/apache\/camel\/issues\/MulticastMixOriginalMessageBodyAndEnrichedHeadersTest.java\r\n\r\nVS\r\nhttps:\/\/github.com\/apache\/camel\/blob\/camel-2.x\/camel-core\/src\/test\/java\/org\/apache\/camel\/issues\/MulticastMixOriginalMessageBodyAndEnrichedHeadersClaimCheckTest.java",
      "assignee":"davsclaus",
      "type":"Improvement",
      "priority":"Major",
      "status":"Resolved",
      "text":"Consider removing useOriginalMessage functionality This feature is a bit more complex and its intention\/design was to in case of an error during routing, you could say, that the original incoming message should be restored as-is and used as \"result\", for example in case you want to move that message to some dead letter queue or log it etc.\r\n\r\nHowever people may mis-understand this, and think you can mix the original message BODY only and enrich it with any existing headers at the time of error - but that was not how it was designed\/intended.\r\n\r\nHowever a few EIPs and if you turned on shared unit of work, you could end up with situations where it would mix the original message with the message of error.\r\n\r\nIf the user wants to mix both the original message with the message at the error, then they should use a bean\/processor\/aggregation strategy etc to \"merge\" the data together as they want. NOT rely on just saying useOriginalMessage and \"hope for the best\". \r\n\r\nAlso the original message body, can when you transfer messages over Camel endpoints be stored at new endpoints such as JMS, direct-vm etc whom creates a new exchange. And if you use direct, and other internals it would not. So it can be a bit unclear where such original message would origin from.\r\n\r\nInstead we should let the user use the Claim Check EIP pattern where you can explict set safe points with the original message, and easily merge data back agains, such as the message body only etc.\r\n\r\nSee for example\r\nhttps:\/\/github.com\/apache\/camel\/blob\/camel-2.x\/camel-core\/src\/test\/java\/org\/apache\/camel\/issues\/MulticastMixOriginalMessageBodyAndEnrichedHeadersTest.java\r\n\r\nVS\r\nhttps:\/\/github.com\/apache\/camel\/blob\/camel-2.x\/camel-core\/src\/test\/java\/org\/apache\/camel\/issues\/MulticastMixOriginalMessageBodyAndEnrichedHeadersClaimCheckTest.java"
    },
    {
      "key":"CAMEL-13174",
      "title":"[consumer.]bridgeErrorHandler doesn't handle exception thrown by startingDirectoryMustExist",
      "description":"Following [StackOverflow: _File component's \\[consumer.\\]bridgeErrorHandler in conjunction with startingDirectoryMustExist_ |https:\/\/stackoverflow.com\/questions\/54513101\/file-components-consumer-bridgeerrorhandler-in-conjunction-with-startingdirec] I created the following test class:\r\n{code:java}\r\npackage test;\r\n\r\nimport org.apache.camel.LoggingLevel;\r\nimport org.apache.camel.builder.RouteBuilder;\r\nimport org.apache.camel.main.Main;\r\nimport org.junit.After;\r\nimport org.junit.Before;\r\nimport org.junit.Test;\r\n\r\npublic class CamelBridgeErrorHandlerTest {\r\n\r\n  private Main main;\r\n\r\n  @Before\r\n  public void before() {\r\n    main = new Main();\r\n  }\r\n\r\n  @Test\r\n  public void bridgeErrorHandler() {\r\n    main.addRouteBuilder(new RouteBuilder() {\r\n      @Override\r\n      public void configure() throws Exception {\r\n        route(this, \"file:not.existing.dir?autoCreate=false&startingDirectoryMustExist=true&bridgeErrorHandler=true\");\r\n      }\r\n    });\r\n  }\r\n\r\n  @Test\r\n  public void consumerBridgeErrorHandler() {\r\n    main.addRouteBuilder(new RouteBuilder() {\r\n      @Override\r\n      public void configure() throws Exception {\r\n        route(this, \"file:not.existing.dir?autoCreate=false&startingDirectoryMustExist=true&consumer.bridgeErrorHandler=true\");\r\n      }\r\n    });\r\n  }\r\n\r\n  private void route(final RouteBuilder builder, final String consumerURI) {\r\n    builder\r\n        .from(consumerURI)\r\n\r\n        \/\/ this is never reached\r\n        .onException(Exception.class)\r\n        .handled(true)\r\n        .log(LoggingLevel.ERROR, \"${exception}\")\r\n        .end()\r\n\r\n        .log(\" ... processing ...\");\r\n  }\r\n\r\n  @After\r\n  public void after() throws Exception {\r\n    main.start();\r\n  }\r\n}\r\n{code}\r\nBoth test methods throw:\r\n{noformat}\r\norg.apache.camel.FailedToCreateRouteException: Failed to create route routeN:\r\n  Route(routeN)[[From[file:not.existing.dir?autoCreate=false&s...\r\n    because of Starting directory does not exist: not.existing.dir\r\n{noformat}\r\nrather than the exception(s) being handled by the route(s)' {{onException()}}.\r\n----\r\nP.S.: When TRACEing through the log output both test methods show:\r\n{quote}2019-02-08 11:29:36.209 TRACE camel.model.ProcessorDefinitionHelper \u2013 There are 6 properties on: From\\[file:not.existing.dir?autoCreate=false&startingDirectoryMustExist=true&\\{consumer.}bridgeErrorHandler=true\\]\r\n{quote}\r\nwhile there are just 3 of them ({{autoCreate}}, {{startingDirectoryMustExist}}, {{[consumer.]bridgeErrorHandler}}), aren't there? Is this worth another issue?",
      "assignee":"davsclaus",
      "type":"Improvement",
      "priority":"Minor",
      "status":"Resolved",
      "text":"[consumer.]bridgeErrorHandler doesn't handle exception thrown by startingDirectoryMustExist Following [StackOverflow: _File component's \\[consumer.\\]bridgeErrorHandler in conjunction with startingDirectoryMustExist_ |https:\/\/stackoverflow.com\/questions\/54513101\/file-components-consumer-bridgeerrorhandler-in-conjunction-with-startingdirec] I created the following test class:\r\n{code:java}\r\npackage test;\r\n\r\nimport org.apache.camel.LoggingLevel;\r\nimport org.apache.camel.builder.RouteBuilder;\r\nimport org.apache.camel.main.Main;\r\nimport org.junit.After;\r\nimport org.junit.Before;\r\nimport org.junit.Test;\r\n\r\npublic class CamelBridgeErrorHandlerTest {\r\n\r\n  private Main main;\r\n\r\n  @Before\r\n  public void before() {\r\n    main = new Main();\r\n  }\r\n\r\n  @Test\r\n  public void bridgeErrorHandler() {\r\n    main.addRouteBuilder(new RouteBuilder() {\r\n      @Override\r\n      public void configure() throws Exception {\r\n        route(this, \"file:not.existing.dir?autoCreate=false&startingDirectoryMustExist=true&bridgeErrorHandler=true\");\r\n      }\r\n    });\r\n  }\r\n\r\n  @Test\r\n  public void consumerBridgeErrorHandler() {\r\n    main.addRouteBuilder(new RouteBuilder() {\r\n      @Override\r\n      public void configure() throws Exception {\r\n        route(this, \"file:not.existing.dir?autoCreate=false&startingDirectoryMustExist=true&consumer.bridgeErrorHandler=true\");\r\n      }\r\n    });\r\n  }\r\n\r\n  private void route(final RouteBuilder builder, final String consumerURI) {\r\n    builder\r\n        .from(consumerURI)\r\n\r\n        \/\/ this is never reached\r\n        .onException(Exception.class)\r\n        .handled(true)\r\n        .log(LoggingLevel.ERROR, \"${exception}\")\r\n        .end()\r\n\r\n        .log(\" ... processing ...\");\r\n  }\r\n\r\n  @After\r\n  public void after() throws Exception {\r\n    main.start();\r\n  }\r\n}\r\n{code}\r\nBoth test methods throw:\r\n{noformat}\r\norg.apache.camel.FailedToCreateRouteException: Failed to create route routeN:\r\n  Route(routeN)[[From[file:not.existing.dir?autoCreate=false&s...\r\n    because of Starting directory does not exist: not.existing.dir\r\n{noformat}\r\nrather than the exception(s) being handled by the route(s)' {{onException()}}.\r\n----\r\nP.S.: When TRACEing through the log output both test methods show:\r\n{quote}2019-02-08 11:29:36.209 TRACE camel.model.ProcessorDefinitionHelper - There are 6 properties on: From\\[file:not.existing.dir?autoCreate=false&startingDirectoryMustExist=true&\\{consumer.}bridgeErrorHandler=true\\]\r\n{quote}\r\nwhile there are just 3 of them ({{autoCreate}}, {{startingDirectoryMustExist}}, {{[consumer.]bridgeErrorHandler}}), aren't there? Is this worth another issue?"
    },
    {
      "key":"CAMEL-13171",
      "title":"camel-restdsl-swagger xml generation can't find required method allowableValues(String)",
      "description":"Reported on SO\r\nhttps:\/\/stackoverflow.com\/questions\/54405868\/camel-restdsl-swagger-xml-generation-cant-find-required-method-allowablevalues?noredirect=1#comment95906957_54405868\r\n\r\nLook at the provided sample project on github and see if we can reproduce the issue and find out whats the issue is",
      "assignee":"davsclaus",
      "type":"Bug",
      "priority":"Minor",
      "status":"Resolved",
      "text":"camel-restdsl-swagger xml generation can't find required method allowableValues(String) Reported on SO\r\nhttps:\/\/stackoverflow.com\/questions\/54405868\/camel-restdsl-swagger-xml-generation-cant-find-required-method-allowablevalues?noredirect=1#comment95906957_54405868\r\n\r\nLook at the provided sample project on github and see if we can reproduce the issue and find out whats the issue is"
    },
    {
      "key":"CAMEL-13164",
      "title":"camel3 - Remove includeRoutes on RouteBuilder",
      "description":"This functionality was not really in use, and was not fully implemented. And there was no similar feature for using other DSLs such as XML.\r\n\r\nIts deprecated in 2.x and removed in 3",
      "assignee":"davsclaus",
      "type":"Improvement",
      "priority":"Major",
      "status":"Resolved",
      "text":"camel3 - Remove includeRoutes on RouteBuilder This functionality was not really in use, and was not fully implemented. And there was no similar feature for using other DSLs such as XML.\r\n\r\nIts deprecated in 2.x and removed in 3"
    },
    {
      "key":"CAMEL-13160",
      "title":"Remove headers should be case in-sensitive by default",
      "description":"The PatternHelper.matchPattern is case sensitive when matching with wildcard and regexp. For exact match then header keys are by default case insensitive so remove foo will remove FOO Foo and foo headers. But remove pattern=foo* will only remove lower-case foo headers. So we should make this case insensitive for all kinds of patterns (exact, wildcard and regexp).",
      "assignee":"davsclaus",
      "type":"Improvement",
      "priority":"Major",
      "status":"Resolved",
      "text":"Remove headers should be case in-sensitive by default The PatternHelper.matchPattern is case sensitive when matching with wildcard and regexp. For exact match then header keys are by default case insensitive so remove foo will remove FOO Foo and foo headers. But remove pattern=foo* will only remove lower-case foo headers. So we should make this case insensitive for all kinds of patterns (exact, wildcard and regexp)."
    },
    {
      "key":"CAMEL-13158",
      "title":"Unable to invoke beans starting with the string \"header\" using toD",
      "description":"\u00a0\r\n\r\nI found one strange behavior when I added below to my route:\r\n\r\n\u00a0\r\n{code:java}\r\nfrom(...)\r\n    .toD(\"headerEnricher\"){code}\r\n\u00a0\r\n\r\nAfter some debugging with below unit test, I was able to find the culprit as this line which is interpreting \"headerEnricher\" as if it is equivalent to \"header.Enricher\" or \"header[Enricher]\"\r\n\r\n[https:\/\/github.com\/apache\/camel\/blob\/camel-2.23.x\/camel-core\/src\/main\/java\/org\/apache\/camel\/language\/simple\/ast\/SimpleFunctionExpression.java#L352]\u00a0\r\n\r\n\u00a0\r\n{code:java}\r\n\r\n@Test\r\npublic void testSimpleHeaderString() {\r\nfinal Language lan = new DefaultCamelContext().resolveLanguage(\"simple\");\r\nfinal Expression exp = lan.createExpression(\"hederEnricher\");\r\n\r\n\/\/Pass\r\nAssert.assertEquals(exp.toString(), \"hederEnricher\");\r\n\r\nfinal Expression exp2 = lan.createExpression(\"headerEnricher\");\r\n\r\n\/\/Fail\r\nAssert.assertEquals(exp2.toString(), \"headerEnricher\");\r\n}\r\n{code}\r\n\u00a0\r\n\r\nMy thought is that the legacy syntax should not try to parse the header expression unless it is followed by some kind of valid operator character like . or ? or [\r\n\r\n\u00a0\r\n\r\n\u00a0",
      "assignee":"davsclaus",
      "type":"Improvement",
      "priority":"Minor",
      "status":"Resolved",
      "text":"Unable to invoke beans starting with the string \"header\" using toD  \r\n\r\nI found one strange behavior when I added below to my route:\r\n\r\n \r\n{code:java}\r\nfrom(...)\r\n    .toD(\"headerEnricher\"){code}\r\n \r\n\r\nAfter some debugging with below unit test, I was able to find the culprit as this line which is interpreting \"headerEnricher\" as if it is equivalent to \"header.Enricher\" or \"header[Enricher]\"\r\n\r\n[https:\/\/github.com\/apache\/camel\/blob\/camel-2.23.x\/camel-core\/src\/main\/java\/org\/apache\/camel\/language\/simple\/ast\/SimpleFunctionExpression.java#L352] \r\n\r\n \r\n{code:java}\r\n\r\n@Test\r\npublic void testSimpleHeaderString() {\r\nfinal Language lan = new DefaultCamelContext().resolveLanguage(\"simple\");\r\nfinal Expression exp = lan.createExpression(\"hederEnricher\");\r\n\r\n\/\/Pass\r\nAssert.assertEquals(exp.toString(), \"hederEnricher\");\r\n\r\nfinal Expression exp2 = lan.createExpression(\"headerEnricher\");\r\n\r\n\/\/Fail\r\nAssert.assertEquals(exp2.toString(), \"headerEnricher\");\r\n}\r\n{code}\r\n \r\n\r\nMy thought is that the legacy syntax should not try to parse the header expression unless it is followed by some kind of valid operator character like . or ? or [\r\n\r\n \r\n\r\n "
    },
    {
      "key":"CAMEL-13154",
      "title":"camel-example-spring-boot-master running error",
      "description":"When running the spring-boot-master, as we use the spring-boot-web-starter by default,  I get the port is ready bound error when I start another instance.\r\n\r\nAs the example doesn't use the web server anymore, the fix could we just remove the spring-boot-web-starter. \r\n",
      "assignee":"njiang",
      "type":"Bug",
      "priority":"Minor",
      "status":"Resolved",
      "text":"camel-example-spring-boot-master running error When running the spring-boot-master, as we use the spring-boot-web-starter by default,  I get the port is ready bound error when I start another instance.\r\n\r\nAs the example doesn't use the web server anymore, the fix could we just remove the spring-boot-web-starter. \r\n"
    },
    {
      "key":"CAMEL-13151",
      "title":"Removed deprecated stuff from simple language",
      "description":"Related to CAMEL-13150. Where property on the date command is deprecated. We should remove that, and also look at other things that has been deprecated in the simple language in 2.x.",
      "assignee":"davsclaus",
      "type":"Task",
      "priority":"Minor",
      "status":"Resolved",
      "text":"Removed deprecated stuff from simple language Related to CAMEL-13150. Where property on the date command is deprecated. We should remove that, and also look at other things that has been deprecated in the simple language in 2.x."
    },
    {
      "key":"CAMEL-13150",
      "title":"Add command \"exchangeProperty\" for dateExpression in ExpressionBuilder",
      "description":"Method \"_dateExpression_\" in _ExpressionBuilder.java_ is not taking care about new\u00a0accessor of \"_exchangeProperty_\".\u00a0Command \"_property_\" is *deprecated* since 2.15\r\n\r\n+working+ : simple(\"_${date:property.CamelCreatedTimestamp:yyyy-MM-dd}_\")\u00a0\r\n\r\n+not-working+ : simple(\"_${date:exchangeProperty.CamelCreatedTimestamp:yyyy-MM-dd}_\")\u00a0",
      "assignee":"davsclaus",
      "type":"Improvement",
      "priority":"Minor",
      "status":"Resolved",
      "text":"Add command \"exchangeProperty\" for dateExpression in ExpressionBuilder Method \"_dateExpression_\" in _ExpressionBuilder.java_ is not taking care about new accessor of \"_exchangeProperty_\". Command \"_property_\" is *deprecated* since 2.15\r\n\r\n+working+ : simple(\"_${date:property.CamelCreatedTimestamp:yyyy-MM-dd}_\") \r\n\r\n+not-working+ : simple(\"_${date:exchangeProperty.CamelCreatedTimestamp:yyyy-MM-dd}_\") "
    },
    {
      "key":"CAMEL-13144",
      "title":"Move bean component out of camel-core",
      "description":"This component is a bit more challenging as bean component is also used for method call language and has support for using language annotations. For example also for @XPath etc.\r\n",
      "assignee":"davsclaus",
      "type":"Task",
      "priority":"Major",
      "status":"Resolved",
      "text":"Move bean component out of camel-core This component is a bit more challenging as bean component is also used for method call language and has support for using language annotations. For example also for @XPath etc.\r\n"
    },
    {
      "key":"CAMEL-13142",
      "title":"Camel may package artifacts from different version",
      "description":"When switching from one branch to another there is a (likely) possibility that component directories that existed in a previous checkout branch are no longer available in the current checkout branch. However, `camel-foo\/target` with all the previously generated artifacts is still on the file system and cannot be detected by `git status` either. Neither will these stale target directories be removed by `mvn clean`.\r\n\r\nThe camel packager plugin seems to be walking the camel directory structure and will package everything it finds. As a result the camel-2.23.2-SNAPSHOT catalog may contain a catalog entry that points to camel-browse-3.0.0-SNAPSHOT.\r\n\r\nAs a workaround, I suggest to do something like this \r\n\r\n{code}\r\nfind . -type d -name target | xargs rm -rf\r\n{code}\r\n\r\nbefore doing a clean mvn build.\r\n\r\nAs a possible solution, it may be necessary for the thing that walks the directory structure to require at least one file that is maintained in SCM (e.g. pom.xml)",
      "assignee":"davsclaus",
      "type":"Task",
      "priority":"Minor",
      "status":"Resolved",
      "text":"Camel may package artifacts from different version When switching from one branch to another there is a (likely) possibility that component directories that existed in a previous checkout branch are no longer available in the current checkout branch. However, `camel-foo\/target` with all the previously generated artifacts is still on the file system and cannot be detected by `git status` either. Neither will these stale target directories be removed by `mvn clean`.\r\n\r\nThe camel packager plugin seems to be walking the camel directory structure and will package everything it finds. As a result the camel-2.23.2-SNAPSHOT catalog may contain a catalog entry that points to camel-browse-3.0.0-SNAPSHOT.\r\n\r\nAs a workaround, I suggest to do something like this \r\n\r\n{code}\r\nfind . -type d -name target | xargs rm -rf\r\n{code}\r\n\r\nbefore doing a clean mvn build.\r\n\r\nAs a possible solution, it may be necessary for the thing that walks the directory structure to require at least one file that is maintained in SCM (e.g. pom.xml)"
    },
    {
      "key":"CAMEL-13141",
      "title":"camel-api - Add API for advising routes",
      "description":"We should likely add a nicer API for testing camel routes with the adviceWith functionality. Today you have to use a RouteReifier from camel-core. We should make a new API in camel-api and make it with a nicer name so its easier to understand and use.\r\n\r\n{code}\r\n        RouteReifier.adviceWith(context.getRouteDefinitions().get(0), context, new RouteBuilder() {\r\n            @Override\r\n            public void configure() throws Exception {\r\n                \/\/ intercept sending to mock:foo and do something else\r\n                interceptSendToEndpoint(\"mock:foo\")\r\n                        .skipSendToOriginalEndpoint()\r\n                        .to(\"log:foo\")\r\n                        .to(\"mock:advised\");\r\n            }\r\n        });\r\n{code}\r\n",
      "assignee":"davsclaus",
      "type":"New Feature",
      "priority":"Major",
      "status":"Resolved",
      "text":"camel-api - Add API for advising routes We should likely add a nicer API for testing camel routes with the adviceWith functionality. Today you have to use a RouteReifier from camel-core. We should make a new API in camel-api and make it with a nicer name so its easier to understand and use.\r\n\r\n{code}\r\n        RouteReifier.adviceWith(context.getRouteDefinitions().get(0), context, new RouteBuilder() {\r\n            @Override\r\n            public void configure() throws Exception {\r\n                \/\/ intercept sending to mock:foo and do something else\r\n                interceptSendToEndpoint(\"mock:foo\")\r\n                        .skipSendToOriginalEndpoint()\r\n                        .to(\"log:foo\")\r\n                        .to(\"mock:advised\");\r\n            }\r\n        });\r\n{code}\r\n"
    },
    {
      "key":"CAMEL-13140",
      "title":"camel-kafka - consumer does not respect auto.commit.interval.ms with AutoCommitEnabled=true",
      "description":"This is probably a side effect of\u00a0CAMEL-12454: when auto commit enabled is enabled kafka consumer commits offsets as soon as an exchange is complete with no regard to the auto.commit.interval.ms setting, which may cause additional non-balanced load on the kafka cluster (see attached screenshot depicting kafka brokers cpu load right after upgrade from 2.20.3 to 2.23.0).\r\n\r\nHere is an example with debugging turned on for org.apache.camel.component.kafka.KafkaConsumer, as you can see Kafka consumer commits every 10-500 ms instead of once per 5 seconds:\r\n{code:java}\r\n2019-01-28 10:46:55.025  INFO 3324 --- [ontext_Worker-3] o.a.k.clients.consumer.ConsumerConfig    : ConsumerConfig values: \r\n\tauto.commit.interval.ms = 5000\r\n\tauto.offset.reset = latest\r\n\tbootstrap.servers = [192.168.56.10:9093]\r\n\tcheck.crcs = true\r\n\tclient.id = \r\n\tconnections.max.idle.ms = 540000\r\n\tenable.auto.commit = true\r\n\texclude.internal.topics = true\r\n\tfetch.max.bytes = 52428800\r\n\tfetch.max.wait.ms = 500\r\n\tfetch.min.bytes = 1\r\n\tgroup.id = service_new\r\n\theartbeat.interval.ms = 3000\r\n\tinterceptor.classes = null\r\n\tinternal.leave.group.on.close = true\r\n\tisolation.level = read_uncommitted\r\n\tkey.deserializer = class org.apache.kafka.common.serialization.StringDeserializer\r\n\tmax.partition.fetch.bytes = 1048576\r\n\tmax.poll.interval.ms = 300000\r\n\tmax.poll.records = 1000\r\n\tmetadata.max.age.ms = 300000\r\n\tmetric.reporters = []\r\n\tmetrics.num.samples = 2\r\n\tmetrics.recording.level = INFO\r\n\tmetrics.sample.window.ms = 30000\r\n\tpartition.assignment.strategy = [org.apache.kafka.clients.consumer.RangeAssignor]\r\n\treceive.buffer.bytes = 65536\r\n\treconnect.backoff.max.ms = 1000\r\n\treconnect.backoff.ms = 50\r\n\trequest.timeout.ms = 40000\r\n\tretry.backoff.ms = 100\r\n\tsasl.jaas.config = null\r\n\tsasl.kerberos.kinit.cmd = \/usr\/bin\/kinit\r\n\tsasl.kerberos.min.time.before.relogin = 60000\r\n\tsasl.kerberos.service.name = null\r\n\tsasl.kerberos.ticket.renew.jitter = 0.05\r\n\tsasl.kerberos.ticket.renew.window.factor = 0.8\r\n\tsasl.mechanism = GSSAPI\r\n\tsecurity.protocol = SSL\r\n\tsend.buffer.bytes = 131072\r\n\tsession.timeout.ms = 30000\r\n\tssl.cipher.suites = null\r\n\tssl.enabled.protocols = [TLSv1.2]\r\n\tssl.endpoint.identification.algorithm = null\r\n\tssl.key.password = null\r\n\tssl.keymanager.algorithm = SunX509\r\n\tssl.keystore.location = \/usr\/files\/server.jks\r\n\tssl.keystore.password = [hidden]\r\n\tssl.keystore.type = JCEKS\r\n\tssl.protocol = TLS\r\n\tssl.provider = null\r\n\tssl.secure.random.implementation = null\r\n\tssl.trustmanager.algorithm = PKIX\r\n\tssl.truststore.location = \/usr\/files\/truststore.jks\r\n\tssl.truststore.password = [hidden]\r\n\tssl.truststore.type = JCEKS\r\n\tvalue.deserializer = class org.apache.kafka.common.serialization.StringDeserializer\r\n\r\n2019-01-28 10:46:55.160  INFO 3324 --- [ontext_Worker-3] o.a.kafka.common.utils.AppInfoParser     : Kafka version : 1.0.2\r\n2019-01-28 10:46:55.160  INFO 3324 --- [ontext_Worker-3] o.a.kafka.common.utils.AppInfoParser     : Kafka commitId : 2a121f7b1d402825\r\n2019-01-28 10:46:55.160  INFO 3324 --- [ontext_Worker-3] o.a.camel.spring.SpringCamelContext      : Route: route1 started and consuming from: kafka:topic1,topic2,topic3?brokers=192.168.56.10:9093\r\n2019-01-28 10:46:55.161  INFO 3324 --- [uponassignment]] o.a.camel.component.kafka.KafkaConsumer  : Subscribing topic1,topic2,topic3-Thread 0 to topic topic1,topic2,topic3\r\n2019-01-28 10:46:55.161  INFO 3324 --- [uponassignment]] o.a.camel.component.kafka.KafkaConsumer  : Subscribing topic1,topic2,topic3-Thread 0 to topic topic1,topic2,topic3\r\n2019-01-28 10:46:55.313  INFO 3324 --- [uponassignment]] o.a.k.c.c.internals.AbstractCoordinator  : [Consumer clientId=consumer-1, groupId=service_new] Discovered group coordinator 192.168.56.10:9093 (id: 2147483646 rack: null)\r\n2019-01-28 10:46:55.315  INFO 3324 --- [uponassignment]] o.a.k.c.c.internals.ConsumerCoordinator  : [Consumer clientId=consumer-1, groupId=service_new] Revoking previously assigned partitions []\r\n2019-01-28 10:46:55.316  INFO 3324 --- [uponassignment]] o.a.k.c.c.internals.AbstractCoordinator  : [Consumer clientId=consumer-1, groupId=service_new] (Re-)joining group\r\n2019-01-28 10:46:58.469  INFO 3324 --- [uponassignment]] o.a.k.c.c.internals.AbstractCoordinator  : [Consumer clientId=consumer-1, groupId=service_new] Successfully joined group with generation 3\r\n2019-01-28 10:46:58.470  INFO 3324 --- [uponassignment]] o.a.k.c.c.internals.ConsumerCoordinator  : [Consumer clientId=consumer-1, groupId=service_new] Setting newly assigned partitions [topic3-1, topic3-0, topic2-1, topic1-0, topic2-0, topic1-1]\r\n2019-01-28 10:47:24.953 DEBUG 3324 --- [uponassignment]] o.a.camel.component.kafka.KafkaConsumer  : Auto commitSync topic1,topic2,topic3-Thread 0 from topic topic1,topic2,topic3 with offset: 3221\r\n2019-01-28 10:47:24.953 DEBUG 3324 --- [uponassignment]] o.a.camel.component.kafka.KafkaConsumer  : Auto commitSync topic1,topic2,topic3-Thread 0 from topic topic1,topic2,topic3 with offset: 3221\r\n2019-01-28 10:47:24.957 DEBUG 3324 --- [uponassignment]] o.a.camel.component.kafka.KafkaConsumer  : Auto commitSync topic1,topic2,topic3-Thread 0 from topic topic1,topic2,topic3 with offset: 3222\r\n2019-01-28 10:47:24.957 DEBUG 3324 --- [uponassignment]] o.a.camel.component.kafka.KafkaConsumer  : Auto commitSync topic1,topic2,topic3-Thread 0 from topic topic1,topic2,topic3 with offset: 3222\r\n2019-01-28 10:47:24.964 DEBUG 3324 --- [uponassignment]] o.a.camel.component.kafka.KafkaConsumer  : Auto commitSync topic1,topic2,topic3-Thread 0 from topic topic1,topic2,topic3 with offset: 3325\r\n2019-01-28 10:47:24.964 DEBUG 3324 --- [uponassignment]] o.a.camel.component.kafka.KafkaConsumer  : Auto commitSync topic1,topic2,topic3-Thread 0 from topic topic1,topic2,topic3 with offset: 3325\r\n2019-01-28 10:47:25.005 DEBUG 3324 --- [uponassignment]] o.a.camel.component.kafka.KafkaConsumer  : Auto commitSync topic1,topic2,topic3-Thread 0 from topic topic1,topic2,topic3 with offset: 3223\r\n2019-01-28 10:47:25.005 DEBUG 3324 --- [uponassignment]] o.a.camel.component.kafka.KafkaConsumer  : Auto commitSync topic1,topic2,topic3-Thread 0 from topic topic1,topic2,topic3 with offset: 3223\r\n2019-01-28 10:47:25.515 DEBUG 3324 --- [uponassignment]] o.a.camel.component.kafka.KafkaConsumer  : Auto commitSync topic1,topic2,topic3-Thread 0 from topic topic1,topic2,topic3 with offset: 3326\r\n2019-01-28 10:47:25.515 DEBUG 3324 --- [uponassignment]] o.a.camel.component.kafka.KafkaConsumer  : Auto commitSync topic1,topic2,topic3-Thread 0 from topic topic1,topic2,topic3 with offset: 3326\r\n2019-01-28 10:47:26.005 DEBUG 3324 --- [uponassignment]] o.a.camel.component.kafka.KafkaConsumer  : Auto commitSync topic1,topic2,topic3-Thread 0 from topic topic1,topic2,topic3 with offset: 3224\r\n2019-01-28 10:47:26.005 DEBUG 3324 --- [uponassignment]] o.a.camel.component.kafka.KafkaConsumer  : Auto commitSync topic1,topic2,topic3-Thread 0 from topic topic1,topic2,topic3 with offset: 3224\r\n2019-01-28 10:47:26.528 DEBUG 3324 --- [uponassignment]] o.a.camel.component.kafka.KafkaConsumer  : Auto commitSync topic1,topic2,topic3-Thread 0 from topic topic1,topic2,topic3 with offset: 3327\r\n2019-01-28 10:47:26.528 DEBUG 3324 --- [uponassignment]] o.a.camel.component.kafka.KafkaConsumer  : Auto commitSync topic1,topic2,topic3-Thread 0 from topic topic1,topic2,topic3 with offset: 3327\r\n2019-01-28 10:47:27.014 DEBUG 3324 --- [uponassignment]] o.a.camel.component.kafka.KafkaConsumer  : Auto commitSync topic1,topic2,topic3-Thread 0 from topic topic1,topic2,topic3 with offset: 3225\r\n2019-01-28 10:47:27.014 DEBUG 3324 --- [uponassignment]] o.a.camel.component.kafka.KafkaConsumer  : Auto commitSync topic1,topic2,topic3-Thread 0 from topic topic1,topic2,topic3 with offset: 3225\r\n2019-01-28 10:47:27.512 DEBUG 3324 --- [uponassignment]] o.a.camel.component.kafka.KafkaConsumer  : Auto commitSync topic1,topic2,topic3-Thread 0 from topic topic1,topic2,topic3 with offset: 3328\r\n2019-01-28 10:47:27.512 DEBUG 3324 --- [uponassignment]] o.a.camel.component.kafka.KafkaConsumer  : Auto commitSync topic1,topic2,topic3-Thread 0 from topic topic1,topic2,topic3 with offset: 3328\r\n2019-01-28 10:47:28.001 DEBUG 3324 --- [uponassignment]] o.a.camel.component.kafka.KafkaConsumer  : Auto commitSync topic1,topic2,topic3-Thread 0 from topic topic1,topic2,topic3 with offset: 3226\r\n2019-01-28 10:47:28.001 DEBUG 3324 --- [uponassignment]] o.a.camel.component.kafka.KafkaConsumer  : Auto commitSync topic1,topic2,topic3-Thread 0 from topic topic1,topic2,topic3 with offset: 3226\r\n2019-01-28 10:47:28.497 DEBUG 3324 --- [uponassignment]] o.a.camel.component.kafka.KafkaConsumer  : Auto commitSync topic1,topic2,topic3-Thread 0 from topic topic1,topic2,topic3 with offset: 3329\r\n2019-01-28 10:47:28.497 DEBUG 3324 --- [uponassignment]] o.a.camel.component.kafka.KafkaConsumer  : Auto commitSync topic1,topic2,topic3-Thread 0 from topic topic1,topic2,topic3 with offset: 3329\r\n2019-01-28 10:47:29.024 DEBUG 3324 --- [uponassignment]] o.a.camel.component.kafka.KafkaConsumer  : Auto commitSync topic1,topic2,topic3-Thread 0 from topic topic1,topic2,topic3 with offset: 3330\r\n2019-01-28 10:47:29.024 DEBUG 3324 --- [uponassignment]] o.a.camel.component.kafka.KafkaConsumer  : Auto commitSync topic1,topic2,topic3-Thread 0 from topic topic1,topic2,topic3 with offset: 3330\r\n2019-01-28 10:47:29.521 DEBUG 3324 --- [uponassignment]] o.a.camel.component.kafka.KafkaConsumer  : Auto commitSync topic1,topic2,topic3-Thread 0 from topic topic1,topic2,topic3 with offset: 3227\r\n2019-01-28 10:47:29.521 DEBUG 3324 --- [uponassignment]] o.a.camel.component.kafka.KafkaConsumer  : Auto commitSync topic1,topic2,topic3-Thread 0 from topic topic1,topic2,topic3 with offset: 3227\r\n2019-01-28 10:47:30.012 DEBUG 3324 --- [uponassignment]] o.a.camel.component.kafka.KafkaConsumer  : Auto commitSync topic1,topic2,topic3-Thread 0 from topic topic1,topic2,topic3 with offset: 3228\r\n2019-01-28 10:47:30.012 DEBUG 3324 --- [uponassignment]] o.a.camel.component.kafka.KafkaConsumer  : Auto commitSync topic1,topic2,topic3-Thread 0 from topic topic1,topic2,topic3 with offset: 3228\r\n{code}\r\n\r\nWhen downgraded to camel-kafka 2.20.3 commits are done correctly (once every auto.commit.interval.ms) and there are no messages from o.a.camel.component.kafka.KafkaConsumer in the debug log.\r\nRunning with debugger showed that this code actually never gets executed in 2.20.3: https:\/\/github.com\/apache\/camel\/blob\/2.20.x\/components\/camel-kafka\/src\/main\/java\/org\/apache\/camel\/component\/kafka\/KafkaConsumer.java#L382 and we seem to rely on the auto-commit feature of the Kafka client itself, not the camel-kafka wrapper.",
      "assignee":"davsclaus",
      "type":"Bug",
      "priority":"Major",
      "status":"Resolved",
      "text":"camel-kafka - consumer does not respect auto.commit.interval.ms with AutoCommitEnabled=true This is probably a side effect of CAMEL-12454: when auto commit enabled is enabled kafka consumer commits offsets as soon as an exchange is complete with no regard to the auto.commit.interval.ms setting, which may cause additional non-balanced load on the kafka cluster (see attached screenshot depicting kafka brokers cpu load right after upgrade from 2.20.3 to 2.23.0).\r\n\r\nHere is an example with debugging turned on for org.apache.camel.component.kafka.KafkaConsumer, as you can see Kafka consumer commits every 10-500 ms instead of once per 5 seconds:\r\n{code:java}\r\n2019-01-28 10:46:55.025  INFO 3324 --- [ontext_Worker-3] o.a.k.clients.consumer.ConsumerConfig    : ConsumerConfig values: \r\n\tauto.commit.interval.ms = 5000\r\n\tauto.offset.reset = latest\r\n\tbootstrap.servers = [192.168.56.10:9093]\r\n\tcheck.crcs = true\r\n\tclient.id = \r\n\tconnections.max.idle.ms = 540000\r\n\tenable.auto.commit = true\r\n\texclude.internal.topics = true\r\n\tfetch.max.bytes = 52428800\r\n\tfetch.max.wait.ms = 500\r\n\tfetch.min.bytes = 1\r\n\tgroup.id = service_new\r\n\theartbeat.interval.ms = 3000\r\n\tinterceptor.classes = null\r\n\tinternal.leave.group.on.close = true\r\n\tisolation.level = read_uncommitted\r\n\tkey.deserializer = class org.apache.kafka.common.serialization.StringDeserializer\r\n\tmax.partition.fetch.bytes = 1048576\r\n\tmax.poll.interval.ms = 300000\r\n\tmax.poll.records = 1000\r\n\tmetadata.max.age.ms = 300000\r\n\tmetric.reporters = []\r\n\tmetrics.num.samples = 2\r\n\tmetrics.recording.level = INFO\r\n\tmetrics.sample.window.ms = 30000\r\n\tpartition.assignment.strategy = [org.apache.kafka.clients.consumer.RangeAssignor]\r\n\treceive.buffer.bytes = 65536\r\n\treconnect.backoff.max.ms = 1000\r\n\treconnect.backoff.ms = 50\r\n\trequest.timeout.ms = 40000\r\n\tretry.backoff.ms = 100\r\n\tsasl.jaas.config = null\r\n\tsasl.kerberos.kinit.cmd = \/usr\/bin\/kinit\r\n\tsasl.kerberos.min.time.before.relogin = 60000\r\n\tsasl.kerberos.service.name = null\r\n\tsasl.kerberos.ticket.renew.jitter = 0.05\r\n\tsasl.kerberos.ticket.renew.window.factor = 0.8\r\n\tsasl.mechanism = GSSAPI\r\n\tsecurity.protocol = SSL\r\n\tsend.buffer.bytes = 131072\r\n\tsession.timeout.ms = 30000\r\n\tssl.cipher.suites = null\r\n\tssl.enabled.protocols = [TLSv1.2]\r\n\tssl.endpoint.identification.algorithm = null\r\n\tssl.key.password = null\r\n\tssl.keymanager.algorithm = SunX509\r\n\tssl.keystore.location = \/usr\/files\/server.jks\r\n\tssl.keystore.password = [hidden]\r\n\tssl.keystore.type = JCEKS\r\n\tssl.protocol = TLS\r\n\tssl.provider = null\r\n\tssl.secure.random.implementation = null\r\n\tssl.trustmanager.algorithm = PKIX\r\n\tssl.truststore.location = \/usr\/files\/truststore.jks\r\n\tssl.truststore.password = [hidden]\r\n\tssl.truststore.type = JCEKS\r\n\tvalue.deserializer = class org.apache.kafka.common.serialization.StringDeserializer\r\n\r\n2019-01-28 10:46:55.160  INFO 3324 --- [ontext_Worker-3] o.a.kafka.common.utils.AppInfoParser     : Kafka version : 1.0.2\r\n2019-01-28 10:46:55.160  INFO 3324 --- [ontext_Worker-3] o.a.kafka.common.utils.AppInfoParser     : Kafka commitId : 2a121f7b1d402825\r\n2019-01-28 10:46:55.160  INFO 3324 --- [ontext_Worker-3] o.a.camel.spring.SpringCamelContext      : Route: route1 started and consuming from: kafka:topic1,topic2,topic3?brokers=192.168.56.10:9093\r\n2019-01-28 10:46:55.161  INFO 3324 --- [uponassignment]] o.a.camel.component.kafka.KafkaConsumer  : Subscribing topic1,topic2,topic3-Thread 0 to topic topic1,topic2,topic3\r\n2019-01-28 10:46:55.161  INFO 3324 --- [uponassignment]] o.a.camel.component.kafka.KafkaConsumer  : Subscribing topic1,topic2,topic3-Thread 0 to topic topic1,topic2,topic3\r\n2019-01-28 10:46:55.313  INFO 3324 --- [uponassignment]] o.a.k.c.c.internals.AbstractCoordinator  : [Consumer clientId=consumer-1, groupId=service_new] Discovered group coordinator 192.168.56.10:9093 (id: 2147483646 rack: null)\r\n2019-01-28 10:46:55.315  INFO 3324 --- [uponassignment]] o.a.k.c.c.internals.ConsumerCoordinator  : [Consumer clientId=consumer-1, groupId=service_new] Revoking previously assigned partitions []\r\n2019-01-28 10:46:55.316  INFO 3324 --- [uponassignment]] o.a.k.c.c.internals.AbstractCoordinator  : [Consumer clientId=consumer-1, groupId=service_new] (Re-)joining group\r\n2019-01-28 10:46:58.469  INFO 3324 --- [uponassignment]] o.a.k.c.c.internals.AbstractCoordinator  : [Consumer clientId=consumer-1, groupId=service_new] Successfully joined group with generation 3\r\n2019-01-28 10:46:58.470  INFO 3324 --- [uponassignment]] o.a.k.c.c.internals.ConsumerCoordinator  : [Consumer clientId=consumer-1, groupId=service_new] Setting newly assigned partitions [topic3-1, topic3-0, topic2-1, topic1-0, topic2-0, topic1-1]\r\n2019-01-28 10:47:24.953 DEBUG 3324 --- [uponassignment]] o.a.camel.component.kafka.KafkaConsumer  : Auto commitSync topic1,topic2,topic3-Thread 0 from topic topic1,topic2,topic3 with offset: 3221\r\n2019-01-28 10:47:24.953 DEBUG 3324 --- [uponassignment]] o.a.camel.component.kafka.KafkaConsumer  : Auto commitSync topic1,topic2,topic3-Thread 0 from topic topic1,topic2,topic3 with offset: 3221\r\n2019-01-28 10:47:24.957 DEBUG 3324 --- [uponassignment]] o.a.camel.component.kafka.KafkaConsumer  : Auto commitSync topic1,topic2,topic3-Thread 0 from topic topic1,topic2,topic3 with offset: 3222\r\n2019-01-28 10:47:24.957 DEBUG 3324 --- [uponassignment]] o.a.camel.component.kafka.KafkaConsumer  : Auto commitSync topic1,topic2,topic3-Thread 0 from topic topic1,topic2,topic3 with offset: 3222\r\n2019-01-28 10:47:24.964 DEBUG 3324 --- [uponassignment]] o.a.camel.component.kafka.KafkaConsumer  : Auto commitSync topic1,topic2,topic3-Thread 0 from topic topic1,topic2,topic3 with offset: 3325\r\n2019-01-28 10:47:24.964 DEBUG 3324 --- [uponassignment]] o.a.camel.component.kafka.KafkaConsumer  : Auto commitSync topic1,topic2,topic3-Thread 0 from topic topic1,topic2,topic3 with offset: 3325\r\n2019-01-28 10:47:25.005 DEBUG 3324 --- [uponassignment]] o.a.camel.component.kafka.KafkaConsumer  : Auto commitSync topic1,topic2,topic3-Thread 0 from topic topic1,topic2,topic3 with offset: 3223\r\n2019-01-28 10:47:25.005 DEBUG 3324 --- [uponassignment]] o.a.camel.component.kafka.KafkaConsumer  : Auto commitSync topic1,topic2,topic3-Thread 0 from topic topic1,topic2,topic3 with offset: 3223\r\n2019-01-28 10:47:25.515 DEBUG 3324 --- [uponassignment]] o.a.camel.component.kafka.KafkaConsumer  : Auto commitSync topic1,topic2,topic3-Thread 0 from topic topic1,topic2,topic3 with offset: 3326\r\n2019-01-28 10:47:25.515 DEBUG 3324 --- [uponassignment]] o.a.camel.component.kafka.KafkaConsumer  : Auto commitSync topic1,topic2,topic3-Thread 0 from topic topic1,topic2,topic3 with offset: 3326\r\n2019-01-28 10:47:26.005 DEBUG 3324 --- [uponassignment]] o.a.camel.component.kafka.KafkaConsumer  : Auto commitSync topic1,topic2,topic3-Thread 0 from topic topic1,topic2,topic3 with offset: 3224\r\n2019-01-28 10:47:26.005 DEBUG 3324 --- [uponassignment]] o.a.camel.component.kafka.KafkaConsumer  : Auto commitSync topic1,topic2,topic3-Thread 0 from topic topic1,topic2,topic3 with offset: 3224\r\n2019-01-28 10:47:26.528 DEBUG 3324 --- [uponassignment]] o.a.camel.component.kafka.KafkaConsumer  : Auto commitSync topic1,topic2,topic3-Thread 0 from topic topic1,topic2,topic3 with offset: 3327\r\n2019-01-28 10:47:26.528 DEBUG 3324 --- [uponassignment]] o.a.camel.component.kafka.KafkaConsumer  : Auto commitSync topic1,topic2,topic3-Thread 0 from topic topic1,topic2,topic3 with offset: 3327\r\n2019-01-28 10:47:27.014 DEBUG 3324 --- [uponassignment]] o.a.camel.component.kafka.KafkaConsumer  : Auto commitSync topic1,topic2,topic3-Thread 0 from topic topic1,topic2,topic3 with offset: 3225\r\n2019-01-28 10:47:27.014 DEBUG 3324 --- [uponassignment]] o.a.camel.component.kafka.KafkaConsumer  : Auto commitSync topic1,topic2,topic3-Thread 0 from topic topic1,topic2,topic3 with offset: 3225\r\n2019-01-28 10:47:27.512 DEBUG 3324 --- [uponassignment]] o.a.camel.component.kafka.KafkaConsumer  : Auto commitSync topic1,topic2,topic3-Thread 0 from topic topic1,topic2,topic3 with offset: 3328\r\n2019-01-28 10:47:27.512 DEBUG 3324 --- [uponassignment]] o.a.camel.component.kafka.KafkaConsumer  : Auto commitSync topic1,topic2,topic3-Thread 0 from topic topic1,topic2,topic3 with offset: 3328\r\n2019-01-28 10:47:28.001 DEBUG 3324 --- [uponassignment]] o.a.camel.component.kafka.KafkaConsumer  : Auto commitSync topic1,topic2,topic3-Thread 0 from topic topic1,topic2,topic3 with offset: 3226\r\n2019-01-28 10:47:28.001 DEBUG 3324 --- [uponassignment]] o.a.camel.component.kafka.KafkaConsumer  : Auto commitSync topic1,topic2,topic3-Thread 0 from topic topic1,topic2,topic3 with offset: 3226\r\n2019-01-28 10:47:28.497 DEBUG 3324 --- [uponassignment]] o.a.camel.component.kafka.KafkaConsumer  : Auto commitSync topic1,topic2,topic3-Thread 0 from topic topic1,topic2,topic3 with offset: 3329\r\n2019-01-28 10:47:28.497 DEBUG 3324 --- [uponassignment]] o.a.camel.component.kafka.KafkaConsumer  : Auto commitSync topic1,topic2,topic3-Thread 0 from topic topic1,topic2,topic3 with offset: 3329\r\n2019-01-28 10:47:29.024 DEBUG 3324 --- [uponassignment]] o.a.camel.component.kafka.KafkaConsumer  : Auto commitSync topic1,topic2,topic3-Thread 0 from topic topic1,topic2,topic3 with offset: 3330\r\n2019-01-28 10:47:29.024 DEBUG 3324 --- [uponassignment]] o.a.camel.component.kafka.KafkaConsumer  : Auto commitSync topic1,topic2,topic3-Thread 0 from topic topic1,topic2,topic3 with offset: 3330\r\n2019-01-28 10:47:29.521 DEBUG 3324 --- [uponassignment]] o.a.camel.component.kafka.KafkaConsumer  : Auto commitSync topic1,topic2,topic3-Thread 0 from topic topic1,topic2,topic3 with offset: 3227\r\n2019-01-28 10:47:29.521 DEBUG 3324 --- [uponassignment]] o.a.camel.component.kafka.KafkaConsumer  : Auto commitSync topic1,topic2,topic3-Thread 0 from topic topic1,topic2,topic3 with offset: 3227\r\n2019-01-28 10:47:30.012 DEBUG 3324 --- [uponassignment]] o.a.camel.component.kafka.KafkaConsumer  : Auto commitSync topic1,topic2,topic3-Thread 0 from topic topic1,topic2,topic3 with offset: 3228\r\n2019-01-28 10:47:30.012 DEBUG 3324 --- [uponassignment]] o.a.camel.component.kafka.KafkaConsumer  : Auto commitSync topic1,topic2,topic3-Thread 0 from topic topic1,topic2,topic3 with offset: 3228\r\n{code}\r\n\r\nWhen downgraded to camel-kafka 2.20.3 commits are done correctly (once every auto.commit.interval.ms) and there are no messages from o.a.camel.component.kafka.KafkaConsumer in the debug log.\r\nRunning with debugger showed that this code actually never gets executed in 2.20.3: https:\/\/github.com\/apache\/camel\/blob\/2.20.x\/components\/camel-kafka\/src\/main\/java\/org\/apache\/camel\/component\/kafka\/KafkaConsumer.java#L382 and we seem to rely on the auto-commit feature of the Kafka client itself, not the camel-kafka wrapper."
    },
    {
      "key":"CAMEL-13137",
      "title":"Move rest component out of camel-core",
      "description":"Create a new camel-rest component which has the rest component (needed when using rest-dsl, or using rest component directly etc).\r\n\r\n",
      "assignee":"davsclaus",
      "type":"Task",
      "priority":"Major",
      "status":"Resolved",
      "text":"Move rest component out of camel-core Create a new camel-rest component which has the rest component (needed when using rest-dsl, or using rest component directly etc).\r\n\r\n"
    },
    {
      "key":"CAMEL-13133",
      "title":"camel3 - build system - Packaging dataformat and language needs to include json metadata",
      "description":"When we just depend on camel-support for custom dataformats and languages then they cant locate camel-core JAR which has model json metadata they need for enriching their json metadata.\r\n\r\nThe camel-package-maven-plugin needs to find the camel-core JAR in another way now as its not on the classpath in the maven project.",
      "assignee":"davsclaus",
      "type":"Task",
      "priority":"Major",
      "status":"Resolved",
      "text":"camel3 - build system - Packaging dataformat and language needs to include json metadata When we just depend on camel-support for custom dataformats and languages then they cant locate camel-core JAR which has model json metadata they need for enriching their json metadata.\r\n\r\nThe camel-package-maven-plugin needs to find the camel-core JAR in another way now as its not on the classpath in the maven project."
    },
    {
      "key":"CAMEL-13131",
      "title":"Duplicate declaration of maven dependency in examples",
      "description":"[WARNING]\r\n[WARNING] Some problems were encountered while building the effective model for org.apache.camel.example:camel-example-cdi:jar:3.0.0-SNAPSHOT\r\n[WARNING] 'dependencies.dependency.(groupId:artifactId:type:classifier)' must be unique: org.apache.camel:camel-core:jar -> duplicate declaration of version (?) @ org.apache.camel.example:camel-example-cdi:[unknown-version], \/Users\/davsclaus\/workspace\/camel\/examples\/camel-example-cdi\/pom.xml, line 61, column 17\r\n[WARNING]\r\n[WARNING] Some problems were encountered while building the effective model for org.apache.camel.example:camel-example-cdi-cassandraql:jar:3.0.0-SNAPSHOT\r\n[WARNING] 'dependencies.dependency.(groupId:artifactId:type:classifier)' must be unique: org.apache.camel:camel-core:jar -> duplicate declaration of version (?) @ org.apache.camel.example:camel-example-cdi-cassandraql:[unknown-version], \/Users\/davsclaus\/workspace\/camel\/examples\/camel-example-cdi-cassandraql\/pom.xml, line 64, column 17\r\n[WARNING]\r\n[WARNING] It is highly recommended to fix these problems because they threaten the stability of your build.\r\n[WARNING]\r\n[WARNING] For this reason, future Maven versions might no longer support building such malformed projects.\r\n[WARNING]\r\n[INFO] --------------------------------------",
      "assignee":"davsclaus",
      "type":"Task",
      "priority":"Minor",
      "status":"Resolved",
      "text":"Duplicate declaration of maven dependency in examples [WARNING]\r\n[WARNING] Some problems were encountered while building the effective model for org.apache.camel.example:camel-example-cdi:jar:3.0.0-SNAPSHOT\r\n[WARNING] 'dependencies.dependency.(groupId:artifactId:type:classifier)' must be unique: org.apache.camel:camel-core:jar -> duplicate declaration of version (?) @ org.apache.camel.example:camel-example-cdi:[unknown-version], \/Users\/davsclaus\/workspace\/camel\/examples\/camel-example-cdi\/pom.xml, line 61, column 17\r\n[WARNING]\r\n[WARNING] Some problems were encountered while building the effective model for org.apache.camel.example:camel-example-cdi-cassandraql:jar:3.0.0-SNAPSHOT\r\n[WARNING] 'dependencies.dependency.(groupId:artifactId:type:classifier)' must be unique: org.apache.camel:camel-core:jar -> duplicate declaration of version (?) @ org.apache.camel.example:camel-example-cdi-cassandraql:[unknown-version], \/Users\/davsclaus\/workspace\/camel\/examples\/camel-example-cdi-cassandraql\/pom.xml, line 64, column 17\r\n[WARNING]\r\n[WARNING] It is highly recommended to fix these problems because they threaten the stability of your build.\r\n[WARNING]\r\n[WARNING] For this reason, future Maven versions might no longer support building such malformed projects.\r\n[WARNING]\r\n[INFO] --------------------------------------"
    },
    {
      "key":"CAMEL-13130",
      "title":"camel3 - Components should not use XmlConverter directly",
      "description":"There are a few components that uses XmlConverter directly like camel-cxf and camel-spring-ws. We should use XmlConverterHelper from camel-support if possible, or better yet the neutral TypeConverter API from camel-api.",
      "assignee":"davsclaus",
      "type":"Task",
      "priority":"Major",
      "status":"Resolved",
      "text":"camel3 - Components should not use XmlConverter directly There are a few components that uses XmlConverter directly like camel-cxf and camel-spring-ws. We should use XmlConverterHelper from camel-support if possible, or better yet the neutral TypeConverter API from camel-api."
    },
    {
      "key":"CAMEL-13126",
      "title":"For Swagger, add an option whether to use X-Forward headers",
      "description":"An earlier JIRA:\u00a0CAMEL-12855\u00a0created an issue where the forwarded header could be used to set the \"host\" for Swagger. This overwrote the old behavior where one could specify a \"hard-code\" host in the RestConfiguration.\r\n\r\nAdd an option to control\u00a0whether these x-forward headers should be applied or not, to have the\u00a0old behavior vs the new. (e.g. *useXForwardHeaders* = true\/false)\r\n\r\n[~cibsen@e-ma.net], a couple of questions:\r\n # would the default be the new behavior (using the headers), or the old behavior (do not use the headers) ?\r\n # should the parameter turn on\/off the entire X-FORWARD section... that is in [the\u00a0setupXForwardedHeaders() here|https:\/\/github.com\/apache\/camel\/blob\/release\/2.23.0\/components\/camel-swagger-java\/src\/main\/java\/org\/apache\/camel\/swagger\/RestSwaggerSupport.java#L358-L385]\u00a0?",
      "assignee":"davsclaus",
      "type":"Improvement",
      "priority":"Major",
      "status":"Resolved",
      "text":"For Swagger, add an option whether to use X-Forward headers An earlier JIRA: CAMEL-12855 created an issue where the forwarded header could be used to set the \"host\" for Swagger. This overwrote the old behavior where one could specify a \"hard-code\" host in the RestConfiguration.\r\n\r\nAdd an option to control whether these x-forward headers should be applied or not, to have the old behavior vs the new. (e.g. *useXForwardHeaders* = true\/false)\r\n\r\n[~cibsen@e-ma.net], a couple of questions:\r\n # would the default be the new behavior (using the headers), or the old behavior (do not use the headers) ?\r\n # should the parameter turn on\/off the entire X-FORWARD section... that is in [the setupXForwardedHeaders() here|https:\/\/github.com\/apache\/camel\/blob\/release\/2.23.0\/components\/camel-swagger-java\/src\/main\/java\/org\/apache\/camel\/swagger\/RestSwaggerSupport.java#L358-L385] ?"
    },
    {
      "key":"CAMEL-13124",
      "title":"camel3 - move xslt componet out of camel-core",
      "description":"This requires a bit of shared xml code to be moved to camel-support.",
      "assignee":"davsclaus",
      "type":"Task",
      "priority":"Major",
      "status":"Resolved",
      "text":"camel3 - move xslt componet out of camel-core This requires a bit of shared xml code to be moved to camel-support."
    },
    {
      "key":"CAMEL-13122",
      "title":"Potential bug in BeanExpression\/HttpMessage",
      "description":"I think I found a potential bug when using a bean to set a property if a message is coming through http. I wanted to check here before opening a bug in case I am missing something. It is very similar to the following bug which has already been fixed: [https:\/\/stackoverflow.com\/questions\/40293128\/camel-rest-service-throws-exception-when-returning-null\/40317432#40317432].\r\n\r\n\u00a0\r\n\r\nThe difference is that instead of returning null, an exception is thrown from the bean method. When that happen, I see the same behavior as described in the stackoverflow post above. \u00a0I included an example on how to reproduce at the end of this email. Here is what I think happens:\r\n\r\n\u00a0\r\n\r\nProblem starts in BeanExpression:\r\n 1. The exchange is copied, BeanExpression: line 194: Exchange resultExchange = ExchangeHelper.createCopy(exchange, true)\r\n 2. The out body is then retrieved from the exchange, BeanExpression: line 201: result = resultExchange.getOut().getBody();\r\n 3. Since out() is null, the in() message is copied to the out(), this makes a copy of the HttpMessage, which is copied along with the original ServletRequest (which contains a closed stream) DefaultExchange.class line 317.\r\n 4. To copy the message from in to out, the method newInstance() from HttpMessage class is called. HttpMessage line 85\r\n 5. At this point, the new instance of HttpMessage tries to read the stream from the original message which is already closed, IOException.\r\n\r\n\u00a0\r\n\r\nExample just below, I would be expecting the EXCEPTION_CAUGHT to be the RuntimeException I throw but instead it's a RuntimeBeanExpressionException effectively wrapping a IOException.\r\n\r\n\u00a0\r\n{code:java}\r\npublic void configureTestException() {\r\n\r\n\u00a0 restDefinitionV1 = restDefinitionV1\r\n\r\n\u00a0\u00a0\u00a0 .get(\"\/throwException\")\r\n\r\n\u00a0\u00a0\u00a0 .route()\r\n\r\n\u00a0\u00a0\u00a0\u00a0 .onException(Exception.class)\r\n\r\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 .process(exchange -> {System.out.println(\"Caught exception of type: \" + exchange.getProperty(Exchange.EXCEPTION_CAUGHT).getClass());} )\r\n\r\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 .handled(true)\r\n\r\n\u00a0\u00a0\u00a0\u00a0 .end()\r\n\r\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 .setProperty(\"test\").method(new TestBean(), \"throwException\")\r\n\r\n\u00a0\u00a0\u00a0\u00a0 .endRest();\r\n\r\n}\r\n\r\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\r\n\r\npublic static class TestBean {\r\n\r\n\u00a0 public void throwException() {\r\n\r\n\u00a0\u00a0\u00a0 throw new RuntimeException(\"Excepting this exception to be handled by onException\");\r\n\r\n\u00a0 }\r\n\r\n}\r\n{code}\r\n\u00a0\r\n\r\nI will try to provide an actual unit test shortly.",
      "assignee":"davsclaus",
      "type":"Bug",
      "priority":"Minor",
      "status":"Resolved",
      "text":"Potential bug in BeanExpression\/HttpMessage I think I found a potential bug when using a bean to set a property if a message is coming through http. I wanted to check here before opening a bug in case I am missing something. It is very similar to the following bug which has already been fixed: [https:\/\/stackoverflow.com\/questions\/40293128\/camel-rest-service-throws-exception-when-returning-null\/40317432#40317432].\r\n\r\n \r\n\r\nThe difference is that instead of returning null, an exception is thrown from the bean method. When that happen, I see the same behavior as described in the stackoverflow post above.  I included an example on how to reproduce at the end of this email. Here is what I think happens:\r\n\r\n \r\n\r\nProblem starts in BeanExpression:\r\n 1. The exchange is copied, BeanExpression: line 194: Exchange resultExchange = ExchangeHelper.createCopy(exchange, true)\r\n 2. The out body is then retrieved from the exchange, BeanExpression: line 201: result = resultExchange.getOut().getBody();\r\n 3. Since out() is null, the in() message is copied to the out(), this makes a copy of the HttpMessage, which is copied along with the original ServletRequest (which contains a closed stream) DefaultExchange.class line 317.\r\n 4. To copy the message from in to out, the method newInstance() from HttpMessage class is called. HttpMessage line 85\r\n 5. At this point, the new instance of HttpMessage tries to read the stream from the original message which is already closed, IOException.\r\n\r\n \r\n\r\nExample just below, I would be expecting the EXCEPTION_CAUGHT to be the RuntimeException I throw but instead it's a RuntimeBeanExpressionException effectively wrapping a IOException.\r\n\r\n \r\n{code:java}\r\npublic void configureTestException() {\r\n\r\n  restDefinitionV1 = restDefinitionV1\r\n\r\n    .get(\"\/throwException\")\r\n\r\n    .route()\r\n\r\n     .onException(Exception.class)\r\n\r\n       .process(exchange -> {System.out.println(\"Caught exception of type: \" + exchange.getProperty(Exchange.EXCEPTION_CAUGHT).getClass());} )\r\n\r\n       .handled(true)\r\n\r\n     .end()\r\n\r\n       .setProperty(\"test\").method(new TestBean(), \"throwException\")\r\n\r\n     .endRest();\r\n\r\n}\r\n\r\n               \r\n\r\npublic static class TestBean {\r\n\r\n  public void throwException() {\r\n\r\n    throw new RuntimeException(\"Excepting this exception to be handled by onException\");\r\n\r\n  }\r\n\r\n}\r\n{code}\r\n \r\n\r\nI will try to provide an actual unit test shortly."
    },
    {
      "key":"CAMEL-13119",
      "title":"Create Cache Policy for routes",
      "description":"Let's write a Policy for camel routes that can\u00a0cache\u00a0the \"result\" of a route and execute the route next time only if nothing is found in the\u00a0cache.\r\n\u00a0\r\nRelated to cache DSL idea, but without DSL change: https:\/\/issues.apache.org\/jira\/browse\/CAMEL-11114\r\n\u00a0\r\nIn the first draft the CachePolicy would cache the Message Body by a key calculated\u00a0via an Expression.\r\nInterface:\r\n * cachePolicy.setCacheManager( cacheManager ) - set the CacheManager. If not set, try lookup automatically.\r\n\r\n * cachePolicy.setCacheName ( name ) - Will use this cache from the CacheManager. If not set, we can use the route id by default.\r\n * cachePolicy.setKeyExpression( expression ) - Camel expression that is evaluated on the Exchange to determine the cache key. If it's found in the cache, the route is not executed and the cached value is\u00a0set\u00a0as\u00a0Body. Otherwise the Message Body is added to the cache after the route with this key.\r\n\r\n\r\n\u00a0\r\nAn earlier related implementation:\u00a0[https:\/\/gist.github.com\/bszeti\/552bf7a1f05a75fc2964a4ce7ce889b5]\u00a0\r\nand how it can be used in a route:\u00a0[https:\/\/gist.github.com\/bszeti\/4f855cd80cd69e3953ff990b0ae056a2]\r\n\u00a0\r\n\u00a0",
      "assignee":"davsclaus",
      "type":"New Feature",
      "priority":"Major",
      "status":"Resolved",
      "text":"Create Cache Policy for routes Let's write a Policy for camel routes that can cache the \"result\" of a route and execute the route next time only if nothing is found in the cache.\r\n \r\nRelated to cache DSL idea, but without DSL change: https:\/\/issues.apache.org\/jira\/browse\/CAMEL-11114\r\n \r\nIn the first draft the CachePolicy would cache the Message Body by a key calculated via an Expression.\r\nInterface:\r\n * cachePolicy.setCacheManager( cacheManager ) - set the CacheManager. If not set, try lookup automatically.\r\n\r\n * cachePolicy.setCacheName ( name ) - Will use this cache from the CacheManager. If not set, we can use the route id by default.\r\n * cachePolicy.setKeyExpression( expression ) - Camel expression that is evaluated on the Exchange to determine the cache key. If it's found in the cache, the route is not executed and the cached value is set as Body. Otherwise the Message Body is added to the cache after the route with this key.\r\n\r\n\r\n \r\nAn earlier related implementation: [https:\/\/gist.github.com\/bszeti\/552bf7a1f05a75fc2964a4ce7ce889b5] \r\nand how it can be used in a route: [https:\/\/gist.github.com\/bszeti\/4f855cd80cd69e3953ff990b0ae056a2]\r\n \r\n "
    },
    {
      "key":"CAMEL-13115",
      "title":"camel3 - build system - camel-catalog should not warn for missing doc for inactive modules",
      "description":"When we have removed deprecated modules in 3.x, then the folders stay in git when you switch branches.\r\n\r\nSo we get this WARNs when building camel-catalog\r\n{code}\r\n[WARNING] \tMissing document detected: 40\r\n[WARNING] \t\tcamel-bam\r\n[WARNING] \t\tcamel-cache\r\n[WARNING] \t\tcamel-castor\r\n[WARNING] \t\tcamel-context\r\n[WARNING] \t\tcamel-eclipse\r\n[WARNING] \t\tcamel-elasticsearch\r\n[WARNING] \t\tcamel-elasticsearch5\r\n[WARNING] \t\tcamel-groovy-dsl\r\n[WARNING] \t\tcamel-guice\r\n[WARNING] \t\tcamel-hawtdb\r\n[WARNING] \t\tcamel-hdfs\r\n[WARNING] \t\tcamel-hessian\r\n[WARNING] \t\tcamel-http\r\n[WARNING] \t\tcamel-ibatis\r\n[WARNING] \t\tcamel-javaspace\r\n[WARNING] \t\tcamel-jira\r\n[WARNING] \t\tcamel-josql\r\n[WARNING] \t\tcamel-juel\r\n[WARNING] \t\tcamel-jxpath\r\n[WARNING] \t\tcamel-kestrel\r\n[WARNING] \t\tcamel-krati\r\n[WARNING] \t\tcamel-mina\r\n[WARNING] \t\tcamel-mongodb\r\n[WARNING] \t\tcamel-netty\r\n[WARNING] \t\tcamel-netty-http\r\n[WARNING] \t\tcamel-openshift\r\n[WARNING] \t\tcamel-quartz\r\n[WARNING] \t\tcamel-routebox\r\n[WARNING] \t\tcamel-ruby\r\n[WARNING] \t\tcamel-rx\r\n[WARNING] \t\tcamel-scala\r\n[WARNING] \t\tcamel-scr\r\n[WARNING] \t\tcamel-servletlistener\r\n[WARNING] \t\tcamel-swagger\r\n[WARNING] \t\tcamel-testng\r\n[WARNING] \t\tcamel-urlrewrite\r\n[WARNING] \t\tcamel-xmlbeans\r\n[WARNING] \t\tcamel-xmljson\r\n[WARNING] \t\tcamel-xmlrpc\r\n[WARNING] \t\tcamel-yql\r\n{code}\r\n\r\nWe should make it detect that these are empty folders (has no pom.xml) and skip them.",
      "assignee":"davsclaus",
      "type":"Task",
      "priority":"Major",
      "status":"Resolved",
      "text":"camel3 - build system - camel-catalog should not warn for missing doc for inactive modules When we have removed deprecated modules in 3.x, then the folders stay in git when you switch branches.\r\n\r\nSo we get this WARNs when building camel-catalog\r\n{code}\r\n[WARNING] \tMissing document detected: 40\r\n[WARNING] \t\tcamel-bam\r\n[WARNING] \t\tcamel-cache\r\n[WARNING] \t\tcamel-castor\r\n[WARNING] \t\tcamel-context\r\n[WARNING] \t\tcamel-eclipse\r\n[WARNING] \t\tcamel-elasticsearch\r\n[WARNING] \t\tcamel-elasticsearch5\r\n[WARNING] \t\tcamel-groovy-dsl\r\n[WARNING] \t\tcamel-guice\r\n[WARNING] \t\tcamel-hawtdb\r\n[WARNING] \t\tcamel-hdfs\r\n[WARNING] \t\tcamel-hessian\r\n[WARNING] \t\tcamel-http\r\n[WARNING] \t\tcamel-ibatis\r\n[WARNING] \t\tcamel-javaspace\r\n[WARNING] \t\tcamel-jira\r\n[WARNING] \t\tcamel-josql\r\n[WARNING] \t\tcamel-juel\r\n[WARNING] \t\tcamel-jxpath\r\n[WARNING] \t\tcamel-kestrel\r\n[WARNING] \t\tcamel-krati\r\n[WARNING] \t\tcamel-mina\r\n[WARNING] \t\tcamel-mongodb\r\n[WARNING] \t\tcamel-netty\r\n[WARNING] \t\tcamel-netty-http\r\n[WARNING] \t\tcamel-openshift\r\n[WARNING] \t\tcamel-quartz\r\n[WARNING] \t\tcamel-routebox\r\n[WARNING] \t\tcamel-ruby\r\n[WARNING] \t\tcamel-rx\r\n[WARNING] \t\tcamel-scala\r\n[WARNING] \t\tcamel-scr\r\n[WARNING] \t\tcamel-servletlistener\r\n[WARNING] \t\tcamel-swagger\r\n[WARNING] \t\tcamel-testng\r\n[WARNING] \t\tcamel-urlrewrite\r\n[WARNING] \t\tcamel-xmlbeans\r\n[WARNING] \t\tcamel-xmljson\r\n[WARNING] \t\tcamel-xmlrpc\r\n[WARNING] \t\tcamel-yql\r\n{code}\r\n\r\nWe should make it detect that these are empty folders (has no pom.xml) and skip them."
    },
    {
      "key":"CAMEL-13113",
      "title":"Remove camel-script and make camel-javascript",
      "description":"scripting api\/jsr is also deprecated in the jdk and to be removed in the future\r\nwe will remove it for camel 3\r\nand deprecate it in 2.x\r\nfor camel k and using javascript i think they are doing something custom, and will can make a new camel-javascript language for that purpose solely\r\nall the other scripting languages was also a security vulnerability as well",
      "assignee":"davsclaus",
      "type":"Task",
      "priority":"Major",
      "status":"Resolved",
      "text":"Remove camel-script and make camel-javascript scripting api\/jsr is also deprecated in the jdk and to be removed in the future\r\nwe will remove it for camel 3\r\nand deprecate it in 2.x\r\nfor camel k and using javascript i think they are doing something custom, and will can make a new camel-javascript language for that purpose solely\r\nall the other scripting languages was also a security vulnerability as well"
    },
    {
      "key":"CAMEL-13112",
      "title":"Move file component out of camel core",
      "description":"There is some file cluster that uses some abstract cluster stuff which we need to move to camel-support",
      "assignee":"davsclaus",
      "type":"Task",
      "priority":"Major",
      "status":"Resolved",
      "text":"Move file component out of camel core There is some file cluster that uses some abstract cluster stuff which we need to move to camel-support"
    },
    {
      "key":"CAMEL-13108",
      "title":"Move dataset component out of camel-core",
      "description":"We should likely put mock, dataset and test components in the same JAR as dataset and test extends mock component. So its easier they are in the same JAR.\r\n\r\nAlso we already have camel-test for junit testing, so the test component would conflict with camel-test.\r\n\r\nSo if we call it camel-mock JAR then we have a free name to use.",
      "assignee":"davsclaus",
      "type":"Task",
      "priority":"Major",
      "status":"Resolved",
      "text":"Move dataset component out of camel-core We should likely put mock, dataset and test components in the same JAR as dataset and test extends mock component. So its easier they are in the same JAR.\r\n\r\nAlso we already have camel-test for junit testing, so the test component would conflict with camel-test.\r\n\r\nSo if we call it camel-mock JAR then we have a free name to use."
    },
    {
      "key":"CAMEL-13102",
      "title":"Move camel-dataformat out of camel-core",
      "description":"for dataformat component we need to move MarshalProcessor \/ UnmarshalProcessor to camel-support first to have it in a public api",
      "assignee":"davsclaus",
      "type":"Task",
      "priority":"Major",
      "status":"Resolved",
      "text":"Move camel-dataformat out of camel-core for dataformat component we need to move MarshalProcessor \/ UnmarshalProcessor to camel-support first to have it in a public api"
    },
    {
      "key":"CAMEL-13094",
      "title":"Context MBean not unregistered on startup failure",
      "description":"In Camel-2.23.x a failure to start the context would call ServiceSupport.doStop(). This is no longer the case. Instead, a CamelContextStartupFailureEvent is thrown and services that might previously have been started are never stopped.\r\n\r\nAs a result or (side effect) the context MBean may remain registered if the startup failure occurred after its initial registration. ",
      "assignee":"davsclaus",
      "type":"Bug",
      "priority":"Major",
      "status":"Resolved",
      "text":"Context MBean not unregistered on startup failure In Camel-2.23.x a failure to start the context would call ServiceSupport.doStop(). This is no longer the case. Instead, a CamelContextStartupFailureEvent is thrown and services that might previously have been started are never stopped.\r\n\r\nAs a result or (side effect) the context MBean may remain registered if the startup failure occurred after its initial registration. "
    },
    {
      "key":"CAMEL-13093",
      "title":"Output of route-profile is empty if there are same route-id for multiple camel-contexts.",
      "description":"* Unzip the attached reproducer.\r\n * Build it using 'mvn clean install'.\r\n * Deploy it in Fuse with command 'bundle:install -s mvn:com.mycompany\/camel-blueprint-cbr\/1.0.0-SNAPSHOT'.\r\n * If we execute route-profile command, we find that output is empty or no output.\r\n\r\nkaraf@root()> route-profile cbr-example-context1 1-route Profile Camel Context: cbr-example-context1 Id Count Last (ms) Delta (ms) Mean (ms) Min (ms) Max (ms) Total (ms) Self (ms) karaf@root()>",
      "assignee":"davsclaus",
      "type":"Bug",
      "priority":"Minor",
      "status":"Resolved",
      "text":"Output of route-profile is empty if there are same route-id for multiple camel-contexts. * Unzip the attached reproducer.\r\n * Build it using 'mvn clean install'.\r\n * Deploy it in Fuse with command 'bundle:install -s mvn:com.mycompany\/camel-blueprint-cbr\/1.0.0-SNAPSHOT'.\r\n * If we execute route-profile command, we find that output is empty or no output.\r\n\r\nkaraf@root()> route-profile cbr-example-context1 1-route Profile Camel Context: cbr-example-context1 Id Count Last (ms) Delta (ms) Mean (ms) Min (ms) Max (ms) Total (ms) Self (ms) karaf@root()>"
    },
    {
      "key":"CAMEL-13088",
      "title":"build system - Automate list of components in parent and apache-camel poms",
      "description":"We need to add manually all the camel JARs in the parent\/pom and apache-camel poms and the include file as well. \r\n\r\nAs we get more and more components and also -starter JARs we should automate this.",
      "assignee":"davsclaus",
      "type":"Task",
      "priority":"Major",
      "status":"Resolved",
      "text":"build system - Automate list of components in parent and apache-camel poms We need to add manually all the camel JARs in the parent\/pom and apache-camel poms and the include file as well. \r\n\r\nAs we get more and more components and also -starter JARs we should automate this."
    },
    {
      "key":"CAMEL-13083",
      "title":"Upgrade to latest Guava version for Swagger dependency",
      "description":"Guava up to ver 24.1 has a denial of service vulnerability.\r\n\r\nUpgrade the camel-swagger dependency on Guava to a newer version.\r\n\r\nWould\u00a0be nice if this could go in the 2.23.x version and above\u00a0",
      "assignee":"davsclaus",
      "type":"Improvement",
      "priority":"Minor",
      "status":"Resolved",
      "text":"Upgrade to latest Guava version for Swagger dependency Guava up to ver 24.1 has a denial of service vulnerability.\r\n\r\nUpgrade the camel-swagger dependency on Guava to a newer version.\r\n\r\nWould be nice if this could go in the 2.23.x version and above "
    },
    {
      "key":"CAMEL-13081",
      "title":"doc - pipes and filters should be pipeline-eip",
      "description":"The tooling report this as a missing EIP doc page.\r\n\r\nIt should just be renamed to pipeline-eip",
      "assignee":"davsclaus",
      "type":"Task",
      "priority":"Major",
      "status":"Resolved",
      "text":"doc - pipes and filters should be pipeline-eip The tooling report this as a missing EIP doc page.\r\n\r\nIt should just be renamed to pipeline-eip"
    },
    {
      "key":"CAMEL-13075",
      "title":"component docs - Generated description with simple language should include curly brackets",
      "description":"For example the idempotentKey at\r\nhttps:\/\/github.com\/apache\/camel\/blob\/master\/camel-core\/src\/main\/docs\/file-component.adoc\r\n\r\nShould include\r\n{code}\r\n${file:name}-...\r\n{code}\r\nWhere the curly brackets are missing.\r\n\r\n",
      "assignee":"davsclaus",
      "type":"Task",
      "priority":"Major",
      "status":"Resolved",
      "text":"component docs - Generated description with simple language should include curly brackets For example the idempotentKey at\r\nhttps:\/\/github.com\/apache\/camel\/blob\/master\/camel-core\/src\/main\/docs\/file-component.adoc\r\n\r\nShould include\r\n{code}\r\n${file:name}-...\r\n{code}\r\nWhere the curly brackets are missing.\r\n\r\n"
    },
    {
      "key":"CAMEL-13074",
      "title":"FileWatcherReloadStrategy - Use file component instead of JDK FileWatcher",
      "description":"The FileWatcherReloadStrategy keeps failing on various platforms and CI server.\r\n\r\nLets use Camel's file component instead (to eat our own dog food)",
      "assignee":"davsclaus",
      "type":"Improvement",
      "priority":"Major",
      "status":"Resolved",
      "text":"FileWatcherReloadStrategy - Use file component instead of JDK FileWatcher The FileWatcherReloadStrategy keeps failing on various platforms and CI server.\r\n\r\nLets use Camel's file component instead (to eat our own dog food)"
    },
    {
      "key":"CAMEL-13067",
      "title":"camel3 - build system - Component level metadata is missing",
      "description":"In 2.x we used to have component level metadata but in 3.x they are not there\r\n\r\nFor example testManagedCamelContextExplainComponentModel fails this test.\r\n",
      "assignee":"davsclaus",
      "type":"Task",
      "priority":"Major",
      "status":"Resolved",
      "text":"camel3 - build system - Component level metadata is missing In 2.x we used to have component level metadata but in 3.x they are not there\r\n\r\nFor example testManagedCamelContextExplainComponentModel fails this test.\r\n"
    },
    {
      "key":"CAMEL-13066",
      "title":"camel-hystrix - Do not fallback on HystrixBadRequestException",
      "description":"See SO\r\nhttps:\/\/stackoverflow.com\/questions\/54151657\/camel-hystrix-eip-ignoreexceptions-to-prevent-call-to-fallback\r\n\r\nAnd the javadoc at\r\nhttps:\/\/netflix.github.io\/Hystrix\/javadoc\/com\/netflix\/hystrix\/exception\/HystrixBadRequestException.html",
      "assignee":"davsclaus",
      "type":"Improvement",
      "priority":"Major",
      "status":"Resolved",
      "text":"camel-hystrix - Do not fallback on HystrixBadRequestException See SO\r\nhttps:\/\/stackoverflow.com\/questions\/54151657\/camel-hystrix-eip-ignoreexceptions-to-prevent-call-to-fallback\r\n\r\nAnd the javadoc at\r\nhttps:\/\/netflix.github.io\/Hystrix\/javadoc\/com\/netflix\/hystrix\/exception\/HystrixBadRequestException.html"
    },
    {
      "key":"CAMEL-13064",
      "title":"camel-zipfile and camel-tarfile - ZipIterator and TarIterator issue",
      "description":"There is a little problem with hasNext vs next contract so they dont behave correctly with the EIPs such as splitter with the 3.0 refactored code.\r\n",
      "assignee":"davsclaus",
      "type":"Task",
      "priority":"Major",
      "status":"Resolved",
      "text":"camel-zipfile and camel-tarfile - ZipIterator and TarIterator issue There is a little problem with hasNext vs next contract so they dont behave correctly with the EIPs such as splitter with the 3.0 refactored code.\r\n"
    },
    {
      "key":"CAMEL-13055",
      "title":"camel3 - build system - Reduce maven plugins not needed to run",
      "description":"We can look at reducing some of the maven goals that runs during building components to reduce the burden on maven and speedup the build a bit.\r\n\r\n- dont run enforcer plugin\r\n- dont run maven site plugin\r\n- only run osgi plugin on core and components\r\n- skip running integration tests if fastinstall profile enabled on some modules\r\n- ...\r\n",
      "assignee":"davsclaus",
      "type":"Task",
      "priority":"Major",
      "status":"Resolved",
      "text":"camel3 - build system - Reduce maven plugins not needed to run We can look at reducing some of the maven goals that runs during building components to reduce the burden on maven and speedup the build a bit.\r\n\r\n- dont run enforcer plugin\r\n- dont run maven site plugin\r\n- only run osgi plugin on core and components\r\n- skip running integration tests if fastinstall profile enabled on some modules\r\n- ...\r\n"
    },
    {
      "key":"CAMEL-13053",
      "title":"camel-restdsl-swagger-plugin - Skip running integration tests with -P fastinstall",
      "description":"When running\r\n\r\nmvn clean install -P fastinstall\r\n\r\nThen the integration tests are run in this module and they take 40+ sec to run. It would be nice to skip this so the build is quicker in fast install mode\r\n\r\n{code}\r\n[INFO] --- maven-invoker-plugin:3.1.0:integration-test (integration-test) @ camel-restdsl-swagger-plugin ---\r\n[INFO] Building: simple-dto\/pom.xml\r\n[INFO] run post-build script verify.groovy\r\n[INFO]           simple-dto\/pom.xml ............................... SUCCESS (22.3 s)\r\n[INFO] Building: simple-xml-dto\/pom.xml\r\n[INFO] run post-build script verify.groovy\r\n[INFO]           simple-xml-dto\/pom.xml ........................... SUCCESS (8.5 s)\r\n[INFO] Building: simple-xml\/pom.xml\r\n[INFO] run post-build script verify.groovy\r\n[INFO]           simple-xml\/pom.xml ............................... SUCCESS (4.8 s)\r\n[INFO] Building: simple\/pom.xml\r\n[INFO] run post-build script verify.groovy\r\n[INFO]           simple\/pom.xml ................................... SUCCESS (2.9 s)\r\n[INFO] Building: customized\/pom.xml\r\n[INFO] run post-build script verify.groovy\r\n[INFO]           customized\/pom.xml ............................... SUCCESS (3.3 s)\r\n[INFO]\r\n[INFO] --- maven-invoker-plugin:3.1.0:verify (integration-test) @ camel-restdsl-swagger-plugin ---\r\n[INFO] -------------------------------------------------\r\n[INFO] Build Summary:\r\n[INFO]   Passed: 5, Failed: 0, Errors: 0, Skipped: 0\r\n[INFO] -------------------------------------------------\r\n{code}",
      "assignee":"davsclaus",
      "type":"Task",
      "priority":"Minor",
      "status":"Resolved",
      "text":"camel-restdsl-swagger-plugin - Skip running integration tests with -P fastinstall When running\r\n\r\nmvn clean install -P fastinstall\r\n\r\nThen the integration tests are run in this module and they take 40+ sec to run. It would be nice to skip this so the build is quicker in fast install mode\r\n\r\n{code}\r\n[INFO] --- maven-invoker-plugin:3.1.0:integration-test (integration-test) @ camel-restdsl-swagger-plugin ---\r\n[INFO] Building: simple-dto\/pom.xml\r\n[INFO] run post-build script verify.groovy\r\n[INFO]           simple-dto\/pom.xml ............................... SUCCESS (22.3 s)\r\n[INFO] Building: simple-xml-dto\/pom.xml\r\n[INFO] run post-build script verify.groovy\r\n[INFO]           simple-xml-dto\/pom.xml ........................... SUCCESS (8.5 s)\r\n[INFO] Building: simple-xml\/pom.xml\r\n[INFO] run post-build script verify.groovy\r\n[INFO]           simple-xml\/pom.xml ............................... SUCCESS (4.8 s)\r\n[INFO] Building: simple\/pom.xml\r\n[INFO] run post-build script verify.groovy\r\n[INFO]           simple\/pom.xml ................................... SUCCESS (2.9 s)\r\n[INFO] Building: customized\/pom.xml\r\n[INFO] run post-build script verify.groovy\r\n[INFO]           customized\/pom.xml ............................... SUCCESS (3.3 s)\r\n[INFO]\r\n[INFO] --- maven-invoker-plugin:3.1.0:verify (integration-test) @ camel-restdsl-swagger-plugin ---\r\n[INFO] -------------------------------------------------\r\n[INFO] Build Summary:\r\n[INFO]   Passed: 5, Failed: 0, Errors: 0, Skipped: 0\r\n[INFO] -------------------------------------------------\r\n{code}"
    },
    {
      "key":"CAMEL-13051",
      "title":"camel3 - build system needs to generate component.properties",
      "description":"We now generate more of the meta files in the META-INF\/services folder. But the JARs from 2.x vs 3.0 is not exactly the same.\r\n\r\nThe component.properties dataformat.properties language.properties files is currently not being generated.\r\n\r\nSome of our tooling depends on that these files are there.\r\n\r\nFor example the camel-catalog is not correct, try to compare its 2.x JAR vs 3.0 JAR, and you can then find out much more what is wrong currently with the 3.0 branch.",
      "assignee":"davsclaus",
      "type":"Task",
      "priority":"Critical",
      "status":"Resolved",
      "text":"camel3 - build system needs to generate component.properties We now generate more of the meta files in the META-INF\/services folder. But the JARs from 2.x vs 3.0 is not exactly the same.\r\n\r\nThe component.properties dataformat.properties language.properties files is currently not being generated.\r\n\r\nSome of our tooling depends on that these files are there.\r\n\r\nFor example the camel-catalog is not correct, try to compare its 2.x JAR vs 3.0 JAR, and you can then find out much more what is wrong currently with the 3.0 branch."
    },
    {
      "key":"CAMEL-13042",
      "title":"camel-core - File producer should by default not allow writing files to directories outside its starting directory",
      "description":"For example\r\n{code:xml}\r\n<from uri=\"file:src\/test\/resources\/data?noop=true\"\/>\r\n<setHeader headerName=\"CamelFileName\">\r\n    <simple>..\/..\/${file:name}<\/simple>\r\n<\/setHeader>\r\n<to uri=\"file:target\/results\"\/>\r\n{code}\r\n\r\nCan write the file outside the target\/results folder. We should not allow this by default to be more security friendly. \r\n\r\nWe should add a new option (maybe name it jailStartingDirectory or allowWriteOutsideStartingDirectory) or some better name\r\n\r\n",
      "assignee":"davsclaus",
      "type":"Improvement",
      "priority":"Major",
      "status":"Resolved",
      "text":"camel-core - File producer should by default not allow writing files to directories outside its starting directory For example\r\n{code:xml}\r\n<from uri=\"file:src\/test\/resources\/data?noop=true\"\/>\r\n<setHeader headerName=\"CamelFileName\">\r\n    <simple>..\/..\/${file:name}<\/simple>\r\n<\/setHeader>\r\n<to uri=\"file:target\/results\"\/>\r\n{code}\r\n\r\nCan write the file outside the target\/results folder. We should not allow this by default to be more security friendly. \r\n\r\nWe should add a new option (maybe name it jailStartingDirectory or allowWriteOutsideStartingDirectory) or some better name\r\n\r\n"
    },
    {
      "key":"CAMEL-13036",
      "title":"Add the possibility to disable the invocation of ModelHelper.dumpModelAsXml() during testing",
      "description":"Add the possibility to disable the invocation of {{ModelHelper.dumpModelAsXml()}}. This is particularly disturbing for Camel contexts with a lot of route definitions as this uses a lot of processing time and the information is only used for log output.\r\n\r\nActual use in 2.x in {{RouteDefinition.java}}:\r\n{code:java|title=RouteDefinition.java}\r\nString beforeAsXml = ModelHelper.dumpModelAsXml(camelContext, this);\r\n...\r\nString afterAsXml = ModelHelper.dumpModelAsXml(camelContext, merged);\r\nlog.info(\"Adviced route before\/after as XML:\\n{}\\n{}\", beforeAsXml, afterAsXml);\r\n{code}\r\n\r\nIn 2.X this should be optimized in {{RouteDefinition.java}}, in 3.X in {{RouteReifier.java}}.\r\n\r\nPossible solution: Add {{log.isInfoEnabled{}}} guard.\r\n\r\n\u00a0",
      "assignee":"davsclaus",
      "type":"Improvement",
      "priority":"Minor",
      "status":"Resolved",
      "text":"Add the possibility to disable the invocation of ModelHelper.dumpModelAsXml() during testing Add the possibility to disable the invocation of {{ModelHelper.dumpModelAsXml()}}. This is particularly disturbing for Camel contexts with a lot of route definitions as this uses a lot of processing time and the information is only used for log output.\r\n\r\nActual use in 2.x in {{RouteDefinition.java}}:\r\n{code:java|title=RouteDefinition.java}\r\nString beforeAsXml = ModelHelper.dumpModelAsXml(camelContext, this);\r\n...\r\nString afterAsXml = ModelHelper.dumpModelAsXml(camelContext, merged);\r\nlog.info(\"Adviced route before\/after as XML:\\n{}\\n{}\", beforeAsXml, afterAsXml);\r\n{code}\r\n\r\nIn 2.X this should be optimized in {{RouteDefinition.java}}, in 3.X in {{RouteReifier.java}}.\r\n\r\nPossible solution: Add {{log.isInfoEnabled{}}} guard.\r\n\r\n "
    },
    {
      "key":"CAMEL-13031",
      "title":"camel-core - test failure: org.apache.camel.impl.FileWatcherReloadStrategyTest.",
      "description":"[INFO] Running org.apache.camel.impl.FileWatcherReloadStrategyTest\r\n[ERROR] Tests run: 7, Failures: 0, Errors: 6, Skipped: 0, Time elapsed: 123.022 s <<< FAILURE! - in org.apache.camel.impl.FileWatcherReloadStrategyTest\r\n[ERROR] testUpdateXmlRoute(org.apache.camel.impl.FileWatcherReloadStrategyTest) Time elapsed: 20.529 s <<< ERROR!\r\norg.awaitility.core.ConditionTimeoutException: Assertion condition defined as a lambda expression in org.apache.camel.impl.FileWatcherReloadStrategyTest expected:<1> but was:<0> within 20 seconds.\r\n at org.apache.camel.impl.FileWatcherReloadStrategyTest.testUpdateXmlRoute(FileWatcherReloadStrategyTest.java:166)\r\nCaused by: java.lang.AssertionError: expected:<1> but was:<0>\r\n at org.apache.camel.impl.FileWatcherReloadStrategyTest.lambda$testUpdateXmlRoute$1(FileWatcherReloadStrategyTest.java:166)\r\n\r\n[ERROR] testAddNewRoute(org.apache.camel.impl.FileWatcherReloadStrategyTest) Time elapsed: 20.058 s <<< ERROR!\r\norg.awaitility.core.ConditionTimeoutException: Assertion condition defined as a lambda expression in org.apache.camel.impl.FileWatcherReloadStrategyTest expected:<1> but was:<0> within 20 seconds.\r\n at org.apache.camel.impl.FileWatcherReloadStrategyTest.testAddNewRoute(FileWatcherReloadStrategyTest.java:71)\r\nCaused by: java.lang.AssertionError: expected:<1> but was:<0>\r\n at org.apache.camel.impl.FileWatcherReloadStrategyTest.lambda$testAddNewRoute$0(FileWatcherReloadStrategyTest.java:71)\r\n\r\n[ERROR] testUpdateXmlRoute(org.apache.camel.impl.FileWatcherReloadStrategyTest) Time elapsed: 20.078 s <<< ERROR!\r\norg.awaitility.core.ConditionTimeoutException: Assertion condition defined as a lambda expression in org.apache.camel.impl.FileWatcherReloadStrategyTest expected:<1> but was:<0> within 20 seconds.\r\n at org.apache.camel.impl.FileWatcherReloadStrategyTest.testUpdateXmlRoute(FileWatcherReloadStrategyTest.java:166)\r\nCaused by: java.lang.AssertionError: expected:<1> but was:<0>\r\n at org.apache.camel.impl.FileWatcherReloadStrategyTest.lambda$testUpdateXmlRoute$1(FileWatcherReloadStrategyTest.java:166)\r\n\r\n[ERROR] testAddNewRoute(org.apache.camel.impl.FileWatcherReloadStrategyTest) Time elapsed: 20.067 s <<< ERROR!\r\norg.awaitility.core.ConditionTimeoutException: Assertion condition defined as a lambda expression in org.apache.camel.impl.FileWatcherReloadStrategyTest expected:<1> but was:<0> within 20 seconds.\r\n at org.apache.camel.impl.FileWatcherReloadStrategyTest.testAddNewRoute(FileWatcherReloadStrategyTest.java:71)\r\nCaused by: java.lang.AssertionError: expected:<1> but was:<0>\r\n at org.apache.camel.impl.FileWatcherReloadStrategyTest.lambda$testAddNewRoute$0(FileWatcherReloadStrategyTest.java:71)\r\n\r\n[ERROR] testUpdateXmlRoute(org.apache.camel.impl.FileWatcherReloadStrategyTest) Time elapsed: 20.095 s <<< ERROR!\r\norg.awaitility.core.ConditionTimeoutException: Assertion condition defined as a lambda expression in org.apache.camel.impl.FileWatcherReloadStrategyTest expected:<1> but was:<0> within 20 seconds.\r\n at org.apache.camel.impl.FileWatcherReloadStrategyTest.testUpdateXmlRoute(FileWatcherReloadStrategyTest.java:166)\r\nCaused by: java.lang.AssertionError: expected:<1> but was:<0>\r\n at org.apache.camel.impl.FileWatcherReloadStrategyTest.lambda$testUpdateXmlRoute$1(FileWatcherReloadStrategyTest.java:166)\r\n\r\n[ERROR] testAddNewRoute(org.apache.camel.impl.FileWatcherReloadStrategyTest) Time elapsed: 20.026 s <<< ERROR!\r\norg.awaitility.core.ConditionTimeoutException: Assertion condition defined as a lambda expression in org.apache.camel.impl.FileWatcherReloadStrategyTest expected:<1> but was:<0> within 20 seconds.\r\n at org.apache.camel.impl.FileWatcherReloadStrategyTest.testAddNewRoute(FileWatcherReloadStrategyTest.java:71)\r\nCaused by: java.lang.AssertionError: expected:<1> but was:<0>\r\n at org.apache.camel.impl.FileWatcherReloadStrategyTest.lambda$testAddNewRoute$0(FileWatcherReloadStrategyTest.java:71)\r\n\r\n[INFO]\r\n[INFO] Results:\r\n[INFO]\r\n[ERROR] Errors:\r\n[ERROR] org.apache.camel.impl.FileWatcherReloadStrategyTest.testAddNewRoute(org.apache.camel.impl.FileWatcherReloadStrategyTest)\r\n[ERROR] Run 1: FileWatcherReloadStrategyTest.testAddNewRoute:71 \u00bb ConditionTimeout Assertion ...\r\n[ERROR] Run 2: FileWatcherReloadStrategyTest.testAddNewRoute:71 \u00bb ConditionTimeout Assertion ...\r\n[ERROR] Run 3: FileWatcherReloadStrategyTest.testAddNewRoute:71 \u00bb ConditionTimeout Assertion ...\r\n[INFO]\r\n[ERROR] org.apache.camel.impl.FileWatcherReloadStrategyTest.testUpdateXmlRoute(org.apache.camel.impl.FileWatcherReloadStrategyTest)\r\n[ERROR] Run 1: FileWatcherReloadStrategyTest.testUpdateXmlRoute:166 \u00bb ConditionTimeout Assert...\r\n[ERROR] Run 2: FileWatcherReloadStrategyTest.testUpdateXmlRoute:166 \u00bb ConditionTimeout Assert...\r\n[ERROR] Run 3: FileWatcherReloadStrategyTest.testUpdateXmlRoute:166 \u00bb ConditionTimeout Assert...\r\n[INFO]\r\n[INFO]\r\n[ERROR] Tests run: 3, Failures: 0, Errors: 2, Skipped: 0",
      "assignee":"davsclaus",
      "type":"Test",
      "priority":"Minor",
      "status":"Resolved",
      "text":"camel-core - test failure: org.apache.camel.impl.FileWatcherReloadStrategyTest. [INFO] Running org.apache.camel.impl.FileWatcherReloadStrategyTest\r\n[ERROR] Tests run: 7, Failures: 0, Errors: 6, Skipped: 0, Time elapsed: 123.022 s <<< FAILURE! - in org.apache.camel.impl.FileWatcherReloadStrategyTest\r\n[ERROR] testUpdateXmlRoute(org.apache.camel.impl.FileWatcherReloadStrategyTest) Time elapsed: 20.529 s <<< ERROR!\r\norg.awaitility.core.ConditionTimeoutException: Assertion condition defined as a lambda expression in org.apache.camel.impl.FileWatcherReloadStrategyTest expected:<1> but was:<0> within 20 seconds.\r\n at org.apache.camel.impl.FileWatcherReloadStrategyTest.testUpdateXmlRoute(FileWatcherReloadStrategyTest.java:166)\r\nCaused by: java.lang.AssertionError: expected:<1> but was:<0>\r\n at org.apache.camel.impl.FileWatcherReloadStrategyTest.lambda$testUpdateXmlRoute$1(FileWatcherReloadStrategyTest.java:166)\r\n\r\n[ERROR] testAddNewRoute(org.apache.camel.impl.FileWatcherReloadStrategyTest) Time elapsed: 20.058 s <<< ERROR!\r\norg.awaitility.core.ConditionTimeoutException: Assertion condition defined as a lambda expression in org.apache.camel.impl.FileWatcherReloadStrategyTest expected:<1> but was:<0> within 20 seconds.\r\n at org.apache.camel.impl.FileWatcherReloadStrategyTest.testAddNewRoute(FileWatcherReloadStrategyTest.java:71)\r\nCaused by: java.lang.AssertionError: expected:<1> but was:<0>\r\n at org.apache.camel.impl.FileWatcherReloadStrategyTest.lambda$testAddNewRoute$0(FileWatcherReloadStrategyTest.java:71)\r\n\r\n[ERROR] testUpdateXmlRoute(org.apache.camel.impl.FileWatcherReloadStrategyTest) Time elapsed: 20.078 s <<< ERROR!\r\norg.awaitility.core.ConditionTimeoutException: Assertion condition defined as a lambda expression in org.apache.camel.impl.FileWatcherReloadStrategyTest expected:<1> but was:<0> within 20 seconds.\r\n at org.apache.camel.impl.FileWatcherReloadStrategyTest.testUpdateXmlRoute(FileWatcherReloadStrategyTest.java:166)\r\nCaused by: java.lang.AssertionError: expected:<1> but was:<0>\r\n at org.apache.camel.impl.FileWatcherReloadStrategyTest.lambda$testUpdateXmlRoute$1(FileWatcherReloadStrategyTest.java:166)\r\n\r\n[ERROR] testAddNewRoute(org.apache.camel.impl.FileWatcherReloadStrategyTest) Time elapsed: 20.067 s <<< ERROR!\r\norg.awaitility.core.ConditionTimeoutException: Assertion condition defined as a lambda expression in org.apache.camel.impl.FileWatcherReloadStrategyTest expected:<1> but was:<0> within 20 seconds.\r\n at org.apache.camel.impl.FileWatcherReloadStrategyTest.testAddNewRoute(FileWatcherReloadStrategyTest.java:71)\r\nCaused by: java.lang.AssertionError: expected:<1> but was:<0>\r\n at org.apache.camel.impl.FileWatcherReloadStrategyTest.lambda$testAddNewRoute$0(FileWatcherReloadStrategyTest.java:71)\r\n\r\n[ERROR] testUpdateXmlRoute(org.apache.camel.impl.FileWatcherReloadStrategyTest) Time elapsed: 20.095 s <<< ERROR!\r\norg.awaitility.core.ConditionTimeoutException: Assertion condition defined as a lambda expression in org.apache.camel.impl.FileWatcherReloadStrategyTest expected:<1> but was:<0> within 20 seconds.\r\n at org.apache.camel.impl.FileWatcherReloadStrategyTest.testUpdateXmlRoute(FileWatcherReloadStrategyTest.java:166)\r\nCaused by: java.lang.AssertionError: expected:<1> but was:<0>\r\n at org.apache.camel.impl.FileWatcherReloadStrategyTest.lambda$testUpdateXmlRoute$1(FileWatcherReloadStrategyTest.java:166)\r\n\r\n[ERROR] testAddNewRoute(org.apache.camel.impl.FileWatcherReloadStrategyTest) Time elapsed: 20.026 s <<< ERROR!\r\norg.awaitility.core.ConditionTimeoutException: Assertion condition defined as a lambda expression in org.apache.camel.impl.FileWatcherReloadStrategyTest expected:<1> but was:<0> within 20 seconds.\r\n at org.apache.camel.impl.FileWatcherReloadStrategyTest.testAddNewRoute(FileWatcherReloadStrategyTest.java:71)\r\nCaused by: java.lang.AssertionError: expected:<1> but was:<0>\r\n at org.apache.camel.impl.FileWatcherReloadStrategyTest.lambda$testAddNewRoute$0(FileWatcherReloadStrategyTest.java:71)\r\n\r\n[INFO]\r\n[INFO] Results:\r\n[INFO]\r\n[ERROR] Errors:\r\n[ERROR] org.apache.camel.impl.FileWatcherReloadStrategyTest.testAddNewRoute(org.apache.camel.impl.FileWatcherReloadStrategyTest)\r\n[ERROR] Run 1: FileWatcherReloadStrategyTest.testAddNewRoute:71 >> ConditionTimeout Assertion ...\r\n[ERROR] Run 2: FileWatcherReloadStrategyTest.testAddNewRoute:71 >> ConditionTimeout Assertion ...\r\n[ERROR] Run 3: FileWatcherReloadStrategyTest.testAddNewRoute:71 >> ConditionTimeout Assertion ...\r\n[INFO]\r\n[ERROR] org.apache.camel.impl.FileWatcherReloadStrategyTest.testUpdateXmlRoute(org.apache.camel.impl.FileWatcherReloadStrategyTest)\r\n[ERROR] Run 1: FileWatcherReloadStrategyTest.testUpdateXmlRoute:166 >> ConditionTimeout Assert...\r\n[ERROR] Run 2: FileWatcherReloadStrategyTest.testUpdateXmlRoute:166 >> ConditionTimeout Assert...\r\n[ERROR] Run 3: FileWatcherReloadStrategyTest.testUpdateXmlRoute:166 >> ConditionTimeout Assert...\r\n[INFO]\r\n[INFO]\r\n[ERROR] Tests run: 3, Failures: 0, Errors: 2, Skipped: 0"
    },
    {
      "key":"CAMEL-13029",
      "title":"camel-swagger-java - Should default use scheme from rest-dsl configuration in swagger doc",
      "description":"Because http is default then we have not noticed before. But if you use https as the scheme in the rest-dsl for the rest service then the swagger doc generated is outputting http by default. We should use the scheme setting from the rest-dsl out of the box.\r\n\r\nYou can configure it explicit via\r\n\r\n\t\t\t\t.apiProperty(\"schemes\", \"https\")\r\n",
      "assignee":"davsclaus",
      "type":"Improvement",
      "priority":"Major",
      "status":"Resolved",
      "text":"camel-swagger-java - Should default use scheme from rest-dsl configuration in swagger doc Because http is default then we have not noticed before. But if you use https as the scheme in the rest-dsl for the rest service then the swagger doc generated is outputting http by default. We should use the scheme setting from the rest-dsl out of the box.\r\n\r\nYou can configure it explicit via\r\n\r\n\t\t\t\t.apiProperty(\"schemes\", \"https\")\r\n"
    },
    {
      "key":"CAMEL-13028",
      "title":"camel-undertow - When using SSL with rest-dsl and api-doc then you can get a port already bound exception",
      "description":"For example this route cannot startup\r\n{code}\r\n\tpublic void configure() throws Exception {\r\n\r\n\t\trestConfiguration().scheme(\"https\").component(\"undertow\").port(7777).contextPath(\"\/\").host(\"0.0.0.0\")\r\n            .apiContextPath(\"\/swagger.json\")\r\n\t\t\t\t.dataFormatProperty(\"prettyPrint\", \"true\")\r\n\r\n\t\t\t\t.apiProperty(\"api.schemes\", \"https\")\r\n\t\t\t\t.apiProperty(\"api.title\", \"Rest swagger\")\r\n\t\t\t\t.apiProperty(\"api.description\", \"Camel Rest App with Swagger\");\r\n\r\n\t\trest(\"\/user\").get().to(\"direct:start\");\r\n\r\n\t\tfrom(\"direct:start\").setBody().constant(\"Hi Camels\");\r\n\t}\r\n{code}\r\n\r\nWith a\r\n{code}\r\nCaused by: java.net.BindException: Address already in use\r\n        at sun.nio.ch.Net.bind0(Native Method) ~[na:1.8.0_181]\r\n        at sun.nio.ch.Net.bind(Net.java:433) ~[na:1.8.0_181]\r\n        at sun.nio.ch.Net.bind(Net.java:425) ~[na:1.8.0_181]\r\n        at sun.nio.ch.ServerSocketChannelImpl.bind(ServerSocketChannelImpl.java:223) ~[na:1.8.0_181]\r\n        at sun.nio.ch.ServerSocketAdaptor.bind(ServerSocketAdaptor.java:74) ~[na:1.8.0_181]\r\n...\r\n{code}",
      "assignee":"davsclaus",
      "type":"Bug",
      "priority":"Major",
      "status":"Resolved",
      "text":"camel-undertow - When using SSL with rest-dsl and api-doc then you can get a port already bound exception For example this route cannot startup\r\n{code}\r\n\tpublic void configure() throws Exception {\r\n\r\n\t\trestConfiguration().scheme(\"https\").component(\"undertow\").port(7777).contextPath(\"\/\").host(\"0.0.0.0\")\r\n            .apiContextPath(\"\/swagger.json\")\r\n\t\t\t\t.dataFormatProperty(\"prettyPrint\", \"true\")\r\n\r\n\t\t\t\t.apiProperty(\"api.schemes\", \"https\")\r\n\t\t\t\t.apiProperty(\"api.title\", \"Rest swagger\")\r\n\t\t\t\t.apiProperty(\"api.description\", \"Camel Rest App with Swagger\");\r\n\r\n\t\trest(\"\/user\").get().to(\"direct:start\");\r\n\r\n\t\tfrom(\"direct:start\").setBody().constant(\"Hi Camels\");\r\n\t}\r\n{code}\r\n\r\nWith a\r\n{code}\r\nCaused by: java.net.BindException: Address already in use\r\n        at sun.nio.ch.Net.bind0(Native Method) ~[na:1.8.0_181]\r\n        at sun.nio.ch.Net.bind(Net.java:433) ~[na:1.8.0_181]\r\n        at sun.nio.ch.Net.bind(Net.java:425) ~[na:1.8.0_181]\r\n        at sun.nio.ch.ServerSocketChannelImpl.bind(ServerSocketChannelImpl.java:223) ~[na:1.8.0_181]\r\n        at sun.nio.ch.ServerSocketAdaptor.bind(ServerSocketAdaptor.java:74) ~[na:1.8.0_181]\r\n...\r\n{code}"
    },
    {
      "key":"CAMEL-13025",
      "title":"camel-core - File read lock changed - If file gets deleted then break out loop",
      "description":"See SO\r\nhttps:\/\/stackoverflow.com\/questions\/53865940\/apache-camel-route-hangs-when-file-is-deleted-during-processing?noredirect=1#comment94587192_53865940\r\n\r\nSo if the target file gets deleted during the check interval and you have timeout = 0, then it will keep looping. So we should add a check if the file still exists in the looping.",
      "assignee":"davsclaus",
      "type":"Improvement",
      "priority":"Major",
      "status":"Resolved",
      "text":"camel-core - File read lock changed - If file gets deleted then break out loop See SO\r\nhttps:\/\/stackoverflow.com\/questions\/53865940\/apache-camel-route-hangs-when-file-is-deleted-during-processing?noredirect=1#comment94587192_53865940\r\n\r\nSo if the target file gets deleted during the check interval and you have timeout = 0, then it will keep looping. So we should add a check if the file still exists in the looping."
    },
    {
      "key":"CAMEL-13022",
      "title":"camel-restlet - sending PATCH operation should include body",
      "description":"We currently only include body for PUT and POST. But we should include the body for PATCH as well.",
      "assignee":"davsclaus",
      "type":"Bug",
      "priority":"Minor",
      "status":"Resolved",
      "text":"camel-restlet - sending PATCH operation should include body We currently only include body for PUT and POST. But we should include the body for PATCH as well."
    },
    {
      "key":"CAMEL-13021",
      "title":"Remove camel-example-swagger-xml",
      "description":"This example downloads from 3rd party repo - lets avoid this and we have 100 other examples already.\r\n",
      "assignee":"davsclaus",
      "type":"Task",
      "priority":"Minor",
      "status":"Resolved",
      "text":"Remove camel-example-swagger-xml This example downloads from 3rd party repo - lets avoid this and we have 100 other examples already.\r\n"
    },
    {
      "key":"CAMEL-13018",
      "title":"Swagger does not work if JMX is disabled",
      "description":"Swagger returns 402 No Content if jmx is disabled.\r\n\r\nHow to reproduce:\r\nAdd following code to main method of [Application|https:\/\/github.com\/apache\/camel\/blob\/master\/examples\/camel-example-spring-boot-rest-swagger\/src\/main\/java\/org\/apache\/camel\/example\/springboot\/Application.java] class\r\n\r\n{{System.setProperty(\"org.apache.camel.jmx.disabled\", \"true\");}}\r\n\r\n\u00a0",
      "assignee":"davsclaus",
      "type":"Improvement",
      "priority":"Minor",
      "status":"Resolved",
      "text":"Swagger does not work if JMX is disabled Swagger returns 402 No Content if jmx is disabled.\r\n\r\nHow to reproduce:\r\nAdd following code to main method of [Application|https:\/\/github.com\/apache\/camel\/blob\/master\/examples\/camel-example-spring-boot-rest-swagger\/src\/main\/java\/org\/apache\/camel\/example\/springboot\/Application.java] class\r\n\r\n{{System.setProperty(\"org.apache.camel.jmx.disabled\", \"true\");}}\r\n\r\n "
    },
    {
      "key":"CAMEL-13016",
      "title":"camel-jetty - If multiple bundles uses the same context-path (pathspec) then Jetty should fail",
      "description":"If you have 2 bundles that both uses the same context-path with a jetty consumer, then the last installed bundle will be routing the incoming requests, and the first installed will not be in use, and if you uninstall the 2nd bundle then the 1st bundle will still not be in use and jetty will return a 404.\r\n\r\nWe should detect that there is already another jetty consumer with the same context-path to be routing when creating a jetty connector listener and then fail if so.",
      "assignee":"davsclaus",
      "type":"Bug",
      "priority":"Major",
      "status":"Resolved",
      "text":"camel-jetty - If multiple bundles uses the same context-path (pathspec) then Jetty should fail If you have 2 bundles that both uses the same context-path with a jetty consumer, then the last installed bundle will be routing the incoming requests, and the first installed will not be in use, and if you uninstall the 2nd bundle then the 1st bundle will still not be in use and jetty will return a 404.\r\n\r\nWe should detect that there is already another jetty consumer with the same context-path to be routing when creating a jetty connector listener and then fail if so."
    },
    {
      "key":"CAMEL-13015",
      "title":"camel-spring-boot - load multiple route xml files ",
      "description":"When\u00a0\u00a0I use SpringDSL , i want to load two route files\u00a0\r\n\r\nFor Example\u00a0route1.xml and route2.xml\r\n\r\nIf I put two files in same directory like below , it is working\r\n\r\ncamel.springboot.xmlRoutes: file :directory\/*.xml\u00a0\r\n\r\n\u00a0\r\n\r\nIf I put two files into different directories , it does not work\r\n\r\ncamel.springboot.xmlRoutes: [file:directory1\/route1.xml|file:\/\/\/directory1\/route1.xml] , directory2\/route2.xml\r\n\r\nCould you please implement this feature?\r\n\r\nThanks",
      "assignee":"davsclaus",
      "type":"New Feature",
      "priority":"Minor",
      "status":"Resolved",
      "text":"camel-spring-boot - load multiple route xml files  When  I use SpringDSL , i want to load two route files \r\n\r\nFor Example route1.xml and route2.xml\r\n\r\nIf I put two files in same directory like below , it is working\r\n\r\ncamel.springboot.xmlRoutes: file :directory\/*.xml \r\n\r\n \r\n\r\nIf I put two files into different directories , it does not work\r\n\r\ncamel.springboot.xmlRoutes: [file:directory1\/route1.xml|file:\/\/\/directory1\/route1.xml] , directory2\/route2.xml\r\n\r\nCould you please implement this feature?\r\n\r\nThanks"
    },
    {
      "key":"CAMEL-13010",
      "title":"Deprecate camel-script",
      "description":"With the release of Java 11, Nashorn is deprecated, and will likely be removed from the JDK at a later time.[9] The GraalVM was suggested as a workaround.\r\n-> https:\/\/en.wikipedia.org\/wiki\/Nashorn_(JavaScript_engine)\r\n\r\nWe have already deprecated these other scripting languages like python, php etc (https:\/\/github.com\/apache\/camel\/blob\/master\/components\/readme.adoc#expression-languages).\r\n\r\nAnd groovy also dont recommend using camel-script by groovy directly, which you can do via camel-groovy\r\nhttp:\/\/docs.groovy-lang.org\/latest\/html\/documentation\/guide-integrating.html#jsr223",
      "assignee":"davsclaus",
      "type":"Task",
      "priority":"Major",
      "status":"Resolved",
      "text":"Deprecate camel-script With the release of Java 11, Nashorn is deprecated, and will likely be removed from the JDK at a later time.[9] The GraalVM was suggested as a workaround.\r\n-> https:\/\/en.wikipedia.org\/wiki\/Nashorn_(JavaScript_engine)\r\n\r\nWe have already deprecated these other scripting languages like python, php etc (https:\/\/github.com\/apache\/camel\/blob\/master\/components\/readme.adoc#expression-languages).\r\n\r\nAnd groovy also dont recommend using camel-script by groovy directly, which you can do via camel-groovy\r\nhttp:\/\/docs.groovy-lang.org\/latest\/html\/documentation\/guide-integrating.html#jsr223"
    },
    {
      "key":"CAMEL-13007",
      "title":"camel-properties : fall-back to env vars",
      "description":"The camel properties component at the moment fall-back to system properties but to improve cloud integration, it should also fall-back to environment variables",
      "assignee":"davsclaus",
      "type":"Improvement",
      "priority":"Minor",
      "status":"Resolved",
      "text":"camel-properties : fall-back to env vars The camel properties component at the moment fall-back to system properties but to improve cloud integration, it should also fall-back to environment variables"
    },
    {
      "key":"CAMEL-13001",
      "title":"Route coverage: specify coverage to fail on",
      "description":"currently, there is an option to fail the build if the coverage does not reach 100%.\r\n\r\nit would be nice to be able to specify the level of coverage wanted as a parameter of the maven plugin",
      "assignee":"davsclaus",
      "type":"Improvement",
      "priority":"Major",
      "status":"Resolved",
      "text":"Route coverage: specify coverage to fail on currently, there is an option to fail the build if the coverage does not reach 100%.\r\n\r\nit would be nice to be able to specify the level of coverage wanted as a parameter of the maven plugin"
    },
    {
      "key":"CAMEL-12994",
      "title":"xquery syntax problem in SpringDSL with spring-boot",
      "description":"this JAVADSL sytnax does not exist \/ supported in SpringDSL \r\nsetHeader(\"myHeader\").xquery(\"resource:classpath:myxquery.txt\", String.class)\r\n\r\n\r\nIt will cause the problem if return type is String instead of DomReulst or xmlString for xquery, when we use SpringDSL instead of JAVADSL\r\n\r\n\u00a0we tried all version >= 2.22, same problem\u00a0",
      "assignee":"davsclaus",
      "type":"Bug",
      "priority":"Minor",
      "status":"Resolved",
      "text":"xquery syntax problem in SpringDSL with spring-boot this JAVADSL sytnax does not exist \/ supported in SpringDSL \r\nsetHeader(\"myHeader\").xquery(\"resource:classpath:myxquery.txt\", String.class)\r\n\r\n\r\nIt will cause the problem if return type is String instead of DomReulst or xmlString for xquery, when we use SpringDSL instead of JAVADSL\r\n\r\n we tried all version >= 2.22, same problem "
    },
    {
      "key":"CAMEL-12991",
      "title":"SftpEndpoint does not allow to use custom process strategy",
      "description":"SftpEndpoint always create generic file strategy even processStrategy object is set in endpoint, same code is used in FtpEndpoint so it's not working also\r\n{code:java}\r\n@Override\r\nprotected RemoteFileConsumer<SftpRemoteFile> buildConsumer(Processor processor) {\r\n    return new SftpConsumer(this, processor, createRemoteFileOperations(), createGenericFileStrategy());\r\n}{code}\r\nit is working in FileEnpoint\r\n{code:java}\r\nprotected FileConsumer newFileConsumer(Processor processor, GenericFileOperations<File> operations) {\r\n    return new FileConsumer(this, processor, operations, processStrategy != null ? processStrategy : createGenericFileStrategy());\r\n}{code}",
      "assignee":"davsclaus",
      "type":"Bug",
      "priority":"Minor",
      "status":"Resolved",
      "text":"SftpEndpoint does not allow to use custom process strategy SftpEndpoint always create generic file strategy even processStrategy object is set in endpoint, same code is used in FtpEndpoint so it's not working also\r\n{code:java}\r\n@Override\r\nprotected RemoteFileConsumer<SftpRemoteFile> buildConsumer(Processor processor) {\r\n    return new SftpConsumer(this, processor, createRemoteFileOperations(), createGenericFileStrategy());\r\n}{code}\r\nit is working in FileEnpoint\r\n{code:java}\r\nprotected FileConsumer newFileConsumer(Processor processor, GenericFileOperations<File> operations) {\r\n    return new FileConsumer(this, processor, operations, processStrategy != null ? processStrategy : createGenericFileStrategy());\r\n}{code}"
    },
    {
      "key":"CAMEL-12990",
      "title":"FTP endpoint with 'localWorkDirectory' considers File Consumer's 'noop' option",
      "description":"[https:\/\/camel.apache.org\/ftp2.html] reads:\r\n{quote}See [File|https:\/\/camel.apache.org\/file2.html] for more options as all the options from [File|https:\/\/camel.apache.org\/file2.html] is inherited.\r\n{quote}\r\n\u00a0and in *Using Local Work Directory*:\r\n{quote}And finally, when the Exchange is complete the local file is deleted.\r\n{quote}\r\n\u00a0[https:\/\/camel.apache.org\/file2.html] reads:\r\n{quote}\r\n|{{noop}}|{{false}}|If *{{true}}*, the file is not moved or deleted in any way.|\r\n{quote}\r\nI have a use case where I'd need the file transferred to \\{{localWorkDirectory}} to stay there. Otherwise I have to change \\{{localWorkDirectory}} to something else and add a Producer endpoint to my route which copies the file to the intended directory (i.e. the former \\{{localWorkDirectory}}), which is inconvenient with GiB-size files.",
      "assignee":"davsclaus",
      "type":"New Feature",
      "priority":"Minor",
      "status":"Resolved",
      "text":"FTP endpoint with 'localWorkDirectory' considers File Consumer's 'noop' option [https:\/\/camel.apache.org\/ftp2.html] reads:\r\n{quote}See [File|https:\/\/camel.apache.org\/file2.html] for more options as all the options from [File|https:\/\/camel.apache.org\/file2.html] is inherited.\r\n{quote}\r\n and in *Using Local Work Directory*:\r\n{quote}And finally, when the Exchange is complete the local file is deleted.\r\n{quote}\r\n [https:\/\/camel.apache.org\/file2.html] reads:\r\n{quote}\r\n|{{noop}}|{{false}}|If *{{true}}*, the file is not moved or deleted in any way.|\r\n{quote}\r\nI have a use case where I'd need the file transferred to \\{{localWorkDirectory}} to stay there. Otherwise I have to change \\{{localWorkDirectory}} to something else and add a Producer endpoint to my route which copies the file to the intended directory (i.e. the former \\{{localWorkDirectory}}), which is inconvenient with GiB-size files."
    },
    {
      "key":"CAMEL-12989",
      "title":"Allow Endpoint to set the key that ProducerCache uses",
      "description":"ProducerCache is heavily tied to Endpoint URIs. Using the Endpoint URI as the key to the cache does not allow for the creation of Endpoints with the same URI but different configurations. For example, using a RecipientList to call the same SOAP endpoint but with different SSL certificates isn't currently possible. As the URI is always the same.the ProducerCache will always\u00a0use the first Endpoint it added to the map even if multiple Endpoints are added to the CamelContext with different keys.\r\n\r\nAdding getProducerCacheKey & setProducerCacheKey methods to the Endpoint interface would allow for setting the key programmatically. ProducerCache.doGetProducer would use the\u00a0getProducerCacheKey method instead of getEndpointUri.\r\n\r\nDefaultEndpoint would have a new member variable producerCacheKey and could implement the getter such that if the producerCacheKey member was not set it would return getEndpointUri()",
      "assignee":"davsclaus",
      "type":"Improvement",
      "priority":"Minor",
      "status":"Resolved",
      "text":"Allow Endpoint to set the key that ProducerCache uses ProducerCache is heavily tied to Endpoint URIs. Using the Endpoint URI as the key to the cache does not allow for the creation of Endpoints with the same URI but different configurations. For example, using a RecipientList to call the same SOAP endpoint but with different SSL certificates isn't currently possible. As the URI is always the same.the ProducerCache will always use the first Endpoint it added to the map even if multiple Endpoints are added to the CamelContext with different keys.\r\n\r\nAdding getProducerCacheKey & setProducerCacheKey methods to the Endpoint interface would allow for setting the key programmatically. ProducerCache.doGetProducer would use the getProducerCacheKey method instead of getEndpointUri.\r\n\r\nDefaultEndpoint would have a new member variable producerCacheKey and could implement the getter such that if the producerCacheKey member was not set it would return getEndpointUri()"
    },
    {
      "key":"CAMEL-12987",
      "title":"camel-core-osgi: OsgiServiceRegistry.onContextStop never gets called.",
      "description":"There is also a second problem with how the registry is being managed within the OsgiDefaultCamelContext.\u00a0 OsgiServiceRegistry is currently extends LifecycleStrategySupport which is suppose to unload the serviceReferenceQueue onContextStop.\u00a0 However the registry is never getting added to the CamelContext to manage the Lifecycle because the overridden createRegistry method in OsgiDefaultCamelContext is not being called.\u00a0 This is because the registry is being set in the constructor of OsgiDefaultCamelContext with\r\n{code:java}\r\nsuper(registry);{code}\r\nthis calls the DefaultCamelContext implementation of createRegistry which does not add the registry to lifecyclemanagement since\r\n{code:java}\r\nOsgiCamelContextHelper.wrapRegistry(this, registry, bundleContext);{code}\r\nis never called.\u00a0\r\n\r\nSee CAMEL-12969 for screen captures.\r\n\r\n\u00a0",
      "assignee":"davsclaus",
      "type":"Bug",
      "priority":"Major",
      "status":"Resolved",
      "text":"camel-core-osgi: OsgiServiceRegistry.onContextStop never gets called. There is also a second problem with how the registry is being managed within the OsgiDefaultCamelContext.  OsgiServiceRegistry is currently extends LifecycleStrategySupport which is suppose to unload the serviceReferenceQueue onContextStop.  However the registry is never getting added to the CamelContext to manage the Lifecycle because the overridden createRegistry method in OsgiDefaultCamelContext is not being called.  This is because the registry is being set in the constructor of OsgiDefaultCamelContext with\r\n{code:java}\r\nsuper(registry);{code}\r\nthis calls the DefaultCamelContext implementation of createRegistry which does not add the registry to lifecyclemanagement since\r\n{code:java}\r\nOsgiCamelContextHelper.wrapRegistry(this, registry, bundleContext);{code}\r\nis never called. \r\n\r\nSee CAMEL-12969 for screen captures.\r\n\r\n "
    },
    {
      "key":"CAMEL-12981",
      "title":"camel-catalog: provide information about active\/passive endpoints",
      "description":"In Camel K we need to distinguish active from passive endpoints in order to determine when a integration can be scaled down to 0.\r\n\r\n\u00a0\r\n\r\nE.g.\r\n * a \"timer\" (start) endpoint is\u00a0*active*, because it needs to have a JVM always running and do something at each interval\r\n * a \"jms\" (start) endpoint is *active* because it needs to establish a connection to the broker and keep it alive\r\n * a \"direct\" or \"seda\" endpoint is *passive*, because they\u00a0do something when they receive an exchange\u00a0from another route\r\n * a \"undertow\" (start)\u00a0endpoint is *passive*, because it does nothing until somebody\u00a0calls it from an +external+\u00a0service (http based endpoints can all be considered passive in Knative+CamelK)\r\n\r\n\u00a0\r\n\r\nWe should add this information to the catalog. Now I've embedded it in Camel K.",
      "assignee":"davsclaus",
      "type":"Task",
      "priority":"Major",
      "status":"Open",
      "text":"camel-catalog: provide information about active\/passive endpoints In Camel K we need to distinguish active from passive endpoints in order to determine when a integration can be scaled down to 0.\r\n\r\n \r\n\r\nE.g.\r\n * a \"timer\" (start) endpoint is *active*, because it needs to have a JVM always running and do something at each interval\r\n * a \"jms\" (start) endpoint is *active* because it needs to establish a connection to the broker and keep it alive\r\n * a \"direct\" or \"seda\" endpoint is *passive*, because they do something when they receive an exchange from another route\r\n * a \"undertow\" (start) endpoint is *passive*, because it does nothing until somebody calls it from an +external+ service (http based endpoints can all be considered passive in Knative+CamelK)\r\n\r\n \r\n\r\nWe should add this information to the catalog. Now I've embedded it in Camel K."
    },
    {
      "key":"CAMEL-12974",
      "title":"Route coverage: When and otherwise are not marked as covered",
      "description":"- use a route with a choice with when and otherwise inside.\r\n- launch mvn test camel:route-coverage\r\n- when and otherwise are marked with a 0 count even if they were used\r\n\r\nexamples of the CBR examples available in Eclipse Fuse Tooling:\r\n{noformat}Route:\tcbr-route\r\n\r\n  Line #      Count   Route\r\n  ------      -----   -----\r\n      33          5   from\r\n      34          5     log\r\n      35          5     choice\r\n      36          0       when\r\n      38          2         log\r\n      39          2         to\r\n      41          0       when\r\n      43          2         log\r\n      44          2         to\r\n      46          0       otherwise\r\n      47          1         log\r\n      48          1         to\r\n      51          5     log\r\n\r\nCoverage: 10 out of 13 (76.9%){noformat}\r\n\r\nwe can notice that elements inside when and otherwise are well counted but when and otherwise are at 0",
      "assignee":"davsclaus",
      "type":"Bug",
      "priority":"Minor",
      "status":"Resolved",
      "text":"Route coverage: When and otherwise are not marked as covered - use a route with a choice with when and otherwise inside.\r\n- launch mvn test camel:route-coverage\r\n- when and otherwise are marked with a 0 count even if they were used\r\n\r\nexamples of the CBR examples available in Eclipse Fuse Tooling:\r\n{noformat}Route:\tcbr-route\r\n\r\n  Line #      Count   Route\r\n  ------      -----   -----\r\n      33          5   from\r\n      34          5     log\r\n      35          5     choice\r\n      36          0       when\r\n      38          2         log\r\n      39          2         to\r\n      41          0       when\r\n      43          2         log\r\n      44          2         to\r\n      46          0       otherwise\r\n      47          1         log\r\n      48          1         to\r\n      51          5     log\r\n\r\nCoverage: 10 out of 13 (76.9%){noformat}\r\n\r\nwe can notice that elements inside when and otherwise are well counted but when and otherwise are at 0"
    },
    {
      "key":"CAMEL-12970",
      "title":"Camel Maven Plugin: false postives with directOrSedaPairCheck",
      "description":"In one of my RouteBuilders I instantiate and include some routes with {{RouteBuilder::includeRoutes}}. When I run {{mvn camel:validate}}, these routes generate the \"Sending to non existing direct queue name\" error. The routes work though.\r\n\r\nHere is the Route. I can make a smaller example, but I won't if I don't need to.\r\n{code:java|title=HealthRoute.java}\r\nimport java.sql.Connection;\r\nimport java.sql.SQLException;\r\nimport java.util.HashMap;\r\nimport javax.sql.DataSource;\r\nimport org.apache.camel.BeanInject;\r\nimport org.apache.camel.Exchange;\r\nimport org.apache.camel.Processor;\r\nimport org.apache.camel.builder.RouteBuilder;\r\nimport org.apache.camel.json.simple.JsonObject;\r\nimport org.slf4j.Logger;\r\nimport org.slf4j.LoggerFactory;\r\n\r\n\/**\r\n * An HTTP service that validates some application configuration properties. The\r\n * validation status is returned as simply \"true\" or \"false\" with error messages\r\n * printed to the log.\r\n *\/\r\npublic class HealthRoute extends RouteBuilder {\r\n\r\n    private static final String ROUTE_CHECK_SUBMIT_ASSESSMENTS_ENDPOINT = \"checkSubmitAssessmentsEndpoint\";\r\n    private static final String ROUTE_CHECK_QUERY_ENDPOINT = \"checkQueryEndpoint\";\r\n    private static final String DATABASE_REACHABLE = \"isDatabaseReachable\";\r\n\r\n    @BeanInject(value = \"dataSource\")\r\n    private DataSource dataSource;\r\n\r\n    private static final Logger LOGGER = LoggerFactory.getLogger(HealthRoute1.class);\r\n\r\n    @Override\r\n    public void configure() throws Exception {\r\n\r\n        from(\"servlet:smoketest?servletName=HealthServlet\")\r\n                .to(\"direct:\" + ROUTE_CHECK_QUERY_ENDPOINT)\r\n                .to(\"direct:\" + ROUTE_CHECK_SUBMIT_ASSESSMENTS_ENDPOINT)\r\n                .process(new CheckDatabaseConnection())\r\n                .process(exchange -> {\r\n                    HashMap<String, Object> hashMap = new HashMap<>();\r\n                    hashMap.put(\"isQueryEndpointReachable\", exchange.getProperty(ROUTE_CHECK_QUERY_ENDPOINT));\r\n                    hashMap.put(\"isSubmitAssessmentsEndpointReachable\", exchange.getProperty(ROUTE_CHECK_SUBMIT_ASSESSMENTS_ENDPOINT));\r\n                    hashMap.put(DATABASE_REACHABLE, exchange.getProperty(DATABASE_REACHABLE));\r\n                    exchange.getIn().setBody(new JsonObject(hashMap).toJson());\r\n                })\r\n                .setHeader(\"Content-Type\", constant(\"application\/json\"));\r\n\r\n        String queryHumanSubjectsUri = getContext().resolvePropertyPlaceholders(\"{{queryHumanSubjectsUri}}\").replaceAll(\"https?:\/\/\", \"\");\r\n        String submitExternalAssessmentsUri = getContext().resolvePropertyPlaceholders(\"{{submitExternalAssessmentsUri}}\").replaceAll(\"https?:\/\/\", \"\");\r\n        includeRoutes(new CheckEndpointRoute(ROUTE_CHECK_QUERY_ENDPOINT, queryHumanSubjectsUri));\r\n        includeRoutes(new CheckEndpointRoute(ROUTE_CHECK_SUBMIT_ASSESSMENTS_ENDPOINT, submitExternalAssessmentsUri));\r\n    }\r\n\r\n    \/**\r\n     * Smoke tests the availability of a given HTTP resource by issuing a GET\r\n     * request. If the request throws an exception an error flag is set on the\r\n     * Exchange.\r\n     *\/\r\n    private static class CheckEndpointRoute extends RouteBuilder {\r\n\r\n        private final String routeId;\r\n        private final String uri;\r\n\r\n        public CheckEndpointRoute(String routeId, String uri) {\r\n            this.routeId = routeId;\r\n            this.uri = uri;\r\n        }\r\n\r\n        @Override\r\n        public void configure() throws Exception {\r\n            from(\"direct:\" + routeId)\r\n                    .doTry()\r\n                    .to(\"https4:\"\r\n                            + uri\r\n                            + \"?sslContextParameters=#sslParameters\"\r\n                            + \"&bridgeEndpoint=true\"\r\n                            + \"&x509HostnameVerifier=#hostnameVerifier\")\r\n                    .setProperty(routeId, constant(true))\r\n                    .doCatch(Exception.class)\r\n                    .to(\"log:com.cgi.best.HealthRoute?level=ERROR&showCaughtException=true\")\r\n                    .setProperty(routeId, constant(false))\r\n                    .end();\r\n        }\r\n    }\r\n\r\n    \/**\r\n     * Smoke tests the availability of the database by executing a standard\r\n     * database health query.\r\n     *\/\r\n    private class CheckDatabaseConnection implements Processor {\r\n\r\n        @Override\r\n        public void process(Exchange exchange) throws Exception {\r\n            try (Connection connection = dataSource.getConnection()) {\r\n                connection.createStatement().execute(\"select * from dual\");\r\n                exchange.setProperty(DATABASE_REACHABLE, true);\r\n            } catch (SQLException ex) {\r\n                LOGGER.error(\"Database test query failed.\", ex);\r\n                exchange.setProperty(DATABASE_REACHABLE, false);\r\n            }\r\n        }\r\n    }\r\n}\r\n{code}\r\n{code}\r\n$ mvn camel:validate\r\n[INFO] Scanning for projects...\r\n[INFO]\r\n[INFO] ------------------------------------------------------------------------\r\n[INFO] Building BestAdapter 1.0-SNAPSHOT\r\n[INFO] ------------------------------------------------------------------------\r\n[INFO]\r\n[INFO] --- camel-maven-plugin:2.23.0:validate (default-cli) @ BestAdapter ---\r\n[INFO] Detected Camel version used in project: 2.23.0\r\n[INFO] Validating using Camel version: 2.23.0\r\n[INFO] Endpoint validation success: (16 = passed, 0 = invalid, 2 = incapable, 0 = unknown components, 0 = deprecated options)\r\n[INFO] Simple validation success: (3 = passed, 0 = invalid)\r\n[WARNING] Endpoint pair (seda\/direct) validation error at: com.cgi.best.HealthRoute.configure(HealthRoute.java:45)\r\n\r\n        direct:checkQueryEndpoint\r\n\r\n                                checkQueryEndpoint      Sending to non existing direct queue name\r\n\r\n\r\n[WARNING] Endpoint pair (seda\/direct) validation error at: com.cgi.best.HealthRoute.configure(HealthRoute.java:45)\r\n\r\n        direct:checkSubmitAssessmentsEndpoint\r\n\r\n                                checkSubmitAssessmentsEndpoint  Sending to non existing direct queue name\r\n\r\n\r\n[WARNING] Endpoint pair (seda\/direct) validation error at: com.cgi.best.HealthRoute1.configure(HealthRoute1.java:45)\r\n\r\n        direct:checkQueryEndpoint\r\n\r\n                                checkQueryEndpoint      Sending to non existing direct queue name\r\n\r\n\r\n[WARNING] Endpoint pair (seda\/direct) validation error at: com.cgi.best.HealthRoute1.configure(HealthRoute1.java:45)\r\n\r\n        direct:checkSubmitAssessmentsEndpoint\r\n\r\n                                checkSubmitAssessmentsEndpoint  Sending to non existing direct queue name\r\n\r\n\r\n[WARNING] Endpoint pair (seda\/direct) validation error: (2 = pairs, 4 = non-pairs)\r\n[INFO] Duplicate route id validation success (3 = ids)\r\n[INFO] ------------------------------------------------------------------------\r\n[INFO] BUILD FAILURE\r\n[INFO] ------------------------------------------------------------------------\r\n[INFO] Total time: 3.030 s\r\n[INFO] Finished at: 2018-11-30T08:55:31-08:00\r\n[INFO] Final Memory: 21M\/398M\r\n[INFO] ------------------------------------------------------------------------\r\n[ERROR] Failed to execute goal org.apache.camel:camel-maven-plugin:2.23.0:validate (default-cli) on project BestAdapter: Endpoint validation success: (16 = passed, 0 = invalid, 2 = incapable, 0 = unknown components, 0 = deprecated options)\r\n[ERROR] Simple validation success: (3 = passed, 0 = invalid)\r\n[ERROR] Duplicate route id validation success (3 = ids)\r\n[ERROR] Endpoint pair (seda\/direct) validation error: (2 = pairs, 4 = non-pairs)\r\n[ERROR] -> [Help 1]\r\n[ERROR]\r\n[ERROR] To see the full stack trace of the errors, re-run Maven with the -e switch.\r\n[ERROR] Re-run Maven using the -X switch to enable full debug logging.\r\n[ERROR]\r\n[ERROR] For more information about the errors and possible solutions, please read the following articles:\r\n[ERROR] [Help 1] http:\/\/cwiki.apache.org\/confluence\/display\/MAVEN\/MojoExecutionException\r\n{code}",
      "assignee":"davsclaus",
      "type":"Bug",
      "priority":"Minor",
      "status":"Resolved",
      "text":"Camel Maven Plugin: false postives with directOrSedaPairCheck In one of my RouteBuilders I instantiate and include some routes with {{RouteBuilder::includeRoutes}}. When I run {{mvn camel:validate}}, these routes generate the \"Sending to non existing direct queue name\" error. The routes work though.\r\n\r\nHere is the Route. I can make a smaller example, but I won't if I don't need to.\r\n{code:java|title=HealthRoute.java}\r\nimport java.sql.Connection;\r\nimport java.sql.SQLException;\r\nimport java.util.HashMap;\r\nimport javax.sql.DataSource;\r\nimport org.apache.camel.BeanInject;\r\nimport org.apache.camel.Exchange;\r\nimport org.apache.camel.Processor;\r\nimport org.apache.camel.builder.RouteBuilder;\r\nimport org.apache.camel.json.simple.JsonObject;\r\nimport org.slf4j.Logger;\r\nimport org.slf4j.LoggerFactory;\r\n\r\n\/**\r\n * An HTTP service that validates some application configuration properties. The\r\n * validation status is returned as simply \"true\" or \"false\" with error messages\r\n * printed to the log.\r\n *\/\r\npublic class HealthRoute extends RouteBuilder {\r\n\r\n    private static final String ROUTE_CHECK_SUBMIT_ASSESSMENTS_ENDPOINT = \"checkSubmitAssessmentsEndpoint\";\r\n    private static final String ROUTE_CHECK_QUERY_ENDPOINT = \"checkQueryEndpoint\";\r\n    private static final String DATABASE_REACHABLE = \"isDatabaseReachable\";\r\n\r\n    @BeanInject(value = \"dataSource\")\r\n    private DataSource dataSource;\r\n\r\n    private static final Logger LOGGER = LoggerFactory.getLogger(HealthRoute1.class);\r\n\r\n    @Override\r\n    public void configure() throws Exception {\r\n\r\n        from(\"servlet:smoketest?servletName=HealthServlet\")\r\n                .to(\"direct:\" + ROUTE_CHECK_QUERY_ENDPOINT)\r\n                .to(\"direct:\" + ROUTE_CHECK_SUBMIT_ASSESSMENTS_ENDPOINT)\r\n                .process(new CheckDatabaseConnection())\r\n                .process(exchange -> {\r\n                    HashMap<String, Object> hashMap = new HashMap<>();\r\n                    hashMap.put(\"isQueryEndpointReachable\", exchange.getProperty(ROUTE_CHECK_QUERY_ENDPOINT));\r\n                    hashMap.put(\"isSubmitAssessmentsEndpointReachable\", exchange.getProperty(ROUTE_CHECK_SUBMIT_ASSESSMENTS_ENDPOINT));\r\n                    hashMap.put(DATABASE_REACHABLE, exchange.getProperty(DATABASE_REACHABLE));\r\n                    exchange.getIn().setBody(new JsonObject(hashMap).toJson());\r\n                })\r\n                .setHeader(\"Content-Type\", constant(\"application\/json\"));\r\n\r\n        String queryHumanSubjectsUri = getContext().resolvePropertyPlaceholders(\"{{queryHumanSubjectsUri}}\").replaceAll(\"https?:\/\/\", \"\");\r\n        String submitExternalAssessmentsUri = getContext().resolvePropertyPlaceholders(\"{{submitExternalAssessmentsUri}}\").replaceAll(\"https?:\/\/\", \"\");\r\n        includeRoutes(new CheckEndpointRoute(ROUTE_CHECK_QUERY_ENDPOINT, queryHumanSubjectsUri));\r\n        includeRoutes(new CheckEndpointRoute(ROUTE_CHECK_SUBMIT_ASSESSMENTS_ENDPOINT, submitExternalAssessmentsUri));\r\n    }\r\n\r\n    \/**\r\n     * Smoke tests the availability of a given HTTP resource by issuing a GET\r\n     * request. If the request throws an exception an error flag is set on the\r\n     * Exchange.\r\n     *\/\r\n    private static class CheckEndpointRoute extends RouteBuilder {\r\n\r\n        private final String routeId;\r\n        private final String uri;\r\n\r\n        public CheckEndpointRoute(String routeId, String uri) {\r\n            this.routeId = routeId;\r\n            this.uri = uri;\r\n        }\r\n\r\n        @Override\r\n        public void configure() throws Exception {\r\n            from(\"direct:\" + routeId)\r\n                    .doTry()\r\n                    .to(\"https4:\"\r\n                            + uri\r\n                            + \"?sslContextParameters=#sslParameters\"\r\n                            + \"&bridgeEndpoint=true\"\r\n                            + \"&x509HostnameVerifier=#hostnameVerifier\")\r\n                    .setProperty(routeId, constant(true))\r\n                    .doCatch(Exception.class)\r\n                    .to(\"log:com.cgi.best.HealthRoute?level=ERROR&showCaughtException=true\")\r\n                    .setProperty(routeId, constant(false))\r\n                    .end();\r\n        }\r\n    }\r\n\r\n    \/**\r\n     * Smoke tests the availability of the database by executing a standard\r\n     * database health query.\r\n     *\/\r\n    private class CheckDatabaseConnection implements Processor {\r\n\r\n        @Override\r\n        public void process(Exchange exchange) throws Exception {\r\n            try (Connection connection = dataSource.getConnection()) {\r\n                connection.createStatement().execute(\"select * from dual\");\r\n                exchange.setProperty(DATABASE_REACHABLE, true);\r\n            } catch (SQLException ex) {\r\n                LOGGER.error(\"Database test query failed.\", ex);\r\n                exchange.setProperty(DATABASE_REACHABLE, false);\r\n            }\r\n        }\r\n    }\r\n}\r\n{code}\r\n{code}\r\n$ mvn camel:validate\r\n[INFO] Scanning for projects...\r\n[INFO]\r\n[INFO] ------------------------------------------------------------------------\r\n[INFO] Building BestAdapter 1.0-SNAPSHOT\r\n[INFO] ------------------------------------------------------------------------\r\n[INFO]\r\n[INFO] --- camel-maven-plugin:2.23.0:validate (default-cli) @ BestAdapter ---\r\n[INFO] Detected Camel version used in project: 2.23.0\r\n[INFO] Validating using Camel version: 2.23.0\r\n[INFO] Endpoint validation success: (16 = passed, 0 = invalid, 2 = incapable, 0 = unknown components, 0 = deprecated options)\r\n[INFO] Simple validation success: (3 = passed, 0 = invalid)\r\n[WARNING] Endpoint pair (seda\/direct) validation error at: com.cgi.best.HealthRoute.configure(HealthRoute.java:45)\r\n\r\n        direct:checkQueryEndpoint\r\n\r\n                                checkQueryEndpoint      Sending to non existing direct queue name\r\n\r\n\r\n[WARNING] Endpoint pair (seda\/direct) validation error at: com.cgi.best.HealthRoute.configure(HealthRoute.java:45)\r\n\r\n        direct:checkSubmitAssessmentsEndpoint\r\n\r\n                                checkSubmitAssessmentsEndpoint  Sending to non existing direct queue name\r\n\r\n\r\n[WARNING] Endpoint pair (seda\/direct) validation error at: com.cgi.best.HealthRoute1.configure(HealthRoute1.java:45)\r\n\r\n        direct:checkQueryEndpoint\r\n\r\n                                checkQueryEndpoint      Sending to non existing direct queue name\r\n\r\n\r\n[WARNING] Endpoint pair (seda\/direct) validation error at: com.cgi.best.HealthRoute1.configure(HealthRoute1.java:45)\r\n\r\n        direct:checkSubmitAssessmentsEndpoint\r\n\r\n                                checkSubmitAssessmentsEndpoint  Sending to non existing direct queue name\r\n\r\n\r\n[WARNING] Endpoint pair (seda\/direct) validation error: (2 = pairs, 4 = non-pairs)\r\n[INFO] Duplicate route id validation success (3 = ids)\r\n[INFO] ------------------------------------------------------------------------\r\n[INFO] BUILD FAILURE\r\n[INFO] ------------------------------------------------------------------------\r\n[INFO] Total time: 3.030 s\r\n[INFO] Finished at: 2018-11-30T08:55:31-08:00\r\n[INFO] Final Memory: 21M\/398M\r\n[INFO] ------------------------------------------------------------------------\r\n[ERROR] Failed to execute goal org.apache.camel:camel-maven-plugin:2.23.0:validate (default-cli) on project BestAdapter: Endpoint validation success: (16 = passed, 0 = invalid, 2 = incapable, 0 = unknown components, 0 = deprecated options)\r\n[ERROR] Simple validation success: (3 = passed, 0 = invalid)\r\n[ERROR] Duplicate route id validation success (3 = ids)\r\n[ERROR] Endpoint pair (seda\/direct) validation error: (2 = pairs, 4 = non-pairs)\r\n[ERROR] -> [Help 1]\r\n[ERROR]\r\n[ERROR] To see the full stack trace of the errors, re-run Maven with the -e switch.\r\n[ERROR] Re-run Maven using the -X switch to enable full debug logging.\r\n[ERROR]\r\n[ERROR] For more information about the errors and possible solutions, please read the following articles:\r\n[ERROR] [Help 1] http:\/\/cwiki.apache.org\/confluence\/display\/MAVEN\/MojoExecutionException\r\n{code}"
    },
    {
      "key":"CAMEL-12969",
      "title":"camel-core-osgi: Slow Memory Leak in OsgiServiceRegistry",
      "description":"The OsgiServiceRegistry has a slow memory leak in the serviceReferenceQueue.\u00a0 Currently every time a service is looked up by any method an item is added to the serviceReferenceQueue.\u00a0 This is required because of OSGi ServiceReference counting.\u00a0 However left unchecked the system just continues to add ConcurrentLinkedQueue$Node objects until memory is exhausted.\r\n\r\n!ServiceReferenceQueueLeak.PNG! .\u00a0\r\n\r\n\u00a0\r\n\r\nThere is also a second problem with how the registry is being managed within the OsgiDefaultCamelContext.\u00a0 OsgiServiceRegistry is currently extends LifecycleStrategySupport which is suppose to unload the serviceReferenceQueue onContextStop.\u00a0 However the registry is never getting added to the CamelContext to manage the Lifecycle because the overridden createRegistry method in OsgiDefaultCamelContext is not being called.\u00a0 This is because the registry is being set in the constructor of OsgiDefaultCamelContext with\r\n{code:java}\r\nsuper(registry);{code}\r\nthis calls the DefaultCamelContext implementation of createRegistry which does not add the registry to lifecyclemanagement since\r\n{code:java}\r\nOsgiCamelContextHelper.wrapRegistry(this, registry, bundleContext);{code}\r\nis never called.\u00a0\r\n\r\nSee serviceReferenceQueue\u00a0 pre context stop\r\n\r\n\u00a0 !ServiceReferenceQueuePreContextStop.PNG!\r\n\r\n!karafCamelContextStop.PNG!\r\n\r\nSee serviceReferenceQueue\u00a0\u00a0 post context stop (still contain objects)\r\n\r\n\u00a0 !ServiceReferenceQueuePostContextStop.PNG!\r\n\r\nBoth issues would have existed for some time but may have gone unnoticed because the leak was so slow (ConcurrentLinkedQueue$Node takes up very little memory).\u00a0 It appears the removal of the cache in https:\/\/issues.apache.org\/jira\/browse\/CAMEL-9631 makes the leak occur more quickly.\u00a0\r\n\r\n\u00a0\r\n\r\nI have a patch that involves reintroducing the cache but with an invalidation strategy using the OSGi ServiceListener that leverages a single clean up thread to remain non-blocking.\u00a0 I'm working on an upstream adaptation and will post a PR for community review.\r\n\r\n\u00a0\r\n\r\n\u00a0",
      "assignee":"davsclaus",
      "type":"Bug",
      "priority":"Major",
      "status":"Resolved",
      "text":"camel-core-osgi: Slow Memory Leak in OsgiServiceRegistry The OsgiServiceRegistry has a slow memory leak in the serviceReferenceQueue.  Currently every time a service is looked up by any method an item is added to the serviceReferenceQueue.  This is required because of OSGi ServiceReference counting.  However left unchecked the system just continues to add ConcurrentLinkedQueue$Node objects until memory is exhausted.\r\n\r\n!ServiceReferenceQueueLeak.PNG! . \r\n\r\n \r\n\r\nThere is also a second problem with how the registry is being managed within the OsgiDefaultCamelContext.  OsgiServiceRegistry is currently extends LifecycleStrategySupport which is suppose to unload the serviceReferenceQueue onContextStop.  However the registry is never getting added to the CamelContext to manage the Lifecycle because the overridden createRegistry method in OsgiDefaultCamelContext is not being called.  This is because the registry is being set in the constructor of OsgiDefaultCamelContext with\r\n{code:java}\r\nsuper(registry);{code}\r\nthis calls the DefaultCamelContext implementation of createRegistry which does not add the registry to lifecyclemanagement since\r\n{code:java}\r\nOsgiCamelContextHelper.wrapRegistry(this, registry, bundleContext);{code}\r\nis never called. \r\n\r\nSee serviceReferenceQueue  pre context stop\r\n\r\n  !ServiceReferenceQueuePreContextStop.PNG!\r\n\r\n!karafCamelContextStop.PNG!\r\n\r\nSee serviceReferenceQueue   post context stop (still contain objects)\r\n\r\n  !ServiceReferenceQueuePostContextStop.PNG!\r\n\r\nBoth issues would have existed for some time but may have gone unnoticed because the leak was so slow (ConcurrentLinkedQueue$Node takes up very little memory).  It appears the removal of the cache in https:\/\/issues.apache.org\/jira\/browse\/CAMEL-9631 makes the leak occur more quickly. \r\n\r\n \r\n\r\nI have a patch that involves reintroducing the cache but with an invalidation strategy using the OSGi ServiceListener that leverages a single clean up thread to remain non-blocking.  I'm working on an upstream adaptation and will post a PR for community review.\r\n\r\n \r\n\r\n "
    },
    {
      "key":"CAMEL-12968",
      "title":"DefaultFluentProducerTemplate is not thread safe (endpoint, etc.)",
      "description":"The DefaultFluentProducerTemplate saves state between method calls. This leads to unexpected behavior when the javadoc specifies that it should be thread safe.\r\n\r\nFor example:\r\n # thread 1 calls fluentProducerTemplate.to(\"direct:a\").send(\"message1\");\r\n # thread 2 calls fluentProducerTemplate.to(\"direct:b\").send(\"message2\");\r\n\r\nIf these are run in parallel, the sequence of calls can be:\r\n # thread 1 calls to(\"direct:a\") - endpoint in the object is direct:a\r\n # thread 2 calls to(\"direct:b\") - endpoint in the object is direct:b\r\n # *thread 1\u00a0calls send(\"message1\") - this gets sent incorrectly to direct:b*\r\n # thread 2 calls send(\"message2\") - this gets sent correctly to direct:b\r\n\r\nEndpoint is one example, but almost all fields in this class share this behavior. It should be clearly documented which fields can be used fluently over multiple threads, and which cannot. As the API is today, all methods returning 'this' should be made thread-safe (state is only local to the caller) so that the fluent interface works as expected.",
      "assignee":"davsclaus",
      "type":"Bug",
      "priority":"Major",
      "status":"Resolved",
      "text":"DefaultFluentProducerTemplate is not thread safe (endpoint, etc.) The DefaultFluentProducerTemplate saves state between method calls. This leads to unexpected behavior when the javadoc specifies that it should be thread safe.\r\n\r\nFor example:\r\n # thread 1 calls fluentProducerTemplate.to(\"direct:a\").send(\"message1\");\r\n # thread 2 calls fluentProducerTemplate.to(\"direct:b\").send(\"message2\");\r\n\r\nIf these are run in parallel, the sequence of calls can be:\r\n # thread 1 calls to(\"direct:a\") - endpoint in the object is direct:a\r\n # thread 2 calls to(\"direct:b\") - endpoint in the object is direct:b\r\n # *thread 1 calls send(\"message1\") - this gets sent incorrectly to direct:b*\r\n # thread 2 calls send(\"message2\") - this gets sent correctly to direct:b\r\n\r\nEndpoint is one example, but almost all fields in this class share this behavior. It should be clearly documented which fields can be used fluently over multiple threads, and which cannot. As the API is today, all methods returning 'this' should be made thread-safe (state is only local to the caller) so that the fluent interface works as expected."
    },
    {
      "key":"CAMEL-12965",
      "title":"deprecate the Camel maven archetypes",
      "description":"ts these maven archetypes, we are considering to deprecate for 2.x and remove in 3.x\r\nhttps:\/\/github.com\/apache\/camel\/tree\/master\/archetypes",
      "assignee":"davsclaus",
      "type":"Task",
      "priority":"Major",
      "status":"Resolved",
      "text":"deprecate the Camel maven archetypes ts these maven archetypes, we are considering to deprecate for 2.x and remove in 3.x\r\nhttps:\/\/github.com\/apache\/camel\/tree\/master\/archetypes"
    },
    {
      "key":"CAMEL-12956",
      "title":"Spring Boot Auto-Configuration via application.properties does not work",
      "description":"I am trying to configure camel with spring boot to use active MQ. But the jms connection factory (activemq) gets not picked up automatically during auto configuration. Thus, I tried to configure it via application.properties\r\n{code:java}\r\ncamel.component.jms.connection-factory=org.apache.activemq.ActiveMQConnectionFactory{code}\r\nBut then I get an error on startup stating, that the expected datatype is\u00a0\r\n{code:java}\r\njavax.jms.ConnectionFactory{code}\r\nand not\r\n{code:java}\r\nString{code}\r\nThe only solutions I have found is not using autoconfiguration and configuring *JmsComponent* by hand or using a *ComponentCustomizer* programatically. This seems to be a Bug, as other component auto configurations expect a String as connectionFactory property.\r\n\r\n\u00a0",
      "assignee":"davsclaus",
      "type":"Bug",
      "priority":"Major",
      "status":"Resolved",
      "text":"Spring Boot Auto-Configuration via application.properties does not work I am trying to configure camel with spring boot to use active MQ. But the jms connection factory (activemq) gets not picked up automatically during auto configuration. Thus, I tried to configure it via application.properties\r\n{code:java}\r\ncamel.component.jms.connection-factory=org.apache.activemq.ActiveMQConnectionFactory{code}\r\nBut then I get an error on startup stating, that the expected datatype is \r\n{code:java}\r\njavax.jms.ConnectionFactory{code}\r\nand not\r\n{code:java}\r\nString{code}\r\nThe only solutions I have found is not using autoconfiguration and configuring *JmsComponent* by hand or using a *ComponentCustomizer* programatically. This seems to be a Bug, as other component auto configurations expect a String as connectionFactory property.\r\n\r\n "
    },
    {
      "key":"CAMEL-12949",
      "title":"onWhen predicate with onException can not bind to method with exception subclass parameter",
      "description":"Inspired by this example for \"Camel in Action, Second Edition\" (page 510):\r\n{code:java}\r\npublic final class MyHttpUtil {\r\n    public static boolean isIllegalDataError(\r\n        HttpOperationFailedException cause) {\r\n        int code = cause.getStatusCode();\r\n        if (code != 500) {\r\n            return false;\r\n            }\r\n        return \"ILLEGAL DATA\".equals(cause.getResponseBody().toString());\r\n    }\r\n}\r\n\r\nonException(HttpOperationFailedException.class)\r\n    .onWhen(bean(MyHttpUtil.class, \"isIllegalData\"))\r\n    .handled(true)\r\n    .to(\"file:\/rider\/files\/illegal\");\r\n{code}\r\nI expected this (simplified test) to pass:\r\n{code:java}\r\npublic class OnWhenBindMethodWithExceptionSubclassParameterTest extends CamelTestSupport {\r\n\r\n    public static class IOExceptionMatcher {\r\n        public static boolean matches(IOException e) {\r\n            \/\/ real logic omited\r\n            return true;\r\n        }\r\n    }\r\n\r\n    @Override\r\n    protected RouteBuilder createRouteBuilder() throws Exception {\r\n        return new RouteBuilder() {\r\n\r\n            public void configure() {\r\n                onException(IOException.class)\r\n                    .onWhen(method(IOExceptionMatcher.class))\r\n                    .to(\"mock:ioexception\");\r\n                from(\"seda:start\")\r\n                    .throwException(new IOException());\r\n            }\r\n        };\r\n    }\r\n\r\n    @Test\r\n    public void test() throws Exception {\r\n        getMockEndpoint(\"mock:ioexception\").expectedMessageCount(1);\r\n\r\n        template.sendBody(\"seda:start\", \"Hello World\");\r\n\r\n        assertMockEndpointsSatisfied();\r\n    }\r\n}\r\n{code}\r\nbut it fails with with:\r\n{noformat}\r\njava.lang.AssertionError: mock:\/\/ioexception Received message count. Expected: <1> but was: <0>\r\n{noformat}\r\nThe workaround is to replace the {{IOException}} parameter of {{IOExceptionMatcher#matches}} with an generic {{Exception}}:\r\n{code:java}\r\npublic static class IOExceptionMatcher {\r\n    public static boolean matches(Exception e) {\r\n        if (e instanceof IOException) {\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n}\r\n{code}\r\n\r\nbut this is not as elegant and more error prone.",
      "assignee":"davsclaus",
      "type":"Bug",
      "priority":"Minor",
      "status":"Closed",
      "text":"onWhen predicate with onException can not bind to method with exception subclass parameter Inspired by this example for \"Camel in Action, Second Edition\" (page 510):\r\n{code:java}\r\npublic final class MyHttpUtil {\r\n    public static boolean isIllegalDataError(\r\n        HttpOperationFailedException cause) {\r\n        int code = cause.getStatusCode();\r\n        if (code != 500) {\r\n            return false;\r\n            }\r\n        return \"ILLEGAL DATA\".equals(cause.getResponseBody().toString());\r\n    }\r\n}\r\n\r\nonException(HttpOperationFailedException.class)\r\n    .onWhen(bean(MyHttpUtil.class, \"isIllegalData\"))\r\n    .handled(true)\r\n    .to(\"file:\/rider\/files\/illegal\");\r\n{code}\r\nI expected this (simplified test) to pass:\r\n{code:java}\r\npublic class OnWhenBindMethodWithExceptionSubclassParameterTest extends CamelTestSupport {\r\n\r\n    public static class IOExceptionMatcher {\r\n        public static boolean matches(IOException e) {\r\n            \/\/ real logic omited\r\n            return true;\r\n        }\r\n    }\r\n\r\n    @Override\r\n    protected RouteBuilder createRouteBuilder() throws Exception {\r\n        return new RouteBuilder() {\r\n\r\n            public void configure() {\r\n                onException(IOException.class)\r\n                    .onWhen(method(IOExceptionMatcher.class))\r\n                    .to(\"mock:ioexception\");\r\n                from(\"seda:start\")\r\n                    .throwException(new IOException());\r\n            }\r\n        };\r\n    }\r\n\r\n    @Test\r\n    public void test() throws Exception {\r\n        getMockEndpoint(\"mock:ioexception\").expectedMessageCount(1);\r\n\r\n        template.sendBody(\"seda:start\", \"Hello World\");\r\n\r\n        assertMockEndpointsSatisfied();\r\n    }\r\n}\r\n{code}\r\nbut it fails with with:\r\n{noformat}\r\njava.lang.AssertionError: mock:\/\/ioexception Received message count. Expected: <1> but was: <0>\r\n{noformat}\r\nThe workaround is to replace the {{IOException}} parameter of {{IOExceptionMatcher#matches}} with an generic {{Exception}}:\r\n{code:java}\r\npublic static class IOExceptionMatcher {\r\n    public static boolean matches(Exception e) {\r\n        if (e instanceof IOException) {\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n}\r\n{code}\r\n\r\nbut this is not as elegant and more error prone."
    },
    {
      "key":"CAMEL-12937",
      "title":"Stream Caching Cipher is misspelled as chiper",
      "description":"The typo is in the docs here:\r\nhttps:\/\/camel.apache.org\/stream-caching.html\r\n\r\nAs well as {{org.apache.camel.spring.boot.CamelConfigurationProperties}}\r\n\r\nI'm guessing it is in other places as well.",
      "assignee":"davsclaus",
      "type":"Task",
      "priority":"Trivial",
      "status":"Resolved",
      "text":"Stream Caching Cipher is misspelled as chiper The typo is in the docs here:\r\nhttps:\/\/camel.apache.org\/stream-caching.html\r\n\r\nAs well as {{org.apache.camel.spring.boot.CamelConfigurationProperties}}\r\n\r\nI'm guessing it is in other places as well."
    },
    {
      "key":"CAMEL-12916",
      "title":"camel-http4 - The sslContextParameters option should be documented on endpoint as well",
      "description":"Reported on gitter\r\nhttps:\/\/gitter.im\/apache\/apache-camel?at=5be0bcd7de33dd0c96d547b3",
      "assignee":"davsclaus",
      "type":"Bug",
      "priority":"Minor",
      "status":"Resolved",
      "text":"camel-http4 - The sslContextParameters option should be documented on endpoint as well Reported on gitter\r\nhttps:\/\/gitter.im\/apache\/apache-camel?at=5be0bcd7de33dd0c96d547b3"
    },
    {
      "key":"CAMEL-12909",
      "title":"Error handler - Counter and option to log when a retry became success",
      "description":"Asked on twitter\r\nhttps:\/\/twitter.com\/luistrigueiros\/status\/1053039644093366272\r\n\r\nIt may be good to have a way to know if a message that has first failed and then with retries from the error handler then became succesful. We should be able to see this with\r\n- counter in the mbean\r\n- log message in the logs, option to configure the logging level.",
      "assignee":"davsclaus",
      "type":"Improvement",
      "priority":"Major",
      "status":"Resolved",
      "text":"Error handler - Counter and option to log when a retry became success Asked on twitter\r\nhttps:\/\/twitter.com\/luistrigueiros\/status\/1053039644093366272\r\n\r\nIt may be good to have a way to know if a message that has first failed and then with retries from the error handler then became succesful. We should be able to see this with\r\n- counter in the mbean\r\n- log message in the logs, option to configure the logging level."
    },
    {
      "key":"CAMEL-12900",
      "title":"Route contract validate does not throw validation exception when validation fails",
      "description":"This route will not throw validation exception when expected\r\n{code}\r\n                validator().type(\"xml\").withUri(\"validator:org\/apache\/camel\/impl\/validate.xsd\");\r\n\r\n                from(\"direct:in\").inputTypeWithValidate(\"xml\")\r\n                    .to(\"mock:result\");\r\n{code}",
      "assignee":"davsclaus",
      "type":"Bug",
      "priority":"Major",
      "status":"Resolved",
      "text":"Route contract validate does not throw validation exception when validation fails This route will not throw validation exception when expected\r\n{code}\r\n                validator().type(\"xml\").withUri(\"validator:org\/apache\/camel\/impl\/validate.xsd\");\r\n\r\n                from(\"direct:in\").inputTypeWithValidate(\"xml\")\r\n                    .to(\"mock:result\");\r\n{code}"
    },
    {
      "key":"CAMEL-12883",
      "title":"WeaveByType not working for OnExceptionDefinition in camel 2.21.0",
      "description":"Below is my route\r\n{code:java}\r\nOnException(Exception.class).handled(true).process(EXCEPTION_PROCESSOR).end()\r\n\r\nfrom(\"file:\").process(SOME_PROCESSOR).to(\"file:\");\r\n{code}\r\nDuring testing i want to investigate each exchange which goes through OnException block , for which i tried below\r\n{code:java}\r\nweaveByType(OnExceptionDefinition.class).after()\r\n                    .to(assertEndpoint)\r\n{code}\r\nwhen i ran the test i got below error\r\n{code:java}\r\njava.lang.IllegalArgumentException: There are no outputs which matches: OnExceptionDefinition in the route\r\n{code}\r\nCould you please help in resolving this issue? Please note i have tried adding code mentioned below in test class, but still the same issue.\r\n\r\n\u00a0\r\n{code:java}\r\n@Override\r\npublic boolean isUseAdviceWith() {\r\n    return true;\r\n}\r\n{code}",
      "assignee":"davsclaus",
      "type":"Bug",
      "priority":"Major",
      "status":"Resolved",
      "text":"WeaveByType not working for OnExceptionDefinition in camel 2.21.0 Below is my route\r\n{code:java}\r\nOnException(Exception.class).handled(true).process(EXCEPTION_PROCESSOR).end()\r\n\r\nfrom(\"file:\").process(SOME_PROCESSOR).to(\"file:\");\r\n{code}\r\nDuring testing i want to investigate each exchange which goes through OnException block , for which i tried below\r\n{code:java}\r\nweaveByType(OnExceptionDefinition.class).after()\r\n                    .to(assertEndpoint)\r\n{code}\r\nwhen i ran the test i got below error\r\n{code:java}\r\njava.lang.IllegalArgumentException: There are no outputs which matches: OnExceptionDefinition in the route\r\n{code}\r\nCould you please help in resolving this issue? Please note i have tried adding code mentioned below in test class, but still the same issue.\r\n\r\n \r\n{code:java}\r\n@Override\r\npublic boolean isUseAdviceWith() {\r\n    return true;\r\n}\r\n{code}"
    },
    {
      "key":"CAMEL-12882",
      "title":"Camel Jms headers missing if producer endpoint has transferExchange=true",
      "description":"The JMS headers are not being extracted if you use transferExchange=true.",
      "assignee":"davsclaus",
      "type":"Bug",
      "priority":"Minor",
      "status":"Resolved",
      "text":"Camel Jms headers missing if producer endpoint has transferExchange=true The JMS headers are not being extracted if you use transferExchange=true."
    },
    {
      "key":"CAMEL-12872",
      "title":"When no route is defined, mention in log that it is the reason why it shutdowns the Camel Context automatically",
      "description":"When starting a project and that no Camel route are found, the camel context is shutdown immediately.\r\n\r\nit would be nice to have a trace  in log mentioning the reason.\r\nmaybe also refer to some documentation on how to configure routes?",
      "assignee":"davsclaus",
      "type":"Improvement",
      "priority":"Minor",
      "status":"Resolved",
      "text":"When no route is defined, mention in log that it is the reason why it shutdowns the Camel Context automatically When starting a project and that no Camel route are found, the camel context is shutdown immediately.\r\n\r\nit would be nice to have a trace  in log mentioning the reason.\r\nmaybe also refer to some documentation on how to configure routes?"
    },
    {
      "key":"CAMEL-12868",
      "title":"Camel project generated from spring initalzr is shutdowning immediately after start",
      "description":"- go to https:\/\/start.spring.io\/\r\n- let default values for \"generate a Maven project with Java and Spring Boot 2.0.5\"\r\n- add Camel dependencies\r\n- expand zipped project\r\n- launch mvn spring-boot:run\r\n- Camel is started and then shutdowned immediately instead of letting the application running\r\n\r\n{noformat}\r\nC:\\ws\\workingDirectoryForTest\\test-project-generated-from-start-spring-io\\demo>mvn spring-boot:run\r\n[INFO] Scanning for projects...\r\n[INFO]\r\n[INFO] ------------------------------------------------------------------------\r\n[INFO] Building demo 0.0.1-SNAPSHOT\r\n[INFO] ------------------------------------------------------------------------\r\n[INFO]\r\n[INFO] >>> spring-boot-maven-plugin:2.0.5.RELEASE:run (default-cli) > test-compile @ demo >>>\r\n[INFO]\r\n[INFO] --- maven-resources-plugin:3.0.2:resources (default-resources) @ demo ---\r\n[INFO] Using 'UTF-8' encoding to copy filtered resources.\r\n[INFO] Copying 1 resource\r\n[INFO] Copying 0 resource\r\n[INFO]\r\n[INFO] --- maven-compiler-plugin:3.7.0:compile (default-compile) @ demo ---\r\n[INFO] Changes detected - recompiling the module!\r\n[INFO] Compiling 1 source file to C:\\ws\\workingDirectoryForTest\\test-project-generated-from-start-spring-io\\demo\\target\\classes\r\n[INFO]\r\n[INFO] --- maven-resources-plugin:3.0.2:testResources (default-testResources) @ demo ---\r\n[INFO] Using 'UTF-8' encoding to copy filtered resources.\r\n[INFO] skip non existing resourceDirectory C:\\ws\\workingDirectoryForTest\\test-project-generated-from-start-spring-io\\demo\\src\\test\\resources\r\n[INFO]\r\n[INFO] --- maven-compiler-plugin:3.7.0:testCompile (default-testCompile) @ demo ---\r\n[INFO] Changes detected - recompiling the module!\r\n[INFO] Compiling 1 source file to C:\\ws\\workingDirectoryForTest\\test-project-generated-from-start-spring-io\\demo\\target\\test-classes\r\n[INFO]\r\n[INFO] <<< spring-boot-maven-plugin:2.0.5.RELEASE:run (default-cli) < test-compile @ demo <<<\r\n[INFO]\r\n[INFO] --- spring-boot-maven-plugin:2.0.5.RELEASE:run (default-cli) @ demo ---\r\n\r\n  .   ____          _            __ _ _\r\n \/\\\\ \/ ___'_ __ _ _(_)_ __  __ _ \\ \\ \\ \\\r\n( ( )\\___ | '_ | '_| | '_ \\\/ _` | \\ \\ \\ \\\r\n \\\\\/  ___)| |_)| | | | | || (_| |  ) ) ) )\r\n  '  |____| .__|_| |_|_| |_\\__, | \/ \/ \/ \/\r\n =========|_|==============|___\/=\/_\/_\/_\/\r\n :: Spring Boot ::        (v2.0.5.RELEASE)\r\n\r\n2018-10-08 16:25:13.240  INFO 18328 --- [           main] com.example.demo.DemoApplication         : Starting DemoApplication on DESKTOP-9NT300B with PID 18328 (C:\\ws\\workingDirectoryForTest\\test-project-generated-from-start-spring-io\\demo\\target\\classes started by Aurelien Pupier in C:\\ws\\workingDirectoryForTest\\test-project-generated-from-start-spring-io\\demo)\r\n2018-10-08 16:25:13.243  INFO 18328 --- [           main] com.example.demo.DemoApplication         : No active profile set, falling back\r\nto default profiles: default\r\n2018-10-08 16:25:13.283  INFO 18328 --- [           main] s.c.a.AnnotationConfigApplicationContext : Refreshing org.springframework.context.annotation.AnnotationConfigApplicationContext@5fc55560: startup date [Mon Oct 08 16:25:13 CEST 2018]; root of context hierarchy\r\n2018-10-08 16:25:14.102  INFO 18328 --- [           main] trationDelegate$BeanPostProcessorChecker : Bean 'org.apache.camel.spring.boot.CamelAutoConfiguration' of type [org.apache.camel.spring.boot.CamelAutoConfiguration$$EnhancerBySpringCGLIB$$cae74b74] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)\r\n2018-10-08 16:25:14.283  INFO 18328 --- [           main] o.a.c.i.converter.DefaultTypeConverter   : Type converters loaded (core: 195, classpath: 1)\r\n2018-10-08 16:25:14.788  INFO 18328 --- [           main] o.s.j.e.a.AnnotationMBeanExporter        : Registering beans for JMX exposure on startup\r\n2018-10-08 16:25:14.804  INFO 18328 --- [           main] o.a.camel.spring.boot.RoutesCollector    : Loading additional Camel XML routes\r\nfrom: classpath:camel\/*.xml\r\n2018-10-08 16:25:14.805  INFO 18328 --- [           main] o.a.camel.spring.boot.RoutesCollector    : Loading additional Camel XML rests from: classpath:camel-rest\/*.xml\r\n2018-10-08 16:25:14.814  INFO 18328 --- [           main] o.a.camel.spring.SpringCamelContext      : Apache Camel 2.22.1 (CamelContext: camel-1) is starting\r\n2018-10-08 16:25:14.817  INFO 18328 --- [           main] o.a.c.m.ManagedManagementStrategy        : JMX is enabled\r\n2018-10-08 16:25:14.981  INFO 18328 --- [           main] o.a.camel.spring.SpringCamelContext      : StreamCaching is not in use. If using streams then its recommended to enable stream caching. See more details at http:\/\/camel.apache.org\/stream-caching.html\r\n2018-10-08 16:25:14.983  INFO 18328 --- [           main] o.a.camel.spring.SpringCamelContext      : Total 0 routes, of which 0 are started\r\n2018-10-08 16:25:14.984  INFO 18328 --- [           main] o.a.camel.spring.SpringCamelContext      : Apache Camel 2.22.1 (CamelContext: camel-1) started in 0.169 seconds\r\n2018-10-08 16:25:14.988  INFO 18328 --- [           main] com.example.demo.DemoApplication         : Started DemoApplication in 2.083 seconds (JVM running for 8.856)\r\n[INFO] ------------------------------------------------------------------------\r\n[INFO] BUILD SUCCESS\r\n[INFO] ------------------------------------------------------------------------\r\n[INFO] Total time: 6.266 s\r\n[INFO] Finished at: 2018-10-08T16:25:14+02:00\r\n[INFO] Final Memory: 48M\/575M\r\n[INFO] ------------------------------------------------------------------------\r\n2018-10-08 16:25:15.274  INFO 18328 --- [       Thread-2] s.c.a.AnnotationConfigApplicationContext : Closing org.springframework.context.annotation.AnnotationConfigApplicationContext@5fc55560: startup date [Mon Oct 08 16:25:13 CEST 2018]; root of context hierarchy\r\n2018-10-08 16:25:15.277  INFO 18328 --- [       Thread-2] o.s.c.support.DefaultLifecycleProcessor  : Stopping beans in phase 2147483647\r\n2018-10-08 16:25:15.278  INFO 18328 --- [       Thread-2] o.a.camel.spring.SpringCamelContext      : Apache Camel 2.22.1 (CamelContext: camel-1) is shutting down\r\n2018-10-08 16:25:15.300  INFO 18328 --- [       Thread-2] o.a.camel.spring.SpringCamelContext      : Apache Camel 2.22.1 (CamelContext: camel-1) uptime 0.486 seconds\r\n2018-10-08 16:25:15.301  INFO 18328 --- [       Thread-2] o.a.camel.spring.SpringCamelContext      : Apache Camel 2.22.1 (CamelContext: camel-1) is shutdown in 0.022 seconds\r\n2018-10-08 16:25:15.301  INFO 18328 --- [       Thread-2] o.s.j.e.a.AnnotationMBeanExporter        : Unregistering JMX-exposed beans on shutdown\r\n{noformat}",
      "assignee":"davsclaus",
      "type":"Improvement",
      "priority":"Major",
      "status":"Resolved",
      "text":"Camel project generated from spring initalzr is shutdowning immediately after start - go to https:\/\/start.spring.io\/\r\n- let default values for \"generate a Maven project with Java and Spring Boot 2.0.5\"\r\n- add Camel dependencies\r\n- expand zipped project\r\n- launch mvn spring-boot:run\r\n- Camel is started and then shutdowned immediately instead of letting the application running\r\n\r\n{noformat}\r\nC:\\ws\\workingDirectoryForTest\\test-project-generated-from-start-spring-io\\demo>mvn spring-boot:run\r\n[INFO] Scanning for projects...\r\n[INFO]\r\n[INFO] ------------------------------------------------------------------------\r\n[INFO] Building demo 0.0.1-SNAPSHOT\r\n[INFO] ------------------------------------------------------------------------\r\n[INFO]\r\n[INFO] >>> spring-boot-maven-plugin:2.0.5.RELEASE:run (default-cli) > test-compile @ demo >>>\r\n[INFO]\r\n[INFO] --- maven-resources-plugin:3.0.2:resources (default-resources) @ demo ---\r\n[INFO] Using 'UTF-8' encoding to copy filtered resources.\r\n[INFO] Copying 1 resource\r\n[INFO] Copying 0 resource\r\n[INFO]\r\n[INFO] --- maven-compiler-plugin:3.7.0:compile (default-compile) @ demo ---\r\n[INFO] Changes detected - recompiling the module!\r\n[INFO] Compiling 1 source file to C:\\ws\\workingDirectoryForTest\\test-project-generated-from-start-spring-io\\demo\\target\\classes\r\n[INFO]\r\n[INFO] --- maven-resources-plugin:3.0.2:testResources (default-testResources) @ demo ---\r\n[INFO] Using 'UTF-8' encoding to copy filtered resources.\r\n[INFO] skip non existing resourceDirectory C:\\ws\\workingDirectoryForTest\\test-project-generated-from-start-spring-io\\demo\\src\\test\\resources\r\n[INFO]\r\n[INFO] --- maven-compiler-plugin:3.7.0:testCompile (default-testCompile) @ demo ---\r\n[INFO] Changes detected - recompiling the module!\r\n[INFO] Compiling 1 source file to C:\\ws\\workingDirectoryForTest\\test-project-generated-from-start-spring-io\\demo\\target\\test-classes\r\n[INFO]\r\n[INFO] <<< spring-boot-maven-plugin:2.0.5.RELEASE:run (default-cli) < test-compile @ demo <<<\r\n[INFO]\r\n[INFO] --- spring-boot-maven-plugin:2.0.5.RELEASE:run (default-cli) @ demo ---\r\n\r\n  .   ____          _            __ _ _\r\n \/\\\\ \/ ___'_ __ _ _(_)_ __  __ _ \\ \\ \\ \\\r\n( ( )\\___ | '_ | '_| | '_ \\\/ _` | \\ \\ \\ \\\r\n \\\\\/  ___)| |_)| | | | | || (_| |  ) ) ) )\r\n  '  |____| .__|_| |_|_| |_\\__, | \/ \/ \/ \/\r\n =========|_|==============|___\/=\/_\/_\/_\/\r\n :: Spring Boot ::        (v2.0.5.RELEASE)\r\n\r\n2018-10-08 16:25:13.240  INFO 18328 --- [           main] com.example.demo.DemoApplication         : Starting DemoApplication on DESKTOP-9NT300B with PID 18328 (C:\\ws\\workingDirectoryForTest\\test-project-generated-from-start-spring-io\\demo\\target\\classes started by Aurelien Pupier in C:\\ws\\workingDirectoryForTest\\test-project-generated-from-start-spring-io\\demo)\r\n2018-10-08 16:25:13.243  INFO 18328 --- [           main] com.example.demo.DemoApplication         : No active profile set, falling back\r\nto default profiles: default\r\n2018-10-08 16:25:13.283  INFO 18328 --- [           main] s.c.a.AnnotationConfigApplicationContext : Refreshing org.springframework.context.annotation.AnnotationConfigApplicationContext@5fc55560: startup date [Mon Oct 08 16:25:13 CEST 2018]; root of context hierarchy\r\n2018-10-08 16:25:14.102  INFO 18328 --- [           main] trationDelegate$BeanPostProcessorChecker : Bean 'org.apache.camel.spring.boot.CamelAutoConfiguration' of type [org.apache.camel.spring.boot.CamelAutoConfiguration$$EnhancerBySpringCGLIB$$cae74b74] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)\r\n2018-10-08 16:25:14.283  INFO 18328 --- [           main] o.a.c.i.converter.DefaultTypeConverter   : Type converters loaded (core: 195, classpath: 1)\r\n2018-10-08 16:25:14.788  INFO 18328 --- [           main] o.s.j.e.a.AnnotationMBeanExporter        : Registering beans for JMX exposure on startup\r\n2018-10-08 16:25:14.804  INFO 18328 --- [           main] o.a.camel.spring.boot.RoutesCollector    : Loading additional Camel XML routes\r\nfrom: classpath:camel\/*.xml\r\n2018-10-08 16:25:14.805  INFO 18328 --- [           main] o.a.camel.spring.boot.RoutesCollector    : Loading additional Camel XML rests from: classpath:camel-rest\/*.xml\r\n2018-10-08 16:25:14.814  INFO 18328 --- [           main] o.a.camel.spring.SpringCamelContext      : Apache Camel 2.22.1 (CamelContext: camel-1) is starting\r\n2018-10-08 16:25:14.817  INFO 18328 --- [           main] o.a.c.m.ManagedManagementStrategy        : JMX is enabled\r\n2018-10-08 16:25:14.981  INFO 18328 --- [           main] o.a.camel.spring.SpringCamelContext      : StreamCaching is not in use. If using streams then its recommended to enable stream caching. See more details at http:\/\/camel.apache.org\/stream-caching.html\r\n2018-10-08 16:25:14.983  INFO 18328 --- [           main] o.a.camel.spring.SpringCamelContext      : Total 0 routes, of which 0 are started\r\n2018-10-08 16:25:14.984  INFO 18328 --- [           main] o.a.camel.spring.SpringCamelContext      : Apache Camel 2.22.1 (CamelContext: camel-1) started in 0.169 seconds\r\n2018-10-08 16:25:14.988  INFO 18328 --- [           main] com.example.demo.DemoApplication         : Started DemoApplication in 2.083 seconds (JVM running for 8.856)\r\n[INFO] ------------------------------------------------------------------------\r\n[INFO] BUILD SUCCESS\r\n[INFO] ------------------------------------------------------------------------\r\n[INFO] Total time: 6.266 s\r\n[INFO] Finished at: 2018-10-08T16:25:14+02:00\r\n[INFO] Final Memory: 48M\/575M\r\n[INFO] ------------------------------------------------------------------------\r\n2018-10-08 16:25:15.274  INFO 18328 --- [       Thread-2] s.c.a.AnnotationConfigApplicationContext : Closing org.springframework.context.annotation.AnnotationConfigApplicationContext@5fc55560: startup date [Mon Oct 08 16:25:13 CEST 2018]; root of context hierarchy\r\n2018-10-08 16:25:15.277  INFO 18328 --- [       Thread-2] o.s.c.support.DefaultLifecycleProcessor  : Stopping beans in phase 2147483647\r\n2018-10-08 16:25:15.278  INFO 18328 --- [       Thread-2] o.a.camel.spring.SpringCamelContext      : Apache Camel 2.22.1 (CamelContext: camel-1) is shutting down\r\n2018-10-08 16:25:15.300  INFO 18328 --- [       Thread-2] o.a.camel.spring.SpringCamelContext      : Apache Camel 2.22.1 (CamelContext: camel-1) uptime 0.486 seconds\r\n2018-10-08 16:25:15.301  INFO 18328 --- [       Thread-2] o.a.camel.spring.SpringCamelContext      : Apache Camel 2.22.1 (CamelContext: camel-1) is shutdown in 0.022 seconds\r\n2018-10-08 16:25:15.301  INFO 18328 --- [       Thread-2] o.s.j.e.a.AnnotationMBeanExporter        : Unregistering JMX-exposed beans on shutdown\r\n{noformat}"
    },
    {
      "key":"CAMEL-12864",
      "title":"rest: Host header should not overwrite host attribute on rest-swagger component",
      "description":"When defining a rest-swagger component\r\n\r\n{code}\r\n@Bean\r\n public Component mobile(CamelContext camelContext) throws URISyntaxException\r\n\r\n{ RestSwaggerComponent mobile = new RestSwaggerComponent(camelContext); mobile.setHost(mobileHost); mobile.setBasePath(mobileBasePath); mobile.setSpecificationUri( new URI(mobileSpecificationPath)); mobile.setComponentName(\"http4\"); return mobile; }\r\n{code}\r\n\r\nin the following route (rest-endpoint missing, this is calling direct:getMobileAccountById) the host attribute is overwritten by the previous host header (therefore removeHeader needs to be called prior to invocation of the rest-swagger endpoint):(\r\n\r\n{code}\r\nfrom(\"direct:getMobileAccountById\").routeId(\"getMobileAccountById\")\r\n .setHeader(\"customerId\", simple(\"headers.mobileAndFixedlineCustomerId.split(',')[1]\"))\r\n .removeHeader(\"Host\")\r\n .to(\"mobile:getAccountById\")\r\n .unmarshal(gsonDataFormatMobile)\r\n .log(\"Just got called for Mobile\");\r\n{code}\r\n\r\nThe attribute host should not be overwritten by the host-header, if it is set explicitly on the component.\r\n\r\n\u00a0",
      "assignee":"davsclaus",
      "type":"Improvement",
      "priority":"Minor",
      "status":"Resolved",
      "text":"rest: Host header should not overwrite host attribute on rest-swagger component When defining a rest-swagger component\r\n\r\n{code}\r\n@Bean\r\n public Component mobile(CamelContext camelContext) throws URISyntaxException\r\n\r\n{ RestSwaggerComponent mobile = new RestSwaggerComponent(camelContext); mobile.setHost(mobileHost); mobile.setBasePath(mobileBasePath); mobile.setSpecificationUri( new URI(mobileSpecificationPath)); mobile.setComponentName(\"http4\"); return mobile; }\r\n{code}\r\n\r\nin the following route (rest-endpoint missing, this is calling direct:getMobileAccountById) the host attribute is overwritten by the previous host header (therefore removeHeader needs to be called prior to invocation of the rest-swagger endpoint):(\r\n\r\n{code}\r\nfrom(\"direct:getMobileAccountById\").routeId(\"getMobileAccountById\")\r\n .setHeader(\"customerId\", simple(\"headers.mobileAndFixedlineCustomerId.split(',')[1]\"))\r\n .removeHeader(\"Host\")\r\n .to(\"mobile:getAccountById\")\r\n .unmarshal(gsonDataFormatMobile)\r\n .log(\"Just got called for Mobile\");\r\n{code}\r\n\r\nThe attribute host should not be overwritten by the host-header, if it is set explicitly on the component.\r\n\r\n "
    },
    {
      "key":"CAMEL-12847",
      "title":"IntrospectionSupport - Allow to use dash style naming",
      "description":"See ticket\r\nhttps:\/\/github.com\/apache\/camel-k\/issues\/142",
      "assignee":"davsclaus",
      "type":"New Feature",
      "priority":"Major",
      "status":"Resolved",
      "text":"IntrospectionSupport - Allow to use dash style naming See ticket\r\nhttps:\/\/github.com\/apache\/camel-k\/issues\/142"
    },
    {
      "key":"CAMEL-12844",
      "title":"splitter with grouping looses encoding property",
      "description":"Reported on user list and today also on gitter\r\nhttp:\/\/camel.465427.n5.nabble.com\/File-Encoding-falls-back-to-default-encoding-while-grouping-after-split-using-tokenize-td5797769.html\r\n\r\nJakob Krejberg \u00d8rh\u00f8j @jakoborhoj_twitter Sep 28 12:30\r\nHello. I've been battling with some encoding issues when using split().tokenize() in Camel. I am having the same issue as described in: http:\/\/camel.465427.n5.nabble.com\/File-Encoding-falls-back-to-default-encoding-while-grouping-after-split-using-tokenize-td5797769.html. Is it a bug that Camel does not pass the exchange to the converter so that it can get the encoding set in the exchange? Currently it will always default to UTF-8 as I see it.",
      "assignee":"davsclaus",
      "type":"Bug",
      "priority":"Major",
      "status":"Resolved",
      "text":"splitter with grouping looses encoding property Reported on user list and today also on gitter\r\nhttp:\/\/camel.465427.n5.nabble.com\/File-Encoding-falls-back-to-default-encoding-while-grouping-after-split-using-tokenize-td5797769.html\r\n\r\nJakob Krejberg Orhoj @jakoborhoj_twitter Sep 28 12:30\r\nHello. I've been battling with some encoding issues when using split().tokenize() in Camel. I am having the same issue as described in: http:\/\/camel.465427.n5.nabble.com\/File-Encoding-falls-back-to-default-encoding-while-grouping-after-split-using-tokenize-td5797769.html. Is it a bug that Camel does not pass the exchange to the converter so that it can get the encoding set in the exchange? Currently it will always default to UTF-8 as I see it."
    },
    {
      "key":"CAMEL-12841",
      "title":"camel-restdsl-swagger:generate - Add restConfiguration with common defaults",
      "description":"We should add restConfiguration in the generated DSL source code so the Camel developer can see the configuration bits there, and more easily be able to configure rest-dsl options.\r\n\r\nWe should detect which component is on the classpath and choose, eg jetty \/ servlet etc.",
      "assignee":"davsclaus",
      "type":"New Feature",
      "priority":"Major",
      "status":"Resolved",
      "text":"camel-restdsl-swagger:generate - Add restConfiguration with common defaults We should add restConfiguration in the generated DSL source code so the Camel developer can see the configuration bits there, and more easily be able to configure rest-dsl options.\r\n\r\nWe should detect which component is on the classpath and choose, eg jetty \/ servlet etc."
    },
    {
      "key":"CAMEL-12836",
      "title":"Type Converter Loader Exception: Elasticsearch-Rest cannot find any in package defined",
      "description":"{code:java}\r\n{{Error creating bean with name 'servletEndpointRegistrar' defined in class path resource [org\/springframework\/boot\/actuate\/autoconfigure\/endpoint\/web\/ServletEndpointManagementContextConfiguration$WebMvcServletEndpointManagementContextConfiguration.class]: Bean instantiation via factory method failed; nested exception is org.springframework.beans.BeanInstantiationException: Failed to instantiate [org.springframework.boot.actuate.endpoint.web.ServletEndpointRegistrar]: Factory method 'servletEndpointRegistrar' threw exception; nested exception is org.springframework.beans.factory.UnsatisfiedDependencyException: Error creating bean with name 'routeControllerEndpoint' defined in class path resource [org\/apache\/camel\/spring\/boot\/actuate\/endpoint\/CamelRouteControllerEndpointAutoConfiguration.class]: Unsatisfied dependency expressed through method 'routeControllerEndpoint' parameter 0; nested exception is org.springframework.beans.factory.BeanCreationException: Error creating bean with name 'camelContext' defined in class path resource [org\/apache\/camel\/spring\/boot\/CamelAutoConfiguration.class]: Bean instantiation via factory method failed; nested exception is org.springframework.beans.BeanInstantiationException: Failed to instantiate [org.apache.camel.CamelContext]: Factory method 'camelContext' threw exception; nested exception is org.apache.camel.RuntimeCamelException: org.apache.camel.TypeConverterLoaderException: Failed to load type converters because of: Cannot find any type converter classes from the following packages: [org.apache.camel.component.elasticsearch.converter] }}{code}\r\n\u00a0\r\n\r\n\u00a0\r\n\r\nA possible solution to this is to use FQN class names instead of package name",
      "assignee":"davsclaus",
      "type":"Bug",
      "priority":"Major",
      "status":"Resolved",
      "text":"Type Converter Loader Exception: Elasticsearch-Rest cannot find any in package defined {code:java}\r\n{{Error creating bean with name 'servletEndpointRegistrar' defined in class path resource [org\/springframework\/boot\/actuate\/autoconfigure\/endpoint\/web\/ServletEndpointManagementContextConfiguration$WebMvcServletEndpointManagementContextConfiguration.class]: Bean instantiation via factory method failed; nested exception is org.springframework.beans.BeanInstantiationException: Failed to instantiate [org.springframework.boot.actuate.endpoint.web.ServletEndpointRegistrar]: Factory method 'servletEndpointRegistrar' threw exception; nested exception is org.springframework.beans.factory.UnsatisfiedDependencyException: Error creating bean with name 'routeControllerEndpoint' defined in class path resource [org\/apache\/camel\/spring\/boot\/actuate\/endpoint\/CamelRouteControllerEndpointAutoConfiguration.class]: Unsatisfied dependency expressed through method 'routeControllerEndpoint' parameter 0; nested exception is org.springframework.beans.factory.BeanCreationException: Error creating bean with name 'camelContext' defined in class path resource [org\/apache\/camel\/spring\/boot\/CamelAutoConfiguration.class]: Bean instantiation via factory method failed; nested exception is org.springframework.beans.BeanInstantiationException: Failed to instantiate [org.apache.camel.CamelContext]: Factory method 'camelContext' threw exception; nested exception is org.apache.camel.RuntimeCamelException: org.apache.camel.TypeConverterLoaderException: Failed to load type converters because of: Cannot find any type converter classes from the following packages: [org.apache.camel.component.elasticsearch.converter] }}{code}\r\n \r\n\r\n \r\n\r\nA possible solution to this is to use FQN class names instead of package name"
    },
    {
      "key":"CAMEL-12835",
      "title":"camel-json-validator - Potential issue with reading from streams",
      "description":"See SO\r\nhttps:\/\/stackoverflow.com\/questions\/52228692\/camel-json-validator-throws-stream-closed-exception?noredirect=1#comment91912061_52228692",
      "assignee":"davsclaus",
      "type":"Bug",
      "priority":"Major",
      "status":"Resolved",
      "text":"camel-json-validator - Potential issue with reading from streams See SO\r\nhttps:\/\/stackoverflow.com\/questions\/52228692\/camel-json-validator-throws-stream-closed-exception?noredirect=1#comment91912061_52228692"
    },
    {
      "key":"CAMEL-12828",
      "title":"camel-restdsl-swagger:generate - Add option to generate dto objects",
      "description":"We should add an option to generete DTO objects defined in the swagger json file. But we should not create our own logic that does that, but execute the existing swagger-codegen maven plugin and then have some default convention. And make this useable for 90% of the use-cases, and if people need more advanced dto generation then they can use the swagger-codegen maven plugin as-is.\r\n\r\nWe should add some documentation on both situations and maybe a little example as well.",
      "assignee":"davsclaus",
      "type":"New Feature",
      "priority":"Major",
      "status":"Resolved",
      "text":"camel-restdsl-swagger:generate - Add option to generate dto objects We should add an option to generete DTO objects defined in the swagger json file. But we should not create our own logic that does that, but execute the existing swagger-codegen maven plugin and then have some default convention. And make this useable for 90% of the use-cases, and if people need more advanced dto generation then they can use the swagger-codegen maven plugin as-is.\r\n\r\nWe should add some documentation on both situations and maybe a little example as well."
    },
    {
      "key":"CAMEL-12827",
      "title":"camel-http-common HttpSendDynamicAware setting port to -1 when port is not defined in uri",
      "description":"If the route qualifies for SendDyanamicAware processing within the camel-http or camel-http4 component and the route does not specify a port it is getting set to -1.\u00a0 This should simply assume port 80 or 443 based on http vs https.\u00a0 Logic exists to trim those ports if they are specified however if you omit them your get the following exception:\r\n\r\n\u00a0\r\n{code:java}\r\n2018-09-21T16:20:32,797 | ERROR | Camel (camel-2) thread #10 - NettyEventExecutorGroup | AbstractErrorListProcessor\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 | 26 - com.somebundle - 1.0.76 | Error Handled for route: http:\/\/0.0.0.0:8880\/%7BsiteId%7D\/%7Bcountry%7D\/somepath?httpMethodRestrict=GET\r\norg.apache.camel.ResolveEndpointFailedException: Failed to resolve endpoint: https4:\/\/somedomain.com:-1?bridgeEndpoint=true due to: Expected scheme-specific part at index 6: https:\r\n\u00a0\u00a0 \u00a0at org.apache.camel.impl.DefaultCamelContext.getEndpoint(DefaultCamelContext.java:758) ~[91:org.apache.camel.camel-core:2.22.0]\r\n\u00a0\u00a0 \u00a0at org.apache.camel.util.CamelContextHelper.getMandatoryEndpoint(CamelContextHelper.java:80) ~[91:org.apache.camel.camel-core:2.22.0]\r\n\u00a0\u00a0 \u00a0at org.apache.camel.util.ExchangeHelper.resolveEndpoint(ExchangeHelper.java:91) ~[91:org.apache.camel.camel-core:2.22.0]\r\n\u00a0\u00a0 \u00a0at org.apache.camel.processor.SendDynamicProcessor.resolveEndpoint(SendDynamicProcessor.java:239) ~[91:org.apache.camel.camel-core:2.22.0]\r\n\u00a0\u00a0 \u00a0at org.apache.camel.processor.SendDynamicProcessor.process(SendDynamicProcessor.java:132) ~[91:org.apache.camel.camel-core:2.22.0]\r\n\u00a0\u00a0 \u00a0at org.apache.camel.processor.interceptor.TraceInterceptor.process(TraceInterceptor.java:181) ~[91:org.apache.camel.camel-core:2.22.0]\r\n\u00a0\u00a0 \u00a0at org.apache.camel.processor.InterceptorToAsyncProcessorBridge.process(InterceptorToAsyncProcessorBridge.java:67) ~[91:org.apache.camel.camel-core:2.22.0]{code}",
      "assignee":"davsclaus",
      "type":"Bug",
      "priority":"Major",
      "status":"Resolved",
      "text":"camel-http-common HttpSendDynamicAware setting port to -1 when port is not defined in uri If the route qualifies for SendDyanamicAware processing within the camel-http or camel-http4 component and the route does not specify a port it is getting set to -1.  This should simply assume port 80 or 443 based on http vs https.  Logic exists to trim those ports if they are specified however if you omit them your get the following exception:\r\n\r\n \r\n{code:java}\r\n2018-09-21T16:20:32,797 | ERROR | Camel (camel-2) thread #10 - NettyEventExecutorGroup | AbstractErrorListProcessor       | 26 - com.somebundle - 1.0.76 | Error Handled for route: http:\/\/0.0.0.0:8880\/%7BsiteId%7D\/%7Bcountry%7D\/somepath?httpMethodRestrict=GET\r\norg.apache.camel.ResolveEndpointFailedException: Failed to resolve endpoint: https4:\/\/somedomain.com:-1?bridgeEndpoint=true due to: Expected scheme-specific part at index 6: https:\r\n    at org.apache.camel.impl.DefaultCamelContext.getEndpoint(DefaultCamelContext.java:758) ~[91:org.apache.camel.camel-core:2.22.0]\r\n    at org.apache.camel.util.CamelContextHelper.getMandatoryEndpoint(CamelContextHelper.java:80) ~[91:org.apache.camel.camel-core:2.22.0]\r\n    at org.apache.camel.util.ExchangeHelper.resolveEndpoint(ExchangeHelper.java:91) ~[91:org.apache.camel.camel-core:2.22.0]\r\n    at org.apache.camel.processor.SendDynamicProcessor.resolveEndpoint(SendDynamicProcessor.java:239) ~[91:org.apache.camel.camel-core:2.22.0]\r\n    at org.apache.camel.processor.SendDynamicProcessor.process(SendDynamicProcessor.java:132) ~[91:org.apache.camel.camel-core:2.22.0]\r\n    at org.apache.camel.processor.interceptor.TraceInterceptor.process(TraceInterceptor.java:181) ~[91:org.apache.camel.camel-core:2.22.0]\r\n    at org.apache.camel.processor.InterceptorToAsyncProcessorBridge.process(InterceptorToAsyncProcessorBridge.java:67) ~[91:org.apache.camel.camel-core:2.22.0]{code}"
    },
    {
      "key":"CAMEL-12824",
      "title":"camel-route-parser - Add parser for rest-dsl",
      "description":"So we can have better tooling for rest-dsl",
      "assignee":"davsclaus",
      "type":"New Feature",
      "priority":"Major",
      "status":"Resolved",
      "text":"camel-route-parser - Add parser for rest-dsl So we can have better tooling for rest-dsl"
    },
    {
      "key":"CAMEL-12822",
      "title":"camel-http4 - Expose connection pool stats in JMX",
      "description":"So end users can track the stats of the client connection pool, for example to see when all connections are in use, or the number of idle connections and so on.",
      "assignee":"davsclaus",
      "type":"New Feature",
      "priority":"Major",
      "status":"Resolved",
      "text":"camel-http4 - Expose connection pool stats in JMX So end users can track the stats of the client connection pool, for example to see when all connections are in use, or the number of idle connections and so on."
    },
    {
      "key":"CAMEL-12821",
      "title":"Fix MQTT URI param typo",
      "description":"The URI params 'willQos' and 'qualityOfService' of the MQTT component have a typo in their enum description.",
      "assignee":"davsclaus",
      "type":"Bug",
      "priority":"Trivial",
      "status":"Resolved",
      "text":"Fix MQTT URI param typo The URI params 'willQos' and 'qualityOfService' of the MQTT component have a typo in their enum description."
    },
    {
      "key":"CAMEL-12805",
      "title":"camel-restdsl-swagger-plugin doesn't convert integer default value to string",
      "description":"When generating a RouteBuilder from a swagger that defines default parameter values of type integer, there is no conversion to a string when setting it:\r\n\r\nSwagger:\r\n\r\n\"limit\":{\r\n \"name\":\"limit\",\r\n \"in\":\"query\",\r\n \"type\":\"integer\",\r\n \"minimum\":1,\r\n \"default\":20,\r\n \"description\":\"the limit of the results for the collections query\"\r\n },\r\n\r\nRouteBuilder:\r\n\r\n.param()\r\n .name(\"limit\")\r\n .type(RestParamType.query)\r\n .dataType(\"integer\")\r\n .defaultValue(20)\r\n .required(false)\r\n .description(\"the limit of the results for the collections query\")\r\n .endParam()\r\n\r\ndefaultValue only accepts parameters of type string and therefore the generated code can't be compiled and needs to be corrected manually.\r\n\r\n\u00a0\r\n\r\n\u00a0\r\n\r\n\u00a0",
      "assignee":"davsclaus",
      "type":"Bug",
      "priority":"Major",
      "status":"Resolved",
      "text":"camel-restdsl-swagger-plugin doesn't convert integer default value to string When generating a RouteBuilder from a swagger that defines default parameter values of type integer, there is no conversion to a string when setting it:\r\n\r\nSwagger:\r\n\r\n\"limit\":{\r\n \"name\":\"limit\",\r\n \"in\":\"query\",\r\n \"type\":\"integer\",\r\n \"minimum\":1,\r\n \"default\":20,\r\n \"description\":\"the limit of the results for the collections query\"\r\n },\r\n\r\nRouteBuilder:\r\n\r\n.param()\r\n .name(\"limit\")\r\n .type(RestParamType.query)\r\n .dataType(\"integer\")\r\n .defaultValue(20)\r\n .required(false)\r\n .description(\"the limit of the results for the collections query\")\r\n .endParam()\r\n\r\ndefaultValue only accepts parameters of type string and therefore the generated code can't be compiled and needs to be corrected manually.\r\n\r\n \r\n\r\n \r\n\r\n "
    },
    {
      "key":"CAMEL-12782",
      "title":"swagger-java - Provide more clear exception when model class is not visible to ClassResolver",
      "description":"Within an OSGi the camel-swagger-java component be run within a different bundle than the routes and models required to generate the swagger document.\u00a0 In this case the swagger code may not be able to read the model.\u00a0 Currently this generates a Nullpointer Exception and the swagger document does not get rendered.\u00a0\r\n\r\nWould prefer that the exception be more specific to help developers with debugging.\u00a0 Also toyed with the idea of converting to a LOG statement instead of an exception but it may be better to fail fast.\r\n\r\n\u00a0\r\n{code:java}\r\norg.apache.camel.camel-swagger-java - 2.22.0 | Error rendering Swagger API due null\r\njava.lang.NullPointerException: null\r\n\u00a0\u00a0 \u00a0at org.apache.camel.swagger.RestModelConverters.readClass(RestModelConverters.java:32) ~[108:org.apache.camel.camel-swagger-java:2.22.0]\r\n\u00a0\u00a0 \u00a0at org.apache.camel.swagger.RestSwaggerReader.appendModels(RestSwaggerReader.java:755) ~[108:org.apache.camel.camel-swagger-java:2.22.0]\r\n\u00a0\u00a0 \u00a0at org.apache.camel.swagger.RestSwaggerReader.parse(RestSwaggerReader.java:227) ~[108:org.apache.camel.camel-swagger-java:2.22.0]\r\n\u00a0\u00a0 \u00a0at org.apache.camel.swagger.RestSwaggerReader.read(RestSwaggerReader.java:113) ~[108:org.apache.camel.camel-swagger-java:2.22.0]\r\n\u00a0\u00a0 \u00a0at org.apache.camel.swagger.RestSwaggerSupport.renderResourceListing(RestSwaggerSupport.java:210) ~[108:org.apache.camel.camel-swagger-java:2.22.0]\r\n\u00a0\u00a0 \u00a0at org.apache.camel.swagger.RestSwaggerProcessor.process(RestSwaggerProcessor.java:119) [108:org.apache.camel.camel-swagger-java:2.22.0]\r\n\u00a0\u00a0 \u00a0at org.apache.camel.component.rest.RestApiProducer.process(RestApiProducer.java:36) [89:org.apache.camel.camel-core:2.22.0]\r\n\u00a0\u00a0 \u00a0at org.apache.camel.util.AsyncProcessorConverterHelper$ProcessorToAsyncProcessorBridge.process(AsyncProcessorConverterHelper.java:61) [89:org.apache.camel.camel-core:2.22.0]\r\n\u00a0\u00a0 \u00a0at org.apache.camel.processor.SendProcessor.process(SendProcessor.java:148) [89:org.apache.camel.camel-core:2.22.0]\r\n\u00a0\u00a0 \u00a0at org.apache.camel.processor.interceptor.TraceInterceptor.process(TraceInterceptor.java:181) [89:org.apache.camel.camel-core:2.22.0]\r\n\u00a0\u00a0 \u00a0at org.apache.camel.processor.DelegateAsyncProcessor.process(DelegateAsyncProcessor.java:110) [89:org.apache.camel.camel-core:2.22.0]\r\n\u00a0\u00a0 \u00a0at org.apache.camel.processor.RedeliveryErrorHandler.process(RedeliveryErrorHandler.java:548) [89:org.apache.camel.camel-core:2.22.0]\r\n\u00a0\u00a0 \u00a0at org.apache.camel.processor.CamelInternalProcessor.process(CamelInternalProcessor.java:201) [89:org.apache.camel.camel-core:2.22.0]\r\n\u00a0\u00a0 \u00a0at org.apache.camel.processor.CamelInternalProcessor.process(CamelInternalProcessor.java:201) [89:org.apache.camel.camel-core:2.22.0]\r\n\u00a0\u00a0 \u00a0at org.apache.camel.component.netty4.handlers.ServerChannelHandler.processAsynchronously(ServerChannelHandler.java:141) [105:org.apache.camel.camel-netty4:2.22.0]\r\n\u00a0\u00a0 \u00a0at org.apache.camel.component.netty4.handlers.ServerChannelHandler.channelRead0(ServerChannelHandler.java:112) [105:org.apache.camel.camel-netty4:2.22.0]\r\n\u00a0\u00a0 \u00a0at org.apache.camel.component.netty4.http.handlers.HttpServerChannelHandler.channelRead0(HttpServerChannelHandler.java:213) [106:org.apache.camel.camel-netty4-http:2.22.0]\r\n\u00a0\u00a0 \u00a0at io.netty.channel.SimpleChannelInboundHandler.channelRead(SimpleChannelInboundHandler.java:105) [55:io.netty.transport:4.1.25.Final]\r\n\u00a0\u00a0 \u00a0at org.apache.camel.component.netty4.http.handlers.HttpServerMultiplexChannelHandler.channelRead0(HttpServerMultiplexChannelHandler.java:113) [106:org.apache.camel.camel-netty4-http:2.22.0]\r\n\u00a0\u00a0 \u00a0at io.netty.channel.SimpleChannelInboundHandler.channelRead(SimpleChannelInboundHandler.java:105) [55:io.netty.transport:4.1.25.Final]\r\n\u00a0\u00a0 \u00a0at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:362) [55:io.netty.transport:4.1.25.Final]\r\n\u00a0\u00a0 \u00a0at io.netty.channel.AbstractChannelHandlerContext.access$600(AbstractChannelHandlerContext.java:38) [55:io.netty.transport:4.1.25.Final]\r\n\u00a0\u00a0 \u00a0at io.netty.channel.AbstractChannelHandlerContext$7.run(AbstractChannelHandlerContext.java:353) [55:io.netty.transport:4.1.25.Final]\r\n\u00a0\u00a0 \u00a0at io.netty.util.concurrent.DefaultEventExecutor.run(DefaultEventExecutor.java:66) [51:io.netty.common:4.1.25.Final]\r\n\u00a0\u00a0 \u00a0at io.netty.util.concurrent.SingleThreadEventExecutor$5.run(SingleThreadEventExecutor.java:884) [51:io.netty.common:4.1.25.Final]\r\n\u00a0\u00a0 \u00a0at java.lang.Thread.run(Thread.java:748) [?:?]{code}",
      "assignee":"davsclaus",
      "type":"Bug",
      "priority":"Minor",
      "status":"Resolved",
      "text":"swagger-java - Provide more clear exception when model class is not visible to ClassResolver Within an OSGi the camel-swagger-java component be run within a different bundle than the routes and models required to generate the swagger document.  In this case the swagger code may not be able to read the model.  Currently this generates a Nullpointer Exception and the swagger document does not get rendered. \r\n\r\nWould prefer that the exception be more specific to help developers with debugging.  Also toyed with the idea of converting to a LOG statement instead of an exception but it may be better to fail fast.\r\n\r\n \r\n{code:java}\r\norg.apache.camel.camel-swagger-java - 2.22.0 | Error rendering Swagger API due null\r\njava.lang.NullPointerException: null\r\n    at org.apache.camel.swagger.RestModelConverters.readClass(RestModelConverters.java:32) ~[108:org.apache.camel.camel-swagger-java:2.22.0]\r\n    at org.apache.camel.swagger.RestSwaggerReader.appendModels(RestSwaggerReader.java:755) ~[108:org.apache.camel.camel-swagger-java:2.22.0]\r\n    at org.apache.camel.swagger.RestSwaggerReader.parse(RestSwaggerReader.java:227) ~[108:org.apache.camel.camel-swagger-java:2.22.0]\r\n    at org.apache.camel.swagger.RestSwaggerReader.read(RestSwaggerReader.java:113) ~[108:org.apache.camel.camel-swagger-java:2.22.0]\r\n    at org.apache.camel.swagger.RestSwaggerSupport.renderResourceListing(RestSwaggerSupport.java:210) ~[108:org.apache.camel.camel-swagger-java:2.22.0]\r\n    at org.apache.camel.swagger.RestSwaggerProcessor.process(RestSwaggerProcessor.java:119) [108:org.apache.camel.camel-swagger-java:2.22.0]\r\n    at org.apache.camel.component.rest.RestApiProducer.process(RestApiProducer.java:36) [89:org.apache.camel.camel-core:2.22.0]\r\n    at org.apache.camel.util.AsyncProcessorConverterHelper$ProcessorToAsyncProcessorBridge.process(AsyncProcessorConverterHelper.java:61) [89:org.apache.camel.camel-core:2.22.0]\r\n    at org.apache.camel.processor.SendProcessor.process(SendProcessor.java:148) [89:org.apache.camel.camel-core:2.22.0]\r\n    at org.apache.camel.processor.interceptor.TraceInterceptor.process(TraceInterceptor.java:181) [89:org.apache.camel.camel-core:2.22.0]\r\n    at org.apache.camel.processor.DelegateAsyncProcessor.process(DelegateAsyncProcessor.java:110) [89:org.apache.camel.camel-core:2.22.0]\r\n    at org.apache.camel.processor.RedeliveryErrorHandler.process(RedeliveryErrorHandler.java:548) [89:org.apache.camel.camel-core:2.22.0]\r\n    at org.apache.camel.processor.CamelInternalProcessor.process(CamelInternalProcessor.java:201) [89:org.apache.camel.camel-core:2.22.0]\r\n    at org.apache.camel.processor.CamelInternalProcessor.process(CamelInternalProcessor.java:201) [89:org.apache.camel.camel-core:2.22.0]\r\n    at org.apache.camel.component.netty4.handlers.ServerChannelHandler.processAsynchronously(ServerChannelHandler.java:141) [105:org.apache.camel.camel-netty4:2.22.0]\r\n    at org.apache.camel.component.netty4.handlers.ServerChannelHandler.channelRead0(ServerChannelHandler.java:112) [105:org.apache.camel.camel-netty4:2.22.0]\r\n    at org.apache.camel.component.netty4.http.handlers.HttpServerChannelHandler.channelRead0(HttpServerChannelHandler.java:213) [106:org.apache.camel.camel-netty4-http:2.22.0]\r\n    at io.netty.channel.SimpleChannelInboundHandler.channelRead(SimpleChannelInboundHandler.java:105) [55:io.netty.transport:4.1.25.Final]\r\n    at org.apache.camel.component.netty4.http.handlers.HttpServerMultiplexChannelHandler.channelRead0(HttpServerMultiplexChannelHandler.java:113) [106:org.apache.camel.camel-netty4-http:2.22.0]\r\n    at io.netty.channel.SimpleChannelInboundHandler.channelRead(SimpleChannelInboundHandler.java:105) [55:io.netty.transport:4.1.25.Final]\r\n    at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:362) [55:io.netty.transport:4.1.25.Final]\r\n    at io.netty.channel.AbstractChannelHandlerContext.access$600(AbstractChannelHandlerContext.java:38) [55:io.netty.transport:4.1.25.Final]\r\n    at io.netty.channel.AbstractChannelHandlerContext$7.run(AbstractChannelHandlerContext.java:353) [55:io.netty.transport:4.1.25.Final]\r\n    at io.netty.util.concurrent.DefaultEventExecutor.run(DefaultEventExecutor.java:66) [51:io.netty.common:4.1.25.Final]\r\n    at io.netty.util.concurrent.SingleThreadEventExecutor$5.run(SingleThreadEventExecutor.java:884) [51:io.netty.common:4.1.25.Final]\r\n    at java.lang.Thread.run(Thread.java:748) [?:?]{code}"
    },
    {
      "key":"CAMEL-12779",
      "title":"camel-spring-redis - When stopping consumer it should stop the message listener",
      "description":"The consumer needs to remove the message listener when its stopping so it wont continue to receive messages, which otherwise can happen when shutting down Camel graceful.\r\n\r\n",
      "assignee":"davsclaus",
      "type":"Bug",
      "priority":"Major",
      "status":"Resolved",
      "text":"camel-spring-redis - When stopping consumer it should stop the message listener The consumer needs to remove the message listener when its stopping so it wont continue to receive messages, which otherwise can happen when shutting down Camel graceful.\r\n\r\n"
    },
    {
      "key":"CAMEL-12778",
      "title":"CamelCatalog - Should be JMX compliant",
      "description":"We have this error\r\n\r\nFailed\r\norg.apache.camel.catalog.CamelCatalogMBeanExporterTest.testMBeanExporter\r\n\r\nFailing for the past 8 builds (Since Unstable#599 )\r\nTook 7 ms.\r\nError Message\r\norg.apache.camel.catalog.CamelCatalog: Method org.apache.camel.catalog.CamelCatalog.setSuggestionStrategy has parameter or return type that cannot be translated into an open type\r\nStacktrace\r\njavax.management.NotCompliantMBeanException: org.apache.camel.catalog.CamelCatalog: Method org.apache.camel.catalog.CamelCatalog.setSuggestionStrategy has parameter or return type that cannot be translated into an open type\r\n\tat org.apache.camel.catalog.CamelCatalogMBeanExporterTest.testMBeanExporter(CamelCatalogMBeanExporterTest.java:35)\r\nCaused by: java.lang.IllegalArgumentException: Method org.apache.camel.catalog.CamelCatalog.setSuggestionStrategy has parameter or return type that cannot be translated into an open type\r\n\tat org.apache.camel.catalog.CamelCatalogMBeanExporterTest.testMBeanExporter(CamelCatalogMBeanExporterTest.java:35)\r\nCaused by: javax.management.openmbean.OpenDataException: Cannot convert type: org.apache.camel.catalog.SuggestionStrategy\r\n\tat org.apache.camel.catalog.CamelCatalogMBeanExporterTest.testMBeanExporter(CamelCatalogMBeanExporterTest.java:35)\r\nCaused by: javax.management.openmbean.OpenDataException: Can't map org.apache.camel.catalog.SuggestionStrategy to an open data type\r\n\tat org.apache.camel.catalog.CamelCatalogMBeanExporterTest.testMBeanExporter(CamelCatalogMBeanExporterTest.java:35)",
      "assignee":"davsclaus",
      "type":"Bug",
      "priority":"Major",
      "status":"Resolved",
      "text":"CamelCatalog - Should be JMX compliant We have this error\r\n\r\nFailed\r\norg.apache.camel.catalog.CamelCatalogMBeanExporterTest.testMBeanExporter\r\n\r\nFailing for the past 8 builds (Since Unstable#599 )\r\nTook 7 ms.\r\nError Message\r\norg.apache.camel.catalog.CamelCatalog: Method org.apache.camel.catalog.CamelCatalog.setSuggestionStrategy has parameter or return type that cannot be translated into an open type\r\nStacktrace\r\njavax.management.NotCompliantMBeanException: org.apache.camel.catalog.CamelCatalog: Method org.apache.camel.catalog.CamelCatalog.setSuggestionStrategy has parameter or return type that cannot be translated into an open type\r\n\tat org.apache.camel.catalog.CamelCatalogMBeanExporterTest.testMBeanExporter(CamelCatalogMBeanExporterTest.java:35)\r\nCaused by: java.lang.IllegalArgumentException: Method org.apache.camel.catalog.CamelCatalog.setSuggestionStrategy has parameter or return type that cannot be translated into an open type\r\n\tat org.apache.camel.catalog.CamelCatalogMBeanExporterTest.testMBeanExporter(CamelCatalogMBeanExporterTest.java:35)\r\nCaused by: javax.management.openmbean.OpenDataException: Cannot convert type: org.apache.camel.catalog.SuggestionStrategy\r\n\tat org.apache.camel.catalog.CamelCatalogMBeanExporterTest.testMBeanExporter(CamelCatalogMBeanExporterTest.java:35)\r\nCaused by: javax.management.openmbean.OpenDataException: Can't map org.apache.camel.catalog.SuggestionStrategy to an open data type\r\n\tat org.apache.camel.catalog.CamelCatalogMBeanExporterTest.testMBeanExporter(CamelCatalogMBeanExporterTest.java:35)"
    },
    {
      "key":"CAMEL-12775",
      "title":"Using StubComponent can block routes depending on MEP",
      "description":"As the name implies and per the documentation 'stub:' should be a no-op.\r\n\r\nHowever, if the exchange pattarn is InOut, routes are actually blocked waiting for a response.\r\n\r\nDiscovered against camel 2.16.3\r\n\r\nConfirmed against Camel 2.22.0 (see attached test-case)\r\n\r\n\u00a0",
      "assignee":"davsclaus",
      "type":"Bug",
      "priority":"Major",
      "status":"Resolved",
      "text":"Using StubComponent can block routes depending on MEP As the name implies and per the documentation 'stub:' should be a no-op.\r\n\r\nHowever, if the exchange pattarn is InOut, routes are actually blocked waiting for a response.\r\n\r\nDiscovered against camel 2.16.3\r\n\r\nConfirmed against Camel 2.22.0 (see attached test-case)\r\n\r\n "
    },
    {
      "key":"CAMEL-12760",
      "title":"deprecate camel-xmlrpc",
      "description":"This project is no longer active maintained and last release was from 2010",
      "assignee":"davsclaus",
      "type":"Task",
      "priority":"Major",
      "status":"Resolved",
      "text":"deprecate camel-xmlrpc This project is no longer active maintained and last release was from 2010"
    },
    {
      "key":"CAMEL-12757",
      "title":"add camel-jclouds-starter",
      "description":"With SB 1 it was a conflict with a gson library. But now with SB2 we can add a jclouds starter.",
      "assignee":"davsclaus",
      "type":"Task",
      "priority":"Major",
      "status":"Resolved",
      "text":"add camel-jclouds-starter With SB 1 it was a conflict with a gson library. But now with SB2 we can add a jclouds starter."
    },
    {
      "key":"CAMEL-12756",
      "title":"`@ConditionalOnProperty` target property with no metadata",
      "description":"\u00a0Several auto-configurations use a condition on a property that has no metadata. As a result, trying to use it to customize the auto-configuration lead to a warning in an IDE.\r\n\r\nThe report detected the following:\r\n\u00a0\r\n{noformat}\r\norg.apache.camel.model.rest.springboot.RestConfigurationDefinitionAutoConfiguration [camel.rest.enabled]\r\norg.apache.camel.spring.boot.TypeConversionConfiguration [camel.springboot.typeConversion]\r\n{noformat}\r\n\r\nFor the latter, the property in {{@ConditionalOnProperty}} must use the canonical format (i.e. must be {{camel.springboot.type-conversion}})",
      "assignee":"davsclaus",
      "type":"Improvement",
      "priority":"Major",
      "status":"Resolved",
      "text":"`@ConditionalOnProperty` target property with no metadata  Several auto-configurations use a condition on a property that has no metadata. As a result, trying to use it to customize the auto-configuration lead to a warning in an IDE.\r\n\r\nThe report detected the following:\r\n \r\n{noformat}\r\norg.apache.camel.model.rest.springboot.RestConfigurationDefinitionAutoConfiguration [camel.rest.enabled]\r\norg.apache.camel.spring.boot.TypeConversionConfiguration [camel.springboot.typeConversion]\r\n{noformat}\r\n\r\nFor the latter, the property in {{@ConditionalOnProperty}} must use the canonical format (i.e. must be {{camel.springboot.type-conversion}})"
    },
    {
      "key":"CAMEL-12755",
      "title":"Upgrade Infinispan",
      "description":"We should upgrade to a newer version, 9.3.1",
      "assignee":"davsclaus",
      "type":"Task",
      "priority":"Major",
      "status":"Resolved",
      "text":"Upgrade Infinispan We should upgrade to a newer version, 9.3.1"
    },
    {
      "key":"CAMEL-12754",
      "title":"Upgrade Apache Ignite",
      "description":"We should upgrade ignite as it has some good fixes needed",
      "assignee":"davsclaus",
      "type":"Task",
      "priority":"Major",
      "status":"Resolved",
      "text":"Upgrade Apache Ignite We should upgrade ignite as it has some good fixes needed"
    },
    {
      "key":"CAMEL-12753",
      "title":"OPTIONS Http request on REST resource returns incorrect content of Allow header",
      "description":"I have a REST resource which consumes multiple Http methods (for example GET, POST and PUT). If I send OPTIONS request to resource and I expect to receive Allow Http header with this content:\r\nAllow: GET,POST,PUT,OPTIONS\r\nThat does not happen because I receive header which contains only two methods one of them is OPTIONS.\r\nAllow: GET,OPTIONS\r\nI have try multiple implementations and only camel-restlet works as I expect. These components contain bug:\r\ncamel-undertow\r\ncamel-servlet\r\ncamel-jetty\r\ncamel-netty4-http",
      "assignee":"davsclaus",
      "type":"Bug",
      "priority":"Minor",
      "status":"Resolved",
      "text":"OPTIONS Http request on REST resource returns incorrect content of Allow header I have a REST resource which consumes multiple Http methods (for example GET, POST and PUT). If I send OPTIONS request to resource and I expect to receive Allow Http header with this content:\r\nAllow: GET,POST,PUT,OPTIONS\r\nThat does not happen because I receive header which contains only two methods one of them is OPTIONS.\r\nAllow: GET,OPTIONS\r\nI have try multiple implementations and only camel-restlet works as I expect. These components contain bug:\r\ncamel-undertow\r\ncamel-servlet\r\ncamel-jetty\r\ncamel-netty4-http"
    },
    {
      "key":"CAMEL-12752",
      "title":"Upgrade jetty to 9.4.11",
      "description":"We are using 9.4.6 but there is a 9.4.11 version",
      "assignee":"davsclaus",
      "type":"Task",
      "priority":"Major",
      "status":"Resolved",
      "text":"Upgrade jetty to 9.4.11 We are using 9.4.6 but there is a 9.4.11 version"
    },
    {
      "key":"CAMEL-12746",
      "title":"Temporary reply queues being created with main endpoint autoAck setting",
      "description":"As discussed here:\r\n\r\n[http:\/\/camel.465427.n5.nabble.com\/Camel-with-Rabbitmq-messages-in-temp-reply-queue-not-being-acked-td5822286.html]\r\n\r\nWhen temporary reply queues are used on InOut capable routes with autoAck set to false on the main queue(s) the reply messages keep piling up in the temporary queue in an un-acked state until a consumer restart.\r\n\r\nThis can be prevented with a change to the\u00a0TemporaryQueueReplyManager line 139 to always start the consumer of temprary queues with auto acknowledge mode of true.\r\n\r\nChanging this:\r\n\r\n\u00a0 \u00a0 private void start() throws IOException {\r\n\u00a0 \u00a0 \u00a0 \u00a0 tag = channel.basicConsume(getReplyTo(), endpoint.isAutoAck(), this);\r\n\u00a0 \u00a0 }\r\n\r\nTo:\r\n\r\n\u00a0 \u00a0 private void start() throws IOException {\r\n\u00a0 \u00a0 \u00a0 \u00a0 tag = channel.basicConsume(getReplyTo(), *true*, this);\r\n\u00a0 \u00a0 }\r\n\r\n\u00a0",
      "assignee":"davsclaus",
      "type":"Bug",
      "priority":"Major",
      "status":"Resolved",
      "text":"Temporary reply queues being created with main endpoint autoAck setting As discussed here:\r\n\r\n[http:\/\/camel.465427.n5.nabble.com\/Camel-with-Rabbitmq-messages-in-temp-reply-queue-not-being-acked-td5822286.html]\r\n\r\nWhen temporary reply queues are used on InOut capable routes with autoAck set to false on the main queue(s) the reply messages keep piling up in the temporary queue in an un-acked state until a consumer restart.\r\n\r\nThis can be prevented with a change to the TemporaryQueueReplyManager line 139 to always start the consumer of temprary queues with auto acknowledge mode of true.\r\n\r\nChanging this:\r\n\r\n    private void start() throws IOException {\r\n        tag = channel.basicConsume(getReplyTo(), endpoint.isAutoAck(), this);\r\n    }\r\n\r\nTo:\r\n\r\n    private void start() throws IOException {\r\n        tag = channel.basicConsume(getReplyTo(), *true*, this);\r\n    }\r\n\r\n "
    },
    {
      "key":"CAMEL-12743",
      "title":"Some @link javadoc notations not handled well in auto-generated adocs",
      "description":"For example, this javadoc:\r\nhttps:\/\/github.com\/apache\/camel\/blob\/master\/camel-core\/src\/main\/java\/org\/apache\/camel\/model\/SplitDefinition.java#L257-L271\r\n{code:java}\r\n    \/**\r\n     * When in streaming mode, then the splitter splits the original message on-demand, and each splitted\r\n     * message is processed one by one. This reduces memory usage as the splitter do not split all the messages first,\r\n     * but then we do not know the total size, and therefore the {@link org.apache.camel.Exchange#SPLIT_SIZE} is empty.\r\n     * <p\/>\r\n     * In non-streaming mode (default) the splitter will split each message first, to know the total size, and then\r\n     * process each message one by one. This requires to keep all the splitted messages in memory and therefore requires\r\n     * more memory. The total size is provided in the {@link org.apache.camel.Exchange#SPLIT_SIZE} header.\r\n     * <p\/>\r\n     * The streaming mode also affects the aggregation behavior.\r\n     * If enabled then Camel will process replies out-of-order, eg in the order they come back.\r\n     * If disabled, Camel will process replies in the same order as the messages was splitted.\r\n     *\r\n     * @return the builder\r\n     *\/\r\n{code}\r\nis generated to:\r\nhttps:\/\/github.com\/apache\/camel\/blob\/master\/camel-core\/src\/main\/docs\/eips\/split-eip.adoc\r\n{code}\r\nWhen in streaming mode, then the splitter splits the original message on-demand, and each splitted message is processed one by one. This reduces memory usage as the splitter do not split all the messages first, but then we do not know the total size, and therefore the *link* org.apache.camel.ExchangeSPLIT_SIZE is empty. In non-streaming mode (default) the splitter will split each message first, to know the total size, and then process each message one by one. This requires to keep all the splitted messages in memory and therefore requires more memory. The total size is provided in the *link* org.apache.camel.ExchangeSPLIT_SIZE header. The streaming mode also affects the aggregation behavior. If enabled then Camel will process replies out-of-order, eg in the order they come back. If disabled, Camel will process replies in the same order as the messages was splitted.\r\n{code}\r\n\r\nIt is my impression that the current doc generator handles only FQCN well but fails to handle all other forms of Java source references.",
      "assignee":"davsclaus",
      "type":"Task",
      "priority":"Major",
      "status":"Resolved",
      "text":"Some @link javadoc notations not handled well in auto-generated adocs For example, this javadoc:\r\nhttps:\/\/github.com\/apache\/camel\/blob\/master\/camel-core\/src\/main\/java\/org\/apache\/camel\/model\/SplitDefinition.java#L257-L271\r\n{code:java}\r\n    \/**\r\n     * When in streaming mode, then the splitter splits the original message on-demand, and each splitted\r\n     * message is processed one by one. This reduces memory usage as the splitter do not split all the messages first,\r\n     * but then we do not know the total size, and therefore the {@link org.apache.camel.Exchange#SPLIT_SIZE} is empty.\r\n     * <p\/>\r\n     * In non-streaming mode (default) the splitter will split each message first, to know the total size, and then\r\n     * process each message one by one. This requires to keep all the splitted messages in memory and therefore requires\r\n     * more memory. The total size is provided in the {@link org.apache.camel.Exchange#SPLIT_SIZE} header.\r\n     * <p\/>\r\n     * The streaming mode also affects the aggregation behavior.\r\n     * If enabled then Camel will process replies out-of-order, eg in the order they come back.\r\n     * If disabled, Camel will process replies in the same order as the messages was splitted.\r\n     *\r\n     * @return the builder\r\n     *\/\r\n{code}\r\nis generated to:\r\nhttps:\/\/github.com\/apache\/camel\/blob\/master\/camel-core\/src\/main\/docs\/eips\/split-eip.adoc\r\n{code}\r\nWhen in streaming mode, then the splitter splits the original message on-demand, and each splitted message is processed one by one. This reduces memory usage as the splitter do not split all the messages first, but then we do not know the total size, and therefore the *link* org.apache.camel.ExchangeSPLIT_SIZE is empty. In non-streaming mode (default) the splitter will split each message first, to know the total size, and then process each message one by one. This requires to keep all the splitted messages in memory and therefore requires more memory. The total size is provided in the *link* org.apache.camel.ExchangeSPLIT_SIZE header. The streaming mode also affects the aggregation behavior. If enabled then Camel will process replies out-of-order, eg in the order they come back. If disabled, Camel will process replies in the same order as the messages was splitted.\r\n{code}\r\n\r\nIt is my impression that the current doc generator handles only FQCN well but fails to handle all other forms of Java source references."
    },
    {
      "key":"CAMEL-12740",
      "title":"Olingo4Component creates and ignores HttpAsyncClientBuilder",
      "description":"The Olingo4Component will create an instance of HttpAsyncClientBuilder is the provided Olingo4Configuration does not contain one. The new instance of HttpAsyncClientBuilder will be configured with timeout settings, proxy and SSL, but will never be used.\r\n\r\nExtract from Olingo4Component.createOlingo4App:\r\n{code:java}\r\nObject clientBuilder = configuration.getHttpAsyncClientBuilder();\r\nif (clientBuilder == null) {\r\n    HttpAsyncClientBuilder asyncClientBuilder = HttpAsyncClientBuilder.create();\r\n    Builder requestConfigBuilder = RequestConfig.custom();\r\n    requestConfigBuilder.setConnectTimeout(configuration.getConnectTimeout());\r\n    requestConfigBuilder.setSocketTimeout(configuration.getSocketTimeout());\r\n    HttpHost proxy = configuration.getProxy();\r\n    if (proxy != null) {\r\n        requestConfigBuilder.setProxy(proxy);\r\n    }\r\n\r\n    asyncClientBuilder.setDefaultRequestConfig(requestConfigBuilder.build());\r\n    SSLContextParameters sslContextParameters = configuration.getSslContextParameters();\r\n    if (sslContextParameters == null) {\r\n        sslContextParameters = this.retrieveGlobalSslContextParameters();\r\n    }\r\n\r\n    if (sslContextParameters == null) {\r\n        sslContextParameters = new SSLContextParameters();\r\n    }\r\n\r\n    try {\r\n        asyncClientBuilder.setSSLContext(sslContextParameters.createSSLContext(this.getCamelContext()));\r\n    } catch (GeneralSecurityException var8) {\r\n        throw ObjectHelper.wrapRuntimeCamelException(var8);\r\n    } catch (IOException var9) {\r\n        throw ObjectHelper.wrapRuntimeCamelException(var9);\r\n    }\r\n}\r\n\r\nOlingo4AppImpl olingo4App;\r\nif (clientBuilder != null && !(clientBuilder instanceof HttpAsyncClientBuilder)) {\r\n    olingo4App = new Olingo4AppImpl(configuration.getServiceUri(), (HttpClientBuilder)clientBuilder);\r\n} else {\r\n    olingo4App = new Olingo4AppImpl(configuration.getServiceUri(), (HttpAsyncClientBuilder)clientBuilder);\r\n}\r\n{code}\r\nThe class Olingo4AppImpl gets a null clientBuilder reference and then instantiates its own:\r\n{code:java}\r\npublic Olingo4AppImpl(String serviceUri, HttpAsyncClientBuilder builder) {\r\n    this.odataClient = ODataClientFactory.getClient();\r\n    this.odataReader = this.odataClient.getReader();\r\n    this.odataWriter = this.odataClient.getWriter();\r\n    this.setServiceUri(serviceUri);\r\n    CloseableHttpAsyncClient asyncClient;\r\n    if (builder == null) {\r\n        asyncClient = HttpAsyncClients.createDefault();\r\n    } else {\r\n        asyncClient = builder.build();\r\n    }\r\n\r\n    asyncClient.start();\r\n    this.client = asyncClient;\r\n    this.contentType = DEFAULT_CONTENT_TYPE;\r\n}\r\n{code}\r\nBecause of this, none of the Olingo4Configuration settings are used and for example connect and socket timeout defaults to -1.",
      "assignee":"davsclaus",
      "type":"Bug",
      "priority":"Major",
      "status":"Resolved",
      "text":"Olingo4Component creates and ignores HttpAsyncClientBuilder The Olingo4Component will create an instance of HttpAsyncClientBuilder is the provided Olingo4Configuration does not contain one. The new instance of HttpAsyncClientBuilder will be configured with timeout settings, proxy and SSL, but will never be used.\r\n\r\nExtract from Olingo4Component.createOlingo4App:\r\n{code:java}\r\nObject clientBuilder = configuration.getHttpAsyncClientBuilder();\r\nif (clientBuilder == null) {\r\n    HttpAsyncClientBuilder asyncClientBuilder = HttpAsyncClientBuilder.create();\r\n    Builder requestConfigBuilder = RequestConfig.custom();\r\n    requestConfigBuilder.setConnectTimeout(configuration.getConnectTimeout());\r\n    requestConfigBuilder.setSocketTimeout(configuration.getSocketTimeout());\r\n    HttpHost proxy = configuration.getProxy();\r\n    if (proxy != null) {\r\n        requestConfigBuilder.setProxy(proxy);\r\n    }\r\n\r\n    asyncClientBuilder.setDefaultRequestConfig(requestConfigBuilder.build());\r\n    SSLContextParameters sslContextParameters = configuration.getSslContextParameters();\r\n    if (sslContextParameters == null) {\r\n        sslContextParameters = this.retrieveGlobalSslContextParameters();\r\n    }\r\n\r\n    if (sslContextParameters == null) {\r\n        sslContextParameters = new SSLContextParameters();\r\n    }\r\n\r\n    try {\r\n        asyncClientBuilder.setSSLContext(sslContextParameters.createSSLContext(this.getCamelContext()));\r\n    } catch (GeneralSecurityException var8) {\r\n        throw ObjectHelper.wrapRuntimeCamelException(var8);\r\n    } catch (IOException var9) {\r\n        throw ObjectHelper.wrapRuntimeCamelException(var9);\r\n    }\r\n}\r\n\r\nOlingo4AppImpl olingo4App;\r\nif (clientBuilder != null && !(clientBuilder instanceof HttpAsyncClientBuilder)) {\r\n    olingo4App = new Olingo4AppImpl(configuration.getServiceUri(), (HttpClientBuilder)clientBuilder);\r\n} else {\r\n    olingo4App = new Olingo4AppImpl(configuration.getServiceUri(), (HttpAsyncClientBuilder)clientBuilder);\r\n}\r\n{code}\r\nThe class Olingo4AppImpl gets a null clientBuilder reference and then instantiates its own:\r\n{code:java}\r\npublic Olingo4AppImpl(String serviceUri, HttpAsyncClientBuilder builder) {\r\n    this.odataClient = ODataClientFactory.getClient();\r\n    this.odataReader = this.odataClient.getReader();\r\n    this.odataWriter = this.odataClient.getWriter();\r\n    this.setServiceUri(serviceUri);\r\n    CloseableHttpAsyncClient asyncClient;\r\n    if (builder == null) {\r\n        asyncClient = HttpAsyncClients.createDefault();\r\n    } else {\r\n        asyncClient = builder.build();\r\n    }\r\n\r\n    asyncClient.start();\r\n    this.client = asyncClient;\r\n    this.contentType = DEFAULT_CONTENT_TYPE;\r\n}\r\n{code}\r\nBecause of this, none of the Olingo4Configuration settings are used and for example connect and socket timeout defaults to -1."
    },
    {
      "key":"CAMEL-12739",
      "title":"TypeConverters are not registered to all contexts",
      "description":"When using multiple Camel contexts in CDI, auto-discovered TypeConverters are registered only to the first encoutered context.",
      "assignee":"davsclaus",
      "type":"Bug",
      "priority":"Major",
      "status":"Resolved",
      "text":"TypeConverters are not registered to all contexts When using multiple Camel contexts in CDI, auto-discovered TypeConverters are registered only to the first encoutered context."
    },
    {
      "key":"CAMEL-12736",
      "title":"Create FHIR authorization and transaction quickstart",
      "description":"Showcase the following features of the underlying HAPI library:\r\n\r\n[http:\/\/hapifhir.io\/doc_rest_client_interceptor.html]\r\n\r\n[http:\/\/hapifhir.io\/doc_rest_client_examples.html#Transaction_With_Placeholder_IDs]\u00a0\r\n\r\n\u00a0",
      "assignee":"davsclaus",
      "type":"Task",
      "priority":"Major",
      "status":"Resolved",
      "text":"Create FHIR authorization and transaction quickstart Showcase the following features of the underlying HAPI library:\r\n\r\n[http:\/\/hapifhir.io\/doc_rest_client_interceptor.html]\r\n\r\n[http:\/\/hapifhir.io\/doc_rest_client_examples.html#Transaction_With_Placeholder_IDs] \r\n\r\n "
    },
    {
      "key":"CAMEL-12735",
      "title":"XmlRouteParser does not handle usage of xml namespace prefix for camel",
      "description":"for instance with this file content, using the org.apache.camel.parser.XmlRouteParser.parseXmlRouteEndpoints(InputStream, String, String, List<CamelEndpointDetails>) method will not find the endpoint\r\n\r\n{quote}<?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n<beans xmlns=\"http:\/\/www.springframework.org\/schema\/beans\"\r\n    xmlns:xsi=\"http:\/\/www.w3.org\/2001\/XMLSchema-instance\" xsi:schemaLocation=\"        http:\/\/www.springframework.org\/schema\/beans http:\/\/www.springframework.org\/schema\/beans\/spring-beans.xsd        http:\/\/camel.apache.org\/schema\/spring http:\/\/camel.apache.org\/schema\/spring\/camel-spring.xsd\">\r\n    <camel:camelContext id=\"camel\" xmlns:camel=\"http:\/\/camel.apache.org\/schema\/spring\">\r\n        <camel:endpoint uri=\"timer:timerName?delay=p\"\/>\r\n        <camel:route id=\"a route\">\r\n            <camel:from id=\"_from1\" uri=\"timer:timerName?delay=1000\"\/>\r\n            <camel:to id=\"_to1\" uri=\"direct:drink\"\/>\r\n        <\/camel:route>\r\n    <\/camel:camelContext>\r\n<\/beans>{quote}",
      "assignee":"davsclaus",
      "type":"Improvement",
      "priority":"Major",
      "status":"Resolved",
      "text":"XmlRouteParser does not handle usage of xml namespace prefix for camel for instance with this file content, using the org.apache.camel.parser.XmlRouteParser.parseXmlRouteEndpoints(InputStream, String, String, List<CamelEndpointDetails>) method will not find the endpoint\r\n\r\n{quote}<?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n<beans xmlns=\"http:\/\/www.springframework.org\/schema\/beans\"\r\n    xmlns:xsi=\"http:\/\/www.w3.org\/2001\/XMLSchema-instance\" xsi:schemaLocation=\"        http:\/\/www.springframework.org\/schema\/beans http:\/\/www.springframework.org\/schema\/beans\/spring-beans.xsd        http:\/\/camel.apache.org\/schema\/spring http:\/\/camel.apache.org\/schema\/spring\/camel-spring.xsd\">\r\n    <camel:camelContext id=\"camel\" xmlns:camel=\"http:\/\/camel.apache.org\/schema\/spring\">\r\n        <camel:endpoint uri=\"timer:timerName?delay=p\"\/>\r\n        <camel:route id=\"a route\">\r\n            <camel:from id=\"_from1\" uri=\"timer:timerName?delay=1000\"\/>\r\n            <camel:to id=\"_to1\" uri=\"direct:drink\"\/>\r\n        <\/camel:route>\r\n    <\/camel:camelContext>\r\n<\/beans>{quote}"
    },
    {
      "key":"CAMEL-12734",
      "title":"camel-sql - Add support for basic dynamic query parameters in consumer",
      "description":"See SO\r\nhttps:\/\/stackoverflow.com\/questions\/51855665\/how-to-implement-stateful-polling-sql-consumer-in-camel\r\n\r\nIt would be nice if we add support for calling simple expressions like beans and the likes, so end users can have dynamic consumer queries in the SQL from routes ",
      "assignee":"davsclaus",
      "type":"New Feature",
      "priority":"Major",
      "status":"Resolved",
      "text":"camel-sql - Add support for basic dynamic query parameters in consumer See SO\r\nhttps:\/\/stackoverflow.com\/questions\/51855665\/how-to-implement-stateful-polling-sql-consumer-in-camel\r\n\r\nIt would be nice if we add support for calling simple expressions like beans and the likes, so end users can have dynamic consumer queries in the SQL from routes "
    },
    {
      "key":"CAMEL-12732",
      "title":"Kafka manual commit to file repository doesn't work properly (using Spring boot)",
      "description":"I'im trying to save the Kafka offset into FileStateRepository, the offset is correctly writing but it is not reading at route start so camel will read all the topic every time\r\n\r\n\u00a0\r\n{code:java}\r\n@Component\r\npublic class Route extends RouteBuilder {\r\n    @Override\r\n    public void configure() throws Exception {\r\n        from(kafka())\r\n                .to(\"log:TEST?level=INFO\")\r\n                .process(Route::commitKafka);\r\n    }\r\n\r\n    private String kafka() {\r\n\r\n        String kafkaEndpoint = \"kafka:\";\r\n\r\n        kafkaEndpoint += \"topictest\";\r\n        kafkaEndpoint += \"?brokers=\";\r\n        kafkaEndpoint += \"localhost:9092\";\r\n        kafkaEndpoint += \"&groupId=\";\r\n        kafkaEndpoint += \"TEST\";\r\n        kafkaEndpoint += \"&autoOffsetReset=\";\r\n        kafkaEndpoint += \"earliest\";\r\n        kafkaEndpoint += \"&autoCommitEnable=\";\r\n        kafkaEndpoint += false;\r\n        kafkaEndpoint += \"&allowManualCommit=\";\r\n        kafkaEndpoint += true;\r\n        kafkaEndpoint += \"&offsetRepository=\";\r\n        kafkaEndpoint += \"#fileStore\";\r\n\r\n        return kafkaEndpoint;\r\n    }\r\n\r\n    @Bean(name = \"fileStore\")\r\n    private FileStateRepository fileStateRepository() {\r\n        FileStateRepository fileStateRepository = FileStateRepository.fileStateRepository(new File(\"\/kafka\/offset_repo\/repo.dat\"));\r\n\r\n        \/\/ This will be empty\r\n        \/\/ System.out.println(fileStateRepository.getCache());\r\n        return fileStateRepository;\r\n    }\r\n\r\n    private static void commitKafka(Exchange exchange) {\r\n\r\n        KafkaManualCommit manual = exchange.getIn().getHeader(KafkaConstants.MANUAL_COMMIT, KafkaManualCommit.class);\r\n        manual.commitSync();\r\n    }\r\n}\r\n\r\n{code}\r\n\u00a0",
      "assignee":"davsclaus",
      "type":"Bug",
      "priority":"Major",
      "status":"Resolved",
      "text":"Kafka manual commit to file repository doesn't work properly (using Spring boot) I'im trying to save the Kafka offset into FileStateRepository, the offset is correctly writing but it is not reading at route start so camel will read all the topic every time\r\n\r\n \r\n{code:java}\r\n@Component\r\npublic class Route extends RouteBuilder {\r\n    @Override\r\n    public void configure() throws Exception {\r\n        from(kafka())\r\n                .to(\"log:TEST?level=INFO\")\r\n                .process(Route::commitKafka);\r\n    }\r\n\r\n    private String kafka() {\r\n\r\n        String kafkaEndpoint = \"kafka:\";\r\n\r\n        kafkaEndpoint += \"topictest\";\r\n        kafkaEndpoint += \"?brokers=\";\r\n        kafkaEndpoint += \"localhost:9092\";\r\n        kafkaEndpoint += \"&groupId=\";\r\n        kafkaEndpoint += \"TEST\";\r\n        kafkaEndpoint += \"&autoOffsetReset=\";\r\n        kafkaEndpoint += \"earliest\";\r\n        kafkaEndpoint += \"&autoCommitEnable=\";\r\n        kafkaEndpoint += false;\r\n        kafkaEndpoint += \"&allowManualCommit=\";\r\n        kafkaEndpoint += true;\r\n        kafkaEndpoint += \"&offsetRepository=\";\r\n        kafkaEndpoint += \"#fileStore\";\r\n\r\n        return kafkaEndpoint;\r\n    }\r\n\r\n    @Bean(name = \"fileStore\")\r\n    private FileStateRepository fileStateRepository() {\r\n        FileStateRepository fileStateRepository = FileStateRepository.fileStateRepository(new File(\"\/kafka\/offset_repo\/repo.dat\"));\r\n\r\n        \/\/ This will be empty\r\n        \/\/ System.out.println(fileStateRepository.getCache());\r\n        return fileStateRepository;\r\n    }\r\n\r\n    private static void commitKafka(Exchange exchange) {\r\n\r\n        KafkaManualCommit manual = exchange.getIn().getHeader(KafkaConstants.MANUAL_COMMIT, KafkaManualCommit.class);\r\n        manual.commitSync();\r\n    }\r\n}\r\n\r\n{code}\r\n "
    },
    {
      "key":"CAMEL-12727",
      "title":"java.util.ConcurrentModificationException at org.apache.camel.impl.DefaultExchange.createProperties(DefaultExchange.java:550) in 2.20.1",
      "description":"A concurrent access exception occurs during our load tests while consuming messages from a rabbitmq queue.\r\n\r\nThe call stack embedded below shows that the issue is related to an \"optimization\" which was introduced in https:\/\/issues.apache.org\/jira\/browse\/CAMEL-11330\u00a0to replace a ConcurrentHashMap with a regular one from version 2.19.5 to 2.20.0 onward.\r\n\r\nThe faulty code is still present in latest 2.22.0.\r\n\r\n\u00a0\r\n\r\n\u00a0",
      "assignee":"davsclaus",
      "type":"Bug",
      "priority":"Major",
      "status":"Resolved",
      "text":"java.util.ConcurrentModificationException at org.apache.camel.impl.DefaultExchange.createProperties(DefaultExchange.java:550) in 2.20.1 A concurrent access exception occurs during our load tests while consuming messages from a rabbitmq queue.\r\n\r\nThe call stack embedded below shows that the issue is related to an \"optimization\" which was introduced in https:\/\/issues.apache.org\/jira\/browse\/CAMEL-11330 to replace a ConcurrentHashMap with a regular one from version 2.19.5 to 2.20.0 onward.\r\n\r\nThe faulty code is still present in latest 2.22.0.\r\n\r\n \r\n\r\n "
    },
    {
      "key":"CAMEL-12716",
      "title":"Some spring-boot-starters generated have wrong component name in their javadoc documentation",
      "description":"See talk on @dev\r\nhttp:\/\/camel.465427.n5.nabble.com\/Re-generating-source-code-Modified-source-files-afterwards-tp5822115.html",
      "assignee":"davsclaus",
      "type":"Task",
      "priority":"Major",
      "status":"Resolved",
      "text":"Some spring-boot-starters generated have wrong component name in their javadoc documentation See talk on @dev\r\nhttp:\/\/camel.465427.n5.nabble.com\/Re-generating-source-code-Modified-source-files-afterwards-tp5822115.html"
    },
    {
      "key":"CAMEL-12714",
      "title":"support handlers in cxf payload data format without SEI",
      "description":"When using a cxf endpoint in payload mode, specifying a WSDL and no service class, the JAX-WS protocol handlers are ignored.\r\n\r\nDocumentation however indicates that payload mode supports protocol JAX-WS handlers.\r\n\r\nI made a pull request that activates the\u00a0JAX-WS handlers in this scenario as well, by using a\u00a0JaxWsEndpointImpl instead of EndpointImpl and removing some checks that avoid the handlers being\u00a0set.\r\n\r\n\u00a0",
      "assignee":"davsclaus",
      "type":"Improvement",
      "priority":"Major",
      "status":"Resolved",
      "text":"support handlers in cxf payload data format without SEI When using a cxf endpoint in payload mode, specifying a WSDL and no service class, the JAX-WS protocol handlers are ignored.\r\n\r\nDocumentation however indicates that payload mode supports protocol JAX-WS handlers.\r\n\r\nI made a pull request that activates the JAX-WS handlers in this scenario as well, by using a JaxWsEndpointImpl instead of EndpointImpl and removing some checks that avoid the handlers being set.\r\n\r\n "
    },
    {
      "key":"CAMEL-12713",
      "title":"relative paths can remove scheme from xslt URI",
      "description":"When using relative paths in an XSLT referenced from another one, the used URI scheme may be ignored.\r\n\r\ne.g. in case of an XSLT\u00a0specified by URI \"classpath:location\/master.xsl\",\u00a0 that\u00a0includes another one:\u00a0 <xsl:include href=\"..\/child.xsl\"\/>\r\n\r\nIn this case, the URI of child.xsl is resolved as just \"child.xsl\" instead of \"classpath:child.xsl\", omitting the URI scheme.\r\n\r\nThe cause is XsltUriResolver, in which\u00a0FileUtil.compactPath() is used to calculate the relative URI, but this call\u00a0ignores the colon separator and considers\u00a0\"classpath:location\" as a single path part.\r\n\r\nI'm creating a\u00a0pull request which passes the URI without scheme to FileUtil.compactPath().",
      "assignee":"davsclaus",
      "type":"Bug",
      "priority":"Major",
      "status":"Resolved",
      "text":"relative paths can remove scheme from xslt URI When using relative paths in an XSLT referenced from another one, the used URI scheme may be ignored.\r\n\r\ne.g. in case of an XSLT specified by URI \"classpath:location\/master.xsl\",  that includes another one:  <xsl:include href=\"..\/child.xsl\"\/>\r\n\r\nIn this case, the URI of child.xsl is resolved as just \"child.xsl\" instead of \"classpath:child.xsl\", omitting the URI scheme.\r\n\r\nThe cause is XsltUriResolver, in which FileUtil.compactPath() is used to calculate the relative URI, but this call ignores the colon separator and considers \"classpath:location\" as a single path part.\r\n\r\nI'm creating a pull request which passes the URI without scheme to FileUtil.compactPath()."
    },
    {
      "key":"CAMEL-12711",
      "title":"SFTP: Cannot specify bind address of local network interface",
      "description":"In an environment with multiple network interfaces, it might be necessary to specify the address of the local interface, to which the SFTP connection should bind.\u00a0Unfortunately, this is not possible with the\u00a0latest version of camel-ftp.\r\n\r\n\u00a0\r\n\r\nA new URI parameter 'bindAddress' should be introduces which can then be set to the IP-Address of the local network interface against which the SFTP connection should bind.",
      "assignee":"davsclaus",
      "type":"Improvement",
      "priority":"Major",
      "status":"Resolved",
      "text":"SFTP: Cannot specify bind address of local network interface In an environment with multiple network interfaces, it might be necessary to specify the address of the local interface, to which the SFTP connection should bind. Unfortunately, this is not possible with the latest version of camel-ftp.\r\n\r\n \r\n\r\nA new URI parameter 'bindAddress' should be introduces which can then be set to the IP-Address of the local network interface against which the SFTP connection should bind."
    },
    {
      "key":"CAMEL-12709",
      "title":"UseOriginalAggregationStrategy in outer loops",
      "description":"Using splitters with the UseOriginalAggregationStrategy +in a loop+ causes the splitter to return always the same original exchange.\r\n\r\n\u00a0\r\n{code:java}\r\n\/\/ my code is similar to the following one:\r\nfrom(\"direct:myLoop\")\r\n  .loop(simple(\"{{export.maxLoopsPerRun}}\"))\r\n    .setHeader(...) \/\/ changing header fields\r\n    .split(body(), new UseOriginalAggregationStrategy(null, false))\r\n      .to(\"direct:handleRecord\")\r\n    .end()\r\n    .log(\"${in.headers}\") \/\/ the headers of the exchange of the very first loop iteration\r\n  .end()\r\n{code}\r\nReason: Once the original exchange is set by UseOriginalAggregationStrategy#setOriginal(Exchange), it is not updated any more for loop iterations > 1.\r\n\r\n\u00a0",
      "assignee":"davsclaus",
      "type":"Bug",
      "priority":"Major",
      "status":"Resolved",
      "text":"UseOriginalAggregationStrategy in outer loops Using splitters with the UseOriginalAggregationStrategy +in a loop+ causes the splitter to return always the same original exchange.\r\n\r\n \r\n{code:java}\r\n\/\/ my code is similar to the following one:\r\nfrom(\"direct:myLoop\")\r\n  .loop(simple(\"{{export.maxLoopsPerRun}}\"))\r\n    .setHeader(...) \/\/ changing header fields\r\n    .split(body(), new UseOriginalAggregationStrategy(null, false))\r\n      .to(\"direct:handleRecord\")\r\n    .end()\r\n    .log(\"${in.headers}\") \/\/ the headers of the exchange of the very first loop iteration\r\n  .end()\r\n{code}\r\nReason: Once the original exchange is set by UseOriginalAggregationStrategy#setOriginal(Exchange), it is not updated any more for loop iterations > 1.\r\n\r\n "
    },
    {
      "key":"CAMEL-12705",
      "title":"Optimising toD via SendDynamicAware component removes the 3rd octet from IP address",
      "description":"IP address 10.192.1.10 is optimized as 10.192.10\r\n{code:java}\r\nDEBUG in SendDynamicProcessor:264 [main] - DynamicSendTo sendTo(netty4-http:http:\/\/10.192.1.10:8080\/client\/alerts\/summary?throwExceptionOnFailure=false) using ProducerCache with default cache size\r\n\r\nDEBUG in SendDynamicProcessor:125 [Camel (camel-1) thread #6 - seda:\/\/alertSummary] - Optimising toD via SendDynamicAware component: netty4-http to use static uri: netty4-http:http:10.192.10:8080\/path?throwExceptionOnFailure=false\r\n{code}\r\nThe issue seems to be in AbstractCamelCatalog class, method \"doAsEndpointUri(String scheme, Map<String, String> properties, String ampersand, boolean encode) throws URISyntaxException\"",
      "assignee":"davsclaus",
      "type":"Bug",
      "priority":"Major",
      "status":"Resolved",
      "text":"Optimising toD via SendDynamicAware component removes the 3rd octet from IP address IP address 10.192.1.10 is optimized as 10.192.10\r\n{code:java}\r\nDEBUG in SendDynamicProcessor:264 [main] - DynamicSendTo sendTo(netty4-http:http:\/\/10.192.1.10:8080\/client\/alerts\/summary?throwExceptionOnFailure=false) using ProducerCache with default cache size\r\n\r\nDEBUG in SendDynamicProcessor:125 [Camel (camel-1) thread #6 - seda:\/\/alertSummary] - Optimising toD via SendDynamicAware component: netty4-http to use static uri: netty4-http:http:10.192.10:8080\/path?throwExceptionOnFailure=false\r\n{code}\r\nThe issue seems to be in AbstractCamelCatalog class, method \"doAsEndpointUri(String scheme, Map<String, String> properties, String ampersand, boolean encode) throws URISyntaxException\""
    },
    {
      "key":"CAMEL-12702",
      "title":"camel-spring-boot - Improve its auto configuration docs",
      "description":"Some of these options has no docs, or its sparse, or has some javadoc link reference etc\r\nhttps:\/\/github.com\/apache\/camel\/blob\/master\/components\/camel-spring-boot\/src\/main\/docs\/spring-boot.adoc#spring-boot-auto-configuration",
      "assignee":"davsclaus",
      "type":"Improvement",
      "priority":"Major",
      "status":"Resolved",
      "text":"camel-spring-boot - Improve its auto configuration docs Some of these options has no docs, or its sparse, or has some javadoc link reference etc\r\nhttps:\/\/github.com\/apache\/camel\/blob\/master\/components\/camel-spring-boot\/src\/main\/docs\/spring-boot.adoc#spring-boot-auto-configuration"
    },
    {
      "key":"CAMEL-12699",
      "title":"Unable to combine retry with Hystrix circuit breaker",
      "description":"There as been more comment activity and no real resolution for the following ticket -> https:\/\/issues.apache.org\/jira\/browse\/CAMEL-12195. This is blocking our ability to create resilient clients combining retry\/exponential back-off\/circuit-breaker without pulling in other frameworks or hacking in our own retry logic.",
      "assignee":"davsclaus",
      "type":"Improvement",
      "priority":"Major",
      "status":"Resolved",
      "text":"Unable to combine retry with Hystrix circuit breaker There as been more comment activity and no real resolution for the following ticket -> https:\/\/issues.apache.org\/jira\/browse\/CAMEL-12195. This is blocking our ability to create resilient clients combining retry\/exponential back-off\/circuit-breaker without pulling in other frameworks or hacking in our own retry logic."
    },
    {
      "key":"CAMEL-12691",
      "title":"Allow configuration of org.xml.sax.ErrorHandler on DocumentBuilders used in Camel",
      "description":"I have trivial route that processes XMLs. When the XML is route and has no content (like empty file processed by {{<from uri=\"file:xxx\">}}) I'm getting:\r\n{noformat}\r\n[Fatal Error] :-1:-1: Premature end of file.\r\n{noformat}\r\n\r\nprinted directly on STDOUT.\r\n\r\nIf there was a way to make {{org.apache.camel.converter.jaxp.XmlConverter}} call {{javax.xml.parsers.DocumentBuilder#setErrorHandler}} (for example delegating to logger), it'd be great.",
      "assignee":"davsclaus",
      "type":"Improvement",
      "priority":"Major",
      "status":"Resolved",
      "text":"Allow configuration of org.xml.sax.ErrorHandler on DocumentBuilders used in Camel I have trivial route that processes XMLs. When the XML is route and has no content (like empty file processed by {{<from uri=\"file:xxx\">}}) I'm getting:\r\n{noformat}\r\n[Fatal Error] :-1:-1: Premature end of file.\r\n{noformat}\r\n\r\nprinted directly on STDOUT.\r\n\r\nIf there was a way to make {{org.apache.camel.converter.jaxp.XmlConverter}} call {{javax.xml.parsers.DocumentBuilder#setErrorHandler}} (for example delegating to logger), it'd be great."
    },
    {
      "key":"CAMEL-12667",
      "title":"camel-spring-boot - Turn of options with @NestedConfigurationProperty in generated auto configuration source",
      "description":"See my last comment on CAMEL-10197",
      "assignee":"davsclaus",
      "type":"Improvement",
      "priority":"Major",
      "status":"Resolved",
      "text":"camel-spring-boot - Turn of options with @NestedConfigurationProperty in generated auto configuration source See my last comment on CAMEL-10197"
    },
    {
      "key":"CAMEL-12661",
      "title":"Spring Boot auto configuration - NestedConfigurationProperty should only be for known Camel types",
      "description":"Currently we generte this for a range of complex objects that may appear as POJOs but they are likely not, so you cannot configure them, eg they dont have setters and a default no-arg constructor etc.\r\n\r\nWe have a blacklist today, but instead we should flip it to be a whitelist for known Camel types that can be configured like the SSLContextParameters and others.\r\n",
      "assignee":"davsclaus",
      "type":"Improvement",
      "priority":"Major",
      "status":"Resolved",
      "text":"Spring Boot auto configuration - NestedConfigurationProperty should only be for known Camel types Currently we generte this for a range of complex objects that may appear as POJOs but they are likely not, so you cannot configure them, eg they dont have setters and a default no-arg constructor etc.\r\n\r\nWe have a blacklist today, but instead we should flip it to be a whitelist for known Camel types that can be configured like the SSLContextParameters and others.\r\n"
    },
    {
      "key":"CAMEL-12660",
      "title":"Spring Boot configuration documentation should be polished",
      "description":"Some of the options have descriptions with html tags for advanced javadoc. We should remove those to make it plain then the spring tooling that generates the metadata json file will be improved for tooling, and also our own online ascii docs\r\n\r\nFor example\r\nhttps:\/\/github.com\/apache\/camel\/blob\/camel-12644\/components\/camel-spring-boot\/src\/main\/docs\/spring-boot.adoc#spring-boot-auto-configuration",
      "assignee":"davsclaus",
      "type":"Improvement",
      "priority":"Major",
      "status":"Resolved",
      "text":"Spring Boot configuration documentation should be polished Some of the options have descriptions with html tags for advanced javadoc. We should remove those to make it plain then the spring tooling that generates the metadata json file will be improved for tooling, and also our own online ascii docs\r\n\r\nFor example\r\nhttps:\/\/github.com\/apache\/camel\/blob\/camel-12644\/components\/camel-spring-boot\/src\/main\/docs\/spring-boot.adoc#spring-boot-auto-configuration"
    },
    {
      "key":"CAMEL-12656",
      "title":"camel-zipkin - Root Span Id is not reported if the route calls multiple route",
      "description":"Camel-Zipkin does not report traces with root span id when there are multiple routes.\u00a0\r\n\r\nFor example:\u00a0\r\n\r\n\u00a0\r\n{code:java}\r\nfrom(\"direct:foo\")\r\n        .delay(1000)\r\n        .to(\"direct:bar\")\r\n        .to(\"direct:moo\")\r\n        .to(\"direct:tar\");\r\n\r\nfrom(\"direct:bar\")\r\n        .delay(2000);\r\n\r\nfrom(\"direct:moo\")\r\n        .delay(1000);\r\n\r\nfrom(\"direct:tar\")\r\n        .delay(3000);\r\n{code}\r\nRoot SpanId(TraceId) should be for service-name = direct:foo and the trace in UI should show all the 4 routes in one sequence. But it breaks. Check the attached screenshot: Traces Breaking.png\r\n\r\nI looked into the code and figured out why its happening. Here is the code which is breaking the functionality.\r\n\r\nClass Name: ZipkinTracer.ZipkinRoutePolicy\r\nInside\u00a0onExchangeBegin() method\u00a0\r\n\r\n\u00a0\r\n{code:java}\r\n\/\/ add on completion after the route is done, but before the consumer writes the response\r\n\/\/ this allows us to track the zipkin event before returning the response which is the right time\r\nexchange.addOnCompletion(new SynchronizationAdapter() {\r\n    @Override\r\n    public void onAfterRoute(Route route, Exchange exchange) {\r\n        String serviceName = getServiceName(exchange, route.getEndpoint(), true, false);\r\n        Brave brave = getBrave(serviceName);\r\n        if (brave != null) {\r\n            serverResponse(brave, serviceName, exchange);\r\n        }\r\n    }\r\n\r\n    @Override\r\n    public String toString() {\r\n        return \"ZipkinTracerOnCompletion[\" + routeId + \"]\";\r\n    }\r\n});\r\n{code}\r\n\u00a0\r\n\r\n\u00a0\r\n\r\nUsing onAfterRoute() : \u00a0if the exchange is being routed through multiple routes, there will be callbacks for each route.\r\n\r\nI have fix for it:\u00a0\r\nIf I use\u00a0onExchangeDone() instead of above code. The traces are reported properly.\u00a0 Check screenshots.\r\n\r\n[https:\/\/zipkin.io\/pages\/instrumenting.html]\r\n\r\n*Note*\u00a0This process must be repeated if the service makes multiple downstream calls. That is each subsequent span will have the same trace id and parent id, but a new and different span id.",
      "assignee":"davsclaus",
      "type":"Bug",
      "priority":"Major",
      "status":"Resolved",
      "text":"camel-zipkin - Root Span Id is not reported if the route calls multiple route Camel-Zipkin does not report traces with root span id when there are multiple routes. \r\n\r\nFor example: \r\n\r\n \r\n{code:java}\r\nfrom(\"direct:foo\")\r\n        .delay(1000)\r\n        .to(\"direct:bar\")\r\n        .to(\"direct:moo\")\r\n        .to(\"direct:tar\");\r\n\r\nfrom(\"direct:bar\")\r\n        .delay(2000);\r\n\r\nfrom(\"direct:moo\")\r\n        .delay(1000);\r\n\r\nfrom(\"direct:tar\")\r\n        .delay(3000);\r\n{code}\r\nRoot SpanId(TraceId) should be for service-name = direct:foo and the trace in UI should show all the 4 routes in one sequence. But it breaks. Check the attached screenshot: Traces Breaking.png\r\n\r\nI looked into the code and figured out why its happening. Here is the code which is breaking the functionality.\r\n\r\nClass Name: ZipkinTracer.ZipkinRoutePolicy\r\nInside onExchangeBegin() method \r\n\r\n \r\n{code:java}\r\n\/\/ add on completion after the route is done, but before the consumer writes the response\r\n\/\/ this allows us to track the zipkin event before returning the response which is the right time\r\nexchange.addOnCompletion(new SynchronizationAdapter() {\r\n    @Override\r\n    public void onAfterRoute(Route route, Exchange exchange) {\r\n        String serviceName = getServiceName(exchange, route.getEndpoint(), true, false);\r\n        Brave brave = getBrave(serviceName);\r\n        if (brave != null) {\r\n            serverResponse(brave, serviceName, exchange);\r\n        }\r\n    }\r\n\r\n    @Override\r\n    public String toString() {\r\n        return \"ZipkinTracerOnCompletion[\" + routeId + \"]\";\r\n    }\r\n});\r\n{code}\r\n \r\n\r\n \r\n\r\nUsing onAfterRoute() :  if the exchange is being routed through multiple routes, there will be callbacks for each route.\r\n\r\nI have fix for it: \r\nIf I use onExchangeDone() instead of above code. The traces are reported properly.  Check screenshots.\r\n\r\n[https:\/\/zipkin.io\/pages\/instrumenting.html]\r\n\r\n*Note* This process must be repeated if the service makes multiple downstream calls. That is each subsequent span will have the same trace id and parent id, but a new and different span id."
    },
    {
      "key":"CAMEL-12650",
      "title":"Log messages that do not match with their method function",
      "description":"There are some possible copy and paste errors in the log messages (The logging statement was copied from an old place to a new place, but the message wasn't changed to adapt to the function of the new place) which may cause confusion when operators are reading the log messages.\u00a0\r\n\r\n\u00a0\r\n\r\nHere is a list of the related logging statements:\r\n\r\n\u00a0\r\n\r\n\u00a0\r\n\r\n*1. log.debug(\"Created FTPClient [connectTimeout: {}, soTimeout: {}, dataTimeout: {}, bufferSize: {}\" + \", receiveDataSocketBufferSize: {}, sendDataSocketBufferSize: {}]: {}\";*\r\n\r\n\u00a0 \u00a0 \u00a0\u00a0*Callsites:*\r\n * org.apache.camel.component.file.remote.*{color:#205081}FTPEndpoint{color}*.createRemoteFileOperations,\r\n * org.apache.camel.component.file.remote.*{color:#205081}FtpsEndpoint{color}*.createRemoteFileOperations,\r\n\r\n\u00a0\r\n\r\n*2. LOG.debug(\"Adding to producer service pool with key: {} for producer: {}\", endpoint, answer);*\r\n\r\n\u00a0 \u00a0 \u00a0\u00a0*Callsites:*\r\n * org.apache.camel.impl.*{color:#205081}ProducerCache{color}*.doGetProducer,\r\n\r\n * org.apache.camel.impl.*{color:#205081}ConsumerCache{color}*.doGetPollingConsumer\r\n\r\n\u00a0\r\n\r\n*3. LOG.debug(\"Trying to update the post {} with id {}\", exchange.getIn().getBody(), this.getConfiguration().getId());*\r\n\r\n\u00a0 \u00a0 \u00a0\u00a0*Callsites:*\r\n * org.apache.camel.component.wordpress.producer.{color:#205081}*WordpressPostProducer*.{color}processUpdate,\r\n\r\n * org.apache.camel.component.wordpress.producer.{color:#205081}*WordpressUserProducer*.{color}processUpdate\r\n\r\n\u00a0\r\n\r\n*4. LOG.error(\"Create a specific pod require specify a namespace name\");*\r\n\r\n\u00a0 \u00a0 \u00a0\u00a0*Callsites:*\r\n * org.apache.camel.component.kubernetes.pods.KubernetesPodsProducer.*{color:#205081}doCreatePod{color},*\r\n\r\n * org.apache.camel.component.kubernetes.deployments.KubernetesDeploymentsProducer.*{color:#205081}doCreateDeployment{color}*\r\n\r\n\u00a0\r\n\r\n*5. LOG.debug(\"Channel closed but no message received from address: {}\", producer.getConfiguration().getAddress());*\r\n\r\n\u00a0 \u00a0 \u00a0\u00a0*Callsites:*\r\n * org.apache.camel.component.netty.handlers.ClientChannelHandler.*{color:#205081}channelClosed{color},*\r\n\r\n * org.apache.camel.component.netty4.handlers.ClientChannelHandler.*{color:#205081}channelInactive{color}*\r\n\r\n\u00a0\r\n\r\n\u00a0\r\n\r\n*6. LOG.trace(\"Delete Broker command returned the error code {}\", ase.getErrorCode());*\r\n\r\n\u00a0 \u00a0 \u00a0\u00a0*Callsites:*\r\n * org.apache.camel.component.aws.mq.MQProducer.*{color:#205081}rebootBroker{color}*,\r\n\r\n * org.apache.camel.component.aws.mq.MQProducer.*{color:#205081}deleteBroker{color}*\r\n\r\n\u00a0\r\n\r\n*7. LOG.debug(\"Stopping JmsReplyManager: {} from processing replies from: {}\", replyManager, endpoint.getReplyTo() != null ? endpoint.getReplyTo() : \"temporary queue\");*\r\n\r\n\u00a0 \u00a0 \u00a0\u00a0*Callsites:*\r\n * org.apache.camel.component.rabbitmq.*{color:#205081}RabbitMQProducer{color}*.unInitReplyManager,\r\n\r\n * org.apache.camel.component.jms.*{color:#205081}JmsProducer{color}*.unInitReplyManager\r\n\r\n\u00a0\r\n\r\n*8. logger.warn(\"Error scanning JAR for custom Camel components\", e);*\r\n\r\n\u00a0 \u00a0 \u00a0\u00a0*Callsites:*\r\n * org.apache.camel.catalog.nexus.*{color:#205081}ComponentCatalogNexusRepository{color}*.addCustomCamelComponentsFromArtifact,\r\n\r\n * org.apache.camel.catalog.nexus.*{color:#205081}ConnectorCatalogNexusRepository.{color}*addCustomCamelConnectorFromArtifact\r\n\r\n\u00a0\r\n\r\n*9. LOGGER.debug(\"Subscribe to events for queue: {}\", resourceName);*\r\n\r\n\u00a0 \u00a0 \u00a0\u00a0*Callsites:*\r\n * org.apache.camel.component.atomix.client.value.{color:#205081}*AtomixValueConsumer*{color}.doStart,\r\n\r\n * org.apache.camel.component.atomix.client.queue.*{color:#205081}AtomixQueueConsumer{color}*.doStart\r\n\r\n\u00a0\r\n\r\n*10. LOG.warn(\"TimeoutEvent received at Sip Subscription Listener\");*\r\n\r\n\u00a0 \u00a0 \u00a0\u00a0*Callsites:*\r\n * org.apache.camel.component.sip.listener.{color:#205081}*SipSubscriptionListener*{color}.processTimeout,\r\n\r\n * org.apache.camel.component.sip.listener.{color:#205081}*SipPresenceAgentListener*{color}.processTimeout\r\n\r\n\u00a0\r\n\r\n*11. LOGGER.debug(\"Executing Docker Kill Container Request\");*\r\n\r\n\u00a0 \u00a0 \u00a0\u00a0*Callsites:*\r\n * org.apache.camel.component.docker.producer.DockerProducer.execute{color:#205081}*StopContainer*{color}Request,\r\n\r\n * org.apache.camel.component.docker.producer.DockerProducer.execute{color:#205081}*KillContainer*{color}Request\r\n\r\n\u00a0\r\n\r\n*12. LOG.trace(\"Rename Droplet {} : [{}] \", dropletId, action);*\r\n\r\n\u00a0 \u00a0 \u00a0\u00a0*Callsites:*\r\n * org.apache.camel.component.digitalocean.producer.DigitalOceanDropletsProducer.change.*{color:#205081}DropletKernel{color}*,\r\n\r\n * org.apache.camel.component.digitalocean.producer.DigitalOceanDropletsProducer.{color:#205081}*renameDroplet*{color}\r\n\r\n\u00a0\r\n\r\n\u00a0",
      "assignee":"davsclaus",
      "type":"Improvement",
      "priority":"Minor",
      "status":"Resolved",
      "text":"Log messages that do not match with their method function There are some possible copy and paste errors in the log messages (The logging statement was copied from an old place to a new place, but the message wasn't changed to adapt to the function of the new place) which may cause confusion when operators are reading the log messages. \r\n\r\n \r\n\r\nHere is a list of the related logging statements:\r\n\r\n \r\n\r\n \r\n\r\n*1. log.debug(\"Created FTPClient [connectTimeout: {}, soTimeout: {}, dataTimeout: {}, bufferSize: {}\" + \", receiveDataSocketBufferSize: {}, sendDataSocketBufferSize: {}]: {}\";*\r\n\r\n      *Callsites:*\r\n * org.apache.camel.component.file.remote.*{color:#205081}FTPEndpoint{color}*.createRemoteFileOperations,\r\n * org.apache.camel.component.file.remote.*{color:#205081}FtpsEndpoint{color}*.createRemoteFileOperations,\r\n\r\n \r\n\r\n*2. LOG.debug(\"Adding to producer service pool with key: {} for producer: {}\", endpoint, answer);*\r\n\r\n      *Callsites:*\r\n * org.apache.camel.impl.*{color:#205081}ProducerCache{color}*.doGetProducer,\r\n\r\n * org.apache.camel.impl.*{color:#205081}ConsumerCache{color}*.doGetPollingConsumer\r\n\r\n \r\n\r\n*3. LOG.debug(\"Trying to update the post {} with id {}\", exchange.getIn().getBody(), this.getConfiguration().getId());*\r\n\r\n      *Callsites:*\r\n * org.apache.camel.component.wordpress.producer.{color:#205081}*WordpressPostProducer*.{color}processUpdate,\r\n\r\n * org.apache.camel.component.wordpress.producer.{color:#205081}*WordpressUserProducer*.{color}processUpdate\r\n\r\n \r\n\r\n*4. LOG.error(\"Create a specific pod require specify a namespace name\");*\r\n\r\n      *Callsites:*\r\n * org.apache.camel.component.kubernetes.pods.KubernetesPodsProducer.*{color:#205081}doCreatePod{color},*\r\n\r\n * org.apache.camel.component.kubernetes.deployments.KubernetesDeploymentsProducer.*{color:#205081}doCreateDeployment{color}*\r\n\r\n \r\n\r\n*5. LOG.debug(\"Channel closed but no message received from address: {}\", producer.getConfiguration().getAddress());*\r\n\r\n      *Callsites:*\r\n * org.apache.camel.component.netty.handlers.ClientChannelHandler.*{color:#205081}channelClosed{color},*\r\n\r\n * org.apache.camel.component.netty4.handlers.ClientChannelHandler.*{color:#205081}channelInactive{color}*\r\n\r\n \r\n\r\n \r\n\r\n*6. LOG.trace(\"Delete Broker command returned the error code {}\", ase.getErrorCode());*\r\n\r\n      *Callsites:*\r\n * org.apache.camel.component.aws.mq.MQProducer.*{color:#205081}rebootBroker{color}*,\r\n\r\n * org.apache.camel.component.aws.mq.MQProducer.*{color:#205081}deleteBroker{color}*\r\n\r\n \r\n\r\n*7. LOG.debug(\"Stopping JmsReplyManager: {} from processing replies from: {}\", replyManager, endpoint.getReplyTo() != null ? endpoint.getReplyTo() : \"temporary queue\");*\r\n\r\n      *Callsites:*\r\n * org.apache.camel.component.rabbitmq.*{color:#205081}RabbitMQProducer{color}*.unInitReplyManager,\r\n\r\n * org.apache.camel.component.jms.*{color:#205081}JmsProducer{color}*.unInitReplyManager\r\n\r\n \r\n\r\n*8. logger.warn(\"Error scanning JAR for custom Camel components\", e);*\r\n\r\n      *Callsites:*\r\n * org.apache.camel.catalog.nexus.*{color:#205081}ComponentCatalogNexusRepository{color}*.addCustomCamelComponentsFromArtifact,\r\n\r\n * org.apache.camel.catalog.nexus.*{color:#205081}ConnectorCatalogNexusRepository.{color}*addCustomCamelConnectorFromArtifact\r\n\r\n \r\n\r\n*9. LOGGER.debug(\"Subscribe to events for queue: {}\", resourceName);*\r\n\r\n      *Callsites:*\r\n * org.apache.camel.component.atomix.client.value.{color:#205081}*AtomixValueConsumer*{color}.doStart,\r\n\r\n * org.apache.camel.component.atomix.client.queue.*{color:#205081}AtomixQueueConsumer{color}*.doStart\r\n\r\n \r\n\r\n*10. LOG.warn(\"TimeoutEvent received at Sip Subscription Listener\");*\r\n\r\n      *Callsites:*\r\n * org.apache.camel.component.sip.listener.{color:#205081}*SipSubscriptionListener*{color}.processTimeout,\r\n\r\n * org.apache.camel.component.sip.listener.{color:#205081}*SipPresenceAgentListener*{color}.processTimeout\r\n\r\n \r\n\r\n*11. LOGGER.debug(\"Executing Docker Kill Container Request\");*\r\n\r\n      *Callsites:*\r\n * org.apache.camel.component.docker.producer.DockerProducer.execute{color:#205081}*StopContainer*{color}Request,\r\n\r\n * org.apache.camel.component.docker.producer.DockerProducer.execute{color:#205081}*KillContainer*{color}Request\r\n\r\n \r\n\r\n*12. LOG.trace(\"Rename Droplet {} : [{}] \", dropletId, action);*\r\n\r\n      *Callsites:*\r\n * org.apache.camel.component.digitalocean.producer.DigitalOceanDropletsProducer.change.*{color:#205081}DropletKernel{color}*,\r\n\r\n * org.apache.camel.component.digitalocean.producer.DigitalOceanDropletsProducer.{color:#205081}*renameDroplet*{color}\r\n\r\n \r\n\r\n "
    },
    {
      "key":"CAMEL-12648",
      "title":"ExchangeSentEvent not fired if no EventNotifier is accepting ExchangeSendingEvent",
      "description":"Due to changes in\u00a0CAMEL-11346, many processors (including SendProcessor) no longer send ExchangeSentEvent when processing is\u00a0done. The StopWatch object is not created when EventHelper.notifyExchangeSending returns false. If no EventNotifier is registered to receive that event, it will be false. But an EventNotifier may still be registered to receive ExchangeSentEvent. The StopWatch should be created when there is an EventNotifier registered for ExchangeSentEvent even when ExchangeSendingEvent is not, unless those events are always required to be paired together.",
      "assignee":"davsclaus",
      "type":"Bug",
      "priority":"Major",
      "status":"Resolved",
      "text":"ExchangeSentEvent not fired if no EventNotifier is accepting ExchangeSendingEvent Due to changes in CAMEL-11346, many processors (including SendProcessor) no longer send ExchangeSentEvent when processing is done. The StopWatch object is not created when EventHelper.notifyExchangeSending returns false. If no EventNotifier is registered to receive that event, it will be false. But an EventNotifier may still be registered to receive ExchangeSentEvent. The StopWatch should be created when there is an EventNotifier registered for ExchangeSentEvent even when ExchangeSendingEvent is not, unless those events are always required to be paired together."
    },
    {
      "key":"CAMEL-12646",
      "title":"camel-spring-boot - Auto configuration of complex types should be more tooling friendly",
      "description":"If you have complex types like javax.sql.DataSource and wants to allow to configure this via spring boot autoconfiguration in application.properties - then the generated spring boot classes with all the options will use getter\/setter of types javax.sql.DataSource. That seems correct, but the spring-boot tooling itself (that generates additional json file) will skip those as it only support primitives and string types.\r\n\r\nSo we may need to fool, and generate the getter\/setter as String type as you use it for configuring it as a bean reference by id anyway, eg\r\n\r\ncamel.component.jdbc.data-source = #myDataSource\r\n\r\nWe can add in the javadoc that the type is javax.sql.DataSource.",
      "assignee":"davsclaus",
      "type":"Improvement",
      "priority":"Major",
      "status":"Resolved",
      "text":"camel-spring-boot - Auto configuration of complex types should be more tooling friendly If you have complex types like javax.sql.DataSource and wants to allow to configure this via spring boot autoconfiguration in application.properties - then the generated spring boot classes with all the options will use getter\/setter of types javax.sql.DataSource. That seems correct, but the spring-boot tooling itself (that generates additional json file) will skip those as it only support primitives and string types.\r\n\r\nSo we may need to fool, and generate the getter\/setter as String type as you use it for configuring it as a bean reference by id anyway, eg\r\n\r\ncamel.component.jdbc.data-source = #myDataSource\r\n\r\nWe can add in the javadoc that the type is javax.sql.DataSource."
    },
    {
      "key":"CAMEL-12645",
      "title":"camel-jdbc - Allow to use default datasource from spring-boot",
      "description":"Like we do in camel-sql where we lookup and use default data source if there is none configured and there is only 1. Then camel-sql and camel-jdbc is a bit similar and easier to use, such as when using spring boot.",
      "assignee":"davsclaus",
      "type":"Improvement",
      "priority":"Major",
      "status":"Resolved",
      "text":"camel-jdbc - Allow to use default datasource from spring-boot Like we do in camel-sql where we lookup and use default data source if there is none configured and there is only 1. Then camel-sql and camel-jdbc is a bit similar and easier to use, such as when using spring boot."
    },
    {
      "key":"CAMEL-12644",
      "title":"Generate documentation for Spring Boot starters",
      "description":"We could add auto-configuration properties section to the component documentation something like that can be seen in the [spring-boot documentation|https:\/\/docs.spring.io\/spring-boot\/docs\/1.5.14.RELEASE\/reference\/htmlsingle\/#common-application-properties] to help the users know which properties are available in application.[properties|yaml] under what keys.",
      "assignee":"davsclaus",
      "type":"New Feature",
      "priority":"Major",
      "status":"Resolved",
      "text":"Generate documentation for Spring Boot starters We could add auto-configuration properties section to the component documentation something like that can be seen in the [spring-boot documentation|https:\/\/docs.spring.io\/spring-boot\/docs\/1.5.14.RELEASE\/reference\/htmlsingle\/#common-application-properties] to help the users know which properties are available in application.[properties|yaml] under what keys."
    },
    {
      "key":"CAMEL-12643",
      "title":"camel-rabbitmq - Inadequate information for handling catch clauses",
      "description":"There are some situations that different exception types are caught, but the handling of those exceptions cannot show the differences between those types. Here are the code snippets which have this problem:\r\n{code}\r\norg.apache.camel.component.rabbitmq.*RabbitConsumer*.handleShutdownSignal, *Line 271*\r\n\r\ncatch (IOException | TimeoutException e)\r\n\r\n{ \u00a0 log.warn(\"Unable to obtain a RabbitMQ channel. Will try again\"); \u00a0 \u00a0 ... \u00a0 \u00a0 \u00a0}\r\n{code}\r\n\r\nIt may cause confusions to the person who\u00a0is reading the log, the person can not know what exception happened here and cannot distinguish if the exception type is\u00a0IOException or TimeoutException. Simply adding a full stack trace is able to improve it.\r\n\r\n\u00a0",
      "assignee":"davsclaus",
      "type":"Improvement",
      "priority":"Minor",
      "status":"Resolved",
      "text":"camel-rabbitmq - Inadequate information for handling catch clauses There are some situations that different exception types are caught, but the handling of those exceptions cannot show the differences between those types. Here are the code snippets which have this problem:\r\n{code}\r\norg.apache.camel.component.rabbitmq.*RabbitConsumer*.handleShutdownSignal, *Line 271*\r\n\r\ncatch (IOException | TimeoutException e)\r\n\r\n{   log.warn(\"Unable to obtain a RabbitMQ channel. Will try again\");     ...      }\r\n{code}\r\n\r\nIt may cause confusions to the person who is reading the log, the person can not know what exception happened here and cannot distinguish if the exception type is IOException or TimeoutException. Simply adding a full stack trace is able to improve it.\r\n\r\n "
    },
    {
      "key":"CAMEL-12640",
      "title":"tooling - Provide character position in validation result",
      "description":"currently the line start and line end are provided but not the character position",
      "assignee":"davsclaus",
      "type":"Improvement",
      "priority":"Minor",
      "status":"Resolved",
      "text":"tooling - Provide character position in validation result currently the line start and line end are provided but not the character position"
    },
    {
      "key":"CAMEL-12639",
      "title":"tooling - Provide line numbers for CamelEndpointDetails for java dsl",
      "description":"currently it is provided for xml dsl but not for java dsl",
      "assignee":"davsclaus",
      "type":"Improvement",
      "priority":"Minor",
      "status":"Resolved",
      "text":"tooling - Provide line numbers for CamelEndpointDetails for java dsl currently it is provided for xml dsl but not for java dsl"
    },
    {
      "key":"CAMEL-12638",
      "title":"DefaultFluentProducerTemplate is not thread safe",
      "description":"I think we have rediscovered the CAMEL-10820 bug. A\u00a0body of one request gets replaced with a body of proceeding request, in our case we use *request()* method instead of\u00a0*asyncSend()*.\r\n\r\nWe use camel together with spring-boot. Consider following code:\r\n\r\n\u00a0\r\n{code:java}\r\n@Service\r\npublic class UseCamelService {\r\n\r\n   private FluentProducerTemplate producer;\r\n\r\n   @Autowired\r\n   public UseCamelService(FluentProducerTemplate producer) {\r\n      this.producer = producer;\r\n   }\r\n\r\n   public String getValueFromCamel(String body) {\r\n      return producer.to(\"route\").withBody(body).request(String.class);\r\n   }\r\n\r\n}\r\n{code}\r\nIf *UseCamelService.getValueFromCamel()*\u00a0gets called from two different threads it is possible for the latter one to override the body of the first one.",
      "assignee":"davsclaus",
      "type":"Bug",
      "priority":"Major",
      "status":"Resolved",
      "text":"DefaultFluentProducerTemplate is not thread safe I think we have rediscovered the CAMEL-10820 bug. A body of one request gets replaced with a body of proceeding request, in our case we use *request()* method instead of *asyncSend()*.\r\n\r\nWe use camel together with spring-boot. Consider following code:\r\n\r\n \r\n{code:java}\r\n@Service\r\npublic class UseCamelService {\r\n\r\n   private FluentProducerTemplate producer;\r\n\r\n   @Autowired\r\n   public UseCamelService(FluentProducerTemplate producer) {\r\n      this.producer = producer;\r\n   }\r\n\r\n   public String getValueFromCamel(String body) {\r\n      return producer.to(\"route\").withBody(body).request(String.class);\r\n   }\r\n\r\n}\r\n{code}\r\nIf *UseCamelService.getValueFromCamel()* gets called from two different threads it is possible for the latter one to override the body of the first one."
    },
    {
      "key":"CAMEL-12636",
      "title":"camel-jmx - Should use a thread pool for routing notifications",
      "description":"The handleNotification event should be a simple noop operation. But if we route in Camel then it may do many things and call external systems etc. So ideally we should have a little thread pool to process these events - eg a like a wire tap.",
      "assignee":"davsclaus",
      "type":"Improvement",
      "priority":"Major",
      "status":"Resolved",
      "text":"camel-jmx - Should use a thread pool for routing notifications The handleNotification event should be a simple noop operation. But if we route in Camel then it may do many things and call external systems etc. So ideally we should have a little thread pool to process these events - eg a like a wire tap."
    },
    {
      "key":"CAMEL-12633",
      "title":"camel-jmx - Add support for monitoring boolean attribute changes",
      "description":"We can monitor counters, gauges and string values. But its not possible to monitor when a boolean value changes.\r\n\r\nYou cannot use the string monitor as JMX does not support that :(\r\n\r\nSo we need to add out own code to handle booleans",
      "assignee":"davsclaus",
      "type":"Improvement",
      "priority":"Minor",
      "status":"Resolved",
      "text":"camel-jmx - Add support for monitoring boolean attribute changes We can monitor counters, gauges and string values. But its not possible to monitor when a boolean value changes.\r\n\r\nYou cannot use the string monitor as JMX does not support that :(\r\n\r\nSo we need to add out own code to handle booleans"
    },
    {
      "key":"CAMEL-12628",
      "title":"[doc] camel-hawtdb documentation should be updated",
      "description":"The documentation for [camel-hawtdb |http:\/\/camel.apache.org\/hawtdb.html]says:\r\n\r\n{quote}\r\nThe [HawtDB|http:\/\/hawtdb.fusesource.org\/] project is being deprecated and replaced by [leveldb|https:\/\/code.google.com\/p\/leveldb\/] as the lightweight and embedable key value database. To make using leveldb easy there is a [leveldbjni|https:\/\/github.com\/fusesource\/leveldbjni] project for that. The Apache ActiveMQ project is planning on using leveldb as their primary file based message store in the future, to replace kahadb.\r\n{quote}\r\n\r\nThe last part about ActiveMQ replacing KahaDB with LevelDB is out of date. \r\nLevelDB has been deprecated on ActiveMQ and KahaDB remains the standard persistence adapter. The top level warning on http:\/\/activemq.apache.org\/leveldb-store.html. \r\nSo I suggest to remove that sentence at minimum.\r\n\r\nAlso, I am not sure do we still recommend LevelDB as an alternative to hawtdb or would there be even better options these days? \r\n\u00a0\r\n\r\n\u00a0",
      "assignee":"davsclaus",
      "type":"Improvement",
      "priority":"Major",
      "status":"Resolved",
      "text":"[doc] camel-hawtdb documentation should be updated The documentation for [camel-hawtdb |http:\/\/camel.apache.org\/hawtdb.html]says:\r\n\r\n{quote}\r\nThe [HawtDB|http:\/\/hawtdb.fusesource.org\/] project is being deprecated and replaced by [leveldb|https:\/\/code.google.com\/p\/leveldb\/] as the lightweight and embedable key value database. To make using leveldb easy there is a [leveldbjni|https:\/\/github.com\/fusesource\/leveldbjni] project for that. The Apache ActiveMQ project is planning on using leveldb as their primary file based message store in the future, to replace kahadb.\r\n{quote}\r\n\r\nThe last part about ActiveMQ replacing KahaDB with LevelDB is out of date. \r\nLevelDB has been deprecated on ActiveMQ and KahaDB remains the standard persistence adapter. The top level warning on http:\/\/activemq.apache.org\/leveldb-store.html. \r\nSo I suggest to remove that sentence at minimum.\r\n\r\nAlso, I am not sure do we still recommend LevelDB as an alternative to hawtdb or would there be even better options these days? \r\n \r\n\r\n "
    },
    {
      "key":"CAMEL-12627",
      "title":"Use Spring Boot autoconfigure-processor to optimize auto-configurations",
      "description":"As explained in [the its reference documentation|https:\/\/github.com\/spring-projects\/spring-boot\/blob\/master\/spring-boot-project\/spring-boot-docs\/src\/main\/asciidoc\/spring-boot-features.adoc#autoconfigure-module], Spring Boot provides a {{spring-boot-autoconfigure-processor}}.\r\n\r\nThis should be added as an optional dependency to each module that contains AutoConfiguration classes (and the `spring.factories` file declaring them).\r\n\r\nOnce configured, this annotation processor will generate metadata at compile time and will help Spring Boot process those auto-configurations without loading the actual classes in some cases.\r\n\r\nIn this project, the several modules are declaring auto-configurations but are not using this annotation processor. Could you add it to the build files?\r\n\r\n{code:xml}\r\n<dependency>\r\n <groupId>org.springframework.boot<\/groupId>\r\n <artifactId>spring-boot-autoconfigure-processor<\/artifactId>\r\n <optional>true<\/optional>\r\n<\/dependency>\r\n{code}\r\n\r\nOnce added, this should generate a {{spring-autoconfigure-metadata.properties}} file in the {{target\/classes\/META-INF}} folder of earch module.",
      "assignee":"davsclaus",
      "type":"Improvement",
      "priority":"Major",
      "status":"Resolved",
      "text":"Use Spring Boot autoconfigure-processor to optimize auto-configurations As explained in [the its reference documentation|https:\/\/github.com\/spring-projects\/spring-boot\/blob\/master\/spring-boot-project\/spring-boot-docs\/src\/main\/asciidoc\/spring-boot-features.adoc#autoconfigure-module], Spring Boot provides a {{spring-boot-autoconfigure-processor}}.\r\n\r\nThis should be added as an optional dependency to each module that contains AutoConfiguration classes (and the `spring.factories` file declaring them).\r\n\r\nOnce configured, this annotation processor will generate metadata at compile time and will help Spring Boot process those auto-configurations without loading the actual classes in some cases.\r\n\r\nIn this project, the several modules are declaring auto-configurations but are not using this annotation processor. Could you add it to the build files?\r\n\r\n{code:xml}\r\n<dependency>\r\n <groupId>org.springframework.boot<\/groupId>\r\n <artifactId>spring-boot-autoconfigure-processor<\/artifactId>\r\n <optional>true<\/optional>\r\n<\/dependency>\r\n{code}\r\n\r\nOnce added, this should generate a {{spring-autoconfigure-metadata.properties}} file in the {{target\/classes\/META-INF}} folder of earch module."
    },
    {
      "key":"CAMEL-12626",
      "title":"Camel Tracing is not working for route with redelivery strategy",
      "description":"Camel Tracing is not being executed if there is redelivery strategy defined.\r\n In our context we have switched on the camel Tracer with the following:\r\n{code:java}\r\n    public static void main(String[] args) throws Exception {\r\n        DefaultCamelContext context = new DefaultCamelContext();\r\n        context.addRoutes(new RouteBuilder() {\r\n            @Override\r\n            public void configure() throws Exception {\r\n\r\n                \/\/ If errorHandler with redelivery is removed then tracer output is visible again.\r\n                errorHandler(new DefaultErrorHandlerBuilder().maximumRedeliveries(3).redeliveryDelay(2000L));\r\n\r\n                from(\"direct:start\").process(new Processor() {\r\n                    public void process(Exchange exchange) throws Exception {\r\n                        System.out.println(\"PROCESSED\");\r\n                    }\r\n                });\r\n            }\r\n        });\r\n\r\n        \/\/ Enable Tracer.\r\n        context.setTracing(true);\r\n        context.start();\r\n        ProducerTemplate template = context.createProducerTemplate();\r\n        template.sendBody(\"direct:start\", \"foo\");\r\n    }\r\n{code}\r\nWe noticed that we were missing output from the tracer that we were excepting.\r\nIf you remove the errohandler with\u00a0redelivery you can see the output we expected:\r\n\r\n\u00a0\r\n{code:java}\r\n[main] INFO org.apache.camel.processor.interceptor.Tracer - ID-rmm-xxx-xxx-x-x >>> (route1) from(direct:\/\/start) --> Processor@0x130d63be <<< Pattern:InOnly, Headers:{breadcrumbId=ID-rmm-xxx-xxx-x-x}, BodyType:String, Body:foo\r\n{code}\r\n\u00a0",
      "assignee":"davsclaus",
      "type":"Bug",
      "priority":"Minor",
      "status":"Resolved",
      "text":"Camel Tracing is not working for route with redelivery strategy Camel Tracing is not being executed if there is redelivery strategy defined.\r\n In our context we have switched on the camel Tracer with the following:\r\n{code:java}\r\n    public static void main(String[] args) throws Exception {\r\n        DefaultCamelContext context = new DefaultCamelContext();\r\n        context.addRoutes(new RouteBuilder() {\r\n            @Override\r\n            public void configure() throws Exception {\r\n\r\n                \/\/ If errorHandler with redelivery is removed then tracer output is visible again.\r\n                errorHandler(new DefaultErrorHandlerBuilder().maximumRedeliveries(3).redeliveryDelay(2000L));\r\n\r\n                from(\"direct:start\").process(new Processor() {\r\n                    public void process(Exchange exchange) throws Exception {\r\n                        System.out.println(\"PROCESSED\");\r\n                    }\r\n                });\r\n            }\r\n        });\r\n\r\n        \/\/ Enable Tracer.\r\n        context.setTracing(true);\r\n        context.start();\r\n        ProducerTemplate template = context.createProducerTemplate();\r\n        template.sendBody(\"direct:start\", \"foo\");\r\n    }\r\n{code}\r\nWe noticed that we were missing output from the tracer that we were excepting.\r\nIf you remove the errohandler with redelivery you can see the output we expected:\r\n\r\n \r\n{code:java}\r\n[main] INFO org.apache.camel.processor.interceptor.Tracer - ID-rmm-xxx-xxx-x-x >>> (route1) from(direct:\/\/start) --> Processor@0x130d63be <<< Pattern:InOnly, Headers:{breadcrumbId=ID-rmm-xxx-xxx-x-x}, BodyType:String, Body:foo\r\n{code}\r\n "
    },
    {
      "key":"CAMEL-12610",
      "title":"Camel bean component invokes cached instance of bean (that impl processor) in Registry",
      "description":"Related SO question: [https:\/\/stackoverflow.com\/questions\/51108913\/camel-bean-component-invokes-cached-instance-of-named-dependent-bean]\r\n\r\nEvery invocation of bean component should query Registry for actual instance. Now it is cached in {{BeanProcessor#delegate}} variable, even if endpoint parameter {{cache=false}} specified.\r\n\r\nThis behavior breaks\u00a0java-ee\u00a0compliance: [https:\/\/docs.oracle.com\/javaee\/7\/api\/javax\/enterprise\/context\/Dependent.html]\r\n{quote}Every invocation of the\u00a0[{{Context.get(Contextual, CreationalContext)}}|https:\/\/docs.oracle.com\/javaee\/7\/api\/javax\/enterprise\/context\/spi\/Context.html#get-javax.enterprise.context.spi.Contextual-javax.enterprise.context.spi.CreationalContext-]\u00a0operation of the context object for the\u00a0{{@Dependent}}\u00a0scope returns a new instance of the given bean.\r\n{quote}\r\nMarking this as Major, because upgrading of Camel from 2.19.x to 2.2x.x leads to unpredictable results in CDI environment. Since this is tied to CDI environment, this issue is hard to notice even in well\u00a0junit covered application and can result in major issues in pre-production or production environment.\r\n\r\nFull reproducible project with unit test and deployable WAR package, which passes\u00a0with 2.19.x and lower. Fails with 2.20.x and higher [on Github|https:\/\/github.com\/bedlaj\/camel-dependent-bean].\u00a0\r\n\r\nAttachments are based on version 2.21.1",
      "assignee":"davsclaus",
      "type":"Bug",
      "priority":"Minor",
      "status":"Resolved",
      "text":"Camel bean component invokes cached instance of bean (that impl processor) in Registry Related SO question: [https:\/\/stackoverflow.com\/questions\/51108913\/camel-bean-component-invokes-cached-instance-of-named-dependent-bean]\r\n\r\nEvery invocation of bean component should query Registry for actual instance. Now it is cached in {{BeanProcessor#delegate}} variable, even if endpoint parameter {{cache=false}} specified.\r\n\r\nThis behavior breaks java-ee compliance: [https:\/\/docs.oracle.com\/javaee\/7\/api\/javax\/enterprise\/context\/Dependent.html]\r\n{quote}Every invocation of the [{{Context.get(Contextual, CreationalContext)}}|https:\/\/docs.oracle.com\/javaee\/7\/api\/javax\/enterprise\/context\/spi\/Context.html#get-javax.enterprise.context.spi.Contextual-javax.enterprise.context.spi.CreationalContext-] operation of the context object for the {{@Dependent}} scope returns a new instance of the given bean.\r\n{quote}\r\nMarking this as Major, because upgrading of Camel from 2.19.x to 2.2x.x leads to unpredictable results in CDI environment. Since this is tied to CDI environment, this issue is hard to notice even in well junit covered application and can result in major issues in pre-production or production environment.\r\n\r\nFull reproducible project with unit test and deployable WAR package, which passes with 2.19.x and lower. Fails with 2.20.x and higher [on Github|https:\/\/github.com\/bedlaj\/camel-dependent-bean]. \r\n\r\nAttachments are based on version 2.21.1"
    },
    {
      "key":"CAMEL-12609",
      "title":"DefaultExchangeFormatter: Make it easy to override the header and property formatting ",
      "description":"To omit certain headers (or mask their values) in ExchangeFormatter, one can write a custom implementation.\u00a0\r\n\r\nIn\u00a0[DefaultExchangeFormatter|[https:\/\/github.com\/apache\/camel\/blob\/apache-master\/camel-core\/src\/main\/java\/org\/apache\/camel\/processor\/DefaultExchangeFormatter.java],]\u00a0... it would be nice if the header-formatting (maybe the Property formatting) was done as separate methods that we could over-ride, while keeping the rest of the functionality.\r\n\r\nNot sure if it would be acceptable to do this without also changing the ExchangeFormatter interface to add such methods.",
      "assignee":"davsclaus",
      "type":"Improvement",
      "priority":"Minor",
      "status":"Resolved",
      "text":"DefaultExchangeFormatter: Make it easy to override the header and property formatting  To omit certain headers (or mask their values) in ExchangeFormatter, one can write a custom implementation. \r\n\r\nIn [DefaultExchangeFormatter|[https:\/\/github.com\/apache\/camel\/blob\/apache-master\/camel-core\/src\/main\/java\/org\/apache\/camel\/processor\/DefaultExchangeFormatter.java],] ... it would be nice if the header-formatting (maybe the Property formatting) was done as separate methods that we could over-ride, while keeping the rest of the functionality.\r\n\r\nNot sure if it would be acceptable to do this without also changing the ExchangeFormatter interface to add such methods."
    },
    {
      "key":"CAMEL-12597",
      "title":"camel-servlet - Add whitelist for accepted file types",
      "description":"Reported on user forum\r\n\r\nhttp:\/\/camel.465427.n5.nabble.com\/Report-Issues-Apache-Camel-Servlet-Component-td5820710.html",
      "assignee":"davsclaus",
      "type":"Improvement",
      "priority":"Major",
      "status":"Resolved",
      "text":"camel-servlet - Add whitelist for accepted file types Reported on user forum\r\n\r\nhttp:\/\/camel.465427.n5.nabble.com\/Report-Issues-Apache-Camel-Servlet-Component-td5820710.html"
    },
    {
      "key":"CAMEL-12594",
      "title":"Rest Producer - Query Parameters : Wrong query parameter name is used when header substitution is performed ",
      "description":"CAMEL-11050 [https:\/\/github.com\/apache\/camel\/commit\/35638b280be7ca43031ea4c5d937590f30495e70]\r\n\r\nIntroduced a bug in this line\u00a0\r\n\r\n[https:\/\/github.com\/apache\/camel\/blob\/6938a4ea6b68e295fae48f52e8e7cb2628f161a3\/camel-core\/src\/main\/java\/org\/apache\/camel\/component\/rest\/RestProducer.java#L409]\r\n\r\n\u00a0\r\n\r\nThe fix is (probably) to replace the line with :\r\n\r\nparams.put(entry.getKey(), value);\r\n\r\n\u00a0\r\n\r\n\u00a0\r\n\r\n\u00a0",
      "assignee":"davsclaus",
      "type":"Bug",
      "priority":"Major",
      "status":"Resolved",
      "text":"Rest Producer - Query Parameters : Wrong query parameter name is used when header substitution is performed  CAMEL-11050 [https:\/\/github.com\/apache\/camel\/commit\/35638b280be7ca43031ea4c5d937590f30495e70]\r\n\r\nIntroduced a bug in this line \r\n\r\n[https:\/\/github.com\/apache\/camel\/blob\/6938a4ea6b68e295fae48f52e8e7cb2628f161a3\/camel-core\/src\/main\/java\/org\/apache\/camel\/component\/rest\/RestProducer.java#L409]\r\n\r\n \r\n\r\nThe fix is (probably) to replace the line with :\r\n\r\nparams.put(entry.getKey(), value);\r\n\r\n \r\n\r\n \r\n\r\n "
    },
    {
      "key":"CAMEL-12590",
      "title":"Type converter confusion when camel-cxf and camel-mail are in same classpath",
      "description":"The CxfRsProducer needs to find a converter to take the String body of an exchange message and turn it into an Object[]. However when camel-mail is present in the classpath the converter search method picks: \r\n \r\n com.sun.mail.imap.SortTerm[] org.apache.camel.component.mail.MailConverters.toSortTerm(String msg) \r\n \r\nThis causes\u00a0the CxfRsProducer to bomb on a NoSuchMethodException. \r\n \r\n If camel-mail is removed, the CxfRsProducer\u00a0client works, finding the right String -> Object[] converter.\r\n\r\n[Issue discussed here on Camel user mailing list|http:\/\/camel.465427.n5.nabble.com\/Type-converter-misbehavior-with-camel-cxf-and-camel-mail-td5820546.html]\r\n\r\n\u00a0",
      "assignee":"davsclaus",
      "type":"Bug",
      "priority":"Minor",
      "status":"Resolved",
      "text":"Type converter confusion when camel-cxf and camel-mail are in same classpath The CxfRsProducer needs to find a converter to take the String body of an exchange message and turn it into an Object[]. However when camel-mail is present in the classpath the converter search method picks: \r\n \r\n com.sun.mail.imap.SortTerm[] org.apache.camel.component.mail.MailConverters.toSortTerm(String msg) \r\n \r\nThis causes the CxfRsProducer to bomb on a NoSuchMethodException. \r\n \r\n If camel-mail is removed, the CxfRsProducer client works, finding the right String -> Object[] converter.\r\n\r\n[Issue discussed here on Camel user mailing list|http:\/\/camel.465427.n5.nabble.com\/Type-converter-misbehavior-with-camel-cxf-and-camel-mail-td5820546.html]\r\n\r\n "
    },
    {
      "key":"CAMEL-12589",
      "title":"Surviving Header AGGREGATION_COMPLETE_ALL_GROUPS_INCLUSIVE affects following aggregations",
      "description":"When AGGREGATION_COMPLETE_ALL_GROUPS_INCLUSIVE is once set true it survives current aggregation processing and affects in unexpected way following aggregation by triggering \"forceCompletionOfAllGroups()\" again\r\n\r\nin next code snippet might be needed some additional handling when the header is true:\r\n{code:java}\r\nprotected void doProcess(Exchange exchange) throws Exception {\r\n...\r\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 \/\/ check for the special header to force completion of all groups (inclusive of the message)\r\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 boolean completeAllGroupsInclusive = exchange.getIn().getHeader(Exchange.AGGREGATION_COMPLETE_ALL_GROUPS_INCLUSIVE, false, boolean.class);\r\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 if (completeAllGroupsInclusive) {\r\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 forceCompletionOfAllGroups();\r\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 }\r\n...\r\n\r\n{code}\r\nthis consideration is made by analysing similar behavior and lifecycle of header AGGREGATION_COMPLETE_ALL_GROUPS:\r\n{code:java}\r\nprivate List<Exchange> doAggregation(String key, Exchange newExchange) throws CamelExchangeException {\r\n...\r\n...\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 \u00a0\r\n\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\/\/ check for the special exchange property to force completion of all groups\r\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 boolean completeAllGroups = answer.getProperty(Exchange.AGGREGATION_COMPLETE_ALL_GROUPS, false, boolean.class);\r\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 if (completeAllGroups) {\r\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 \/\/ remove the exchange property so we do not complete again\r\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 answer.removeProperty(Exchange.AGGREGATION_COMPLETE_ALL_GROUPS);\r\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 forceCompletionOfAllGroups();\r\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 } else if (isCompletionOnNewCorrelationGroup() && originalExchange == null) {\r\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 \/\/ its a new group so force complete of all existing groups\r\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 forceCompletionOfAllGroups();\r\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 }\r\n...\r\n{code}",
      "assignee":"davsclaus",
      "type":"Bug",
      "priority":"Major",
      "status":"Closed",
      "text":"Surviving Header AGGREGATION_COMPLETE_ALL_GROUPS_INCLUSIVE affects following aggregations When AGGREGATION_COMPLETE_ALL_GROUPS_INCLUSIVE is once set true it survives current aggregation processing and affects in unexpected way following aggregation by triggering \"forceCompletionOfAllGroups()\" again\r\n\r\nin next code snippet might be needed some additional handling when the header is true:\r\n{code:java}\r\nprotected void doProcess(Exchange exchange) throws Exception {\r\n...\r\n        \/\/ check for the special header to force completion of all groups (inclusive of the message)\r\n        boolean completeAllGroupsInclusive = exchange.getIn().getHeader(Exchange.AGGREGATION_COMPLETE_ALL_GROUPS_INCLUSIVE, false, boolean.class);\r\n        if (completeAllGroupsInclusive) {\r\n            forceCompletionOfAllGroups();\r\n        }\r\n...\r\n\r\n{code}\r\nthis consideration is made by analysing similar behavior and lifecycle of header AGGREGATION_COMPLETE_ALL_GROUPS:\r\n{code:java}\r\nprivate List<Exchange> doAggregation(String key, Exchange newExchange) throws CamelExchangeException {\r\n...\r\n...        \r\n        \/\/ check for the special exchange property to force completion of all groups\r\n        boolean completeAllGroups = answer.getProperty(Exchange.AGGREGATION_COMPLETE_ALL_GROUPS, false, boolean.class);\r\n        if (completeAllGroups) {\r\n            \/\/ remove the exchange property so we do not complete again\r\n            answer.removeProperty(Exchange.AGGREGATION_COMPLETE_ALL_GROUPS);\r\n            forceCompletionOfAllGroups();\r\n        } else if (isCompletionOnNewCorrelationGroup() && originalExchange == null) {\r\n            \/\/ its a new group so force complete of all existing groups\r\n            forceCompletionOfAllGroups();\r\n        }\r\n...\r\n{code}"
    },
    {
      "key":"CAMEL-12571",
      "title":"Seda component forgets URI setting when duplicates are present",
      "description":"when {color:#008000}blockWhenFull=true&blockWhenFull=true {color}{color:#333333}is set twice the option is not set at all{color}\r\n\r\n{color:#333333}it might out of context but from my point of view the last one should win (as it is in a properties file){color}\r\n\r\n{color:#333333}of if an error should be thrown could also be welcome{color}\r\n\r\n\u00a0\r\n\r\n{color:#333333}I quickly adapted{color} SedaComponentConfigurationAndDocumentationTest (I know, it uses now deprecated stuff) and the result is an array of set values ( 2 in this case) and the test fails.\r\n\r\nkind regards\r\n\r\nG.\r\n\r\n\u00a0",
      "assignee":"davsclaus",
      "type":"Bug",
      "priority":"Trivial",
      "status":"Closed",
      "text":"Seda component forgets URI setting when duplicates are present when {color:#008000}blockWhenFull=true&blockWhenFull=true {color}{color:#333333}is set twice the option is not set at all{color}\r\n\r\n{color:#333333}it might out of context but from my point of view the last one should win (as it is in a properties file){color}\r\n\r\n{color:#333333}of if an error should be thrown could also be welcome{color}\r\n\r\n \r\n\r\n{color:#333333}I quickly adapted{color} SedaComponentConfigurationAndDocumentationTest (I know, it uses now deprecated stuff) and the result is an array of set values ( 2 in this case) and the test fails.\r\n\r\nkind regards\r\n\r\nG.\r\n\r\n "
    },
    {
      "key":"CAMEL-12567",
      "title":"camel-stream - Add support for configuring timeout for HTTP urls",
      "description":"So you can set connect and read timeouts.",
      "assignee":"davsclaus",
      "type":"New Feature",
      "priority":"Major",
      "status":"Resolved",
      "text":"camel-stream - Add support for configuring timeout for HTTP urls So you can set connect and read timeouts."
    },
    {
      "key":"CAMEL-12566",
      "title":"camel-stream - Add support for HTTP headers",
      "description":"Asked on user forum\r\n\r\nhttp:\/\/camel.465427.n5.nabble.com\/url-http-streaming-issue-tp5820467.html",
      "assignee":"davsclaus",
      "type":"New Feature",
      "priority":"Major",
      "status":"Resolved",
      "text":"camel-stream - Add support for HTTP headers Asked on user forum\r\n\r\nhttp:\/\/camel.465427.n5.nabble.com\/url-http-streaming-issue-tp5820467.html"
    },
    {
      "key":"CAMEL-12565",
      "title":"outputTypeWithValidate (or inputTypeWithValidate) + validator()... doesn't work as expected",
      "description":"{code:java}\r\npackage org.mike.tests;\r\n\r\nimport org.apache.camel.ValidationException;\r\nimport org.apache.camel.builder.RouteBuilder;\r\nimport org.apache.camel.test.junit4.CamelTestSupport;\r\nimport org.junit.Test;\r\n\r\npublic class ValidatorTests extends CamelTestSupport {\r\n    @Override\r\n    protected RouteBuilder createRouteBuilder() throws Exception {\r\n        return new RouteBuilder() {\r\n            @Override\r\n            public void configure() throws Exception {\r\n\r\n                validator()\r\n                        .type(String.class)\r\n                        .withExpression(bodyAs(String.class).isEqualToIgnoreCase(\"valid\"));\r\n\r\n                onException(ValidationException.class)\r\n                        .handled(true)\r\n                        .log(\"Invalid predicate: ${exception.message}\")\r\n                        .to(\"mock:invalid\");\r\n\r\n                from(\"direct:in\")\r\n                        \/\/.validate(bodyAs(String.class).isEqualToIgnoreCase(\"valid\"))\r\n                        .outputTypeWithValidate(String.class) \/\/ or .inputTypeWithValidate(String.class)\r\n                        .to(\"mock:out\");\r\n            }\r\n        };\r\n    }\r\n\r\n    @Test\r\n    public void testValid() throws InterruptedException {\r\n\r\n        getMockEndpoint(\"mock:out\").expectedMessageCount(1);\r\n        getMockEndpoint(\"mock:invalid\").expectedMessageCount(0);\r\n\r\n        template.sendBody(\"direct:in\", \"valid\");\r\n\r\n        assertMockEndpointsSatisfied();\r\n    }\r\n\r\n    @Test\r\n    public void testInvalid() throws InterruptedException {\r\n        getMockEndpoint(\"mock:out\").expectedMessageCount(0);\r\n        getMockEndpoint(\"mock:invalid\").expectedMessageCount(1);\r\n\r\n        template.sendBody(\"direct:in\", \"wrong\");\r\n\r\n        assertMockEndpointsSatisfied();\r\n    }\r\n}\r\n\r\n\r\n{code}\r\nExpected result: both tests pass\r\n\r\nActual result: 'testValid' - passed, 'testInvalid' - failed\r\n\r\nIf uncomment line 25 & comment 26\r\n{code:java}\r\n.validate(bodyAs(String.class).isEqualToIgnoreCase(\"valid\"))\r\n\/\/.inputTypeWithValidate(String.class)\r\n{code}\r\ntests will OK\r\n\r\n\u00a0\r\n\r\nOther test case with same results\r\n\r\n\u00a0\r\n{code:java}\r\npackage org.mike.tests;\r\n\r\nimport org.apache.camel.Message;\r\nimport org.apache.camel.ValidationException;\r\nimport org.apache.camel.builder.RouteBuilder;\r\nimport org.apache.camel.impl.JndiRegistry;\r\nimport org.apache.camel.spi.DataType;\r\nimport org.apache.camel.spi.Validator;\r\nimport org.apache.camel.test.junit4.CamelTestSupport;\r\nimport org.junit.Test;\r\nimport org.slf4j.Logger;\r\nimport org.slf4j.LoggerFactory;\r\n\r\npublic class BeanValidatorTest extends CamelTestSupport {\r\n    @Override\r\n    protected RouteBuilder createRouteBuilder() throws Exception {\r\n        return new RouteBuilder() {\r\n            @Override\r\n            public void configure() throws Exception {\r\n                validator()\r\n                        .type(\"toValidate\")\r\n                        .withBean(\"testValidator\");\r\n\r\n                onException(ValidationException.class)\r\n                        .handled(true)\r\n                        .log(\"Invalid validation: ${exception.message}\")\r\n                        .to(\"mock:invalid\");\r\n\r\n                from(\"direct:in\")\r\n                        .outputTypeWithValidate(\"toValidate\")\r\n                        .to(\"mock:out\");\r\n            }\r\n        };\r\n    }\r\n\r\n    public static class TestValidator extends Validator {\r\n        private static final Logger LOG = LoggerFactory.getLogger(TestValidator.class);\r\n\r\n        @Override\r\n        public void validate(Message message, DataType type) throws ValidationException {\r\n            Object body = message.getBody();\r\n            LOG.info(\"Validating : [{}]\", body);\r\n            if (body instanceof String && body.equals(\"valid\")) {\r\n                LOG.info(\"OK\");\r\n            } else {\r\n                throw new ValidationException(message.getExchange(), \"Wrong content\");\r\n            }\r\n        }\r\n    }\r\n\r\n\r\n    @Override\r\n    protected JndiRegistry createRegistry() throws Exception {\r\n        JndiRegistry registry = super.createRegistry();\r\n\r\n        registry.bind(\"testValidator\", new TestValidator());\r\n\r\n        return registry;\r\n    }\r\n\r\n    @Test\r\n    public void testValid() throws InterruptedException {\r\n\r\n        getMockEndpoint(\"mock:out\").expectedMessageCount(1);\r\n        getMockEndpoint(\"mock:invalid\").expectedMessageCount(0);\r\n\r\n        template.sendBody(\"direct:in\", \"valid\");\r\n\r\n        assertMockEndpointsSatisfied();\r\n    }\r\n\r\n    @Test\r\n    public void testInvalid() throws InterruptedException {\r\n        getMockEndpoint(\"mock:out\").expectedMessageCount(0);\r\n        getMockEndpoint(\"mock:invalid\").expectedMessageCount(1);\r\n\r\n        template.sendBody(\"direct:in\", \"wrong\");\r\n\r\n        assertMockEndpointsSatisfied();\r\n    }\r\n}\r\n\r\n{code}",
      "assignee":"davsclaus",
      "type":"Bug",
      "priority":"Major",
      "status":"Resolved",
      "text":"outputTypeWithValidate (or inputTypeWithValidate) + validator()... doesn't work as expected {code:java}\r\npackage org.mike.tests;\r\n\r\nimport org.apache.camel.ValidationException;\r\nimport org.apache.camel.builder.RouteBuilder;\r\nimport org.apache.camel.test.junit4.CamelTestSupport;\r\nimport org.junit.Test;\r\n\r\npublic class ValidatorTests extends CamelTestSupport {\r\n    @Override\r\n    protected RouteBuilder createRouteBuilder() throws Exception {\r\n        return new RouteBuilder() {\r\n            @Override\r\n            public void configure() throws Exception {\r\n\r\n                validator()\r\n                        .type(String.class)\r\n                        .withExpression(bodyAs(String.class).isEqualToIgnoreCase(\"valid\"));\r\n\r\n                onException(ValidationException.class)\r\n                        .handled(true)\r\n                        .log(\"Invalid predicate: ${exception.message}\")\r\n                        .to(\"mock:invalid\");\r\n\r\n                from(\"direct:in\")\r\n                        \/\/.validate(bodyAs(String.class).isEqualToIgnoreCase(\"valid\"))\r\n                        .outputTypeWithValidate(String.class) \/\/ or .inputTypeWithValidate(String.class)\r\n                        .to(\"mock:out\");\r\n            }\r\n        };\r\n    }\r\n\r\n    @Test\r\n    public void testValid() throws InterruptedException {\r\n\r\n        getMockEndpoint(\"mock:out\").expectedMessageCount(1);\r\n        getMockEndpoint(\"mock:invalid\").expectedMessageCount(0);\r\n\r\n        template.sendBody(\"direct:in\", \"valid\");\r\n\r\n        assertMockEndpointsSatisfied();\r\n    }\r\n\r\n    @Test\r\n    public void testInvalid() throws InterruptedException {\r\n        getMockEndpoint(\"mock:out\").expectedMessageCount(0);\r\n        getMockEndpoint(\"mock:invalid\").expectedMessageCount(1);\r\n\r\n        template.sendBody(\"direct:in\", \"wrong\");\r\n\r\n        assertMockEndpointsSatisfied();\r\n    }\r\n}\r\n\r\n\r\n{code}\r\nExpected result: both tests pass\r\n\r\nActual result: 'testValid' - passed, 'testInvalid' - failed\r\n\r\nIf uncomment line 25 & comment 26\r\n{code:java}\r\n.validate(bodyAs(String.class).isEqualToIgnoreCase(\"valid\"))\r\n\/\/.inputTypeWithValidate(String.class)\r\n{code}\r\ntests will OK\r\n\r\n \r\n\r\nOther test case with same results\r\n\r\n \r\n{code:java}\r\npackage org.mike.tests;\r\n\r\nimport org.apache.camel.Message;\r\nimport org.apache.camel.ValidationException;\r\nimport org.apache.camel.builder.RouteBuilder;\r\nimport org.apache.camel.impl.JndiRegistry;\r\nimport org.apache.camel.spi.DataType;\r\nimport org.apache.camel.spi.Validator;\r\nimport org.apache.camel.test.junit4.CamelTestSupport;\r\nimport org.junit.Test;\r\nimport org.slf4j.Logger;\r\nimport org.slf4j.LoggerFactory;\r\n\r\npublic class BeanValidatorTest extends CamelTestSupport {\r\n    @Override\r\n    protected RouteBuilder createRouteBuilder() throws Exception {\r\n        return new RouteBuilder() {\r\n            @Override\r\n            public void configure() throws Exception {\r\n                validator()\r\n                        .type(\"toValidate\")\r\n                        .withBean(\"testValidator\");\r\n\r\n                onException(ValidationException.class)\r\n                        .handled(true)\r\n                        .log(\"Invalid validation: ${exception.message}\")\r\n                        .to(\"mock:invalid\");\r\n\r\n                from(\"direct:in\")\r\n                        .outputTypeWithValidate(\"toValidate\")\r\n                        .to(\"mock:out\");\r\n            }\r\n        };\r\n    }\r\n\r\n    public static class TestValidator extends Validator {\r\n        private static final Logger LOG = LoggerFactory.getLogger(TestValidator.class);\r\n\r\n        @Override\r\n        public void validate(Message message, DataType type) throws ValidationException {\r\n            Object body = message.getBody();\r\n            LOG.info(\"Validating : [{}]\", body);\r\n            if (body instanceof String && body.equals(\"valid\")) {\r\n                LOG.info(\"OK\");\r\n            } else {\r\n                throw new ValidationException(message.getExchange(), \"Wrong content\");\r\n            }\r\n        }\r\n    }\r\n\r\n\r\n    @Override\r\n    protected JndiRegistry createRegistry() throws Exception {\r\n        JndiRegistry registry = super.createRegistry();\r\n\r\n        registry.bind(\"testValidator\", new TestValidator());\r\n\r\n        return registry;\r\n    }\r\n\r\n    @Test\r\n    public void testValid() throws InterruptedException {\r\n\r\n        getMockEndpoint(\"mock:out\").expectedMessageCount(1);\r\n        getMockEndpoint(\"mock:invalid\").expectedMessageCount(0);\r\n\r\n        template.sendBody(\"direct:in\", \"valid\");\r\n\r\n        assertMockEndpointsSatisfied();\r\n    }\r\n\r\n    @Test\r\n    public void testInvalid() throws InterruptedException {\r\n        getMockEndpoint(\"mock:out\").expectedMessageCount(0);\r\n        getMockEndpoint(\"mock:invalid\").expectedMessageCount(1);\r\n\r\n        template.sendBody(\"direct:in\", \"wrong\");\r\n\r\n        assertMockEndpointsSatisfied();\r\n    }\r\n}\r\n\r\n{code}"
    },
    {
      "key":"CAMEL-12558",
      "title":"camel-catalog - Transacted and Policy should not have outputs",
      "description":"These 2 eips should not have output: true in the camel-catalog json meta-data.\r\n\r\nFor Camel 3.0 we will change their base class in the model so they are no outputs",
      "assignee":"davsclaus",
      "type":"Bug",
      "priority":"Major",
      "status":"Resolved",
      "text":"camel-catalog - Transacted and Policy should not have outputs These 2 eips should not have output: true in the camel-catalog json meta-data.\r\n\r\nFor Camel 3.0 we will change their base class in the model so they are no outputs"
    },
    {
      "key":"CAMEL-12553",
      "title":"Using cxf new LoggingFeature",
      "description":"CXF deprecated the old LoggingFeature, we need to switch to [new one|http:\/\/cxf.apache.org\/docs\/message-logging.html].",
      "assignee":"njiang",
      "type":"Improvement",
      "priority":"Major",
      "status":"Resolved",
      "text":"Using cxf new LoggingFeature CXF deprecated the old LoggingFeature, we need to switch to [new one|http:\/\/cxf.apache.org\/docs\/message-logging.html]."
    },
    {
      "key":"CAMEL-12551",
      "title":"Camel does not have logic that checks that it should only retry when its a new\/changed file",
      "description":"Hello,\r\n\r\nI am reading a file using the stream camel component. The behaviour expected is the following :\r\n # Read the stream\r\n # When the file roll over, start the reading the file from the begining\r\n\r\nMy code :\r\n\r\n{{from(\"stream:file?fileName=myfile&scanStream=true&scanStreamDelay=1000&retry=true\") }}\r\n\r\nThe problem with the code above is that the same file is read every 1000ms. The component don't check is the file was rolled over.\r\n\r\nThanks in advance.",
      "assignee":"davsclaus",
      "type":"Bug",
      "priority":"Major",
      "status":"Resolved",
      "text":"Camel does not have logic that checks that it should only retry when its a new\/changed file Hello,\r\n\r\nI am reading a file using the stream camel component. The behaviour expected is the following :\r\n # Read the stream\r\n # When the file roll over, start the reading the file from the begining\r\n\r\nMy code :\r\n\r\n{{from(\"stream:file?fileName=myfile&scanStream=true&scanStreamDelay=1000&retry=true\") }}\r\n\r\nThe problem with the code above is that the same file is read every 1000ms. The component don't check is the file was rolled over.\r\n\r\nThanks in advance."
    },
    {
      "key":"CAMEL-12546",
      "title":"rest-dsl - Allow to configure rest configuration via spring boot auto configuration",
      "description":"There are some global configurations you can configure on restConfiguration. We should make it possible to configure these via spring boot auto configuration, eg application.properties etc.",
      "assignee":"davsclaus",
      "type":"Improvement",
      "priority":"Major",
      "status":"Resolved",
      "text":"rest-dsl - Allow to configure rest configuration via spring boot auto configuration There are some global configurations you can configure on restConfiguration. We should make it possible to configure these via spring boot auto configuration, eg application.properties etc."
    },
    {
      "key":"CAMEL-12540",
      "title":"We should avoid the address setting of CxfRsEndpointConfigurer ",
      "description":"When using the CxfRsEndpointConfigurer to do the setting, the address setting from the Message header could be override.  We just need to make sure the address can be override from message header.",
      "assignee":"njiang",
      "type":"Bug",
      "priority":"Minor",
      "status":"Resolved",
      "text":"We should avoid the address setting of CxfRsEndpointConfigurer  When using the CxfRsEndpointConfigurer to do the setting, the address setting from the Message header could be override.  We just need to make sure the address can be override from message header."
    },
    {
      "key":"CAMEL-12533",
      "title":"rest-dsl - Should check for required parameters generally",
      "description":"See SO\r\n\r\n[https:\/\/stackoverflow.com\/questions\/50489713\/camel-rest-dsl-required-param-ignored]\r\n\r\nThere is AFAIR a little bit of required validation. But we could might as well do this if the user has specified those in the rest-dsl.\u00a0\r\n\r\nCurrently we rely a bit on the chosen http component to do its own validation. But since we have the rest-dsl contract at hand in the rest-dsl we should let camel-core figure this out.",
      "assignee":"davsclaus",
      "type":"Improvement",
      "priority":"Major",
      "status":"Resolved",
      "text":"rest-dsl - Should check for required parameters generally See SO\r\n\r\n[https:\/\/stackoverflow.com\/questions\/50489713\/camel-rest-dsl-required-param-ignored]\r\n\r\nThere is AFAIR a little bit of required validation. But we could might as well do this if the user has specified those in the rest-dsl. \r\n\r\nCurrently we rely a bit on the chosen http component to do its own validation. But since we have the rest-dsl contract at hand in the rest-dsl we should let camel-core figure this out."
    },
    {
      "key":"CAMEL-12532",
      "title":"Content Based Router in Java DSL may not resolve property placeholders in when predicates",
      "description":"Reported on gitter",
      "assignee":"davsclaus",
      "type":"Bug",
      "priority":"Major",
      "status":"Resolved",
      "text":"Content Based Router in Java DSL may not resolve property placeholders in when predicates Reported on gitter"
    },
    {
      "key":"CAMEL-12529",
      "title":"Dynamic Router implementation behavior inconsistent with Dynamic Router EIP specification",
      "description":"Currently, the Dynamic Router component of camel-core repeatedly routes messages back through the dynamic router, as indicated in the documentation. However, when examining the Dynamic Router EIP specification at [http:\/\/www.enterpriseintegrationpatterns.com\/patterns\/messaging\/DynamicRouter.html], we can see that this behavior is not consistent with the specification.\r\n\r\nThe description is:\r\n{quote}Use a Dynamic Router, a Router that can self-configure based on special configuration messages from participating destinations.\r\n\r\nBesides the usual input and output channels the Dynamic Router uses an additional control channel. During system start-up, each potential recipient sends a special message to the Dynamic Router on this control channel, announcing its presence and listing the conditions under which it can handle a message. The Dynamic Router stores the 'preferences' for each participant in a rule base. When a message arrives, the Dynamic Router evaluates all rules and routes the message to the recipient whose rules are fulfilled. This allows for efficient, predictive routing without the maintenance dependency of the Dynamic Router on each potential recipient.\r\n{quote}\r\nSince the documentation specifies the re-routing nature of the dynamic router quite clearly, this is obviously not an unintended side-effect or consequence but, I believe, a misunderstanding of the EIP itself.\u00a0 It appears that there _might_ be a point of confusion with the control channel that connects the potential endpoints to the rule base. This is not for re-routing of the messages, but for the potential endpoints to register rules with the dynamic router. While I am not certain how this should (or would) be implemented within Camel, the current behavior is not quite consistent with the description of the EIP",
      "assignee":"davsclaus",
      "type":"Improvement",
      "priority":"Minor",
      "status":"Resolved",
      "text":"Dynamic Router implementation behavior inconsistent with Dynamic Router EIP specification Currently, the Dynamic Router component of camel-core repeatedly routes messages back through the dynamic router, as indicated in the documentation. However, when examining the Dynamic Router EIP specification at [http:\/\/www.enterpriseintegrationpatterns.com\/patterns\/messaging\/DynamicRouter.html], we can see that this behavior is not consistent with the specification.\r\n\r\nThe description is:\r\n{quote}Use a Dynamic Router, a Router that can self-configure based on special configuration messages from participating destinations.\r\n\r\nBesides the usual input and output channels the Dynamic Router uses an additional control channel. During system start-up, each potential recipient sends a special message to the Dynamic Router on this control channel, announcing its presence and listing the conditions under which it can handle a message. The Dynamic Router stores the 'preferences' for each participant in a rule base. When a message arrives, the Dynamic Router evaluates all rules and routes the message to the recipient whose rules are fulfilled. This allows for efficient, predictive routing without the maintenance dependency of the Dynamic Router on each potential recipient.\r\n{quote}\r\nSince the documentation specifies the re-routing nature of the dynamic router quite clearly, this is obviously not an unintended side-effect or consequence but, I believe, a misunderstanding of the EIP itself.  It appears that there _might_ be a point of confusion with the control channel that connects the potential endpoints to the rule base. This is not for re-routing of the messages, but for the potential endpoints to register rules with the dynamic router. While I am not certain how this should (or would) be implemented within Camel, the current behavior is not quite consistent with the description of the EIP"
    },
    {
      "key":"CAMEL-12525",
      "title":"camel-kafka component commits the offset as soon as it is retrieved",
      "description":"I am trying the maual commit from consumer below is the code snippet, i want to consume and\u00a0 commit the message after 2 mins\u00a0of its arrival in the topic. My consumer retrieves and checks the time difference if it is above 2 mins then it should commit. But message once retrieved and not committed manually.\u00a0I am expecting it to come back but it does not comeback ever.\u00a0 when i try creating kafka consumer it works fine\r\n\r\npublic void configure() throws Exception {\r\nfrom(\"kafka:BENEFITSLOADER.LOAD?brokers=xxxx:9092,xxxx:9092,xxxx:9092&groupId=BENEFITSLOADER&consumersCount=1&pollTimeoutMs=1000&autoCommitEnable=false&allowManualCommit=true&maxPollRecords=1\")\r\n.process(new Processor() {\r\n @Override\r\n public void process(Exchange exchange) throws Exception {\r\n\r\n Long msgDateTime = (Long) exchange.getIn().getHeaders().get(KafkaConstants.TIMESTAMP);\r\n System.out.println(\"Message : \" + (exchange.getIn().getHeaders()));\r\n System.out.println(\"Message : \" + (exchange.getIn().getBody()));\r\n Date msgDate = new Date(msgDateTime);\r\n Date currentDate = new Date();\r\n long diff = currentDate.getTime() - msgDate.getTime();\r\n long diffMinutes = diff \/ (60 * 1000) % 60;\r\n System.out.println(\"Difference in Minutes \" + diffMinutes);\r\n KafkaManualCommit manualCommit = exchange.getIn().getHeader(KafkaConstants.MANUAL_COMMIT, KafkaManualCommit.class);\r\nif(diffMinutes > 2)\r\n {\r\n System.out.println(\"Commiting Message \" + exchange.getIn().getBody()); \r\n manualCommit.commitSync(); \r\n } \r\n }\r\n });\r\n }\r\n }\r\n\r\n\u00a0\r\n\r\n\u00a0\r\n\r\nCode that works fine\r\n\r\n\u00a0\r\n\r\npublic class TestKafkaConsumer {\r\n static Consumer<String, String> consumer = null;\r\n static ConsumerRecord<String,String> fetchedRecord; \r\n static ConsumerRecords<String, String> records;\r\n public static void main(String... args) {\r\n\r\n\r\nString topicName = \"BENEFITSLOADER.LOAD\";\r\n consumer = createConsumer();\r\n consumer.subscribe(Collections.singletonList(topicName));\r\n\r\ntry {\r\n while (true) {\r\n \r\n if(fetchedRecord == null)\r\n records = consumer.poll(1000);\r\n \r\n \r\n records.forEach(record -> { \r\n fetchedRecord = record; \r\n });\r\n \r\n if(fetchedRecord != null)\r\n {\r\n Date msgDate = new Date(fetchedRecord.timestamp());\r\n Date date = new Date(System.currentTimeMillis());\r\n long diff = date.getTime() - msgDate.getTime();\r\n long diffMinutes = diff \/ (60 * 1000) % 60;\r\n \r\n System.out.printf(\"Consumer Record:(%s, %s, %d, %d)\\n\",\r\n fetchedRecord.key(), fetchedRecord.value(),\r\n fetchedRecord.partition(), fetchedRecord.offset());\r\n if(diffMinutes > 2)\r\n {\r\n System.out.printf(\"Consumer Record Commiting:(%s, %s, %d, %d)\\n\",\r\n fetchedRecord.key(), fetchedRecord.value(),\r\n fetchedRecord.partition(), fetchedRecord.offset());\r\n consumer.commitSync();\r\n System.out.println(\"Commited\");\r\n fetchedRecord = null;\r\n }\r\n } \r\n }\r\n }\r\n\r\ncatch (Exception ex) {\r\n ex.printStackTrace();\r\n } finally { \r\n consumer.close();\r\n }\r\n\r\n}\r\n\r\nprivate static Consumer<String, String> createConsumer() {\r\n Properties props = new Properties();\r\n props.put(ConsumerConfig.BOOTSTRAP_SERVERS_CONFIG, \"xxx:9092,xxx:9092,xxx:9093\");\r\n props.put(ConsumerConfig.GROUP_ID_CONFIG, \"BENEFITSLOADER\");\r\n props.put(ConsumerConfig.KEY_DESERIALIZER_CLASS_CONFIG, StringDeserializer.class.getName());\r\n props.put(ConsumerConfig.VALUE_DESERIALIZER_CLASS_CONFIG, StringDeserializer.class.getName());\r\n props.put(ConsumerConfig.ENABLE_AUTO_COMMIT_CONFIG, false);\r\n props.put(ConsumerConfig.MAX_POLL_RECORDS_CONFIG, 1);\r\n return new KafkaConsumer<>(props);\r\n }\r\n\r\n}",
      "assignee":"davsclaus",
      "type":"Bug",
      "priority":"Major",
      "status":"Resolved",
      "text":"camel-kafka component commits the offset as soon as it is retrieved I am trying the maual commit from consumer below is the code snippet, i want to consume and  commit the message after 2 mins of its arrival in the topic. My consumer retrieves and checks the time difference if it is above 2 mins then it should commit. But message once retrieved and not committed manually. I am expecting it to come back but it does not comeback ever.  when i try creating kafka consumer it works fine\r\n\r\npublic void configure() throws Exception {\r\nfrom(\"kafka:BENEFITSLOADER.LOAD?brokers=xxxx:9092,xxxx:9092,xxxx:9092&groupId=BENEFITSLOADER&consumersCount=1&pollTimeoutMs=1000&autoCommitEnable=false&allowManualCommit=true&maxPollRecords=1\")\r\n.process(new Processor() {\r\n @Override\r\n public void process(Exchange exchange) throws Exception {\r\n\r\n Long msgDateTime = (Long) exchange.getIn().getHeaders().get(KafkaConstants.TIMESTAMP);\r\n System.out.println(\"Message : \" + (exchange.getIn().getHeaders()));\r\n System.out.println(\"Message : \" + (exchange.getIn().getBody()));\r\n Date msgDate = new Date(msgDateTime);\r\n Date currentDate = new Date();\r\n long diff = currentDate.getTime() - msgDate.getTime();\r\n long diffMinutes = diff \/ (60 * 1000) % 60;\r\n System.out.println(\"Difference in Minutes \" + diffMinutes);\r\n KafkaManualCommit manualCommit = exchange.getIn().getHeader(KafkaConstants.MANUAL_COMMIT, KafkaManualCommit.class);\r\nif(diffMinutes > 2)\r\n {\r\n System.out.println(\"Commiting Message \" + exchange.getIn().getBody()); \r\n manualCommit.commitSync(); \r\n } \r\n }\r\n });\r\n }\r\n }\r\n\r\n \r\n\r\n \r\n\r\nCode that works fine\r\n\r\n \r\n\r\npublic class TestKafkaConsumer {\r\n static Consumer<String, String> consumer = null;\r\n static ConsumerRecord<String,String> fetchedRecord; \r\n static ConsumerRecords<String, String> records;\r\n public static void main(String... args) {\r\n\r\n\r\nString topicName = \"BENEFITSLOADER.LOAD\";\r\n consumer = createConsumer();\r\n consumer.subscribe(Collections.singletonList(topicName));\r\n\r\ntry {\r\n while (true) {\r\n \r\n if(fetchedRecord == null)\r\n records = consumer.poll(1000);\r\n \r\n \r\n records.forEach(record -> { \r\n fetchedRecord = record; \r\n });\r\n \r\n if(fetchedRecord != null)\r\n {\r\n Date msgDate = new Date(fetchedRecord.timestamp());\r\n Date date = new Date(System.currentTimeMillis());\r\n long diff = date.getTime() - msgDate.getTime();\r\n long diffMinutes = diff \/ (60 * 1000) % 60;\r\n \r\n System.out.printf(\"Consumer Record:(%s, %s, %d, %d)\\n\",\r\n fetchedRecord.key(), fetchedRecord.value(),\r\n fetchedRecord.partition(), fetchedRecord.offset());\r\n if(diffMinutes > 2)\r\n {\r\n System.out.printf(\"Consumer Record Commiting:(%s, %s, %d, %d)\\n\",\r\n fetchedRecord.key(), fetchedRecord.value(),\r\n fetchedRecord.partition(), fetchedRecord.offset());\r\n consumer.commitSync();\r\n System.out.println(\"Commited\");\r\n fetchedRecord = null;\r\n }\r\n } \r\n }\r\n }\r\n\r\ncatch (Exception ex) {\r\n ex.printStackTrace();\r\n } finally { \r\n consumer.close();\r\n }\r\n\r\n}\r\n\r\nprivate static Consumer<String, String> createConsumer() {\r\n Properties props = new Properties();\r\n props.put(ConsumerConfig.BOOTSTRAP_SERVERS_CONFIG, \"xxx:9092,xxx:9092,xxx:9093\");\r\n props.put(ConsumerConfig.GROUP_ID_CONFIG, \"BENEFITSLOADER\");\r\n props.put(ConsumerConfig.KEY_DESERIALIZER_CLASS_CONFIG, StringDeserializer.class.getName());\r\n props.put(ConsumerConfig.VALUE_DESERIALIZER_CLASS_CONFIG, StringDeserializer.class.getName());\r\n props.put(ConsumerConfig.ENABLE_AUTO_COMMIT_CONFIG, false);\r\n props.put(ConsumerConfig.MAX_POLL_RECORDS_CONFIG, 1);\r\n return new KafkaConsumer<>(props);\r\n }\r\n\r\n}"
    },
    {
      "key":"CAMEL-12520",
      "title":"FluentProducerTemplate.withExchange() does not seem to send exchange",
      "description":"When I use the following simple but complete code example:\r\n{code:java}\r\npublic static void main(String[] args) throws Exception {\r\n    CamelContext camelContext = new DefaultCamelContext();\r\n    camelContext.start();\r\n    camelContext.addRoutes(new RouteBuilder() {\r\n        @Override\r\n        public void configure() {\r\n            from(\"direct-vm:start\").process(exchange -> {\r\n                String incoming = exchange.getIn().getBody(String.class);\r\n                exchange.getIn().setBody(\"Message received: \" + incoming, String.class);\r\n            });\r\n        }\r\n    });\r\n    Exchange exchange = ExchangeBuilder.anExchange(camelContext)\r\n            .withBody(\"Hello!\")\r\n            .withPattern(ExchangePattern.InOut)\r\n            .build();\r\n    System.out.println(\r\n            camelContext.createFluentProducerTemplate()\r\n            .withExchange(exchange)\r\n            .to(\"direct-vm:start\")\r\n            .request(String.class)\r\n    );\r\n}{code}\r\nThe message body appears to be missing, as indicated in the program output:\r\n{code:java}\r\nMessage received: null{code}\r\nI have tried this with java 1.8 and 1.9, and with camel 2.19.2 and 2.21.1, and both camel versions exhibit the same behavior when run with both java versions.",
      "assignee":"davsclaus",
      "type":"Improvement",
      "priority":"Minor",
      "status":"Resolved",
      "text":"FluentProducerTemplate.withExchange() does not seem to send exchange When I use the following simple but complete code example:\r\n{code:java}\r\npublic static void main(String[] args) throws Exception {\r\n    CamelContext camelContext = new DefaultCamelContext();\r\n    camelContext.start();\r\n    camelContext.addRoutes(new RouteBuilder() {\r\n        @Override\r\n        public void configure() {\r\n            from(\"direct-vm:start\").process(exchange -> {\r\n                String incoming = exchange.getIn().getBody(String.class);\r\n                exchange.getIn().setBody(\"Message received: \" + incoming, String.class);\r\n            });\r\n        }\r\n    });\r\n    Exchange exchange = ExchangeBuilder.anExchange(camelContext)\r\n            .withBody(\"Hello!\")\r\n            .withPattern(ExchangePattern.InOut)\r\n            .build();\r\n    System.out.println(\r\n            camelContext.createFluentProducerTemplate()\r\n            .withExchange(exchange)\r\n            .to(\"direct-vm:start\")\r\n            .request(String.class)\r\n    );\r\n}{code}\r\nThe message body appears to be missing, as indicated in the program output:\r\n{code:java}\r\nMessage received: null{code}\r\nI have tried this with java 1.8 and 1.9, and with camel 2.19.2 and 2.21.1, and both camel versions exhibit the same behavior when run with both java versions."
    },
    {
      "key":"CAMEL-12513",
      "title":"Camel breadcrumb - Consider turning it off by default",
      "description":"This was added many years ago with the breadcrumbId header. But today there is standards with opentracing \/ zipkin etc.\r\n\r\nSo ideally we should turn this off by default, and then point people to these other standards.\r\n\r\n[http:\/\/camel.apache.org\/mdc-logging.html]\r\n\r\n\u00a0",
      "assignee":"davsclaus",
      "type":"Improvement",
      "priority":"Major",
      "status":"Resolved",
      "text":"Camel breadcrumb - Consider turning it off by default This was added many years ago with the breadcrumbId header. But today there is standards with opentracing \/ zipkin etc.\r\n\r\nSo ideally we should turn this off by default, and then point people to these other standards.\r\n\r\n[http:\/\/camel.apache.org\/mdc-logging.html]\r\n\r\n "
    },
    {
      "key":"CAMEL-12510",
      "title":"Camel servlet component throw \"IOException: Stream closed\" during route processing for HTTP get request with custom processor",
      "description":"If i just build a simple Route like this to proxy a incoming Get request to external host:\r\n{code:java}\r\n\u00a0\u00a0\u00a0 @Override\r\n\u00a0\u00a0\u00a0 public void configure() throws Exception {\r\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 from(format(\"servlet:\/\/%s?httpMethodRestrict=GET&servletName=%s\", RETRIEVE_PATH, servletName))\r\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 .process((exchange) -> {\r\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 exchange.getOut().setHeader(Exchange.HTTP_URI, \"https:\/\/some.external.system\/\");\r\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 }).to(\"https4:something\");\r\n\u00a0\u00a0\u00a0 }\r\n{code}\r\nThe following exception is thrown:\r\n{code:java}\r\norg.apache.camel.RuntimeCamelException: java.io.IOException: Stream closed\r\n\tat org.apache.camel.http.common.HttpMessage.createBody(HttpMessage.java:80)\r\n\tat org.apache.camel.impl.MessageSupport.getBody(MessageSupport.java:54)\r\n\tat org.apache.camel.processor.DefaultExchangeFormatter.getBodyTypeAsString(DefaultExchangeFormatter.java:468)\r\n\tat org.apache.camel.processor.DefaultExchangeFormatter.format(DefaultExchangeFormatter.java:126)\r\n\tat org.apache.camel.processor.CamelLogProcessor.process(CamelLogProcessor.java:88)\r\n\tat org.apache.camel.component.log.LogProducer.process(LogProducer.java:40)\r\n\tat org.apache.camel.processor.SendProcessor.process(SendProcessor.java:148)\r\n\tat org.apache.camel.processor.RedeliveryErrorHandler.process(RedeliveryErrorHandler.java:548)\r\n\tat org.apache.camel.processor.CamelInternalProcessor.process(CamelInternalProcessor.java:201)\r\n\tat org.apache.camel.processor.Pipeline.process(Pipeline.java:138)\r\n\tat org.apache.camel.processor.Pipeline.process(Pipeline.java:101)\r\n\tat org.apache.camel.processor.CamelInternalProcessor.process(CamelInternalProcessor.java:201)\r\n\tat org.apache.camel.processor.DelegateAsyncProcessor.process(DelegateAsyncProcessor.java:97)\r\n\tat org.apache.camel.http.common.CamelServlet.doService(CamelServlet.java:208)\r\n\tat org.apache.camel.http.common.CamelServlet.service(CamelServlet.java:78)\r\n\tat javax.servlet.http.HttpServlet.service(HttpServlet.java:742)\r\n\tat org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:231)\r\n\tat org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166)\r\n\tat org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:52)\r\n\tat org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193)\r\n\tat org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166)\r\n\tat org.springframework.boot.actuate.trace.WebRequestTraceFilter.doFilterInternal(WebRequestTraceFilter.java:110)\r\n\tat org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:107)\r\n\tat org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193)\r\n\tat org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166)\r\n\tat org.springframework.web.filter.RequestContextFilter.doFilterInternal(RequestContextFilter.java:99)\r\n\tat org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:107)\r\n\tat org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193)\r\n\tat org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166)\r\n\tat org.springframework.web.filter.HttpPutFormContentFilter.doFilterInternal(HttpPutFormContentFilter.java:108)\r\n\tat org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:107)\r\n\tat org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193)\r\n\tat org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166)\r\n\tat org.springframework.web.filter.HiddenHttpMethodFilter.doFilterInternal(HiddenHttpMethodFilter.java:81)\r\n\tat org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:107)\r\n\tat org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193)\r\n\tat org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166)\r\n\tat org.springframework.web.filter.CharacterEncodingFilter.doFilterInternal(CharacterEncodingFilter.java:197)\r\n\tat org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:107)\r\n\tat org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193)\r\n\tat org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166)\r\n\tat org.springframework.boot.actuate.autoconfigure.MetricsFilter.doFilterInternal(MetricsFilter.java:106)\r\n\tat org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:107)\r\n\tat org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193)\r\n\tat org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166)\r\n\tat org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:199)\r\n\tat org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:96)\r\n\tat org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:504)\r\n\tat org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:140)\r\n\tat org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:81)\r\n\tat org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:87)\r\n\tat org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:342)\r\n\tat org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:803)\r\n\tat org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:66)\r\n\tat org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:790)\r\n\tat org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1459)\r\n\tat org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:49)\r\n\tat java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)\r\n\tat java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)\r\n\tat org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:61)\r\n\tat java.lang.Thread.run(Thread.java:748)\r\nCaused by: java.io.IOException: Stream closed\r\n\tat org.apache.catalina.connector.InputBuffer.read(InputBuffer.java:346)\r\n\tat org.apache.catalina.connector.CoyoteInputStream.read(CoyoteInputStream.java:152)\r\n\tat org.apache.camel.util.IOHelper.copy(IOHelper.java:202)\r\n\tat org.apache.camel.util.IOHelper.copy(IOHelper.java:174)\r\n\tat org.apache.camel.util.IOHelper.copyAndCloseInput(IOHelper.java:234)\r\n\tat org.apache.camel.util.IOHelper.copyAndCloseInput(IOHelper.java:230)\r\n\tat org.apache.camel.http.common.HttpHelper.readResponseBodyFromInputStream(HttpHelper.java:245)\r\n\tat org.apache.camel.http.common.HttpHelper.readRequestBodyFromServletRequest(HttpHelper.java:196)\r\n\tat org.apache.camel.http.common.DefaultHttpBinding.parseBody(DefaultHttpBinding.java:577)\r\n\tat org.apache.camel.http.common.HttpMessage.createBody(HttpMessage.java:78)\r\n\t... 60 more\r\n{code}\r\n*Workaround \/ Additional notice:*\r\n * If I rewrite my example route to work without a processor, {{.setHeader(Exchange.HTTP_URI, constant(\"https:\/\/some.external.system\/\"))}} everything works, so it seems to be an issue with the processor handling. Nevertheless, processor logic should also work.\r\n * even if i use a simple {{to(\"log:com.mycompany.order?showAll=true&multiline=true\")}} the issue occurs as well. So it has nothing to with the camel-http4 producer.\r\n * Adding \"mapHttpMessageBody=false\" to the servlet definition seems to be a proper workaround for my example, since I only proxy GET requests which never have a body in the request.\r\n * I already debug into the camel code, but i am not 100% sure if this is the correct place to fix: {{org.apache.camel.http.common.DefaultHttpBinding.parseBody(HttpMessage)}} - here it might make sense to skip body parsing for certain HTTP methods (e.g. GET)\r\n * I found two quiet similar issues on the mailing list:\r\n ** [http:\/\/camel.465427.n5.nabble.com\/Stream-closed-exception-when-using-camel-as-http-proxy-with-tomcat-servlet-tt5809653.html#none]\r\n ** [http:\/\/camel.465427.n5.nabble.com\/IOException-Stream-closed-when-forwarding-HTTP-request-td5796802.html]",
      "assignee":"davsclaus",
      "type":"Bug",
      "priority":"Major",
      "status":"Resolved",
      "text":"Camel servlet component throw \"IOException: Stream closed\" during route processing for HTTP get request with custom processor If i just build a simple Route like this to proxy a incoming Get request to external host:\r\n{code:java}\r\n    @Override\r\n    public void configure() throws Exception {\r\n        from(format(\"servlet:\/\/%s?httpMethodRestrict=GET&servletName=%s\", RETRIEVE_PATH, servletName))\r\n                .process((exchange) -> {\r\n                    exchange.getOut().setHeader(Exchange.HTTP_URI, \"https:\/\/some.external.system\/\");\r\n                }).to(\"https4:something\");\r\n    }\r\n{code}\r\nThe following exception is thrown:\r\n{code:java}\r\norg.apache.camel.RuntimeCamelException: java.io.IOException: Stream closed\r\n\tat org.apache.camel.http.common.HttpMessage.createBody(HttpMessage.java:80)\r\n\tat org.apache.camel.impl.MessageSupport.getBody(MessageSupport.java:54)\r\n\tat org.apache.camel.processor.DefaultExchangeFormatter.getBodyTypeAsString(DefaultExchangeFormatter.java:468)\r\n\tat org.apache.camel.processor.DefaultExchangeFormatter.format(DefaultExchangeFormatter.java:126)\r\n\tat org.apache.camel.processor.CamelLogProcessor.process(CamelLogProcessor.java:88)\r\n\tat org.apache.camel.component.log.LogProducer.process(LogProducer.java:40)\r\n\tat org.apache.camel.processor.SendProcessor.process(SendProcessor.java:148)\r\n\tat org.apache.camel.processor.RedeliveryErrorHandler.process(RedeliveryErrorHandler.java:548)\r\n\tat org.apache.camel.processor.CamelInternalProcessor.process(CamelInternalProcessor.java:201)\r\n\tat org.apache.camel.processor.Pipeline.process(Pipeline.java:138)\r\n\tat org.apache.camel.processor.Pipeline.process(Pipeline.java:101)\r\n\tat org.apache.camel.processor.CamelInternalProcessor.process(CamelInternalProcessor.java:201)\r\n\tat org.apache.camel.processor.DelegateAsyncProcessor.process(DelegateAsyncProcessor.java:97)\r\n\tat org.apache.camel.http.common.CamelServlet.doService(CamelServlet.java:208)\r\n\tat org.apache.camel.http.common.CamelServlet.service(CamelServlet.java:78)\r\n\tat javax.servlet.http.HttpServlet.service(HttpServlet.java:742)\r\n\tat org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:231)\r\n\tat org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166)\r\n\tat org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:52)\r\n\tat org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193)\r\n\tat org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166)\r\n\tat org.springframework.boot.actuate.trace.WebRequestTraceFilter.doFilterInternal(WebRequestTraceFilter.java:110)\r\n\tat org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:107)\r\n\tat org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193)\r\n\tat org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166)\r\n\tat org.springframework.web.filter.RequestContextFilter.doFilterInternal(RequestContextFilter.java:99)\r\n\tat org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:107)\r\n\tat org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193)\r\n\tat org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166)\r\n\tat org.springframework.web.filter.HttpPutFormContentFilter.doFilterInternal(HttpPutFormContentFilter.java:108)\r\n\tat org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:107)\r\n\tat org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193)\r\n\tat org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166)\r\n\tat org.springframework.web.filter.HiddenHttpMethodFilter.doFilterInternal(HiddenHttpMethodFilter.java:81)\r\n\tat org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:107)\r\n\tat org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193)\r\n\tat org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166)\r\n\tat org.springframework.web.filter.CharacterEncodingFilter.doFilterInternal(CharacterEncodingFilter.java:197)\r\n\tat org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:107)\r\n\tat org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193)\r\n\tat org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166)\r\n\tat org.springframework.boot.actuate.autoconfigure.MetricsFilter.doFilterInternal(MetricsFilter.java:106)\r\n\tat org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:107)\r\n\tat org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193)\r\n\tat org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166)\r\n\tat org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:199)\r\n\tat org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:96)\r\n\tat org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:504)\r\n\tat org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:140)\r\n\tat org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:81)\r\n\tat org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:87)\r\n\tat org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:342)\r\n\tat org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:803)\r\n\tat org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:66)\r\n\tat org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:790)\r\n\tat org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1459)\r\n\tat org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:49)\r\n\tat java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)\r\n\tat java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)\r\n\tat org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:61)\r\n\tat java.lang.Thread.run(Thread.java:748)\r\nCaused by: java.io.IOException: Stream closed\r\n\tat org.apache.catalina.connector.InputBuffer.read(InputBuffer.java:346)\r\n\tat org.apache.catalina.connector.CoyoteInputStream.read(CoyoteInputStream.java:152)\r\n\tat org.apache.camel.util.IOHelper.copy(IOHelper.java:202)\r\n\tat org.apache.camel.util.IOHelper.copy(IOHelper.java:174)\r\n\tat org.apache.camel.util.IOHelper.copyAndCloseInput(IOHelper.java:234)\r\n\tat org.apache.camel.util.IOHelper.copyAndCloseInput(IOHelper.java:230)\r\n\tat org.apache.camel.http.common.HttpHelper.readResponseBodyFromInputStream(HttpHelper.java:245)\r\n\tat org.apache.camel.http.common.HttpHelper.readRequestBodyFromServletRequest(HttpHelper.java:196)\r\n\tat org.apache.camel.http.common.DefaultHttpBinding.parseBody(DefaultHttpBinding.java:577)\r\n\tat org.apache.camel.http.common.HttpMessage.createBody(HttpMessage.java:78)\r\n\t... 60 more\r\n{code}\r\n*Workaround \/ Additional notice:*\r\n * If I rewrite my example route to work without a processor, {{.setHeader(Exchange.HTTP_URI, constant(\"https:\/\/some.external.system\/\"))}} everything works, so it seems to be an issue with the processor handling. Nevertheless, processor logic should also work.\r\n * even if i use a simple {{to(\"log:com.mycompany.order?showAll=true&multiline=true\")}} the issue occurs as well. So it has nothing to with the camel-http4 producer.\r\n * Adding \"mapHttpMessageBody=false\" to the servlet definition seems to be a proper workaround for my example, since I only proxy GET requests which never have a body in the request.\r\n * I already debug into the camel code, but i am not 100% sure if this is the correct place to fix: {{org.apache.camel.http.common.DefaultHttpBinding.parseBody(HttpMessage)}} - here it might make sense to skip body parsing for certain HTTP methods (e.g. GET)\r\n * I found two quiet similar issues on the mailing list:\r\n ** [http:\/\/camel.465427.n5.nabble.com\/Stream-closed-exception-when-using-camel-as-http-proxy-with-tomcat-servlet-tt5809653.html#none]\r\n ** [http:\/\/camel.465427.n5.nabble.com\/IOException-Stream-closed-when-forwarding-HTTP-request-td5796802.html]"
    },
    {
      "key":"CAMEL-12503",
      "title":"Kafka component should be able to propagate camel headers to kafka",
      "description":"Since 0.11.0 Kafka support headers, and it would be awesome to have such feature available also in camel component.",
      "assignee":"davsclaus",
      "type":"New Feature",
      "priority":"Major",
      "status":"Resolved",
      "text":"Kafka component should be able to propagate camel headers to kafka Since 0.11.0 Kafka support headers, and it would be awesome to have such feature available also in camel component."
    },
    {
      "key":"CAMEL-12491",
      "title":"route-coverage : report summary problem",
      "description":"Consider the example code given in\u00a0CAMEL-12483\r\n\r\nWhen running camel:route-coverage the report show to many passes for the routes. It looks like the RouteCoverageEventNotifier files holds the sum of all tests, and not just the values for the single test method.\u00a0\r\n\u00a0\r\n{code:java}\r\nClass:  dk.smor.MySpringBootRouter\r\nRoute:  myRouteId\r\n\r\n  Line #      Count   Route\r\n  ------      -----   -----\r\n      11          8   from\r\n      13          8     log\r\n      15          8     choice\r\n      16          2       setBody\r\n      18          2       log\r\n      20          2       setBody\r\n      22          2       log\r\n      24          2       setBody\r\n      26          2       log\r\n      28          2       setBody\r\n      30          2       log\r\n\r\nCoverage: 11 out of 11 (100.0%)\r\n{code}\r\n\r\neach log statement should only have been passed 1 time. And a total for 4 passes for the whole route. \r\n\u00a0",
      "assignee":"davsclaus",
      "type":"Bug",
      "priority":"Minor",
      "status":"Resolved",
      "text":"route-coverage : report summary problem Consider the example code given in CAMEL-12483\r\n\r\nWhen running camel:route-coverage the report show to many passes for the routes. It looks like the RouteCoverageEventNotifier files holds the sum of all tests, and not just the values for the single test method. \r\n \r\n{code:java}\r\nClass:  dk.smor.MySpringBootRouter\r\nRoute:  myRouteId\r\n\r\n  Line #      Count   Route\r\n  ------      -----   -----\r\n      11          8   from\r\n      13          8     log\r\n      15          8     choice\r\n      16          2       setBody\r\n      18          2       log\r\n      20          2       setBody\r\n      22          2       log\r\n      24          2       setBody\r\n      26          2       log\r\n      28          2       setBody\r\n      30          2       log\r\n\r\nCoverage: 11 out of 11 (100.0%)\r\n{code}\r\n\r\neach log statement should only have been passed 1 time. And a total for 4 passes for the whole route. \r\n "
    },
    {
      "key":"CAMEL-12490",
      "title":"Camel-jms: ClassNotFoundException: org.springframework.messaging.handler.annotation.support.MessageHandlerMethodFactory in Spring-Boot",
      "description":"Not sure if this is a Camel bug, but I'm using activemq-camel 5.14.5 in a spring-boot 1.5.12 application.\r\n\r\nAfter upgrading from Camel 2.21.0 to 2.21.1 start-up fails with:\r\n\r\n{noformat}\r\n2018-05-07 09:45:34.213 ERROR 7992 --- [  restartedMain] o.s.boot.SpringApplication               : Application startup failed\r\n\r\norg.springframework.beans.factory.BeanCreationException: Error creating bean with name 'org.springframework.jms.config.internalJmsListenerAnnotationProcessor' defined in class path resource [org\/springframework\/jms\/annotation\/JmsBootstrapConfiguration.class]: Bean instantiation via factory method failed; nested exception is org.springframework.beans.BeanInstantiationException: Failed to instantiate [org.springframework.jms.annotation.JmsListenerAnnotationBeanPostProcessor]: Factory method 'jmsListenerAnnotationProcessor' threw exception; nested exception is java.lang.NoClassDefFoundError: org\/springframework\/messaging\/handler\/annotation\/support\/MessageHandlerMethodFactory\r\n\tat org.springframework.beans.factory.support.ConstructorResolver.instantiateUsingFactoryMethod(ConstructorResolver.java:599) ~[spring-beans-4.3.16.RELEASE.jar:4.3.16.RELEASE]\r\n\tat org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.instantiateUsingFactoryMethod(AbstractAutowireCapableBeanFactory.java:1177) ~[spring-beans-4.3.16.RELEASE.jar:4.3.16.RELEASE]\r\n\tat org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBeanInstance(AbstractAutowireCapableBeanFactory.java:1071) ~[spring-beans-4.3.16.RELEASE.jar:4.3.16.RELEASE]\r\n\tat org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:513) ~[spring-beans-4.3.16.RELEASE.jar:4.3.16.RELEASE]\r\n\tat org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:483) ~[spring-beans-4.3.16.RELEASE.jar:4.3.16.RELEASE]\r\n\tat org.springframework.beans.factory.support.AbstractBeanFactory$1.getObject(AbstractBeanFactory.java:312) ~[spring-beans-4.3.16.RELEASE.jar:4.3.16.RELEASE]\r\n\tat org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:230) ~[spring-beans-4.3.16.RELEASE.jar:4.3.16.RELEASE]\r\n\tat org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:308) ~[spring-beans-4.3.16.RELEASE.jar:4.3.16.RELEASE]\r\n\tat org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:202) ~[spring-beans-4.3.16.RELEASE.jar:4.3.16.RELEASE]\r\n\tat org.springframework.context.support.PostProcessorRegistrationDelegate.registerBeanPostProcessors(PostProcessorRegistrationDelegate.java:225) ~[spring-context-4.3.16.RELEASE.jar:4.3.16.RELEASE]\r\n\tat org.springframework.context.support.AbstractApplicationContext.registerBeanPostProcessors(AbstractApplicationContext.java:703) ~[spring-context-4.3.16.RELEASE.jar:4.3.16.RELEASE]\r\n\tat org.springframework.context.support.AbstractApplicationContext.refresh(AbstractApplicationContext.java:528) ~[spring-context-4.3.16.RELEASE.jar:4.3.16.RELEASE]\r\n\tat org.springframework.boot.SpringApplication.refresh(SpringApplication.java:693) [spring-boot-1.5.12.RELEASE.jar:1.5.12.RELEASE]\r\n\tat org.springframework.boot.SpringApplication.refreshContext(SpringApplication.java:360) [spring-boot-1.5.12.RELEASE.jar:1.5.12.RELEASE]\r\n\tat org.springframework.boot.SpringApplication.run(SpringApplication.java:303) [spring-boot-1.5.12.RELEASE.jar:1.5.12.RELEASE]\r\n\tat org.springframework.boot.SpringApplication.run(SpringApplication.java:1118) [spring-boot-1.5.12.RELEASE.jar:1.5.12.RELEASE]\r\n\tat org.springframework.boot.SpringApplication.run(SpringApplication.java:1107) [spring-boot-1.5.12.RELEASE.jar:1.5.12.RELEASE]\r\n\tat de.telekom.dms.FlexKommBusinessServicesApplication.main(FlexKommBusinessServicesApplication.java:10) [classes\/:na]\r\n\tat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) ~[na:1.8.0_121]\r\n\tat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) ~[na:1.8.0_121]\r\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) ~[na:1.8.0_121]\r\n\tat java.lang.reflect.Method.invoke(Method.java:498) ~[na:1.8.0_121]\r\n\tat org.springframework.boot.devtools.restart.RestartLauncher.run(RestartLauncher.java:49) [spring-boot-devtools-1.5.12.RELEASE.jar:1.5.12.RELEASE]\r\nCaused by: org.springframework.beans.BeanInstantiationException: Failed to instantiate [org.springframework.jms.annotation.JmsListenerAnnotationBeanPostProcessor]: Factory method 'jmsListenerAnnotationProcessor' threw exception; nested exception is java.lang.NoClassDefFoundError: org\/springframework\/messaging\/handler\/annotation\/support\/MessageHandlerMethodFactory\r\n\tat org.springframework.beans.factory.support.SimpleInstantiationStrategy.instantiate(SimpleInstantiationStrategy.java:189) ~[spring-beans-4.3.16.RELEASE.jar:4.3.16.RELEASE]\r\n\tat org.springframework.beans.factory.support.ConstructorResolver.instantiateUsingFactoryMethod(ConstructorResolver.java:588) ~[spring-beans-4.3.16.RELEASE.jar:4.3.16.RELEASE]\r\n\t... 22 common frames omitted\r\nCaused by: java.lang.NoClassDefFoundError: org\/springframework\/messaging\/handler\/annotation\/support\/MessageHandlerMethodFactory\r\n\tat java.lang.ClassLoader.defineClass1(Native Method) ~[na:1.8.0_121]\r\n\tat java.lang.ClassLoader.defineClass(ClassLoader.java:763) ~[na:1.8.0_121]\r\n\tat java.security.SecureClassLoader.defineClass(SecureClassLoader.java:142) ~[na:1.8.0_121]\r\n\tat java.net.URLClassLoader.defineClass(URLClassLoader.java:467) ~[na:1.8.0_121]\r\n\tat java.net.URLClassLoader.access$100(URLClassLoader.java:73) ~[na:1.8.0_121]\r\n\tat java.net.URLClassLoader$1.run(URLClassLoader.java:368) ~[na:1.8.0_121]\r\n\tat java.net.URLClassLoader$1.run(URLClassLoader.java:362) ~[na:1.8.0_121]\r\n\tat java.security.AccessController.doPrivileged(Native Method) ~[na:1.8.0_121]\r\n\tat java.net.URLClassLoader.findClass(URLClassLoader.java:361) ~[na:1.8.0_121]\r\n\tat java.lang.ClassLoader.loadClass(ClassLoader.java:424) ~[na:1.8.0_121]\r\n\tat sun.misc.Launcher$AppClassLoader.loadClass(Launcher.java:331) ~[na:1.8.0_121]\r\n\tat java.lang.ClassLoader.loadClass(ClassLoader.java:357) ~[na:1.8.0_121]\r\n\tat org.springframework.jms.annotation.JmsListenerAnnotationBeanPostProcessor.<init>(JmsListenerAnnotationBeanPostProcessor.java:103) ~[spring-jms-4.3.16.RELEASE.jar:4.3.16.RELEASE]\r\n\tat org.springframework.jms.annotation.JmsBootstrapConfiguration.jmsListenerAnnotationProcessor(JmsBootstrapConfiguration.java:47) ~[spring-jms-4.3.16.RELEASE.jar:4.3.16.RELEASE]\r\n\tat org.springframework.jms.annotation.JmsBootstrapConfiguration$$EnhancerBySpringCGLIB$$1878cc3d.CGLIB$jmsListenerAnnotationProcessor$1(<generated>) ~[spring-jms-4.3.16.RELEASE.jar:4.3.16.RELEASE]\r\n\tat org.springframework.jms.annotation.JmsBootstrapConfiguration$$EnhancerBySpringCGLIB$$1878cc3d$$FastClassBySpringCGLIB$$265c8d54.invoke(<generated>) ~[spring-jms-4.3.16.RELEASE.jar:4.3.16.RELEASE]\r\n\tat org.springframework.cglib.proxy.MethodProxy.invokeSuper(MethodProxy.java:228) ~[spring-core-4.3.16.RELEASE.jar:4.3.16.RELEASE]\r\n\tat org.springframework.context.annotation.ConfigurationClassEnhancer$BeanMethodInterceptor.intercept(ConfigurationClassEnhancer.java:358) ~[spring-context-4.3.16.RELEASE.jar:4.3.16.RELEASE]\r\n\tat org.springframework.jms.annotation.JmsBootstrapConfiguration$$EnhancerBySpringCGLIB$$1878cc3d.jmsListenerAnnotationProcessor(<generated>) ~[spring-jms-4.3.16.RELEASE.jar:4.3.16.RELEASE]\r\n\tat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) ~[na:1.8.0_121]\r\n\tat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) ~[na:1.8.0_121]\r\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) ~[na:1.8.0_121]\r\n\tat java.lang.reflect.Method.invoke(Method.java:498) ~[na:1.8.0_121]\r\n\tat org.springframework.beans.factory.support.SimpleInstantiationStrategy.instantiate(SimpleInstantiationStrategy.java:162) ~[spring-beans-4.3.16.RELEASE.jar:4.3.16.RELEASE]\r\n\t... 23 common frames omitted\r\nCaused by: java.lang.ClassNotFoundException: org.springframework.messaging.handler.annotation.support.MessageHandlerMethodFactory\r\n\tat java.net.URLClassLoader.findClass(URLClassLoader.java:381) ~[na:1.8.0_121]\r\n\tat java.lang.ClassLoader.loadClass(ClassLoader.java:424) ~[na:1.8.0_121]\r\n\tat sun.misc.Launcher$AppClassLoader.loadClass(Launcher.java:331) ~[na:1.8.0_121]\r\n\tat java.lang.ClassLoader.loadClass(ClassLoader.java:357) ~[na:1.8.0_121]\r\n\t... 47 common frames omitted\r\n{noformat}\r\n\r\nThe cause is https:\/\/issues.apache.org\/jira\/browse\/CAMEL-12447, because when I add\r\n\r\n{code}\r\n<dependency>\r\n    <groupId>org.springframework<\/groupId>\r\n    <artifactId>spring-messaging<\/artifactId>\r\n<\/dependency>\r\n{code}\r\n\r\neverything works fine again.\r\n\r\n",
      "assignee":"davsclaus",
      "type":"Bug",
      "priority":"Major",
      "status":"Resolved",
      "text":"Camel-jms: ClassNotFoundException: org.springframework.messaging.handler.annotation.support.MessageHandlerMethodFactory in Spring-Boot Not sure if this is a Camel bug, but I'm using activemq-camel 5.14.5 in a spring-boot 1.5.12 application.\r\n\r\nAfter upgrading from Camel 2.21.0 to 2.21.1 start-up fails with:\r\n\r\n{noformat}\r\n2018-05-07 09:45:34.213 ERROR 7992 --- [  restartedMain] o.s.boot.SpringApplication               : Application startup failed\r\n\r\norg.springframework.beans.factory.BeanCreationException: Error creating bean with name 'org.springframework.jms.config.internalJmsListenerAnnotationProcessor' defined in class path resource [org\/springframework\/jms\/annotation\/JmsBootstrapConfiguration.class]: Bean instantiation via factory method failed; nested exception is org.springframework.beans.BeanInstantiationException: Failed to instantiate [org.springframework.jms.annotation.JmsListenerAnnotationBeanPostProcessor]: Factory method 'jmsListenerAnnotationProcessor' threw exception; nested exception is java.lang.NoClassDefFoundError: org\/springframework\/messaging\/handler\/annotation\/support\/MessageHandlerMethodFactory\r\n\tat org.springframework.beans.factory.support.ConstructorResolver.instantiateUsingFactoryMethod(ConstructorResolver.java:599) ~[spring-beans-4.3.16.RELEASE.jar:4.3.16.RELEASE]\r\n\tat org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.instantiateUsingFactoryMethod(AbstractAutowireCapableBeanFactory.java:1177) ~[spring-beans-4.3.16.RELEASE.jar:4.3.16.RELEASE]\r\n\tat org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBeanInstance(AbstractAutowireCapableBeanFactory.java:1071) ~[spring-beans-4.3.16.RELEASE.jar:4.3.16.RELEASE]\r\n\tat org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:513) ~[spring-beans-4.3.16.RELEASE.jar:4.3.16.RELEASE]\r\n\tat org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:483) ~[spring-beans-4.3.16.RELEASE.jar:4.3.16.RELEASE]\r\n\tat org.springframework.beans.factory.support.AbstractBeanFactory$1.getObject(AbstractBeanFactory.java:312) ~[spring-beans-4.3.16.RELEASE.jar:4.3.16.RELEASE]\r\n\tat org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:230) ~[spring-beans-4.3.16.RELEASE.jar:4.3.16.RELEASE]\r\n\tat org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:308) ~[spring-beans-4.3.16.RELEASE.jar:4.3.16.RELEASE]\r\n\tat org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:202) ~[spring-beans-4.3.16.RELEASE.jar:4.3.16.RELEASE]\r\n\tat org.springframework.context.support.PostProcessorRegistrationDelegate.registerBeanPostProcessors(PostProcessorRegistrationDelegate.java:225) ~[spring-context-4.3.16.RELEASE.jar:4.3.16.RELEASE]\r\n\tat org.springframework.context.support.AbstractApplicationContext.registerBeanPostProcessors(AbstractApplicationContext.java:703) ~[spring-context-4.3.16.RELEASE.jar:4.3.16.RELEASE]\r\n\tat org.springframework.context.support.AbstractApplicationContext.refresh(AbstractApplicationContext.java:528) ~[spring-context-4.3.16.RELEASE.jar:4.3.16.RELEASE]\r\n\tat org.springframework.boot.SpringApplication.refresh(SpringApplication.java:693) [spring-boot-1.5.12.RELEASE.jar:1.5.12.RELEASE]\r\n\tat org.springframework.boot.SpringApplication.refreshContext(SpringApplication.java:360) [spring-boot-1.5.12.RELEASE.jar:1.5.12.RELEASE]\r\n\tat org.springframework.boot.SpringApplication.run(SpringApplication.java:303) [spring-boot-1.5.12.RELEASE.jar:1.5.12.RELEASE]\r\n\tat org.springframework.boot.SpringApplication.run(SpringApplication.java:1118) [spring-boot-1.5.12.RELEASE.jar:1.5.12.RELEASE]\r\n\tat org.springframework.boot.SpringApplication.run(SpringApplication.java:1107) [spring-boot-1.5.12.RELEASE.jar:1.5.12.RELEASE]\r\n\tat de.telekom.dms.FlexKommBusinessServicesApplication.main(FlexKommBusinessServicesApplication.java:10) [classes\/:na]\r\n\tat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) ~[na:1.8.0_121]\r\n\tat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) ~[na:1.8.0_121]\r\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) ~[na:1.8.0_121]\r\n\tat java.lang.reflect.Method.invoke(Method.java:498) ~[na:1.8.0_121]\r\n\tat org.springframework.boot.devtools.restart.RestartLauncher.run(RestartLauncher.java:49) [spring-boot-devtools-1.5.12.RELEASE.jar:1.5.12.RELEASE]\r\nCaused by: org.springframework.beans.BeanInstantiationException: Failed to instantiate [org.springframework.jms.annotation.JmsListenerAnnotationBeanPostProcessor]: Factory method 'jmsListenerAnnotationProcessor' threw exception; nested exception is java.lang.NoClassDefFoundError: org\/springframework\/messaging\/handler\/annotation\/support\/MessageHandlerMethodFactory\r\n\tat org.springframework.beans.factory.support.SimpleInstantiationStrategy.instantiate(SimpleInstantiationStrategy.java:189) ~[spring-beans-4.3.16.RELEASE.jar:4.3.16.RELEASE]\r\n\tat org.springframework.beans.factory.support.ConstructorResolver.instantiateUsingFactoryMethod(ConstructorResolver.java:588) ~[spring-beans-4.3.16.RELEASE.jar:4.3.16.RELEASE]\r\n\t... 22 common frames omitted\r\nCaused by: java.lang.NoClassDefFoundError: org\/springframework\/messaging\/handler\/annotation\/support\/MessageHandlerMethodFactory\r\n\tat java.lang.ClassLoader.defineClass1(Native Method) ~[na:1.8.0_121]\r\n\tat java.lang.ClassLoader.defineClass(ClassLoader.java:763) ~[na:1.8.0_121]\r\n\tat java.security.SecureClassLoader.defineClass(SecureClassLoader.java:142) ~[na:1.8.0_121]\r\n\tat java.net.URLClassLoader.defineClass(URLClassLoader.java:467) ~[na:1.8.0_121]\r\n\tat java.net.URLClassLoader.access$100(URLClassLoader.java:73) ~[na:1.8.0_121]\r\n\tat java.net.URLClassLoader$1.run(URLClassLoader.java:368) ~[na:1.8.0_121]\r\n\tat java.net.URLClassLoader$1.run(URLClassLoader.java:362) ~[na:1.8.0_121]\r\n\tat java.security.AccessController.doPrivileged(Native Method) ~[na:1.8.0_121]\r\n\tat java.net.URLClassLoader.findClass(URLClassLoader.java:361) ~[na:1.8.0_121]\r\n\tat java.lang.ClassLoader.loadClass(ClassLoader.java:424) ~[na:1.8.0_121]\r\n\tat sun.misc.Launcher$AppClassLoader.loadClass(Launcher.java:331) ~[na:1.8.0_121]\r\n\tat java.lang.ClassLoader.loadClass(ClassLoader.java:357) ~[na:1.8.0_121]\r\n\tat org.springframework.jms.annotation.JmsListenerAnnotationBeanPostProcessor.<init>(JmsListenerAnnotationBeanPostProcessor.java:103) ~[spring-jms-4.3.16.RELEASE.jar:4.3.16.RELEASE]\r\n\tat org.springframework.jms.annotation.JmsBootstrapConfiguration.jmsListenerAnnotationProcessor(JmsBootstrapConfiguration.java:47) ~[spring-jms-4.3.16.RELEASE.jar:4.3.16.RELEASE]\r\n\tat org.springframework.jms.annotation.JmsBootstrapConfiguration$$EnhancerBySpringCGLIB$$1878cc3d.CGLIB$jmsListenerAnnotationProcessor$1(<generated>) ~[spring-jms-4.3.16.RELEASE.jar:4.3.16.RELEASE]\r\n\tat org.springframework.jms.annotation.JmsBootstrapConfiguration$$EnhancerBySpringCGLIB$$1878cc3d$$FastClassBySpringCGLIB$$265c8d54.invoke(<generated>) ~[spring-jms-4.3.16.RELEASE.jar:4.3.16.RELEASE]\r\n\tat org.springframework.cglib.proxy.MethodProxy.invokeSuper(MethodProxy.java:228) ~[spring-core-4.3.16.RELEASE.jar:4.3.16.RELEASE]\r\n\tat org.springframework.context.annotation.ConfigurationClassEnhancer$BeanMethodInterceptor.intercept(ConfigurationClassEnhancer.java:358) ~[spring-context-4.3.16.RELEASE.jar:4.3.16.RELEASE]\r\n\tat org.springframework.jms.annotation.JmsBootstrapConfiguration$$EnhancerBySpringCGLIB$$1878cc3d.jmsListenerAnnotationProcessor(<generated>) ~[spring-jms-4.3.16.RELEASE.jar:4.3.16.RELEASE]\r\n\tat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) ~[na:1.8.0_121]\r\n\tat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) ~[na:1.8.0_121]\r\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) ~[na:1.8.0_121]\r\n\tat java.lang.reflect.Method.invoke(Method.java:498) ~[na:1.8.0_121]\r\n\tat org.springframework.beans.factory.support.SimpleInstantiationStrategy.instantiate(SimpleInstantiationStrategy.java:162) ~[spring-beans-4.3.16.RELEASE.jar:4.3.16.RELEASE]\r\n\t... 23 common frames omitted\r\nCaused by: java.lang.ClassNotFoundException: org.springframework.messaging.handler.annotation.support.MessageHandlerMethodFactory\r\n\tat java.net.URLClassLoader.findClass(URLClassLoader.java:381) ~[na:1.8.0_121]\r\n\tat java.lang.ClassLoader.loadClass(ClassLoader.java:424) ~[na:1.8.0_121]\r\n\tat sun.misc.Launcher$AppClassLoader.loadClass(Launcher.java:331) ~[na:1.8.0_121]\r\n\tat java.lang.ClassLoader.loadClass(ClassLoader.java:357) ~[na:1.8.0_121]\r\n\t... 47 common frames omitted\r\n{noformat}\r\n\r\nThe cause is https:\/\/issues.apache.org\/jira\/browse\/CAMEL-12447, because when I add\r\n\r\n{code}\r\n<dependency>\r\n    <groupId>org.springframework<\/groupId>\r\n    <artifactId>spring-messaging<\/artifactId>\r\n<\/dependency>\r\n{code}\r\n\r\neverything works fine again.\r\n\r\n"
    },
    {
      "key":"CAMEL-12486",
      "title":"Placeholders are not resolved in Simple language while using resource: prefix",
      "description":"This behavior was found in question https:\/\/stackoverflow.com\/questions\/50063874\/load-camels-body-dynamically-depending-on-header\r\n\r\nThis is because expression with prefix *resource* is resolved in LanguageSupport#loadResource before property placeholders are resolved. This is reasonable,\u00a0as placeholders are resolved in expression loaded from file. But it prevents from dynamic resource loading.\r\n\r\nIt would be nice to allow property resolution in resource in this way\r\n{code:java}\r\n.transform().simple(\"resource:classpath:${header.myFileName}\"){code}\r\nI would expect this behavior:\r\n # Resolve placeholders in expression (now missing)\r\n # Load String from resource as new expression (exists)\r\n # Resolve placeholders in new expression (exists)\r\n\r\nI have tried to create patch for *SimpleLanguage*, but I failed. Attaching patch to\u00a0*SimpleResourceTest* with expected behavior based on master.",
      "assignee":"davsclaus",
      "type":"Wish",
      "priority":"Minor",
      "status":"Resolved",
      "text":"Placeholders are not resolved in Simple language while using resource: prefix This behavior was found in question https:\/\/stackoverflow.com\/questions\/50063874\/load-camels-body-dynamically-depending-on-header\r\n\r\nThis is because expression with prefix *resource* is resolved in LanguageSupport#loadResource before property placeholders are resolved. This is reasonable, as placeholders are resolved in expression loaded from file. But it prevents from dynamic resource loading.\r\n\r\nIt would be nice to allow property resolution in resource in this way\r\n{code:java}\r\n.transform().simple(\"resource:classpath:${header.myFileName}\"){code}\r\nI would expect this behavior:\r\n # Resolve placeholders in expression (now missing)\r\n # Load String from resource as new expression (exists)\r\n # Resolve placeholders in new expression (exists)\r\n\r\nI have tried to create patch for *SimpleLanguage*, but I failed. Attaching patch to *SimpleResourceTest* with expected behavior based on master."
    },
    {
      "key":"CAMEL-12483",
      "title":"route-coverage : endChoice() problem",
      "description":"When running\u00a0\r\n{code:java}\r\nmvn camel:route-coverage{code}\r\non routes that use endChoice() you get a NullPointerException.\u00a0\r\n{code:java}\r\n[WARNING] Error parsing java file c:\\workspace\\kk\\coverage\\src\\main\\java\\dk\\smor\\MySpringBootRouter.java code due null\r\njava.lang.NullPointerException\r\nat org.apache.camel.parser.helper.CamelJavaTreeParserHelper.parseCamelRouteTree(CamelJavaTreeParserHelper.java:132)\r\nat org.apache.camel.parser.RouteBuilderParser.parseRouteBuilderTree(RouteBuilderParser.java:80)\r\nat org.apache.camel.maven.RouteCoverageMojo.execute(RouteCoverageMojo.java:158)\r\nat org.apache.maven.plugin.DefaultBuildPluginManager.executeMojo(DefaultBuildPluginManager.java:134)\r\nat org.apache.maven.lifecycle.internal.MojoExecutor.execute(MojoExecutor.java:207)\r\nat org.apache.maven.lifecycle.internal.MojoExecutor.execute(MojoExecutor.java:153)\r\nat org.apache.maven.lifecycle.internal.MojoExecutor.execute(MojoExecutor.java:145)\r\nat org.apache.maven.lifecycle.internal.LifecycleModuleBuilder.buildProject(LifecycleModuleBuilder.java:116)\r\nat org.apache.maven.lifecycle.internal.LifecycleModuleBuilder.buildProject(LifecycleModuleBuilder.java:80)\r\nat org.apache.maven.lifecycle.internal.builder.singlethreaded.SingleThreadedBuilder.build(SingleThreadedBuilder.java:51)\r\nat org.apache.maven.lifecycle.internal.LifecycleStarter.execute(LifecycleStarter.java:128)\r\nat org.apache.maven.DefaultMaven.doExecute(DefaultMaven.java:307)\r\nat org.apache.maven.DefaultMaven.doExecute(DefaultMaven.java:193)\r\nat org.apache.maven.DefaultMaven.execute(DefaultMaven.java:106)\r\nat org.apache.maven.cli.MavenCli.execute(MavenCli.java:863)\r\nat org.apache.maven.cli.MavenCli.doMain(MavenCli.java:288)\r\nat org.apache.maven.cli.MavenCli.main(MavenCli.java:199)\r\nat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\r\nat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)\r\nat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\r\nat java.lang.reflect.Method.invoke(Method.java:498)\r\nat org.codehaus.plexus.classworlds.launcher.Launcher.launchEnhanced(Launcher.java:289)\r\nat org.codehaus.plexus.classworlds.launcher.Launcher.launch(Launcher.java:229)\r\nat org.codehaus.plexus.classworlds.launcher.Launcher.mainWithExitCode(Launcher.java:415)\r\nat org.codehaus.plexus.classworlds.launcher.Launcher.main(Launcher.java:356)\r\n{code}\r\n\r\nI have attached a zip file with some example code to re-produce the problem.\r\nThe example code has 2 routes, 1 with endChoice() and 1 without. The 2 route should behave equally.\r\n",
      "assignee":"davsclaus",
      "type":"Bug",
      "priority":"Minor",
      "status":"Resolved",
      "text":"route-coverage : endChoice() problem When running \r\n{code:java}\r\nmvn camel:route-coverage{code}\r\non routes that use endChoice() you get a NullPointerException. \r\n{code:java}\r\n[WARNING] Error parsing java file c:\\workspace\\kk\\coverage\\src\\main\\java\\dk\\smor\\MySpringBootRouter.java code due null\r\njava.lang.NullPointerException\r\nat org.apache.camel.parser.helper.CamelJavaTreeParserHelper.parseCamelRouteTree(CamelJavaTreeParserHelper.java:132)\r\nat org.apache.camel.parser.RouteBuilderParser.parseRouteBuilderTree(RouteBuilderParser.java:80)\r\nat org.apache.camel.maven.RouteCoverageMojo.execute(RouteCoverageMojo.java:158)\r\nat org.apache.maven.plugin.DefaultBuildPluginManager.executeMojo(DefaultBuildPluginManager.java:134)\r\nat org.apache.maven.lifecycle.internal.MojoExecutor.execute(MojoExecutor.java:207)\r\nat org.apache.maven.lifecycle.internal.MojoExecutor.execute(MojoExecutor.java:153)\r\nat org.apache.maven.lifecycle.internal.MojoExecutor.execute(MojoExecutor.java:145)\r\nat org.apache.maven.lifecycle.internal.LifecycleModuleBuilder.buildProject(LifecycleModuleBuilder.java:116)\r\nat org.apache.maven.lifecycle.internal.LifecycleModuleBuilder.buildProject(LifecycleModuleBuilder.java:80)\r\nat org.apache.maven.lifecycle.internal.builder.singlethreaded.SingleThreadedBuilder.build(SingleThreadedBuilder.java:51)\r\nat org.apache.maven.lifecycle.internal.LifecycleStarter.execute(LifecycleStarter.java:128)\r\nat org.apache.maven.DefaultMaven.doExecute(DefaultMaven.java:307)\r\nat org.apache.maven.DefaultMaven.doExecute(DefaultMaven.java:193)\r\nat org.apache.maven.DefaultMaven.execute(DefaultMaven.java:106)\r\nat org.apache.maven.cli.MavenCli.execute(MavenCli.java:863)\r\nat org.apache.maven.cli.MavenCli.doMain(MavenCli.java:288)\r\nat org.apache.maven.cli.MavenCli.main(MavenCli.java:199)\r\nat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\r\nat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)\r\nat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\r\nat java.lang.reflect.Method.invoke(Method.java:498)\r\nat org.codehaus.plexus.classworlds.launcher.Launcher.launchEnhanced(Launcher.java:289)\r\nat org.codehaus.plexus.classworlds.launcher.Launcher.launch(Launcher.java:229)\r\nat org.codehaus.plexus.classworlds.launcher.Launcher.mainWithExitCode(Launcher.java:415)\r\nat org.codehaus.plexus.classworlds.launcher.Launcher.main(Launcher.java:356)\r\n{code}\r\n\r\nI have attached a zip file with some example code to re-produce the problem.\r\nThe example code has 2 routes, 1 with endChoice() and 1 without. The 2 route should behave equally.\r\n"
    },
    {
      "key":"CAMEL-12475",
      "title":"Undertow consumer with http4 producer results in Undertow throwing NullPointerException",
      "description":"I have a very simple setup of Camel (standalone).\r\n\r\nMy route is as follows:\r\n{code:java}\r\npublic class Application {\r\n    public static void main(String... args) throws Exception {\r\n        Main main = new Main();\r\n\r\n        main.addRouteBuilder(new RouteBuilder() {\r\n            @Override\r\n            public void configure() throws Exception {\r\n                restConfiguration().port(8080);\r\n\r\n                rest(\"\/pi\")\r\n                        .get()\r\n                        .route()\r\n                        .setExchangePattern(ExchangePattern.InOut)\r\n                        .to(\"https4:\/\/api.pi.delivery\/v1\/pi?bridgeEndpoint=true\");\r\n            }\r\n        });\r\n\r\n        main.run();\r\n    }\r\n}{code}\r\nCall the endpoint with:\u00a0\r\n{noformat}\r\ncurl \"http:\/\/localhost:8080\/pi?start=0&numberOfDigits=10\"{noformat}\r\n\u00a0\r\n\r\nWhen using camel-undertow for consumer and camel-http4 for producer, I get a NullPointerException.\r\n{code:java}\r\njava.lang.NullPointerException: null\r\nat io.undertow.io.AsyncSenderImpl.send(AsyncSenderImpl.java:141) ~[undertow-core-1.4.23.Final.jar:1.4.23.Final]\r\nat io.undertow.io.AsyncSenderImpl.send(AsyncSenderImpl.java:285) ~[undertow-core-1.4.23.Final.jar:1.4.23.Final]\r\nat org.apache.camel.component.undertow.UndertowConsumer.handleRequest(UndertowConsumer.java:142) ~[camel-undertow-2.21.0.jar:2.21.0]\r\nat io.undertow.server.Connectors.executeRootHandler(Connectors.java:336) ~[undertow-core-1.4.23.Final.jar:1.4.23.Final]\r\nat io.undertow.server.HttpServerExchange$1.run(HttpServerExchange.java:830) ~[undertow-core-1.4.23.Final.jar:1.4.23.Final]\r\nat java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142) ~[na:1.8.0_102]\r\nat java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617) ~[na:1.8.0_102]\r\nat java.lang.Thread.run(Thread.java:745) ~[na:1.8.0_102]\r\n{code}\r\nHowever, if I switch out the camel-undertow dependency with camel-jetty, the above route configuration works just fine.",
      "assignee":"njiang",
      "type":"Bug",
      "priority":"Major",
      "status":"Resolved",
      "text":"Undertow consumer with http4 producer results in Undertow throwing NullPointerException I have a very simple setup of Camel (standalone).\r\n\r\nMy route is as follows:\r\n{code:java}\r\npublic class Application {\r\n    public static void main(String... args) throws Exception {\r\n        Main main = new Main();\r\n\r\n        main.addRouteBuilder(new RouteBuilder() {\r\n            @Override\r\n            public void configure() throws Exception {\r\n                restConfiguration().port(8080);\r\n\r\n                rest(\"\/pi\")\r\n                        .get()\r\n                        .route()\r\n                        .setExchangePattern(ExchangePattern.InOut)\r\n                        .to(\"https4:\/\/api.pi.delivery\/v1\/pi?bridgeEndpoint=true\");\r\n            }\r\n        });\r\n\r\n        main.run();\r\n    }\r\n}{code}\r\nCall the endpoint with: \r\n{noformat}\r\ncurl \"http:\/\/localhost:8080\/pi?start=0&numberOfDigits=10\"{noformat}\r\n \r\n\r\nWhen using camel-undertow for consumer and camel-http4 for producer, I get a NullPointerException.\r\n{code:java}\r\njava.lang.NullPointerException: null\r\nat io.undertow.io.AsyncSenderImpl.send(AsyncSenderImpl.java:141) ~[undertow-core-1.4.23.Final.jar:1.4.23.Final]\r\nat io.undertow.io.AsyncSenderImpl.send(AsyncSenderImpl.java:285) ~[undertow-core-1.4.23.Final.jar:1.4.23.Final]\r\nat org.apache.camel.component.undertow.UndertowConsumer.handleRequest(UndertowConsumer.java:142) ~[camel-undertow-2.21.0.jar:2.21.0]\r\nat io.undertow.server.Connectors.executeRootHandler(Connectors.java:336) ~[undertow-core-1.4.23.Final.jar:1.4.23.Final]\r\nat io.undertow.server.HttpServerExchange$1.run(HttpServerExchange.java:830) ~[undertow-core-1.4.23.Final.jar:1.4.23.Final]\r\nat java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142) ~[na:1.8.0_102]\r\nat java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617) ~[na:1.8.0_102]\r\nat java.lang.Thread.run(Thread.java:745) ~[na:1.8.0_102]\r\n{code}\r\nHowever, if I switch out the camel-undertow dependency with camel-jetty, the above route configuration works just fine."
    },
    {
      "key":"CAMEL-12469",
      "title":"How to do dynamic redirecting for rest and soap calls in Apache Camel without bothering what the request method type(post\/get\/update\/delete) and request payload.",
      "description":"Incoming REST Url: [http:\/\/localhost:8888\/carParking\/carCheckOut]\r\n\r\nRedirect URL\u00a0 will be like:\u00a0Redirect Url \u2013 [http:\/\/\\|http:\/\/issues.apache.org\/]{localhost:9090}\/\\{MainController}\/\\{requestParam}\r\n\r\nExample: [http:\/\/camelRouteHost:9090\/carParking\/carCheckIn|http:\/\/camelroutehost:9090\/carParking\/carCheckIn]\r\n\r\nI just want to redirect the rest\/soap url without bothering method type(post\/put etc..) and request payload(json\/xml)\r\n\r\nAnd i just want to display same result what my actual endpoint is giving.\r\n\r\n\u00a0\r\n\r\n\u00a0",
      "assignee":"davsclaus",
      "type":"Bug",
      "priority":"Major",
      "status":"Closed",
      "text":"How to do dynamic redirecting for rest and soap calls in Apache Camel without bothering what the request method type(post\/get\/update\/delete) and request payload. Incoming REST Url: [http:\/\/localhost:8888\/carParking\/carCheckOut]\r\n\r\nRedirect URL  will be like: Redirect Url - [http:\/\/\\|http:\/\/issues.apache.org\/]{localhost:9090}\/\\{MainController}\/\\{requestParam}\r\n\r\nExample: [http:\/\/camelRouteHost:9090\/carParking\/carCheckIn|http:\/\/camelroutehost:9090\/carParking\/carCheckIn]\r\n\r\nI just want to redirect the rest\/soap url without bothering method type(post\/put etc..) and request payload(json\/xml)\r\n\r\nAnd i just want to display same result what my actual endpoint is giving.\r\n\r\n \r\n\r\n "
    },
    {
      "key":"CAMEL-12467",
      "title":"FatJarRouter no longer exists",
      "description":"Inthe documentation, FatJarRouter is referenced as the entry point for spring boot apps\r\n\r\n\u00a0\r\n\r\n[http:\/\/camel.apache.org\/spring-boot.html]\r\n\r\n\u00a0\r\n\r\nThis is no longer the case.\u00a0 If I read this PR correctly, [https:\/\/github.com\/apache\/camel\/pull\/1222]\u00a0, users have to implement it the normal way in spring boot, just using a main method.",
      "assignee":"davsclaus",
      "type":"Bug",
      "priority":"Major",
      "status":"Resolved",
      "text":"FatJarRouter no longer exists Inthe documentation, FatJarRouter is referenced as the entry point for spring boot apps\r\n\r\n \r\n\r\n[http:\/\/camel.apache.org\/spring-boot.html]\r\n\r\n \r\n\r\nThis is no longer the case.  If I read this PR correctly, [https:\/\/github.com\/apache\/camel\/pull\/1222] , users have to implement it the normal way in spring boot, just using a main method."
    },
    {
      "key":"CAMEL-12462",
      "title":"toD with HTTP endpoints - Optimise dynamic query to leverage HTTP_QUERY header",
      "description":"We can consider for some HTTP components that support dynamic parts of their endpoints from Camel headers such as HTTP_QUERY and others.\r\n\r\nWe can then in toD detect those components and then build a processor chain that does\r\n # setHeader - set dynamic header HTTP_QUERY\r\n # toD - call the endpoint with a more static uri\r\n\r\nThis optimises to reuse the toD with more static uris, especially if you hit the same host for each toD and its only the query parameters that are dynamic.\r\n\r\nToday developers would need to use setHeader and to combo to do this, instead of a single toD.\r\n\r\nThe trick is to separate the query parameters and the endpoint parameters and only set query parameters in the setHeader, and the endpoint parameters in toD.",
      "assignee":"davsclaus",
      "type":"Improvement",
      "priority":"Major",
      "status":"Resolved",
      "text":"toD with HTTP endpoints - Optimise dynamic query to leverage HTTP_QUERY header We can consider for some HTTP components that support dynamic parts of their endpoints from Camel headers such as HTTP_QUERY and others.\r\n\r\nWe can then in toD detect those components and then build a processor chain that does\r\n # setHeader - set dynamic header HTTP_QUERY\r\n # toD - call the endpoint with a more static uri\r\n\r\nThis optimises to reuse the toD with more static uris, especially if you hit the same host for each toD and its only the query parameters that are dynamic.\r\n\r\nToday developers would need to use setHeader and to combo to do this, instead of a single toD.\r\n\r\nThe trick is to separate the query parameters and the endpoint parameters and only set query parameters in the setHeader, and the endpoint parameters in toD."
    },
    {
      "key":"CAMEL-12458",
      "title":"camel-twitter - Should support extended mode by default",
      "description":"So we can receive > 140 chars.\r\n\r\n\u00a0\r\n\r\nSee this PR\r\n\r\nhttps:\/\/github.com\/apache\/camel\/pull\/2292",
      "assignee":"davsclaus",
      "type":"Improvement",
      "priority":"Major",
      "status":"Resolved",
      "text":"camel-twitter - Should support extended mode by default So we can receive > 140 chars.\r\n\r\n \r\n\r\nSee this PR\r\n\r\nhttps:\/\/github.com\/apache\/camel\/pull\/2292"
    },
    {
      "key":"CAMEL-12457",
      "title":"file consumer - Should not use readlock by default",
      "description":"The file consumer should use readLock=none by default, which is also what the documentation says. However its reconfigured to markerFile which is a little mistake.\r\n\r\n\u00a0",
      "assignee":"davsclaus",
      "type":"Bug",
      "priority":"Major",
      "status":"Resolved",
      "text":"file consumer - Should not use readlock by default The file consumer should use readLock=none by default, which is also what the documentation says. However its reconfigured to markerFile which is a little mistake.\r\n\r\n "
    },
    {
      "key":"CAMEL-12454",
      "title":"camel-kafka - AutoCommitEnabled=false should not auto commit",
      "description":"Reported on gitter\r\n\r\nJohn Culleton @jcullet Apr 17 17:22\r\nHi All - I'm running into an issue with the camel-kafka component when attempting to disable auto commit behavior. On camel 2.21, I'm finding that the offset is being committed even when \"autoCommitEnable=false\" is specified. When running through a debugger, I see that the offset commit is happening here: https:\/\/github.com\/apache\/camel\/blob\/0f98938e3b6ea15a2e022c707bf21a2af4ed7e0d\/components\/camel-kafka\/src\/main\/java\/org\/apache\/camel\/component\/kafka\/KafkaConsumer.java#L382. Based on the conditional, I think it would always evaluate to true when autoCommitEnable is set to false?",
      "assignee":"davsclaus",
      "type":"Bug",
      "priority":"Major",
      "status":"Resolved",
      "text":"camel-kafka - AutoCommitEnabled=false should not auto commit Reported on gitter\r\n\r\nJohn Culleton @jcullet Apr 17 17:22\r\nHi All - I'm running into an issue with the camel-kafka component when attempting to disable auto commit behavior. On camel 2.21, I'm finding that the offset is being committed even when \"autoCommitEnable=false\" is specified. When running through a debugger, I see that the offset commit is happening here: https:\/\/github.com\/apache\/camel\/blob\/0f98938e3b6ea15a2e022c707bf21a2af4ed7e0d\/components\/camel-kafka\/src\/main\/java\/org\/apache\/camel\/component\/kafka\/KafkaConsumer.java#L382. Based on the conditional, I think it would always evaluate to true when autoCommitEnable is set to false?"
    }]}