JDBC StreamList and outputClass does not work Situation is simple:I try to load data from jdbc by Stream to Java objectwith such command jdbc:dbBean?outputType=StreamList&outputClass=myClass.I estimate Java object on exit of flow? but i have Map<String, Object>.Bug in JdbcProducer at lines 326.if (outputType == JdbcOutputType.StreamList) { exchange.getOut().setBody(iterator); exchange.addOnCompletion(new ResultSetIteratorCompletion(iterator)); // do not close resources as we are in streaming mode answer = false;}Here need wrap iterator to map objects by method newBeanInstance Bug JDBC StreamList and outputClass does not work Situation is simple:I try to load data from jdbc by Stream to Java objectwith such command jdbc:dbBean?outputType=StreamList&outputClass=myClass.I estimate Java object on exit of flow? but i have Map<String, Object>.Bug in JdbcProducer at lines 326.if (outputType == JdbcOutputType.StreamList) { exchange.getOut().setBody(iterator); exchange.addOnCompletion(new ResultSetIteratorCompletion(iterator)); // do not close resources as we are in streaming mode answer = false;}Here need wrap iterator to map objects by method newBeanInstance
multiple consumers for namedReplyTo results in a cryptic nullPointer Per [https://camel.apache.org/components/latest/sjms-component.html#_clustering] you should not have multiple inOut producerEndpoints using the same replyTo address but if you do it results in a cryptic null pointer exception it would be nice to have a better error message of some sort directing you to use a unique replyTo address or temporary queue. Additionally if the replyTo is a topic then I don't believe it should result in an error and it may be better to actually use a message selector for this case.java.lang.NullPointerException: nulljava.lang.NullPointerException: null at org.apache.camel.component.sjms.producer.InOutProducer$MessageConsumerResourcesFactory$1.onMessage(InOutProducer.java:103) ~[?:?] at org.apache.activemq.artemis.jms.client.JMSMessageListenerWrapper.onMessage(JMSMessageListenerWrapper.java:110) ~[254:org.apache.activemq.artemis-server-osgi:2.8.1] at org.apache.activemq.artemis.core.client.impl.ClientConsumerImpl.callOnMessage(ClientConsumerImpl.java:1031) ~[?:?] at org.apache.activemq.artemis.core.client.impl.ClientConsumerImpl.access$400(ClientConsumerImpl.java:50) ~[?:?] at org.apache.activemq.artemis.core.client.impl.ClientConsumerImpl$Runner.run(ClientConsumerImpl.java:1154) ~[?:?] at org.apache.activemq.artemis.utils.actors.OrderedExecutor.doTask(OrderedExecutor.java:42) ~[?:?] at org.apache.activemq.artemis.utils.actors.OrderedExecutor.doTask(OrderedExecutor.java:31) ~[?:?] at org.apache.activemq.artemis.utils.actors.ProcessorBase.executePendingTasks(ProcessorBase.java:66) ~[?:?] at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149) [?:?] at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624) [?:?] Bug multiple consumers for namedReplyTo results in a cryptic nullPointer Per [https://camel.apache.org/components/latest/sjms-component.html#_clustering] you should not have multiple inOut producerEndpoints using the same replyTo address but if you do it results in a cryptic null pointer exception it would be nice to have a better error message of some sort directing you to use a unique replyTo address or temporary queue. Additionally if the replyTo is a topic then I don't believe it should result in an error and it may be better to actually use a message selector for this case.java.lang.NullPointerException: nulljava.lang.NullPointerException: null at org.apache.camel.component.sjms.producer.InOutProducer$MessageConsumerResourcesFactory$1.onMessage(InOutProducer.java:103) ~[?:?] at org.apache.activemq.artemis.jms.client.JMSMessageListenerWrapper.onMessage(JMSMessageListenerWrapper.java:110) ~[254:org.apache.activemq.artemis-server-osgi:2.8.1] at org.apache.activemq.artemis.core.client.impl.ClientConsumerImpl.callOnMessage(ClientConsumerImpl.java:1031) ~[?:?] at org.apache.activemq.artemis.core.client.impl.ClientConsumerImpl.access$400(ClientConsumerImpl.java:50) ~[?:?] at org.apache.activemq.artemis.core.client.impl.ClientConsumerImpl$Runner.run(ClientConsumerImpl.java:1154) ~[?:?] at org.apache.activemq.artemis.utils.actors.OrderedExecutor.doTask(OrderedExecutor.java:42) ~[?:?] at org.apache.activemq.artemis.utils.actors.OrderedExecutor.doTask(OrderedExecutor.java:31) ~[?:?] at org.apache.activemq.artemis.utils.actors.ProcessorBase.executePendingTasks(ProcessorBase.java:66) ~[?:?] at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149) [?:?] at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624) [?:?]
camel-ftp - streamDownload=true and move options dont work Reported on mailing listhttps://camel.465427.n5.nabble.com/Bug-Camel-FTP-streamdownload-move-options-tp5843791.html Bug camel-ftp - streamDownload=true and move options dont work Reported on mailing listhttps://camel.465427.n5.nabble.com/Bug-Camel-FTP-streamdownload-move-options-tp5843791.html
Salesforce Component IDLE_TIMEOUT Blocks Async Request Responses for 2.x Bulk, Composite Batch, etc. all throw an exception when trying to return on more than a few records due to [static final IDLE_TIMEOUT|https://github.com/apache/camel/blob/master/components/camel-salesforce/camel-salesforce-component/src/main/java/org/apache/camel/component/salesforce/SalesforceComponent.java#L80] on the instantiated salesforce component httpClient: Caused by: org.apache.camel.component.salesforce.api.SalesforceException: Unexpected error \{0:null} executing \{POST:https://genericSFDCInstance.salesforce.com/services/data/v38.0/composite/batch}        at org.apache.camel.component.salesforce.internal.client.AbstractClientBase$1.onComplete(AbstractClientBase.java:199) ~[camel-salesforce-2.23.0.jar:2.23.0]        at org.eclipse.jetty.client.ResponseNotifier.notifyComplete(ResponseNotifier.java:202) ~[jetty-client-9.4.12.v20180830.jar:9.4.12.v20180830]        at org.eclipse.jetty.client.ResponseNotifier.notifyComplete(ResponseNotifier.java:194) ~[jetty-client-9.4.12.v20180830.jar:9.4.12.v20180830]        at org.eclipse.jetty.client.HttpReceiver.terminateResponse(HttpReceiver.java:470) ~[jetty-client-9.4.12.v20180830.jar:9.4.12.v20180830]        at org.eclipse.jetty.client.HttpReceiver.abort(HttpReceiver.java:552) ~[jetty-client-9.4.12.v20180830.jar:9.4.12.v20180830]        at org.eclipse.jetty.client.HttpChannel.abortResponse(HttpChannel.java:156) ~[jetty-client-9.4.12.v20180830.jar:9.4.12.v20180830]        at org.eclipse.jetty.client.HttpChannel.abort(HttpChannel.java:149) ~[jetty-client-9.4.12.v20180830.jar:9.4.12.v20180830]        at org.eclipse.jetty.client.HttpExchange.abort(HttpExchange.java:257) ~[jetty-client-9.4.12.v20180830.jar:9.4.12.v20180830]        at org.eclipse.jetty.client.HttpConversation.abort(HttpConversation.java:141) ~[jetty-client-9.4.12.v20180830.jar:9.4.12.v20180830]        at org.eclipse.jetty.client.HttpRequest.abort(HttpRequest.java:767) ~[jetty-client-9.4.12.v20180830.jar:9.4.12.v20180830]        at org.eclipse.jetty.client.http.HttpConnectionOverHTTP.abort(HttpConnectionOverHTTP.java:204) ~[jetty-client-9.4.12.v20180830.jar:9.4.12.v20180830]        at org.eclipse.jetty.client.http.HttpConnectionOverHTTP.close(HttpConnectionOverHTTP.java:190) ~[jetty-client-9.4.12.v20180830.jar:9.4.12.v20180830]        at org.eclipse.jetty.client.http.HttpConnectionOverHTTP.onIdleExpired(HttpConnectionOverHTTP.java:145) ~[jetty-client-9.4.12.v20180830.jar:9.4.12.v20180830]        at org.eclipse.jetty.io.ssl.SslConnection.onIdleExpired(SslConnection.java:286) ~[jetty-io-9.4.12.v20180830.jar:9.4.12.v20180830]        at org.eclipse.jetty.io.AbstractEndPoint.onIdleExpired(AbstractEndPoint.java:401) ~[jetty-io-9.4.12.v20180830.jar:9.4.12.v20180830]        at org.eclipse.jetty.io.IdleTimeout.checkIdleTimeout(IdleTimeout.java:166) ~[jetty-io-9.4.12.v20180830.jar:9.4.12.v20180830]        at org.eclipse.jetty.io.IdleTimeout$1.run(IdleTimeout.java:50) ~[jetty-io-9.4.12.v20180830.jar:9.4.12.v20180830]        at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511) ~[?:1.8.0_201]        at java.util.concurrent.FutureTask.run(FutureTask.java:266) ~[?:1.8.0_201]        at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.access$201(ScheduledThreadPoolExecutor.java:180) ~[?:1.8.0_201]        at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:293) ~[?:1.8.0_201]        at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149) ~[?:1.8.0_201]        at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624) ~[?:1.8.0_201]        ... 1 more*Caused by: java.util.concurrent.TimeoutException: Idle timeout 5000 ms*        at org.eclipse.jetty.client.http.HttpConnectionOverHTTP.onIdleExpired(HttpConnectionOverHTTP.java:145) ~[jetty-client-9.4.12.v20180830.jar:9.4.12.v20180830]        at org.eclipse.jetty.io.ssl.SslConnection.onIdleExpired(SslConnection.java:286) ~[jetty-io-9.4.12.v20180830.jar:9.4.12.v20180830]        at org.eclipse.jetty.io.AbstractEndPoint.onIdleExpired(AbstractEndPoint.java:401) ~[jetty-io-9.4.12.v20180830.jar:9.4.12.v20180830]        at org.eclipse.jetty.io.IdleTimeout.checkIdleTimeout(IdleTimeout.java:166) ~[jetty-io-9.4.12.v20180830.jar:9.4.12.v20180830]        at org.eclipse.jetty.io.IdleTimeout$1.run(IdleTimeout.java:50) ~[jetty-io-9.4.12.v20180830.jar:9.4.12.v20180830]        at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511) ~[?:1.8.0_201]        at java.util.concurrent.FutureTask.run(FutureTask.java:266) ~[?:1.8.0_201]        at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.access$201(ScheduledThreadPoolExecutor.java:180) ~[?:1.8.0_201]        at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:293) ~[?:1.8.0_201]        at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149) ~[?:1.8.0_201]        at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624) ~[?:1.8.0_201]        ... 1 more Note that as IDLE_TIMEOUT is static, it cannot be set via Spring, and the httpClientProperties map is [never used to set any timeouts|https://github.com/apache/camel/blob/master/components/camel-salesforce/camel-salesforce-component/src/main/java/org/apache/camel/component/salesforce/SalesforceComponent.java#L714], instead opting to take the [hardcoded defaults|https://github.com/apache/camel/blob/master/components/camel-salesforce/camel-salesforce-component/src/main/java/org/apache/camel/component/salesforce/SalesforceComponent.java#L707].  Bug Salesforce Component IDLE_TIMEOUT Blocks Async Request Responses for 2.x Bulk, Composite Batch, etc. all throw an exception when trying to return on more than a few records due to [static final IDLE_TIMEOUT|https://github.com/apache/camel/blob/master/components/camel-salesforce/camel-salesforce-component/src/main/java/org/apache/camel/component/salesforce/SalesforceComponent.java#L80] on the instantiated salesforce component httpClient: Caused by: org.apache.camel.component.salesforce.api.SalesforceException: Unexpected error \{0:null} executing \{POST:https://genericSFDCInstance.salesforce.com/services/data/v38.0/composite/batch}        at org.apache.camel.component.salesforce.internal.client.AbstractClientBase$1.onComplete(AbstractClientBase.java:199) ~[camel-salesforce-2.23.0.jar:2.23.0]        at org.eclipse.jetty.client.ResponseNotifier.notifyComplete(ResponseNotifier.java:202) ~[jetty-client-9.4.12.v20180830.jar:9.4.12.v20180830]        at org.eclipse.jetty.client.ResponseNotifier.notifyComplete(ResponseNotifier.java:194) ~[jetty-client-9.4.12.v20180830.jar:9.4.12.v20180830]        at org.eclipse.jetty.client.HttpReceiver.terminateResponse(HttpReceiver.java:470) ~[jetty-client-9.4.12.v20180830.jar:9.4.12.v20180830]        at org.eclipse.jetty.client.HttpReceiver.abort(HttpReceiver.java:552) ~[jetty-client-9.4.12.v20180830.jar:9.4.12.v20180830]        at org.eclipse.jetty.client.HttpChannel.abortResponse(HttpChannel.java:156) ~[jetty-client-9.4.12.v20180830.jar:9.4.12.v20180830]        at org.eclipse.jetty.client.HttpChannel.abort(HttpChannel.java:149) ~[jetty-client-9.4.12.v20180830.jar:9.4.12.v20180830]        at org.eclipse.jetty.client.HttpExchange.abort(HttpExchange.java:257) ~[jetty-client-9.4.12.v20180830.jar:9.4.12.v20180830]        at org.eclipse.jetty.client.HttpConversation.abort(HttpConversation.java:141) ~[jetty-client-9.4.12.v20180830.jar:9.4.12.v20180830]        at org.eclipse.jetty.client.HttpRequest.abort(HttpRequest.java:767) ~[jetty-client-9.4.12.v20180830.jar:9.4.12.v20180830]        at org.eclipse.jetty.client.http.HttpConnectionOverHTTP.abort(HttpConnectionOverHTTP.java:204) ~[jetty-client-9.4.12.v20180830.jar:9.4.12.v20180830]        at org.eclipse.jetty.client.http.HttpConnectionOverHTTP.close(HttpConnectionOverHTTP.java:190) ~[jetty-client-9.4.12.v20180830.jar:9.4.12.v20180830]        at org.eclipse.jetty.client.http.HttpConnectionOverHTTP.onIdleExpired(HttpConnectionOverHTTP.java:145) ~[jetty-client-9.4.12.v20180830.jar:9.4.12.v20180830]        at org.eclipse.jetty.io.ssl.SslConnection.onIdleExpired(SslConnection.java:286) ~[jetty-io-9.4.12.v20180830.jar:9.4.12.v20180830]        at org.eclipse.jetty.io.AbstractEndPoint.onIdleExpired(AbstractEndPoint.java:401) ~[jetty-io-9.4.12.v20180830.jar:9.4.12.v20180830]        at org.eclipse.jetty.io.IdleTimeout.checkIdleTimeout(IdleTimeout.java:166) ~[jetty-io-9.4.12.v20180830.jar:9.4.12.v20180830]        at org.eclipse.jetty.io.IdleTimeout$1.run(IdleTimeout.java:50) ~[jetty-io-9.4.12.v20180830.jar:9.4.12.v20180830]        at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511) ~[?:1.8.0_201]        at java.util.concurrent.FutureTask.run(FutureTask.java:266) ~[?:1.8.0_201]        at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.access$201(ScheduledThreadPoolExecutor.java:180) ~[?:1.8.0_201]        at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:293) ~[?:1.8.0_201]        at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149) ~[?:1.8.0_201]        at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624) ~[?:1.8.0_201]        ... 1 more*Caused by: java.util.concurrent.TimeoutException: Idle timeout 5000 ms*        at org.eclipse.jetty.client.http.HttpConnectionOverHTTP.onIdleExpired(HttpConnectionOverHTTP.java:145) ~[jetty-client-9.4.12.v20180830.jar:9.4.12.v20180830]        at org.eclipse.jetty.io.ssl.SslConnection.onIdleExpired(SslConnection.java:286) ~[jetty-io-9.4.12.v20180830.jar:9.4.12.v20180830]        at org.eclipse.jetty.io.AbstractEndPoint.onIdleExpired(AbstractEndPoint.java:401) ~[jetty-io-9.4.12.v20180830.jar:9.4.12.v20180830]        at org.eclipse.jetty.io.IdleTimeout.checkIdleTimeout(IdleTimeout.java:166) ~[jetty-io-9.4.12.v20180830.jar:9.4.12.v20180830]        at org.eclipse.jetty.io.IdleTimeout$1.run(IdleTimeout.java:50) ~[jetty-io-9.4.12.v20180830.jar:9.4.12.v20180830]        at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511) ~[?:1.8.0_201]        at java.util.concurrent.FutureTask.run(FutureTask.java:266) ~[?:1.8.0_201]        at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.access$201(ScheduledThreadPoolExecutor.java:180) ~[?:1.8.0_201]        at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:293) ~[?:1.8.0_201]        at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149) ~[?:1.8.0_201]        at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624) ~[?:1.8.0_201]        ... 1 more Note that as IDLE_TIMEOUT is static, it cannot be set via Spring, and the httpClientProperties map is [never used to set any timeouts|https://github.com/apache/camel/blob/master/components/camel-salesforce/camel-salesforce-component/src/main/java/org/apache/camel/component/salesforce/SalesforceComponent.java#L714], instead opting to take the [hardcoded defaults|https://github.com/apache/camel/blob/master/components/camel-salesforce/camel-salesforce-component/src/main/java/org/apache/camel/component/salesforce/SalesforceComponent.java#L707]. 
camel-main - Configuring component options with #class dont work The fast component configurer is in use before we check whether the value is a #class etc which we need to do beforehand Bug camel-main - Configuring component options with #class dont work The fast component configurer is in use before we check whether the value is a #class etc which we need to do beforehand
Reconsider default for xslt:allowStAX This is currently set to true. However, Xalan (which the default XSLT processor for most) cannot handle StAXSource{code}Caused by: javax.xml.transform.TransformerException: javax.xml.transform.TransformerException: org.apache.xml.dtm.DTMException: Not supported: javax.xml.transform.stax.StAXSource@6a35603	at org.apache.xalan.xsltc.trax.TransformerImpl.transform(TransformerImpl.java:642)	at org.apache.xalan.xsltc.trax.TransformerImpl.transform(TransformerImpl.java:303)	at org.apache.camel.component.xslt.XsltBuilder.process(XsltBuilder.java:132)	at org.apache.camel.support.ProcessorEndpoint.onExchange(ProcessorEndpoint.java:95)	at org.apache.camel.component.xslt.XsltEndpoint.onExchange(XsltEndpoint.java:121){code} Bug Reconsider default for xslt:allowStAX This is currently set to true. However, Xalan (which the default XSLT processor for most) cannot handle StAXSource{code}Caused by: javax.xml.transform.TransformerException: javax.xml.transform.TransformerException: org.apache.xml.dtm.DTMException: Not supported: javax.xml.transform.stax.StAXSource@6a35603	at org.apache.xalan.xsltc.trax.TransformerImpl.transform(TransformerImpl.java:642)	at org.apache.xalan.xsltc.trax.TransformerImpl.transform(TransformerImpl.java:303)	at org.apache.camel.component.xslt.XsltBuilder.process(XsltBuilder.java:132)	at org.apache.camel.support.ProcessorEndpoint.onExchange(ProcessorEndpoint.java:95)	at org.apache.camel.component.xslt.XsltEndpoint.onExchange(XsltEndpoint.java:121){code}
NullPointerException when Conduit is null Hello,the CxfProducer.doStart() retrieves a Conduit.If this Conduit is null, should we still throw a NullPointerException or, should we check nullity before condition?{code:java}Conduit conduit = client.getConduit();        if (conduit.getClass().getName().endsWith("JMSConduit")) {...}{code}https://github.com/apache/camel/blob/camel-2.21.2/components/camel-cxf/src/main/java/org/apache/camel/component/cxf/CxfProducer.java#L87https://github.com/apache/camel/blob/camel-2.23.1/components/camel-cxf/src/main/java/org/apache/camel/component/cxf/CxfProducer.java#L87https://github.com/apache/camel/blob/camel-2.24.1/components/camel-cxf/src/main/java/org/apache/camel/component/cxf/CxfProducer.java#L87Thanks for your point of view. Bug NullPointerException when Conduit is null Hello,the CxfProducer.doStart() retrieves a Conduit.If this Conduit is null, should we still throw a NullPointerException or, should we check nullity before condition?{code:java}Conduit conduit = client.getConduit();        if (conduit.getClass().getName().endsWith("JMSConduit")) {...}{code}https://github.com/apache/camel/blob/camel-2.21.2/components/camel-cxf/src/main/java/org/apache/camel/component/cxf/CxfProducer.java#L87https://github.com/apache/camel/blob/camel-2.23.1/components/camel-cxf/src/main/java/org/apache/camel/component/cxf/CxfProducer.java#L87https://github.com/apache/camel/blob/camel-2.24.1/components/camel-cxf/src/main/java/org/apache/camel/component/cxf/CxfProducer.java#L87Thanks for your point of view.
camel-properties: Properties with types different from string are not taken into account The properties component spi has a setOverrideProperties that allow to use an arbitrary Properties object so it is possible that the properties it holds are not of type string. In case the properties component is asked to resolve a non string property, then it will fail as DefaultPropertiesLookup uses Properties::getProperty [¹] which returns null in case of the requested property is not of type string.The error is a little bit misleading as it states: {code}because of PropertiesComponent with name properties must be defined in CamelContext to support property placeholders. Property with key [the.body] not found in properties from text: in.body == {{the.body}}{code}[1] https://github.com/apache/camel/blob/master/components/camel-properties/src/main/java/org/apache/camel/component/properties/DefaultPropertiesLookup.java#L40 Bug camel-properties: Properties with types different from string are not taken into account The properties component spi has a setOverrideProperties that allow to use an arbitrary Properties object so it is possible that the properties it holds are not of type string. In case the properties component is asked to resolve a non string property, then it will fail as DefaultPropertiesLookup uses Properties::getProperty [1] which returns null in case of the requested property is not of type string.The error is a little bit misleading as it states: {code}because of PropertiesComponent with name properties must be defined in CamelContext to support property placeholders. Property with key [the.body] not found in properties from text: in.body == {{the.body}}{code}[1] https://github.com/apache/camel/blob/master/components/camel-properties/src/main/java/org/apache/camel/component/properties/DefaultPropertiesLookup.java#L40
camel-file - tempFileName directory is not auto-created if it is relative before the endpoint path Hi,I face a requirement to place temp files in a folder at the same hierarchy as the output folder like this: * {{target/data/output/claus.txt}} * {{target/data/temp/claus.tmp}}Using a simple route definition like:{code:java}from("direct:a").to("file://target/data/output/?tempFileName=../temp/${file:name.noext}.tmp"){code} If the temp folder does not exist, the GenericFileProducer should auto-create it. However, it only does so correctly for the tempFileName path, if it is *relativ "after" the endpoint path*. If it is above/before the endpoint path the tempFileName path will be created as a child of the endpoint path instead: * {{target/data/output/target/data/temp}}This results in a NoSuchFileException when camel tries to write the temp file into the "correct" temp directory target/data/temp afterwards.  A very easy way to reproduce this is to use the 'parentFileUrl' instead of the 'fileUrl' in the createRouteBuilder method of FileProduceTempFileNameTest.java ([https://github.com/apache/camel/blob/master/core/camel-core/src/test/java/org/apache/camel/component/file/FileProduceTempFileNameTest.java]). Bug camel-file - tempFileName directory is not auto-created if it is relative before the endpoint path Hi,I face a requirement to place temp files in a folder at the same hierarchy as the output folder like this: * {{target/data/output/claus.txt}} * {{target/data/temp/claus.tmp}}Using a simple route definition like:{code:java}from("direct:a").to("file://target/data/output/?tempFileName=../temp/${file:name.noext}.tmp"){code} If the temp folder does not exist, the GenericFileProducer should auto-create it. However, it only does so correctly for the tempFileName path, if it is *relativ "after" the endpoint path*. If it is above/before the endpoint path the tempFileName path will be created as a child of the endpoint path instead: * {{target/data/output/target/data/temp}}This results in a NoSuchFileException when camel tries to write the temp file into the "correct" temp directory target/data/temp afterwards.  A very easy way to reproduce this is to use the 'parentFileUrl' instead of the 'fileUrl' in the createRouteBuilder method of FileProduceTempFileNameTest.java ([https://github.com/apache/camel/blob/master/core/camel-core/src/test/java/org/apache/camel/component/file/FileProduceTempFileNameTest.java]).
"camel-package:update-readme" throws ArrayIndexOutOfBoundsException when there is an empty "adoc" file Steps to produce:  * Create an empty {{adoc}} file in any component. * Run {{camel-package:update-readme}}. * It will fail with the following error: {code}Caused by: java.lang.ArrayIndexOutOfBoundsException: Index 1 out of bounds for length 1    at org.apache.camel.maven.packaging.UpdateReadmeMojo.updateAvailableFrom (UpdateReadmeMojo.java:510)    at org.apache.camel.maven.packaging.UpdateReadmeMojo.executeComponent (UpdateReadmeMojo.java:151)    at org.apache.camel.maven.packaging.UpdateReadmeMojo.execute (UpdateReadmeMojo.java:105){code}* As I can see [here|https://github.com/apache/camel/blob/master/tooling/maven/camel-package-maven-plugin/src/main/java/org/apache/camel/maven/packaging/UpdateReadmeMojo.java#L510], it looks it will try to retrieve index although there are empty lines Bug "camel-package:update-readme" throws ArrayIndexOutOfBoundsException when there is an empty "adoc" file Steps to produce:  * Create an empty {{adoc}} file in any component. * Run {{camel-package:update-readme}}. * It will fail with the following error: {code}Caused by: java.lang.ArrayIndexOutOfBoundsException: Index 1 out of bounds for length 1    at org.apache.camel.maven.packaging.UpdateReadmeMojo.updateAvailableFrom (UpdateReadmeMojo.java:510)    at org.apache.camel.maven.packaging.UpdateReadmeMojo.executeComponent (UpdateReadmeMojo.java:151)    at org.apache.camel.maven.packaging.UpdateReadmeMojo.execute (UpdateReadmeMojo.java:105){code}* As I can see [here|https://github.com/apache/camel/blob/master/tooling/maven/camel-package-maven-plugin/src/main/java/org/apache/camel/maven/packaging/UpdateReadmeMojo.java#L510], it looks it will try to retrieve index although there are empty lines
JMX - Early registered services may not be enlisted in XML DSL In some use-cases depending on how you run Camel then some early services for JMX may not get registered Bug JMX - Early registered services may not be enlisted in XML DSL In some use-cases depending on how you run Camel then some early services for JMX may not get registered
Message is forwarded to the wrong Kafka Topic I have 3 Apache Spring Boot applications and 3 topics.Let's call them Topic A, B and C and the Spring Boot applications FirstApp, SecondApp and ThridApp. I use Java DSL for the Kafka configuration.The FirstApp creates a message to Kafka Topic A.The SecondApp reads from Topic A makes transformations and passes each value to Topic B.The ThirdApp reads from Topic B and after transformations tries to pass it to Topic C.At this point through the debugger I saw that at the class  org.apache.camel.component.kafka.KafkaProducer and at the method protected Iterator<ProducerRecord> createRecorder(Exchange exchange) something strange is happening.The headerTopic (line 140) from the following line:String headerTopic = exchange.getIn().getHeader(KafkaConstants.TOPIC, String.class);contains the topic A! The correct topic that I have clearly set through the Java DSL can be found under the line 137: String topic = endpoint.getConfiguration().getTopic();As a workaround I have entered the following line inside a processor at the SecondProgram:exchange.getIn().setHeader(KafkaConstants.TOPIC, null);This has the side-effect that the headerTopic at line 140 is empty and thus the correct topic from line 137 is used.I believe that since I have clearly set the destination topic at the ThirdProgram to Topic C then Apache Camel should not override this with Topic A.It looks like a bug since from the method description I understand that we try to avoid circular loops.  Bug Message is forwarded to the wrong Kafka Topic I have 3 Apache Spring Boot applications and 3 topics.Let's call them Topic A, B and C and the Spring Boot applications FirstApp, SecondApp and ThridApp. I use Java DSL for the Kafka configuration.The FirstApp creates a message to Kafka Topic A.The SecondApp reads from Topic A makes transformations and passes each value to Topic B.The ThirdApp reads from Topic B and after transformations tries to pass it to Topic C.At this point through the debugger I saw that at the class  org.apache.camel.component.kafka.KafkaProducer and at the method protected Iterator<ProducerRecord> createRecorder(Exchange exchange) something strange is happening.The headerTopic (line 140) from the following line:String headerTopic = exchange.getIn().getHeader(KafkaConstants.TOPIC, String.class);contains the topic A! The correct topic that I have clearly set through the Java DSL can be found under the line 137: String topic = endpoint.getConfiguration().getTopic();As a workaround I have entered the following line inside a processor at the SecondProgram:exchange.getIn().setHeader(KafkaConstants.TOPIC, null);This has the side-effect that the headerTopic at line 140 is empty and thus the correct topic from line 137 is used.I believe that since I have clearly set the destination topic at the ThirdProgram to Topic C then Apache Camel should not override this with Topic A.It looks like a bug since from the method description I understand that we try to avoid circular loops. 
camel-webhook - Should be lenient properties So you can pass in uri parameters to the target endpoint, as today it will validate its own configuration only. Bug camel-webhook - Should be lenient properties So you can pass in uri parameters to the target endpoint, as today it will validate its own configuration only.
Salesforce Component IDLE_TIMEOUT Blocks Async Request Responses Bulk, Composite Batch, etc. all throw an exception when trying to return on more than a few records due to [static final IDLE_TIMEOUT|https://github.com/apache/camel/blob/master/components/camel-salesforce/camel-salesforce-component/src/main/java/org/apache/camel/component/salesforce/SalesforceComponent.java#L80] on the instantiated salesforce component httpClient: Caused by: org.apache.camel.component.salesforce.api.SalesforceException: Unexpected error \{0:null} executing \{POST:https://genericSFDCInstance.salesforce.com/services/data/v38.0/composite/batch}        at org.apache.camel.component.salesforce.internal.client.AbstractClientBase$1.onComplete(AbstractClientBase.java:199) ~[camel-salesforce-2.23.0.jar:2.23.0]        at org.eclipse.jetty.client.ResponseNotifier.notifyComplete(ResponseNotifier.java:202) ~[jetty-client-9.4.12.v20180830.jar:9.4.12.v20180830]        at org.eclipse.jetty.client.ResponseNotifier.notifyComplete(ResponseNotifier.java:194) ~[jetty-client-9.4.12.v20180830.jar:9.4.12.v20180830]        at org.eclipse.jetty.client.HttpReceiver.terminateResponse(HttpReceiver.java:470) ~[jetty-client-9.4.12.v20180830.jar:9.4.12.v20180830]        at org.eclipse.jetty.client.HttpReceiver.abort(HttpReceiver.java:552) ~[jetty-client-9.4.12.v20180830.jar:9.4.12.v20180830]        at org.eclipse.jetty.client.HttpChannel.abortResponse(HttpChannel.java:156) ~[jetty-client-9.4.12.v20180830.jar:9.4.12.v20180830]        at org.eclipse.jetty.client.HttpChannel.abort(HttpChannel.java:149) ~[jetty-client-9.4.12.v20180830.jar:9.4.12.v20180830]        at org.eclipse.jetty.client.HttpExchange.abort(HttpExchange.java:257) ~[jetty-client-9.4.12.v20180830.jar:9.4.12.v20180830]        at org.eclipse.jetty.client.HttpConversation.abort(HttpConversation.java:141) ~[jetty-client-9.4.12.v20180830.jar:9.4.12.v20180830]        at org.eclipse.jetty.client.HttpRequest.abort(HttpRequest.java:767) ~[jetty-client-9.4.12.v20180830.jar:9.4.12.v20180830]        at org.eclipse.jetty.client.http.HttpConnectionOverHTTP.abort(HttpConnectionOverHTTP.java:204) ~[jetty-client-9.4.12.v20180830.jar:9.4.12.v20180830]        at org.eclipse.jetty.client.http.HttpConnectionOverHTTP.close(HttpConnectionOverHTTP.java:190) ~[jetty-client-9.4.12.v20180830.jar:9.4.12.v20180830]        at org.eclipse.jetty.client.http.HttpConnectionOverHTTP.onIdleExpired(HttpConnectionOverHTTP.java:145) ~[jetty-client-9.4.12.v20180830.jar:9.4.12.v20180830]        at org.eclipse.jetty.io.ssl.SslConnection.onIdleExpired(SslConnection.java:286) ~[jetty-io-9.4.12.v20180830.jar:9.4.12.v20180830]        at org.eclipse.jetty.io.AbstractEndPoint.onIdleExpired(AbstractEndPoint.java:401) ~[jetty-io-9.4.12.v20180830.jar:9.4.12.v20180830]        at org.eclipse.jetty.io.IdleTimeout.checkIdleTimeout(IdleTimeout.java:166) ~[jetty-io-9.4.12.v20180830.jar:9.4.12.v20180830]        at org.eclipse.jetty.io.IdleTimeout$1.run(IdleTimeout.java:50) ~[jetty-io-9.4.12.v20180830.jar:9.4.12.v20180830]        at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511) ~[?:1.8.0_201]        at java.util.concurrent.FutureTask.run(FutureTask.java:266) ~[?:1.8.0_201]        at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.access$201(ScheduledThreadPoolExecutor.java:180) ~[?:1.8.0_201]        at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:293) ~[?:1.8.0_201]        at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149) ~[?:1.8.0_201]        at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624) ~[?:1.8.0_201]        ... 1 more*Caused by: java.util.concurrent.TimeoutException: Idle timeout 5000 ms*        at org.eclipse.jetty.client.http.HttpConnectionOverHTTP.onIdleExpired(HttpConnectionOverHTTP.java:145) ~[jetty-client-9.4.12.v20180830.jar:9.4.12.v20180830]        at org.eclipse.jetty.io.ssl.SslConnection.onIdleExpired(SslConnection.java:286) ~[jetty-io-9.4.12.v20180830.jar:9.4.12.v20180830]        at org.eclipse.jetty.io.AbstractEndPoint.onIdleExpired(AbstractEndPoint.java:401) ~[jetty-io-9.4.12.v20180830.jar:9.4.12.v20180830]        at org.eclipse.jetty.io.IdleTimeout.checkIdleTimeout(IdleTimeout.java:166) ~[jetty-io-9.4.12.v20180830.jar:9.4.12.v20180830]        at org.eclipse.jetty.io.IdleTimeout$1.run(IdleTimeout.java:50) ~[jetty-io-9.4.12.v20180830.jar:9.4.12.v20180830]        at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511) ~[?:1.8.0_201]        at java.util.concurrent.FutureTask.run(FutureTask.java:266) ~[?:1.8.0_201]        at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.access$201(ScheduledThreadPoolExecutor.java:180) ~[?:1.8.0_201]        at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:293) ~[?:1.8.0_201]        at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149) ~[?:1.8.0_201]        at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624) ~[?:1.8.0_201]        ... 1 more Note that as IDLE_TIMEOUT is static, it cannot be set via Spring, and the httpClientProperties map is [never used to set any timeouts|https://github.com/apache/camel/blob/master/components/camel-salesforce/camel-salesforce-component/src/main/java/org/apache/camel/component/salesforce/SalesforceComponent.java#L714], instead opting to take the [hardcoded defaults|https://github.com/apache/camel/blob/master/components/camel-salesforce/camel-salesforce-component/src/main/java/org/apache/camel/component/salesforce/SalesforceComponent.java#L707].  Bug Salesforce Component IDLE_TIMEOUT Blocks Async Request Responses Bulk, Composite Batch, etc. all throw an exception when trying to return on more than a few records due to [static final IDLE_TIMEOUT|https://github.com/apache/camel/blob/master/components/camel-salesforce/camel-salesforce-component/src/main/java/org/apache/camel/component/salesforce/SalesforceComponent.java#L80] on the instantiated salesforce component httpClient: Caused by: org.apache.camel.component.salesforce.api.SalesforceException: Unexpected error \{0:null} executing \{POST:https://genericSFDCInstance.salesforce.com/services/data/v38.0/composite/batch}        at org.apache.camel.component.salesforce.internal.client.AbstractClientBase$1.onComplete(AbstractClientBase.java:199) ~[camel-salesforce-2.23.0.jar:2.23.0]        at org.eclipse.jetty.client.ResponseNotifier.notifyComplete(ResponseNotifier.java:202) ~[jetty-client-9.4.12.v20180830.jar:9.4.12.v20180830]        at org.eclipse.jetty.client.ResponseNotifier.notifyComplete(ResponseNotifier.java:194) ~[jetty-client-9.4.12.v20180830.jar:9.4.12.v20180830]        at org.eclipse.jetty.client.HttpReceiver.terminateResponse(HttpReceiver.java:470) ~[jetty-client-9.4.12.v20180830.jar:9.4.12.v20180830]        at org.eclipse.jetty.client.HttpReceiver.abort(HttpReceiver.java:552) ~[jetty-client-9.4.12.v20180830.jar:9.4.12.v20180830]        at org.eclipse.jetty.client.HttpChannel.abortResponse(HttpChannel.java:156) ~[jetty-client-9.4.12.v20180830.jar:9.4.12.v20180830]        at org.eclipse.jetty.client.HttpChannel.abort(HttpChannel.java:149) ~[jetty-client-9.4.12.v20180830.jar:9.4.12.v20180830]        at org.eclipse.jetty.client.HttpExchange.abort(HttpExchange.java:257) ~[jetty-client-9.4.12.v20180830.jar:9.4.12.v20180830]        at org.eclipse.jetty.client.HttpConversation.abort(HttpConversation.java:141) ~[jetty-client-9.4.12.v20180830.jar:9.4.12.v20180830]        at org.eclipse.jetty.client.HttpRequest.abort(HttpRequest.java:767) ~[jetty-client-9.4.12.v20180830.jar:9.4.12.v20180830]        at org.eclipse.jetty.client.http.HttpConnectionOverHTTP.abort(HttpConnectionOverHTTP.java:204) ~[jetty-client-9.4.12.v20180830.jar:9.4.12.v20180830]        at org.eclipse.jetty.client.http.HttpConnectionOverHTTP.close(HttpConnectionOverHTTP.java:190) ~[jetty-client-9.4.12.v20180830.jar:9.4.12.v20180830]        at org.eclipse.jetty.client.http.HttpConnectionOverHTTP.onIdleExpired(HttpConnectionOverHTTP.java:145) ~[jetty-client-9.4.12.v20180830.jar:9.4.12.v20180830]        at org.eclipse.jetty.io.ssl.SslConnection.onIdleExpired(SslConnection.java:286) ~[jetty-io-9.4.12.v20180830.jar:9.4.12.v20180830]        at org.eclipse.jetty.io.AbstractEndPoint.onIdleExpired(AbstractEndPoint.java:401) ~[jetty-io-9.4.12.v20180830.jar:9.4.12.v20180830]        at org.eclipse.jetty.io.IdleTimeout.checkIdleTimeout(IdleTimeout.java:166) ~[jetty-io-9.4.12.v20180830.jar:9.4.12.v20180830]        at org.eclipse.jetty.io.IdleTimeout$1.run(IdleTimeout.java:50) ~[jetty-io-9.4.12.v20180830.jar:9.4.12.v20180830]        at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511) ~[?:1.8.0_201]        at java.util.concurrent.FutureTask.run(FutureTask.java:266) ~[?:1.8.0_201]        at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.access$201(ScheduledThreadPoolExecutor.java:180) ~[?:1.8.0_201]        at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:293) ~[?:1.8.0_201]        at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149) ~[?:1.8.0_201]        at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624) ~[?:1.8.0_201]        ... 1 more*Caused by: java.util.concurrent.TimeoutException: Idle timeout 5000 ms*        at org.eclipse.jetty.client.http.HttpConnectionOverHTTP.onIdleExpired(HttpConnectionOverHTTP.java:145) ~[jetty-client-9.4.12.v20180830.jar:9.4.12.v20180830]        at org.eclipse.jetty.io.ssl.SslConnection.onIdleExpired(SslConnection.java:286) ~[jetty-io-9.4.12.v20180830.jar:9.4.12.v20180830]        at org.eclipse.jetty.io.AbstractEndPoint.onIdleExpired(AbstractEndPoint.java:401) ~[jetty-io-9.4.12.v20180830.jar:9.4.12.v20180830]        at org.eclipse.jetty.io.IdleTimeout.checkIdleTimeout(IdleTimeout.java:166) ~[jetty-io-9.4.12.v20180830.jar:9.4.12.v20180830]        at org.eclipse.jetty.io.IdleTimeout$1.run(IdleTimeout.java:50) ~[jetty-io-9.4.12.v20180830.jar:9.4.12.v20180830]        at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511) ~[?:1.8.0_201]        at java.util.concurrent.FutureTask.run(FutureTask.java:266) ~[?:1.8.0_201]        at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.access$201(ScheduledThreadPoolExecutor.java:180) ~[?:1.8.0_201]        at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:293) ~[?:1.8.0_201]        at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149) ~[?:1.8.0_201]        at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624) ~[?:1.8.0_201]        ... 1 more Note that as IDLE_TIMEOUT is static, it cannot be set via Spring, and the httpClientProperties map is [never used to set any timeouts|https://github.com/apache/camel/blob/master/components/camel-salesforce/camel-salesforce-component/src/main/java/org/apache/camel/component/salesforce/SalesforceComponent.java#L714], instead opting to take the [hardcoded defaults|https://github.com/apache/camel/blob/master/components/camel-salesforce/camel-salesforce-component/src/main/java/org/apache/camel/component/salesforce/SalesforceComponent.java#L707]. 
TokenXMLExpressionIterator with inheritNamespaceToken creates duplicate default namespace definition  If a sub-item also contains the default namespace definition the splitter will duplicate it. {code:java|title=route definition}from("file:target/pair?initialDelay=0&delay=10")                    // split the order child tags, and inherit namespaces from the orders root tag                    .split().tokenizeXML("order", "orders")                        .to("mock:split");{code}  {code:xml|title=input}<orders xmlns="http:acme.com">  <order xmlns="http:acme.com" id="1">Camel in Action</order> <order id="2">ActiveMQ in Action</order> <order id="3">DSL in Action</order></orders>"{code}{code:xml|title=output[1]}<order xmlns="http:acme.com" id="1" xmlns="http:acme.com">Camel in Action</order>{code}{code:xml|title=expected[1]} <order xmlns="http:acme.com" id="1">Camel in Action</order>{code} Bug TokenXMLExpressionIterator with inheritNamespaceToken creates duplicate default namespace definition  If a sub-item also contains the default namespace definition the splitter will duplicate it. {code:java|title=route definition}from("file:target/pair?initialDelay=0&delay=10")                    // split the order child tags, and inherit namespaces from the orders root tag                    .split().tokenizeXML("order", "orders")                        .to("mock:split");{code}  {code:xml|title=input}<orders xmlns="http:acme.com">  <order xmlns="http:acme.com" id="1">Camel in Action</order> <order id="2">ActiveMQ in Action</order> <order id="3">DSL in Action</order></orders>"{code}{code:xml|title=output[1]}<order xmlns="http:acme.com" id="1" xmlns="http:acme.com">Camel in Action</order>{code}{code:xml|title=expected[1]} <order xmlns="http:acme.com" id="1">Camel in Action</order>{code}
Fix the camel-archetype-component to inherit from DefaultConsumer instead of ScheduledPollConsumer Currently the {{[camel-archetype-component|https://github.com/apache/camel/blob/master/archetypes/camel-archetype-component/src/main/resources/archetype-resources/src/main/java/__name__Consumer.java#L28]}} inherits from {{ScheduledPollConsumer}}, since this consumer is less used, it will make sense to change the consumer to {{DefaultConsumer}} instead.  Bug Fix the camel-archetype-component to inherit from DefaultConsumer instead of ScheduledPollConsumer Currently the {{[camel-archetype-component|https://github.com/apache/camel/blob/master/archetypes/camel-archetype-component/src/main/resources/archetype-resources/src/main/java/__name__Consumer.java#L28]}} inherits from {{ScheduledPollConsumer}}, since this consumer is less used, it will make sense to change the consumer to {{DefaultConsumer}} instead. 
Properties of class Map does not work with Spring Boot 2.x From version 2.22.0 onwards spring-boot version is upgraded to 2.xAfter that all Map properties are not workingFor example in application.propertiescamel.component.salesforce.http-client-properties is treated as string instead of Map and whatever value we provide to it, the Map is initialize as null Bug Properties of class Map does not work with Spring Boot 2.x From version 2.22.0 onwards spring-boot version is upgraded to 2.xAfter that all Map properties are not workingFor example in application.propertiescamel.component.salesforce.http-client-properties is treated as string instead of Map and whatever value we provide to it, the Map is initialize as null
Unable to parse $simple{}, when you have prefixToken="${" suffixToken="}" in the propertyPlaceholder Unable to parse $simple{}, when you have prefixToken={color:#14892c}"$\{"{color} suffixToken={color:#14892c}"}{color}" in the propertyPlaceholder.For example -{{<camelContext xmlns="http://camel.apache.org/schema/spring"> <propertyPlaceholder id="ignoreId" location="classpath:props.properties" prefixToken="${" suffixToken="}"/> <route id="sendNotification"> <from uri="jms:queue:queue.sendNotification"/> <to uri="file:${OnDemand.output.url}?fileName=L2W.$simple\{in.header.accountNum}-${date:now:yyyyMMddHHmmssSSS}.csv"/> </route> </camelContext>}} In the above route ${OnDemand.output.url} {color:#333333}is a Spring property placeholders and $simple\{in.header.accountNum}{color} is a camel property placeholder.{{{color:#205081}Note:- This route configuration used to work till Camel 2.12{color}}}{{According to [https://github.com/apache/camel/blob/master/docs/user-manual/modules/ROOT/pages/using-propertyplaceholder.adoc]- one should be able to refer to Camel's properties using $simple\{...} like this:}} {{<setHeader headerName="Exchange.FILE_NAME"> <simple>{{file.rootdir}}{{/$simple\{in.header.CamelFileName}</simple </setHeader>}} {{Replication - camel-test.zip attached. Main class - CamelHelloWorldSpringExample.java}} Bug Unable to parse $simple{}, when you have prefixToken="${" suffixToken="}" in the propertyPlaceholder Unable to parse $simple{}, when you have prefixToken={color:#14892c}"$\{"{color} suffixToken={color:#14892c}"}{color}" in the propertyPlaceholder.For example -{{<camelContext xmlns="http://camel.apache.org/schema/spring"> <propertyPlaceholder id="ignoreId" location="classpath:props.properties" prefixToken="${" suffixToken="}"/> <route id="sendNotification"> <from uri="jms:queue:queue.sendNotification"/> <to uri="file:${OnDemand.output.url}?fileName=L2W.$simple\{in.header.accountNum}-${date:now:yyyyMMddHHmmssSSS}.csv"/> </route> </camelContext>}} In the above route ${OnDemand.output.url} {color:#333333}is a Spring property placeholders and $simple\{in.header.accountNum}{color} is a camel property placeholder.{{{color:#205081}Note:- This route configuration used to work till Camel 2.12{color}}}{{According to [https://github.com/apache/camel/blob/master/docs/user-manual/modules/ROOT/pages/using-propertyplaceholder.adoc]- one should be able to refer to Camel's properties using $simple\{...} like this:}} {{<setHeader headerName="Exchange.FILE_NAME"> <simple>{{file.rootdir}}{{/$simple\{in.header.CamelFileName}</simple </setHeader>}} {{Replication - camel-test.zip attached. Main class - CamelHelloWorldSpringExample.java}}
Fix syntax for pulsar component Replace {noformat}pulsar:persistence://tenant/namespace/topic{noformat} with{noformat}pulsar:configuration{noformat}or{noformat}pulsar:uri{noformat} There is currently only a single property of kind "path" for this component which is called "topic". The description of that parameter suggests that is should hold type, tenant and topic values for the endpoint which makes the name "topic" for this parameter a bad choice. I would rather suggest to rename it to something more fitting like "configuration" or "uri" instead.  Bug Fix syntax for pulsar component Replace {noformat}pulsar:persistence://tenant/namespace/topic{noformat} with{noformat}pulsar:configuration{noformat}or{noformat}pulsar:uri{noformat} There is currently only a single property of kind "path" for this component which is called "topic". The description of that parameter suggests that is should hold type, tenant and topic values for the endpoint which makes the name "topic" for this parameter a bad choice. I would rather suggest to rename it to something more fitting like "configuration" or "uri" instead. 
NotifyBuilder not working as expected am trying to test an error handling route. The {{NotificationBuilder}} does not work as expected (it always returns false).Created a main route and a test route to test the main route. I used Spring Boot - all other tests work fine, so there is no problem with the setup I guess. I have attached the sample project. Please uncomment the @Ignore method to test the method. Please read the README.md attached in the project Bug NotifyBuilder not working as expected am trying to test an error handling route. The {{NotificationBuilder}} does not work as expected (it always returns false).Created a main route and a test route to test the main route. I used Spring Boot - all other tests work fine, so there is no problem with the setup I guess. I have attached the sample project. Please uncomment the @Ignore method to test the method. Please read the README.md attached in the project
camel-file - From file to file with readLock=fileLock dont work on windows You can get errors like{code}Stacktrace---------------------------------------------------------------------------------------------------------------------------------------org.apache.camel.component.file.GenericFileOperationFailedException: Cannot store file: work\cbr\output\ID-WIN-JTA8KU4EF9D-1561426618994-0-2	at org.apache.camel.component.file.FileOperations.storeFile(FileOperations.java:352)	at org.apache.camel.component.file.GenericFileProducer.writeFile(GenericFileProducer.java:305)	at org.apache.camel.component.file.GenericFileProducer.processExchange(GenericFileProducer.java:169)	at org.apache.camel.component.file.GenericFileProducer.process(GenericFileProducer.java:80)	at org.apache.camel.util.AsyncProcessorConverterHelper$ProcessorToAsyncProcessorBridge.process(AsyncProcessorConverterHelper.java:61)	at org.apache.camel.processor.SendProcessor.process(SendProcessor.java:148)	at org.apache.camel.processor.RedeliveryErrorHandler.process(RedeliveryErrorHandler.java:548)	at org.apache.camel.processor.CamelInternalProcessor.process(CamelInternalProcessor.java:201)	at org.apache.camel.processor.Pipeline.process(Pipeline.java:138)	at org.apache.camel.processor.Pipeline.process(Pipeline.java:101)	at org.apache.camel.processor.CamelInternalProcessor.process(CamelInternalProcessor.java:201)	at org.apache.camel.component.file.GenericFileConsumer.processExchange(GenericFileConsumer.java:452)	at org.apache.camel.component.file.GenericFileConsumer.processBatch(GenericFileConsumer.java:219)	at org.apache.camel.component.file.GenericFileConsumer.poll(GenericFileConsumer.java:183)	at org.apache.camel.impl.ScheduledPollConsumer.doRun(ScheduledPollConsumer.java:174)	at org.apache.camel.impl.ScheduledPollConsumer.run(ScheduledPollConsumer.java:101)	at java.util.concurrent.Executors$RunnableAdapter.call(Unknown Source)	at java.util.concurrent.FutureTask.runAndReset(Unknown Source)	at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.access$301(Unknown Source)	at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(Unknown Source)	at java.util.concurrent.ThreadPoolExecutor.runWorker(Unknown Source)	at java.util.concurrent.ThreadPoolExecutor$Worker.run(Unknown Source)	at java.lang.Thread.run(Unknown Source)Caused by: java.nio.file.FileSystemException: work\cbr\input\ID-WIN-JTA8KU4EF9D-1561426618994-0-2 -> work\cbr\output\ID-WIN-JTA8KU4EF9D-1561426618994-0-2: The process cannot access the file because it is being used by another process	at sun.nio.fs.WindowsException.translateToIOException(Unknown Source)	at sun.nio.fs.WindowsException.rethrowAsIOException(Unknown Source)	at sun.nio.fs.WindowsFileCopy.copy(Unknown Source)	at sun.nio.fs.WindowsFileSystemProvider.copy(Unknown Source)	at java.nio.file.Files.copy(Unknown Source){code} Bug camel-file - From file to file with readLock=fileLock dont work on windows You can get errors like{code}Stacktrace---------------------------------------------------------------------------------------------------------------------------------------org.apache.camel.component.file.GenericFileOperationFailedException: Cannot store file: work\cbr\output\ID-WIN-JTA8KU4EF9D-1561426618994-0-2	at org.apache.camel.component.file.FileOperations.storeFile(FileOperations.java:352)	at org.apache.camel.component.file.GenericFileProducer.writeFile(GenericFileProducer.java:305)	at org.apache.camel.component.file.GenericFileProducer.processExchange(GenericFileProducer.java:169)	at org.apache.camel.component.file.GenericFileProducer.process(GenericFileProducer.java:80)	at org.apache.camel.util.AsyncProcessorConverterHelper$ProcessorToAsyncProcessorBridge.process(AsyncProcessorConverterHelper.java:61)	at org.apache.camel.processor.SendProcessor.process(SendProcessor.java:148)	at org.apache.camel.processor.RedeliveryErrorHandler.process(RedeliveryErrorHandler.java:548)	at org.apache.camel.processor.CamelInternalProcessor.process(CamelInternalProcessor.java:201)	at org.apache.camel.processor.Pipeline.process(Pipeline.java:138)	at org.apache.camel.processor.Pipeline.process(Pipeline.java:101)	at org.apache.camel.processor.CamelInternalProcessor.process(CamelInternalProcessor.java:201)	at org.apache.camel.component.file.GenericFileConsumer.processExchange(GenericFileConsumer.java:452)	at org.apache.camel.component.file.GenericFileConsumer.processBatch(GenericFileConsumer.java:219)	at org.apache.camel.component.file.GenericFileConsumer.poll(GenericFileConsumer.java:183)	at org.apache.camel.impl.ScheduledPollConsumer.doRun(ScheduledPollConsumer.java:174)	at org.apache.camel.impl.ScheduledPollConsumer.run(ScheduledPollConsumer.java:101)	at java.util.concurrent.Executors$RunnableAdapter.call(Unknown Source)	at java.util.concurrent.FutureTask.runAndReset(Unknown Source)	at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.access$301(Unknown Source)	at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(Unknown Source)	at java.util.concurrent.ThreadPoolExecutor.runWorker(Unknown Source)	at java.util.concurrent.ThreadPoolExecutor$Worker.run(Unknown Source)	at java.lang.Thread.run(Unknown Source)Caused by: java.nio.file.FileSystemException: work\cbr\input\ID-WIN-JTA8KU4EF9D-1561426618994-0-2 -> work\cbr\output\ID-WIN-JTA8KU4EF9D-1561426618994-0-2: The process cannot access the file because it is being used by another process	at sun.nio.fs.WindowsException.translateToIOException(Unknown Source)	at sun.nio.fs.WindowsException.rethrowAsIOException(Unknown Source)	at sun.nio.fs.WindowsFileCopy.copy(Unknown Source)	at sun.nio.fs.WindowsFileSystemProvider.copy(Unknown Source)	at java.nio.file.Files.copy(Unknown Source){code}
Quartz2 firenow doesn't work consistently Hi Colleagues,We have an interesting bug in the camel-quartz2 where the firenow doesn't work consistently.it works sometimes and sometimes it doesn't. On debug i found that the problem occurs when Scheduler starts it invokes *CamleJob,*  *CamleJob* starts executing and tries to read from *getProcessors()* method of *LoadBalancerSupport* class. sometimes *getProcessors()* method returns empty list as a result routes doesn't get executed.*StartupListener* (QuartzComponent) gets notified much before the *QuartzConsumer* starts, as a result it is not able to get the List<Processor> from *getProcessors()* method of *LoadBalancerSupport* class. Analysis of the problem-------------------------------------------------------------------------------------------------- # *DefaultCamelContext* method *safelyStartRouteServices()* notifies QuartzComponent's *onCamelContextStarted()* method. # The above step starts the scheduler which then calls *execute()* method in *CamelJob* class. # In the execute() method it invokes *getProcessors()* method of *LoadBalancerSupport* class to get the List<Processor>. # Sometimes *getProcessors()*  returns empty list. # The reason is  List<Processor> in *LoadBalancerSupport* class is populated by *QuartzConsumer* on start of consumer. but  it is started after QuartzComponent's *onCamelContextStarted()* method is called in *DefaultCamelContext*. # When i checked the older version of camel which we are using in our organization 2.17.0 i see the order is different. # Consumer starts first then the classes that implements *StartupListener*.To Summarize------------------------------------------------------------------------------------------------------- # The order in which *StartupListener* and *Consumer* is started in *DefaultCamelContext* is causing race condition. # The older version of camel 2.17.0 order is first *Consumer* starts followed by classes that implement *StartupListener* I have attached the junit with quartz2, since it is intermittent issue, i made the junit to run 1000 times and it fails randomly which proves existence of the problem.I have also attached by proposed solution in DefaultCamelContext in the attachment.   Bug Quartz2 firenow doesn't work consistently Hi Colleagues,We have an interesting bug in the camel-quartz2 where the firenow doesn't work consistently.it works sometimes and sometimes it doesn't. On debug i found that the problem occurs when Scheduler starts it invokes *CamleJob,*  *CamleJob* starts executing and tries to read from *getProcessors()* method of *LoadBalancerSupport* class. sometimes *getProcessors()* method returns empty list as a result routes doesn't get executed.*StartupListener* (QuartzComponent) gets notified much before the *QuartzConsumer* starts, as a result it is not able to get the List<Processor> from *getProcessors()* method of *LoadBalancerSupport* class. Analysis of the problem-------------------------------------------------------------------------------------------------- # *DefaultCamelContext* method *safelyStartRouteServices()* notifies QuartzComponent's *onCamelContextStarted()* method. # The above step starts the scheduler which then calls *execute()* method in *CamelJob* class. # In the execute() method it invokes *getProcessors()* method of *LoadBalancerSupport* class to get the List<Processor>. # Sometimes *getProcessors()*  returns empty list. # The reason is  List<Processor> in *LoadBalancerSupport* class is populated by *QuartzConsumer* on start of consumer. but  it is started after QuartzComponent's *onCamelContextStarted()* method is called in *DefaultCamelContext*. # When i checked the older version of camel which we are using in our organization 2.17.0 i see the order is different. # Consumer starts first then the classes that implements *StartupListener*.To Summarize------------------------------------------------------------------------------------------------------- # The order in which *StartupListener* and *Consumer* is started in *DefaultCamelContext* is causing race condition. # The older version of camel 2.17.0 order is first *Consumer* starts followed by classes that implement *StartupListener* I have attached the junit with quartz2, since it is intermittent issue, i made the junit to run 1000 times and it fails randomly which proves existence of the problem.I have also attached by proposed solution in DefaultCamelContext in the attachment.  
camel-sql - Repeated parameters in URI are not treated correctly When constructing Camel SQL component with the following URI:{code:java}sql:INSERT INTO TABLE ....?batch=true&...&batch=true{code}Resulting camel endpoint ends up with batch == false. The reason for this is found in {code:java}private static void addParameter // this is in UriSupport.java{code}This method adds values into a list and then setting the parameter does not work correctly. I believe that Camel should be more linient for such "errors" (which can occur if you construct URI programatically). I suggest parameter value detection. If{code:java}existing.equals(value) // to use actual names of variables from the code{code}then just ignore. DO NOT do the following (list construction; current behavior):{code:java}if (existing instanceof List) {    list = CastUtils.cast((List<?>) existing);} else {    // create a new list to hold the multiple values    list = new ArrayList<String>();    String s = existing != null ? existing.toString() : null;    if (s != null) {        list.add(s);    }}list.add(value);{code}In the end the URI shown in the beginning will result in Component with batch equal to false. Which is really hard to determine why and what happened.  I believe this is a generic problem tho Bug camel-sql - Repeated parameters in URI are not treated correctly When constructing Camel SQL component with the following URI:{code:java}sql:INSERT INTO TABLE ....?batch=true&...&batch=true{code}Resulting camel endpoint ends up with batch == false. The reason for this is found in {code:java}private static void addParameter // this is in UriSupport.java{code}This method adds values into a list and then setting the parameter does not work correctly. I believe that Camel should be more linient for such "errors" (which can occur if you construct URI programatically). I suggest parameter value detection. If{code:java}existing.equals(value) // to use actual names of variables from the code{code}then just ignore. DO NOT do the following (list construction; current behavior):{code:java}if (existing instanceof List) {    list = CastUtils.cast((List<?>) existing);} else {    // create a new list to hold the multiple values    list = new ArrayList<String>();    String s = existing != null ? existing.toString() : null;    if (s != null) {        list.add(s);    }}list.add(value);{code}In the end the URI shown in the beginning will result in Component with batch equal to false. Which is really hard to determine why and what happened.  I believe this is a generic problem tho
InflightRepository, InflightEntry getElapsed is 0 Hi,I made a camel-route that checks about inflight messages on other server through JMX connection.It was working fine in 2.17.x but now we upgrade to 2.22.1 and I always obtain a result of 0 millisecond for the elapsed field.I use the browse() operation of JMX bean. You can use jconsole to run a simple test.!image-2019-05-27-17-04-12-319.png!This is a major bug for us, since we use the code to monitoring production routes. Is there any workaround like get the echange historymessage from the exchage id?Thank you Bug InflightRepository, InflightEntry getElapsed is 0 Hi,I made a camel-route that checks about inflight messages on other server through JMX connection.It was working fine in 2.17.x but now we upgrade to 2.22.1 and I always obtain a result of 0 millisecond for the elapsed field.I use the browse() operation of JMX bean. You can use jconsole to run a simple test.!image-2019-05-27-17-04-12-319.png!This is a major bug for us, since we use the code to monitoring production routes. Is there any workaround like get the echange historymessage from the exchage id?Thank you
camel-hystrix - HystrixBadRequestException is swallowed CAMEL-13066 fixed a problem that HystrixBadRequestExceptions caused the fallback processor being executed.However, it seems that due to this fix the exception is simply thrown away and the route proceeds as if no error has occurred. This is certainly not the intended behavior.As I understand it, the HystrixBadRequestExceptions should simply be thrown out of the HystrixProcessor, but without any fallback processor being triggered or circuit being opened Bug camel-hystrix - HystrixBadRequestException is swallowed CAMEL-13066 fixed a problem that HystrixBadRequestExceptions caused the fallback processor being executed.However, it seems that due to this fix the exception is simply thrown away and the route proceeds as if no error has occurred. This is certainly not the intended behavior.As I understand it, the HystrixBadRequestExceptions should simply be thrown out of the HystrixProcessor, but without any fallback processor being triggered or circuit being opened
Camel main - Duration max messages may not work Looks like max duration = 1 will not shutdown the jvm. Also the idle checker background thread is stopping camel from the same thread as itself so its own thread pool cannot shutdown nicely. Bug Camel main - Duration max messages may not work Looks like max duration = 1 will not shutdown the jvm. Also the idle checker background thread is stopping camel from the same thread as itself so its own thread pool cannot shutdown nicely.
Using "route1" as a route id produces infinite loop Steps:# Start a Camel context.# Add a route through RouteBuilder with id *"route1"* (reserved id).# Attempt to add a second route with no id. The method enters an infinite loop. Example code that reproduces the problem:{code:java}package com.paytrue.swakka;import org.apache.camel.builder.RouteBuilder;import org.apache.camel.impl.DefaultCamelContext;public class InfLoopMain {    public static void main(final String[] args) throws Exception {        final DefaultCamelContext camelContext = new DefaultCamelContext();        camelContext.start();        final RouteBuilder route1 = new RouteBuilder() {            @Override            public void configure() {                from("direct:in1")                    .id("route1") // Note the name                    .to("mock:test1");            }        };        camelContext.addRoutes(route1);        final RouteBuilder route2 = new RouteBuilder() {            @Override            public void configure() {                from("direct:in2")                    .to("mock:test2");            }        };        // Infinite loop        camelContext.addRoutes(route2);    }}{code}  Bug Using "route1" as a route id produces infinite loop Steps:# Start a Camel context.# Add a route through RouteBuilder with id *"route1"* (reserved id).# Attempt to add a second route with no id. The method enters an infinite loop. Example code that reproduces the problem:{code:java}package com.paytrue.swakka;import org.apache.camel.builder.RouteBuilder;import org.apache.camel.impl.DefaultCamelContext;public class InfLoopMain {    public static void main(final String[] args) throws Exception {        final DefaultCamelContext camelContext = new DefaultCamelContext();        camelContext.start();        final RouteBuilder route1 = new RouteBuilder() {            @Override            public void configure() {                from("direct:in1")                    .id("route1") // Note the name                    .to("mock:test1");            }        };        camelContext.addRoutes(route1);        final RouteBuilder route2 = new RouteBuilder() {            @Override            public void configure() {                from("direct:in2")                    .to("mock:test2");            }        };        // Infinite loop        camelContext.addRoutes(route2);    }}{code} 
expectedHeaderReceived should failed when no message is received This test should fail:{code:java}import org.apache.camel.RoutesBuilder;import org.apache.camel.builder.RouteBuilder;import org.apache.camel.component.mock.MockEndpoint;import org.apache.camel.test.junit4.CamelTestSupport;import org.assertj.core.api.Assertions;import org.junit.Test;public class MyRouteTest extends CamelTestSupport {  private static final String ROUTE_ID = "mytest";  @Override  public RoutesBuilder createRouteBuilder() throws Exception {    return new RouteBuilder() {      @Override      public void configure() throws Exception {        from("direct:foo")          .id(ROUTE_ID)          .to("mock:extract");      }    };  }  @Test  public void shouldFail() throws InterruptedException {    // given    final MockEndpoint mock = getMockEndpoint("mock:extract");    // declare    mock.expectedHeaderReceived("foo", "bar");    // when//template.sendBody("direct:foo", "test");    // then    mock.assertIsSatisfied();  }}{code}Because we were expecting some headers, but none headers were received Bug expectedHeaderReceived should failed when no message is received This test should fail:{code:java}import org.apache.camel.RoutesBuilder;import org.apache.camel.builder.RouteBuilder;import org.apache.camel.component.mock.MockEndpoint;import org.apache.camel.test.junit4.CamelTestSupport;import org.assertj.core.api.Assertions;import org.junit.Test;public class MyRouteTest extends CamelTestSupport {  private static final String ROUTE_ID = "mytest";  @Override  public RoutesBuilder createRouteBuilder() throws Exception {    return new RouteBuilder() {      @Override      public void configure() throws Exception {        from("direct:foo")          .id(ROUTE_ID)          .to("mock:extract");      }    };  }  @Test  public void shouldFail() throws InterruptedException {    // given    final MockEndpoint mock = getMockEndpoint("mock:extract");    // declare    mock.expectedHeaderReceived("foo", "bar");    // when//template.sendBody("direct:foo", "test");    // then    mock.assertIsSatisfied();  }}{code}Because we were expecting some headers, but none headers were received
adviceWith in test should be fired before routes are started This test should pass:{code:java}import java.util.concurrent.atomic.AtomicInteger;import org.apache.camel.CamelContext;import org.apache.camel.RoutesBuilder;import org.apache.camel.builder.AdviceWithRouteBuilder;import org.apache.camel.builder.RouteBuilder;import org.apache.camel.component.mock.MockEndpoint;import org.apache.camel.test.junit4.CamelTestSupport;import org.assertj.core.api.Assertions;import org.junit.Test;public class MyRouteTest extends CamelTestSupport {  private static final String ROUTE_ID = "mytest";  private final AtomicInteger counter = new AtomicInteger(0);  @Override  public RoutesBuilder createRouteBuilder() throws Exception {    return new RouteBuilder() {      @Override      public void configure() throws Exception {        from("quartz2://test?cron=0/1+*+*+*+*+?")          .id(ROUTE_ID)          .bean(counter, "incrementAndGet", false)          .to("stream:out");      }    };  }  @Override  public void setUp() throws Exception {      super.setUp();      final CamelContext camelContext = context();      camelContext.getRouteDefinition(ROUTE_ID)        .adviceWith(camelContext, new AdviceWithRouteBuilder() {          @Override          public void configure() throws Exception {            replaceFromWith("direct:quartz");            weaveAddLast().to("mock:extract");          }        });  }  @Test  public void shouldReceive2Messages() throws InterruptedException {    // given    final MockEndpoint quartzMock = getMockEndpoint("mock:extract");    // declare    quartzMock.expectedMessageCount(2);    // when    template.sendBody("direct:quartz", "tick");    template.sendBody("direct:quartz", "tick");    // then    quartzMock.assertIsSatisfied();    Assertions.assertThat(counter).hasValue(2);  }}{code}Unfortunatelly, before adviceWith is invoked, quartz sends already two messages Bug adviceWith in test should be fired before routes are started This test should pass:{code:java}import java.util.concurrent.atomic.AtomicInteger;import org.apache.camel.CamelContext;import org.apache.camel.RoutesBuilder;import org.apache.camel.builder.AdviceWithRouteBuilder;import org.apache.camel.builder.RouteBuilder;import org.apache.camel.component.mock.MockEndpoint;import org.apache.camel.test.junit4.CamelTestSupport;import org.assertj.core.api.Assertions;import org.junit.Test;public class MyRouteTest extends CamelTestSupport {  private static final String ROUTE_ID = "mytest";  private final AtomicInteger counter = new AtomicInteger(0);  @Override  public RoutesBuilder createRouteBuilder() throws Exception {    return new RouteBuilder() {      @Override      public void configure() throws Exception {        from("quartz2://test?cron=0/1+*+*+*+*+?")          .id(ROUTE_ID)          .bean(counter, "incrementAndGet", false)          .to("stream:out");      }    };  }  @Override  public void setUp() throws Exception {      super.setUp();      final CamelContext camelContext = context();      camelContext.getRouteDefinition(ROUTE_ID)        .adviceWith(camelContext, new AdviceWithRouteBuilder() {          @Override          public void configure() throws Exception {            replaceFromWith("direct:quartz");            weaveAddLast().to("mock:extract");          }        });  }  @Test  public void shouldReceive2Messages() throws InterruptedException {    // given    final MockEndpoint quartzMock = getMockEndpoint("mock:extract");    // declare    quartzMock.expectedMessageCount(2);    // when    template.sendBody("direct:quartz", "tick");    template.sendBody("direct:quartz", "tick");    // then    quartzMock.assertIsSatisfied();    Assertions.assertThat(counter).hasValue(2);  }}{code}Unfortunatelly, before adviceWith is invoked, quartz sends already two messages
StackOverflow when using bean(this) This testcase{code:java}import org.apache.camel.CamelContext;import org.apache.camel.Exchange;import org.apache.camel.RoutesBuilder;import org.apache.camel.builder.AdviceWithRouteBuilder;import org.apache.camel.builder.RouteBuilder;import org.apache.camel.component.mock.MockEndpoint;import org.apache.camel.test.junit4.CamelTestSupport;import org.junit.Test;public class MyRouteTest extends CamelTestSupport {private static final String ROUTE_ID = "mytest";@Overrideprotected RoutesBuilder createRouteBuilder() throws Exception {  return new RouteBuilder() {    @Override    public void configure() throws Exception {      from("direct:mytest")      .id(ROUTE_ID)      .bean(this, "hello", false) // <- here is the problem      .to("stream:out");    }    public void hello(final Exchange exchange) {    }  };}@Overridepublic void setUp() throws Exception {  super.setUp();  final CamelContext camelContext = context();  camelContext.getRouteDefinition(ROUTE_ID)    .adviceWith(camelContext, new AdviceWithRouteBuilder() {    @Override    public void configure() throws Exception {      weaveAddLast().to("mock:extract");    }  });}@Overridepublic boolean isUseAdviceWith() {  return true;}@Testpublic void shouldFire() throws InterruptedException {  // given  final MockEndpoint myMock = getMockEndpoint("mock:extract");  myMock.expectedMessageCount(1);  // when  template.sendBody("direct:mytest", "test");  // then  myMock.assertIsSatisfied();}}{code}Throws{code:java}java.lang.StackOverflowErrorat java.util.AbstractCollection.toString(Unknown Source)at java.lang.String.valueOf(Unknown Source)at java.lang.StringBuilder.append(Unknown Source)at org.apache.camel.model.RoutesDefinition.toString(RoutesDefinition.java:64)at org.apache.camel.builder.RouteBuilder.toString(RouteBuilder.java:74)at org.apache.camel.model.BeanDefinition.description(BeanDefinition.java:89)at org.apache.camel.model.BeanDefinition.toString(BeanDefinition.java:78)at java.lang.String.valueOf(Unknown Source){code}  Bug StackOverflow when using bean(this) This testcase{code:java}import org.apache.camel.CamelContext;import org.apache.camel.Exchange;import org.apache.camel.RoutesBuilder;import org.apache.camel.builder.AdviceWithRouteBuilder;import org.apache.camel.builder.RouteBuilder;import org.apache.camel.component.mock.MockEndpoint;import org.apache.camel.test.junit4.CamelTestSupport;import org.junit.Test;public class MyRouteTest extends CamelTestSupport {private static final String ROUTE_ID = "mytest";@Overrideprotected RoutesBuilder createRouteBuilder() throws Exception {  return new RouteBuilder() {    @Override    public void configure() throws Exception {      from("direct:mytest")      .id(ROUTE_ID)      .bean(this, "hello", false) // <- here is the problem      .to("stream:out");    }    public void hello(final Exchange exchange) {    }  };}@Overridepublic void setUp() throws Exception {  super.setUp();  final CamelContext camelContext = context();  camelContext.getRouteDefinition(ROUTE_ID)    .adviceWith(camelContext, new AdviceWithRouteBuilder() {    @Override    public void configure() throws Exception {      weaveAddLast().to("mock:extract");    }  });}@Overridepublic boolean isUseAdviceWith() {  return true;}@Testpublic void shouldFire() throws InterruptedException {  // given  final MockEndpoint myMock = getMockEndpoint("mock:extract");  myMock.expectedMessageCount(1);  // when  template.sendBody("direct:mytest", "test");  // then  myMock.assertIsSatisfied();}}{code}Throws{code:java}java.lang.StackOverflowErrorat java.util.AbstractCollection.toString(Unknown Source)at java.lang.String.valueOf(Unknown Source)at java.lang.StringBuilder.append(Unknown Source)at org.apache.camel.model.RoutesDefinition.toString(RoutesDefinition.java:64)at org.apache.camel.builder.RouteBuilder.toString(RouteBuilder.java:74)at org.apache.camel.model.BeanDefinition.description(BeanDefinition.java:89)at org.apache.camel.model.BeanDefinition.toString(BeanDefinition.java:78)at java.lang.String.valueOf(Unknown Source){code} 
file2: pollEnrich with sendEmptyMessageWhenIdle does not send correct Exchanges I use the file component in pollEnrich with sendEmptyMessageWhenIdle=true and readLock=changedIn 2.20.4 and before the attached test case worked, from 2.21.0 on it fails.My test writes several characters delayed into a file so that the component runs into a timeout after 10000ms on the first call. This is correct.On the second call the writing of the file is finished within the 10000ms, my expectation is the correct processing of the file in my route, but it fails because the Exchange has an empty body.I debugged the thing an saw that in the variable GenericFilePollingConsumer.queue there are two exchanges instead of one. The first one sems to be the "empty" message from the first call without a GenericFile in the In-Body, and the second Exchange in the queue is the correct one with the GenericFile from the second call.Because it's a FiFo, only the first, empty one is returned (in EventDrivenPollingConsumer.receive()) so that the route states that there is nothing to do.I suspect an error in the processing of the empty message, so that it is not cleared or taken properly from the queue so that it remains there and conflicts with later calls. Bug file2: pollEnrich with sendEmptyMessageWhenIdle does not send correct Exchanges I use the file component in pollEnrich with sendEmptyMessageWhenIdle=true and readLock=changedIn 2.20.4 and before the attached test case worked, from 2.21.0 on it fails.My test writes several characters delayed into a file so that the component runs into a timeout after 10000ms on the first call. This is correct.On the second call the writing of the file is finished within the 10000ms, my expectation is the correct processing of the file in my route, but it fails because the Exchange has an empty body.I debugged the thing an saw that in the variable GenericFilePollingConsumer.queue there are two exchanges instead of one. The first one sems to be the "empty" message from the first call without a GenericFile in the In-Body, and the second Exchange in the queue is the correct one with the GenericFile from the second call.Because it's a FiFo, only the first, empty one is returned (in EventDrivenPollingConsumer.receive()) so that the route states that there is nothing to do.I suspect an error in the processing of the empty message, so that it is not cleared or taken properly from the queue so that it remains there and conflicts with later calls.
RuntimeCamelCatalog#asEndpointUri strips dash from url with toD and netty4-http [https://stackoverflow.com/questions/56136857/how-to-use-camel-tod-and-netty4-http-component-problem-with-optimization-of-din]This is very similar to CAMEL-12705, but in this case it affects url with dashes. Tested with current master.*{{url}}*{code:java}netty4-http:http://a-b-c.hostname.tld:8080/anything{code}*results in* {code:java}netty4-http:http:a-b:8080/path{code}Unit test in attachment. -Maybe--_AbstractCamelCatalog#SYNTAX_PATTERN_ should be changed to- {code:java}([\w.-]+){code}-Or is there reason, why is dash excluded from regexp?-I have tried to edit regexp and it broke test too, it results in resolved = "netty4-http:http:a-b-c.hostname.tld-8080" Bug RuntimeCamelCatalog#asEndpointUri strips dash from url with toD and netty4-http [https://stackoverflow.com/questions/56136857/how-to-use-camel-tod-and-netty4-http-component-problem-with-optimization-of-din]This is very similar to CAMEL-12705, but in this case it affects url with dashes. Tested with current master.*{{url}}*{code:java}netty4-http:http://a-b-c.hostname.tld:8080/anything{code}*results in* {code:java}netty4-http:http:a-b:8080/path{code}Unit test in attachment. -Maybe--_AbstractCamelCatalog#SYNTAX_PATTERN_ should be changed to- {code:java}([\w.-]+){code}-Or is there reason, why is dash excluded from regexp?-I have tried to edit regexp and it broke test too, it results in resolved = "netty4-http:http:a-b-c.hostname.tld-8080"
CamelTestSupport.isCreateCamelContextPerClass no longer works for junit4 tests With the changes in org.apache.camel.test.junit4.CamelTestSupport done during the work on https://issues.apache.org/jira/browse/CAMEL-12534 the camel context is now recreated for every test regardless of the return value fromisCreateCamelContextPerClass(). Since junit4 creates a new instance of the class for every test the variable tests will be recreated and initialized to 0 for every test.This condition in tearDown will always be true{code:java}// code placeholderif (tests.compareAndSet(v, v - 1)) {    if (v == 1) {{code}which stops the camel context after every test. Bug CamelTestSupport.isCreateCamelContextPerClass no longer works for junit4 tests With the changes in org.apache.camel.test.junit4.CamelTestSupport done during the work on https://issues.apache.org/jira/browse/CAMEL-12534 the camel context is now recreated for every test regardless of the return value fromisCreateCamelContextPerClass(). Since junit4 creates a new instance of the class for every test the variable tests will be recreated and initialized to 0 for every test.This condition in tearDown will always be true{code:java}// code placeholderif (tests.compareAndSet(v, v - 1)) {    if (v == 1) {{code}which stops the camel context after every test.
KafkaConfiguration puts truststore password into keystore password property If you create a component-level KafkaConfiguration, and set SslContextParameters on it that includes a truststore password, then when creating consumer or producer properties, the KafkaConfiguration puts the truststore password into the keystore password field, resulting in errors such as:{{Caused by: org.apache.kafka.common.KafkaException: SSL key store is not specified, but key store password is specified.}}{{ at org.apache.kafka.common.security.ssl.SslFactory.createKeystore(SslFactory.java:283)}}{{ at org.apache.kafka.common.security.ssl.SslFactory.configure(SslFactory.java:126)}}{{ at org.apache.kafka.common.network.SaslChannelBuilder.configure(SaslChannelBuilder.java:149)}} PR available here:[https://github.com/apache/camel/pull/2899] Bug KafkaConfiguration puts truststore password into keystore password property If you create a component-level KafkaConfiguration, and set SslContextParameters on it that includes a truststore password, then when creating consumer or producer properties, the KafkaConfiguration puts the truststore password into the keystore password field, resulting in errors such as:{{Caused by: org.apache.kafka.common.KafkaException: SSL key store is not specified, but key store password is specified.}}{{ at org.apache.kafka.common.security.ssl.SslFactory.createKeystore(SslFactory.java:283)}}{{ at org.apache.kafka.common.security.ssl.SslFactory.configure(SslFactory.java:126)}}{{ at org.apache.kafka.common.network.SaslChannelBuilder.configure(SaslChannelBuilder.java:149)}} PR available here:[https://github.com/apache/camel/pull/2899]
Camel with Olingo4 not shutting down I'm using the Olingo4 component and I want my Camel to run as a cron job. After my exchange is completed I stop the camel context, but the jvm doesn’t close and keeps running. I found out that there still was a thread running with a httpAsyncClient.I checked the code for the component and found in the class Olingo4AppImpl that there by default a CloseableHttpAsyncClient is started, but not closed when camel is being shut down.I added this to close method and now the jvm process is stopping:@Overridepublic void close() {   if (client instanceof CloseableHttpAsyncClient) {       try {           client.close();       }       catch (IOException e) {           throw new RuntimeException(e);       }   }}Not sure what should happen when somebody uses their own httpAsyncClientBuilder. Bug Camel with Olingo4 not shutting down I'm using the Olingo4 component and I want my Camel to run as a cron job. After my exchange is completed I stop the camel context, but the jvm doesn't close and keeps running. I found out that there still was a thread running with a httpAsyncClient.I checked the code for the component and found in the class Olingo4AppImpl that there by default a CloseableHttpAsyncClient is started, but not closed when camel is being shut down.I added this to close method and now the jvm process is stopping:@Overridepublic void close() {   if (client instanceof CloseableHttpAsyncClient) {       try {           client.close();       }       catch (IOException e) {           throw new RuntimeException(e);       }   }}Not sure what should happen when somebody uses their own httpAsyncClientBuilder.
Exception tag is missing when Camel Java DSL is converted into XML using dumpRouteAsXml() operation Exception tag is missing when Camel Java DSL is converted into XML using dumpRouteAsXml() operation#Java DSL route{code:java}public void configure() {	onException(Exception.class).log("${exception.stacktrace}").logStackTrace(true)			.handled(true);	from("timer://foo?fixedRate=true&period=10000&repeatCount=101").routeId("test")			.log("Hello World");}{code}#XML converted by dumpRouteAsXml() operation(*<exception>java.lang.Exception</exception>* tag is missing){code:java}<?xml version="1.0" encoding="UTF-8" standalone="yes"?><route xmlns="http://camel.apache.org/schema/spring" customId="true" id="test">    <from uri="timer://foo?fixedRate=true&amp;period=10000&amp;repeatCount=101"/>    <onException id="onException1">        <redeliveryPolicy logStackTrace="true"/>        <log id="log1" message="${exception.stacktrace}"/>    </onException>    <log id="log2" message="Hello World"/></route>{code} Bug Exception tag is missing when Camel Java DSL is converted into XML using dumpRouteAsXml() operation Exception tag is missing when Camel Java DSL is converted into XML using dumpRouteAsXml() operation#Java DSL route{code:java}public void configure() {	onException(Exception.class).log("${exception.stacktrace}").logStackTrace(true)			.handled(true);	from("timer://foo?fixedRate=true&period=10000&repeatCount=101").routeId("test")			.log("Hello World");}{code}#XML converted by dumpRouteAsXml() operation(*<exception>java.lang.Exception</exception>* tag is missing){code:java}<?xml version="1.0" encoding="UTF-8" standalone="yes"?><route xmlns="http://camel.apache.org/schema/spring" customId="true" id="test">    <from uri="timer://foo?fixedRate=true&amp;period=10000&amp;repeatCount=101"/>    <onException id="onException1">        <redeliveryPolicy logStackTrace="true"/>        <log id="log1" message="${exception.stacktrace}"/>    </onException>    <log id="log2" message="Hello World"/></route>{code}
Default allowUseOriginalMessage="false" prevent clearing inflightRepository using jms with transferExchange="true" When using transferExchange="true" in a JMS consumer (assuming producer also did), camel is breaking the match between key and exchange in inflightRepository if allowUseOriginalMessage="true" is not set in camel context.This can lead to java heap space out of memory because camel is not able to clear the inflightRepository from old Exchange.Identified behaviour : # Camel receive the JMS message ## If allowUseOriginalMessage=true : parse JMS message to build Exchange instance ## If not : generate a new Instance # Camel add the Exchange to inflightRepository # On accessing the ExchangeBody, if it was not parsed  yet camel rebuild the Exchange but do not change the key(exchangeId) in the inflightRepository # When the route process is over the message is not disposed if the key has been changed in the Exchange but not inflightRepository # Sooner or later the heap space if full and application crash.The problem appeared in 2.18.0 and is present up until 2.23.1 (tested with attached test case). Release note of 2.18.0 says :"Optimize Camel to only enable AllowUseOriginalMessage if in use by error handler or OnCompletion<[http://camel.apache.org/oncompletion.html]>. End user who manually access the original message using the Java API must configure AllowUseOriginalMessage=true."Problem is transferExchange="true" case also needs allowUseOriginalMessage="true" even if the not accessing original message by Java API an other way.Easy work around : set allowUseOriginalMessage="true" in camel context configuration Bug Default allowUseOriginalMessage="false" prevent clearing inflightRepository using jms with transferExchange="true" When using transferExchange="true" in a JMS consumer (assuming producer also did), camel is breaking the match between key and exchange in inflightRepository if allowUseOriginalMessage="true" is not set in camel context.This can lead to java heap space out of memory because camel is not able to clear the inflightRepository from old Exchange.Identified behaviour : # Camel receive the JMS message ## If allowUseOriginalMessage=true : parse JMS message to build Exchange instance ## If not : generate a new Instance # Camel add the Exchange to inflightRepository # On accessing the ExchangeBody, if it was not parsed  yet camel rebuild the Exchange but do not change the key(exchangeId) in the inflightRepository # When the route process is over the message is not disposed if the key has been changed in the Exchange but not inflightRepository # Sooner or later the heap space if full and application crash.The problem appeared in 2.18.0 and is present up until 2.23.1 (tested with attached test case). Release note of 2.18.0 says :"Optimize Camel to only enable AllowUseOriginalMessage if in use by error handler or OnCompletion<[http://camel.apache.org/oncompletion.html]>. End user who manually access the original message using the Java API must configure AllowUseOriginalMessage=true."Problem is transferExchange="true" case also needs allowUseOriginalMessage="true" even if the not accessing original message by Java API an other way.Easy work around : set allowUseOriginalMessage="true" in camel context configuration
Camel FTP Cannot list directory with 'File not found' prepending additional '/' in front of directory automatically I need to poll files form a dynamic folder based on a specific date, so I have provided the parent directory in endpoint URI, enabled recursive flag and add filterDirectory accordingly. But It is not able to poll from the directory, it says file not found for that directory. It is trying with an addition '/' while listing {{listFor(/XXXX)}}*Endpoint URI*{{sftp://XXXX:22051?connectTimeout=90000&disconnect=true&filterDirectory=%24%7Bfile%3Aname%7D+starts+with+%27%24%7Bbean%3AdateofExchange%3Fmethod%3DforLoc%28%22MY%22%29%7D%27&flatten=true&include=.*IMG&knownHostsFile=C%3A%5Cprogram+files%5Cascertain%5CI2R-MystiQ-Engine%5Cknown_hosts&noop=true&password=xxxxxx&preferredAuthentications=password&reconnectDelay=30000&recursive=true&scheduler=quartz2&scheduler.cron=0+0%2F5+*+*+*+%3F&stepwise=false&username=XXXX_ftpuser }}*TRACE LOG*{{TRACE 2019-04-05T15:25:03,389 [org.apache.camel.component.file.remote.SftpConsumer] - Polling directory: TRACE 2019-04-05T15:25:03,389 [org.apache.camel.component.file.remote.SftpOperations] - listFiles() TRACE 2019-04-05T15:25:03,712 [org.apache.camel.component.file.remote.SftpConsumer] - Found 12 in directory: TRACE 2019-04-05T15:25:03,712 [org.apache.camel.component.file.remote.SftpConsumer] - SftpFile[fileName=., longName=dr-x------ 2 ftpadmin ftpadmin 0 Mar 12 05:27 ., dir=true] TRACE 2019-04-05T15:25:03,712 [org.apache.camel.component.file.remote.SftpConsumer] - File did not match. Will skip this file: RemoteFile[.] TRACE 2019-04-05T15:25:03,712 [org.apache.camel.component.file.remote.SftpConsumer] - SftpFile[fileName=.., longName=dr-x------ 2 ftpadmin ftpadmin 0 Mar 12 03:04 .., dir=true] TRACE 2019-04-05T15:25:03,712 [org.apache.camel.component.file.remote.SftpConsumer] - File did not match. Will skip this file: RemoteFile[..] TRACE 2019-04-05T15:25:03,728 [org.apache.camel.component.file.remote.SftpConsumer] - SftpFile[fileName=20170526, longName=dr-x------ 2 ftpadmin ftpadmin 0 Mar 12 02:16 20170526, dir=true] TRACE 2019-04-05T15:25:04,413 [org.apache.camel.component.file.remote.SftpConsumer] - File did not match. Will skip this file: RemoteFile[20170526] TRACE 2019-04-05T15:25:04,413 [org.apache.camel.component.file.remote.SftpConsumer] - SftpFile[fileName=20181119, longName=dr-x------ 2 ftpadmin ftpadmin 0 Mar 12 05:24 20181119, dir=true] TRACE 2019-04-05T15:25:05,117 [org.apache.camel.component.file.remote.SftpConsumer] - File did not match. Will skip this file: RemoteFile[20181119] TRACE 2019-04-05T15:25:05,117 [org.apache.camel.component.file.remote.SftpConsumer] - SftpFile[fileName=20181121, longName=dr-x------ 2 ftpadmin ftpadmin 0 Mar 12 05:25 20181121, dir=true] TRACE 2019-04-05T15:25:05,837 [org.apache.camel.component.file.remote.SftpConsumer] - File did not match. Will skip this file: RemoteFile[20181121] TRACE 2019-04-05T15:25:05,840 [org.apache.camel.component.file.remote.SftpConsumer] - SftpFile[fileName=20181122, longName=dr-x------ 2 ftpadmin ftpadmin 0 Mar 12 05:26 20181122, dir=true] TRACE 2019-04-05T15:25:06,561 [org.apache.camel.component.file.remote.SftpConsumer] - File did not match. Will skip this file: RemoteFile[20181122] TRACE 2019-04-05T15:25:06,563 [org.apache.camel.component.file.remote.SftpConsumer] - SftpFile[fileName=20181123, longName=dr-x------ 2 ftpadmin ftpadmin 0 Mar 12 05:27 20181123, dir=true] TRACE 2019-04-05T15:25:07,258 [org.apache.camel.component.file.remote.SftpConsumer] - Polling sub directory: /20181123 from: sftp://XXXX:22051?connectTimeout=90000&disconnect=true&filterDirectory=%24%7Bfile%3Aname%7D+starts+with+%27%24%7Bbean%3AdateofExchange%3Fmethod%3DforLoc%28%22MY%22%29%7D%27&flatten=true&include=.*IMG&knownHostsFile=C%3A%5Cprogram+files%5Cascertain%5CI2R-MystiQ-Engine%5Cknown_hosts&noop=true&password=xxxxxx&preferredAuthentications=password&reconnectDelay=30000&recursive=true&scheduler=quartz2&scheduler.cron=0+0%2F5+*+*+*+%3F&stepwise=false&username=XXXX_ftpuser TRACE 2019-04-05T15:25:07,260 [org.apache.camel.component.file.remote.SftpConsumer] - doPollDirectory from absolutePath: /20181123, dirName: 20181123 TRACE 2019-04-05T15:25:07,263 [org.apache.camel.component.file.remote.SftpConsumer] - Polling directory: /20181123 TRACE 2019-04-05T15:25:07,265 [org.apache.camel.component.file.remote.SftpOperations] - listFiles(/20181123) DEBUG 2019-04-05T15:25:07,281 [org.apache.camel.component.file.remote.SftpConsumer] - Caught exception Cannot list directory: /20181123 TRACE 2019-04-05T15:25:07,297 [org.apache.camel.component.file.remote.SftpConsumer] - Not ignoring file error Cannot list directory: /20181123 for /20181123 DEBUG 2019-04-05T15:25:07,297 [org.apache.camel.component.file.remote.SftpConsumer] - Error occurred during poll directory: due Cannot list directory: /20181123. Removing 0 files marked as in-progress. WARN 2019-04-05T15:25:07,297 [org.apache.camel.component.file.remote.RemoteFilePollingConsumerPollStrategy] - Trying to recover by force disconnecting from remote server and re-connecting at next poll: sftp://XXX@1XXXX:22051 DEBUG 2019-04-05T15:25:07,297 [org.apache.camel.component.file.remote.SftpConsumer] - Force disconnecting from: sftp://XXX@XXXX:22051 WARN 2019-04-05T15:25:07,297 [org.apache.camel.component.file.remote.SftpConsumer] - Consumer SftpConsumer[sftp://XXXX:22051?connectTimeout=90000&disconnect=true&filterDirectory=%24%7Bfile%3Aname%7D+starts+with+%27%24%7Bbean%3AdateofExchange%3Fmethod%3DforLoc%28%22MY%22%29%7D%27&flatten=true&include=.*IMG&knownHostsFile=C%3A%5Cprogram+files%5Cascertain%5CI2R-MystiQ-Engine%5Cknown_hosts&noop=true&password=xxxxxx&preferredAuthentications=password&reconnectDelay=30000&recursive=true&scheduler=quartz2&scheduler.cron=0+0%2F5+*+*+*+%3F&stepwise=false&username=XXXX_ftpuser] failed polling endpoint: sftp://XXXX:22051?connectTimeout=90000&disconnect=true&filterDirectory=%24%7Bfile%3Aname%7D+starts+with+%27%24%7Bbean%3AdateofExchange%3Fmethod%3DforLoc%28%22MY%22%29%7D%27&flatten=true&include=.*IMG&knownHostsFile=C%3A%5Cprogram+files%5Cascertain%5CI2R-MystiQ-Engine%5Cknown_hosts&noop=true&password=xxxxxx&preferredAuthentications=password&reconnectDelay=30000&recursive=true&scheduler=quartz2&scheduler.cron=0+0%2F5+*+*+*+%3F&stepwise=false&username=XXXX_ftpuser. Will try again at next poll. Caused by: [org.apache.camel.component.file.GenericFileOperationFailedException - Cannot list directory: /20181123] org.apache.camel.component.file.GenericFileOperationFailedException: Cannot list directory: /20181123 at org.apache.camel.component.file.remote.SftpOperations.listFiles(SftpOperations.java:660) ~[camel-ftp-2.21.1.jar!/:2.21.1] at org.apache.camel.component.file.remote.SftpConsumer.doPollDirectory(SftpConsumer.java:128) ~[camel-ftp-2.21.1.jar!/:2.21.1] at org.apache.camel.component.file.remote.RemoteFileConsumer.doSafePollSubDirectory(RemoteFileConsumer.java:260) ~[camel-ftp-2.21.1.jar!/:2.21.1] at org.apache.camel.component.file.remote.SftpConsumer.pollSubDirectory(SftpConsumer.java:96) ~[camel-ftp-2.21.1.jar!/:2.21.1] at org.apache.camel.component.file.remote.SftpConsumer.doPollDirectory(SftpConsumer.java:178) ~[camel-ftp-2.21.1.jar!/:2.21.1] at org.apache.camel.component.file.remote.SftpConsumer.pollDirectory(SftpConsumer.java:87) ~[camel-ftp-2.21.1.jar!/:2.21.1] at org.apache.camel.component.file.GenericFileConsumer.poll(GenericFileConsumer.java:124) ~[camel-core-2.21.1.jar!/:2.21.1] at org.apache.camel.impl.ScheduledPollConsumer.doRun(ScheduledPollConsumer.java:174) [camel-core-2.21.1.jar!/:2.21.1] at org.apache.camel.impl.ScheduledPollConsumer.run(ScheduledPollConsumer.java:101) [camel-core-2.21.1.jar!/:2.21.1] at org.apache.camel.pollconsumer.quartz2.QuartzScheduledPollConsumerJob.execute(QuartzScheduledPollConsumerJob.java:61) [camel-quartz2-2.21.1.jar!/:2.21.1] at org.quartz.core.JobRunShell.run(JobRunShell.java:202) [quartz-2.3.0.jar!/:?] at org.quartz.simpl.SimpleThreadPool$WorkerThread.run(SimpleThreadPool.java:573) [quartz-2.3.0.jar!/:?] Caused by: com.jcraft.jsch.SftpException: File not found: /20181123 at com.jcraft.jsch.ChannelSftp.throwStatusError(ChannelSftp.java:2873) ~[jsch-0.1.54.jar!/:?] at com.jcraft.jsch.ChannelSftp._stat(ChannelSftp.java:2225) ~[jsch-0.1.54.jar!/:?] at com.jcraft.jsch.ChannelSftp._stat(ChannelSftp.java:2242) ~[jsch-0.1.54.jar!/:?] at com.jcraft.jsch.ChannelSftp.ls(ChannelSftp.java:1592) ~[jsch-0.1.54.jar!/:?] at com.jcraft.jsch.ChannelSftp.ls(ChannelSftp.java:1553) ~[jsch-0.1.54.jar!/:?] at org.apache.camel.component.file.remote.SftpOperations.listFiles(SftpOperations.java:651) ~[camel-ftp-2.21.1.jar!/:2.21.1] ... 11 more }}When I try to hardcode that folder along with endpint URI, it simply can list that directory and poll files. This time there is no '/' before the directory while listing {{listFor(XXXX)}}*Endpoint URI*{{sftp://XXXX:22051/20181123?connectTimeout=90000&disconnect=true&flatten=true&include=.*IMG&knownHostsFile=C%3A%5Cprogram+files%5Cascertain%5CI2R-MystiQ-Engine%5Cknown_hosts&noop=true&password=xxxxxx&preferredAuthentications=password&reconnectDelay=30000&recursive=true&scheduler=quartz2&scheduler.cron=0+0%2F5+*+*+*+%3F&separator=Auto&stepwise=false&username=XXXX_ftpuser }}*TRACE LOG*{{TRACE 2019-04-05T18:40:00,009 [org.apache.camel.component.file.remote.SftpConsumer] - prePollCheck on sftp://XXX@XXXX:22051 DEBUG 2019-04-05T18:40:00,009 [org.apache.camel.component.file.remote.SftpConsumer] - Not connected/logged in, connecting to: sftp://XXX@XXXX:22051 TRACE 2019-04-05T18:40:00,009 [org.apache.camel.component.file.remote.SftpOperations] - Session isn't connected, trying to recreate and connect. DEBUG 2019-04-05T18:40:00,009 [org.apache.camel.component.file.remote.SftpOperations] - Using knownhosts file: C:\program files\ascertain\I2R-MystiQ-Engine\known_hosts DEBUG 2019-04-05T18:40:00,009 [org.apache.camel.component.file.remote.SftpOperations] - Using known hosts information from file: C:\program files\ascertain\I2R-MystiQ-Engine\known_hosts DEBUG 2019-04-05T18:40:00,025 [org.apache.camel.component.file.remote.SftpOperations] - Using StrickHostKeyChecking: no DEBUG 2019-04-05T18:40:00,025 [org.apache.camel.component.file.remote.SftpOperations] - Using PreferredAuthentications: password TRACE 2019-04-05T18:40:00,025 [org.apache.camel.component.file.remote.SftpOperations] - Connecting use connectTimeout: 90000 ... TRACE 2019-04-05T18:40:00,465 [org.apache.camel.component.file.remote.SftpOperations] - Channel isn't connected, trying to recreate and connect. TRACE 2019-04-05T18:40:00,465 [org.apache.camel.component.file.remote.SftpOperations] - Connecting use connectTimeout: 90000 ... DEBUG 2019-04-05T18:40:01,215 [org.apache.camel.component.file.remote.SftpOperations] - Connected to sftp://XXX@XXXX:22051 DEBUG 2019-04-05T18:40:01,215 [org.apache.camel.component.file.remote.SftpConsumer] - Connected and logged in to: sftp://XXX@XXXX:22051 TRACE 2019-04-05T18:40:01,215 [org.apache.camel.component.file.remote.SftpConsumer] - doPollDirectory from absolutePath: 20181123, dirName: null TRACE 2019-04-05T18:40:01,215 [org.apache.camel.component.file.remote.SftpConsumer] - Polling directory: 20181123 TRACE 2019-04-05T18:40:01,215 [org.apache.camel.component.file.remote.SftpOperations] - listFiles(20181123) TRACE 2019-04-05T18:40:02,621 [org.apache.camel.component.file.remote.SftpConsumer] - Found 6 in directory: 20181123 TRACE 2019-04-05T18:40:02,621 [org.apache.camel.component.file.remote.SftpConsumer] - SftpFile[fileName=., longName=dr-x------ 2 ftpadmin ftpadmin 0 Mar 12 05:27 ., dir=true] TRACE 2019-04-05T18:40:02,621 [org.apache.camel.component.file.remote.SftpConsumer] - File did not match. Will skip this file: RemoteFile[.] TRACE 2019-04-05T18:40:02,637 [org.apache.camel.component.file.remote.SftpConsumer] - SftpFile[fileName=.., longName=dr-x------ 2 ftpadmin ftpadmin 0 Mar 12 05:27 .., dir=true] TRACE 2019-04-05T18:40:02,637 [org.apache.camel.component.file.remote.SftpConsumer] - File did not match. Will skip this file: RemoteFile[..] TRACE 2019-04-05T18:40:02,637 [org.apache.camel.component.file.remote.SftpConsumer] - SftpFile[fileName=Consolidated, longName=dr-x------ 2 ftpadmin ftpadmin 0 Mar 12 05:26 Consolidated, dir=true] TRACE 2019-04-05T18:40:02,637 [org.apache.camel.component.file.remote.SftpConsumer] - Polling sub directory: 20181123/Consolidated from: sftp://XXXX:22051/20181123?connectTimeout=90000&disconnect=true&flatten=true&include=.*IMG&knownHostsFile=C%3A%5Cprogram+files%5Cascertain%5CI2R-MystiQ-Engine%5Cknown_hosts&noop=true&password=xxxxxx&preferredAuthentications=password&reconnectDelay=30000&recursive=true&scheduler=quartz2&scheduler.cron=0+0%2F5+*+*+*+%3F&separator=Auto&stepwise=false&username=XXXX_ftpuser TRACE 2019-04-05T18:40:02,637 [org.apache.camel.component.file.remote.SftpConsumer] - doPollDirectory from absolutePath: 20181123/Consolidated, dirName: Consolidated TRACE 2019-04-05T18:40:02,637 [org.apache.camel.component.file.remote.SftpConsumer] - Polling directory: 20181123/Consolidated TRACE 2019-04-05T18:40:02,637 [org.apache.camel.component.file.remote.SftpOperations] - listFiles(20181123/Consolidated) TRACE 2019-04-05T18:40:02,715 [org.apache.camel.component.file.remote.SftpConsumer] - Found 5 in directory: 20181123/Consolidated TRACE 2019-04-05T18:40:02,715 [org.apache.camel.component.file.remote.SftpConsumer] - SftpFile[fileName=., longName=dr-x------ 2 ftpadmin ftpadmin 0 Mar 12 05:26 ., dir=true] TRACE 2019-04-05T18:40:02,715 [org.apache.camel.component.file.remote.SftpConsumer] - File did not match. Will skip this file: RemoteFile[Consolidated/.] TRACE 2019-04-05T18:40:02,715 [org.apache.camel.component.file.remote.SftpConsumer] - SftpFile[fileName=.., longName=dr-x------ 2 ftpadmin ftpadmin 0 Mar 12 05:27 .., dir=true] TRACE 2019-04-05T18:40:02,715 [org.apache.camel.component.file.remote.SftpConsumer] - File did not match. Will skip this file: RemoteFile[Consolidated/..] TRACE 2019-04-05T18:40:02,715 [org.apache.camel.component.file.remote.SftpConsumer] - SftpFile[fileName=20181124020438943_021420181123INW.MYR, longName=-r-x------ 1 ftpadmin ftpadmin 408097 Nov 23 2018 20181124020438943_021420181123INW.MYR, dir=false] TRACE 2019-04-05T18:40:02,731 [org.apache.camel.component.file.remote.SftpConsumer] - File did not match. Will skip this file: RemoteFile[Consolidated/20181124020438943_021420181123INW.MYR] TRACE 2019-04-05T18:40:02,731 [org.apache.camel.component.file.remote.SftpConsumer] - SftpFile[fileName=20181124020439099_035820181123INW.MYR, longName=-r-x------ 1 ftpadmin ftpadmin 21689 Nov 23 2018 20181124020439099_035820181123INW.MYR, dir=false] TRACE 2019-04-05T18:40:02,731 [org.apache.camel.component.file.remote.SftpConsumer] - File did not match. Will skip this file: RemoteFile[Consolidated/20181124020439099_035820181123INW.MYR] TRACE 2019-04-05T18:40:02,731 [org.apache.camel.component.file.remote.SftpConsumer] - SftpFile[fileName=ToPPay, longName=dr-x------ 2 ftpadmin ftpadmin 0 Mar 12 06:41 ToPPay, dir=true] TRACE 2019-04-05T18:40:02,731 [org.apache.camel.component.file.remote.SftpConsumer] - Polling sub directory: 20181123/Consolidated/ToPPay from: sftp://XXXX:22051/20181123?connectTimeout=90000&disconnect=true&flatten=true&include=.*IMG&knownHostsFile=C%3A%5Cprogram+files%5Cascertain%5CI2R-MystiQ-Engine%5Cknown_hosts&noop=true&password=xxxxxx&preferredAuthentications=password&reconnectDelay=30000&recursive=true&scheduler=quartz2&scheduler.cron=0+0%2F5+*+*+*+%3F&separator=Auto&stepwise=false&username=XXXX_ftpuser TRACE 2019-04-05T18:40:02,731 [org.apache.camel.component.file.remote.SftpConsumer] - doPollDirectory from absolutePath: 20181123/Consolidated/ToPPay, dirName: ToPPay TRACE 2019-04-05T18:40:02,731 [org.apache.camel.component.file.remote.SftpConsumer] - Polling directory: 20181123/Consolidated/ToPPay TRACE 2019-04-05T18:40:02,731 [org.apache.camel.component.file.remote.SftpOperations] - listFiles(20181123/Consolidated/ToPPay) TRACE 2019-04-05T18:40:02,777 [org.apache.camel.component.file.remote.SftpConsumer] - Found 8 in directory: 20181123/Consolidated/ToPPay TRACE 2019-04-05T18:40:02,777 [org.apache.camel.component.file.remote.SftpConsumer] - SftpFile[fileName=., longName=dr-x------ 2 ftpadmin ftpadmin 0 Mar 12 06:41 ., dir=true] TRACE 2019-04-05T18:40:02,777 [org.apache.camel.component.file.remote.SftpConsumer] - File did not match. Will skip this file: RemoteFile[Consolidated/ToPPay/.] TRACE 2019-04-05T18:40:02,777 [org.apache.camel.component.file.remote.SftpConsumer] - SftpFile[fileName=.., longName=dr-x------ 2 ftpadmin ftpadmin 0 Mar 12 05:26 .., dir=true] TRACE 2019-04-05T18:40:02,777 [org.apache.camel.component.file.remote.SftpConsumer] - File did not match. Will skip this file: RemoteFile[Consolidated/ToPPay/..] TRACE 2019-04-05T18:40:02,793 [org.apache.camel.component.file.remote.SftpConsumer] - SftpFile[fileName=021420181123INW.MYR, longName=-r-x------ 1 ftpadmin ftpadmin 408097 Nov 23 2018 021420181123INW.MYR, dir=false] TRACE 2019-04-05T18:40:02,793 [org.apache.camel.component.file.remote.SftpConsumer] - File did not match. Will skip this file: RemoteFile[Consolidated/ToPPay/021420181123INW.MYR] TRACE 2019-04-05T18:40:02,793 [org.apache.camel.component.file.remote.SftpConsumer] - SftpFile[fileName=021420181123INW1.MYR, longName=-r-x------ 1 ftpadmin ftpadmin 579829 Nov 23 2018 021420181123INW1.MYR, dir=false] TRACE 2019-04-05T18:40:02,793 [org.apache.camel.component.file.remote.SftpConsumer] - File did not match. Will skip this file: RemoteFile[Consolidated/ToPPay/021420181123INW1.MYR] TRACE 2019-04-05T18:40:02,793 [org.apache.camel.component.file.remote.SftpConsumer] - SftpFile[fileName=035820181123INW.MYR, longName=-r-x------ 1 ftpadmin ftpadmin 21689 Nov 23 2018 035820181123INW.MYR, dir=false] TRACE 2019-04-05T18:40:02,793 [org.apache.camel.component.file.remote.SftpConsumer] - File did not match. Will skip this file: RemoteFile[Consolidated/ToPPay/035820181123INW.MYR] TRACE 2019-04-05T18:40:02,793 [org.apache.camel.component.file.remote.SftpConsumer] - SftpFile[fileName=035820181123INW1.MYR, longName=-r-x------ 1 ftpadmin ftpadmin 30954 Nov 23 2018 035820181123INW1.MYR, dir=false] TRACE 2019-04-05T18:40:02,793 [org.apache.camel.component.file.remote.SftpConsumer] - File did not match. Will skip this file: RemoteFile[Consolidated/ToPPay/035820181123INW1.MYR] TRACE 2019-04-05T18:40:02,809 [org.apache.camel.component.file.remote.SftpConsumer] - SftpFile[fileName=20181124020438943_021420181123INW.MYR, longName=-r-x------ 1 ftpadmin ftpadmin 408097 Nov 23 2018 20181124020438943_021420181123INW.MYR, dir=false] TRACE 2019-04-05T18:40:02,809 [org.apache.camel.component.file.remote.SftpConsumer] - File did not match. Will skip this file: RemoteFile[Consolidated/ToPPay/20181124020438943_021420181123INW.MYR] TRACE 2019-04-05T18:40:02,809 [org.apache.camel.component.file.remote.SftpConsumer] - SftpFile[fileName=20181124020439099_035820181123INW.MYR, longName=-r-x------ 1 ftpadmin ftpadmin 21689 Nov 23 2018 20181124020439099_035820181123INW.MYR, dir=false] TRACE 2019-04-05T18:40:02,809 [org.apache.camel.component.file.remote.SftpConsumer] - File did not match. Will skip this file: RemoteFile[Consolidated/ToPPay/20181124020439099_035820181123INW.MYR] TRACE 2019-04-05T18:40:02,809 [org.apache.camel.component.file.remote.SftpConsumer] - SftpFile[fileName=Data, longName=dr-x------ 2 ftpadmin ftpadmin 0 Mar 12 05:26 Data, dir=true] TRACE 2019-04-05T18:40:02,809 [org.apache.camel.component.file.remote.SftpConsumer] - Polling sub directory: 20181123/Data from: sftp://XXXX:22051/20181123?connectTimeout=90000&disconnect=true&flatten=true&include=.*IMG&knownHostsFile=C%3A%5Cprogram+files%5Cascertain%5CI2R-MystiQ-Engine%5Cknown_hosts&noop=true&password=xxxxxx&preferredAuthentications=password&reconnectDelay=30000&recursive=true&scheduler=quartz2&scheduler.cron=0+0%2F5+*+*+*+%3F&separator=Auto&stepwise=false&username=XXXX_ftpuser TRACE 2019-04-05T18:40:02,809 [org.apache.camel.component.file.remote.SftpConsumer] - doPollDirectory from absolutePath: 20181123/Data, dirName: Data TRACE 2019-04-05T18:40:02,809 [org.apache.camel.component.file.remote.SftpConsumer] - Polling directory: 20181123/Data TRACE 2019-04-05T18:40:02,809 [org.apache.camel.component.file.remote.SftpOperations] - listFiles(20181123/Data) TRACE 2019-04-05T18:40:02,871 [org.apache.camel.component.file.remote.SftpConsumer] - Found 501 in directory: 20181123/Data TRACE 2019-04-05T18:40:02,871 [org.apache.camel.component.file.remote.SftpConsumer] - SftpFile[fileName=., longName=dr-x------ 2 ftpadmin ftpadmin 0 Mar 12 05:26 ., dir=true] TRACE 2019-04-05T18:40:02,871 [org.apache.camel.component.file.remote.SftpConsumer] - File did not match. Will skip this file: RemoteFile[Data/.] TRACE 2019-04-05T18:40:02,871 [org.apache.camel.component.file.remote.SftpConsumer] - SftpFile[fileName=.., longName=dr-x------ 2 ftpadmin ftpadmin 0 Mar 12 05:27 .., dir=true] TRACE 2019-04-05T18:40:02,871 [org.apache.camel.component.file.remote.SftpConsumer] - File did not match. Will skip this file: RemoteFile[Data/..] TRACE 2019-04-05T18:40:02,871 [org.apache.camel.component.file.remote.SftpConsumer] - SftpFile[fileName=20181123021401015101004323IWNM.MMYR, longName=-r-x------ 1 ftpadmin ftpadmin 14846 Nov 23 2018 20181123021401015101004323IWNM.MMYR, dir=false] TRACE 2019-04-05T18:40:02,871 [org.apache.camel.component.file.remote.SftpConsumer] - File did not match. Will skip this file: RemoteFile[Data/20181123021401015101004323IWNM.MMYR] }}I am sure that the cause of the issue has to be the addition '/' prepending with directory name while listing {{listFor(/XXXX)}}. How can I avoid it ! .. using {{seperator}} parameter didn't effect i suppose it is only for producing files and not for consuming. I need to resolve this issue as soon as possible. Please suggest me some solution :(*EDITED :*I can reproduce the issue in latest version as well,I suppose the issue is when there is no base path only the '/' gets prepended which should not actually happenCode Snippet from SftpConsumer.java Camel 3.0.0.M1{{if (file.isDirectory()) \{ RemoteFile<SftpRemoteFile> remote = asRemoteFile(absolutePath, file, getEndpoint().getCharset()); if (endpoint.isRecursive() && depth < endpoint.getMaxDepth() && isValidFile(remote, true, files)) { // recursive scan and add the sub files and folders String subDirectory = file.getFilename(); String path = absolutePath + "/" + subDirectory; boolean canPollMore = pollSubDirectory(path, subDirectory, fileList, depth); if (!canPollMore) { return false; } } // we cannot use file.getAttrs().isLink on Windows, so we dont invoke the method // just assuming its a file we should poll } }}{quote}String path = absolutePath + "/" + subDirectory;{quote} Bug Camel FTP Cannot list directory with 'File not found' prepending additional '/' in front of directory automatically I need to poll files form a dynamic folder based on a specific date, so I have provided the parent directory in endpoint URI, enabled recursive flag and add filterDirectory accordingly. But It is not able to poll from the directory, it says file not found for that directory. It is trying with an addition '/' while listing {{listFor(/XXXX)}}*Endpoint URI*{{sftp://XXXX:22051?connectTimeout=90000&disconnect=true&filterDirectory=%24%7Bfile%3Aname%7D+starts+with+%27%24%7Bbean%3AdateofExchange%3Fmethod%3DforLoc%28%22MY%22%29%7D%27&flatten=true&include=.*IMG&knownHostsFile=C%3A%5Cprogram+files%5Cascertain%5CI2R-MystiQ-Engine%5Cknown_hosts&noop=true&password=xxxxxx&preferredAuthentications=password&reconnectDelay=30000&recursive=true&scheduler=quartz2&scheduler.cron=0+0%2F5+*+*+*+%3F&stepwise=false&username=XXXX_ftpuser }}*TRACE LOG*{{TRACE 2019-04-05T15:25:03,389 [org.apache.camel.component.file.remote.SftpConsumer] - Polling directory: TRACE 2019-04-05T15:25:03,389 [org.apache.camel.component.file.remote.SftpOperations] - listFiles() TRACE 2019-04-05T15:25:03,712 [org.apache.camel.component.file.remote.SftpConsumer] - Found 12 in directory: TRACE 2019-04-05T15:25:03,712 [org.apache.camel.component.file.remote.SftpConsumer] - SftpFile[fileName=., longName=dr-x------ 2 ftpadmin ftpadmin 0 Mar 12 05:27 ., dir=true] TRACE 2019-04-05T15:25:03,712 [org.apache.camel.component.file.remote.SftpConsumer] - File did not match. Will skip this file: RemoteFile[.] TRACE 2019-04-05T15:25:03,712 [org.apache.camel.component.file.remote.SftpConsumer] - SftpFile[fileName=.., longName=dr-x------ 2 ftpadmin ftpadmin 0 Mar 12 03:04 .., dir=true] TRACE 2019-04-05T15:25:03,712 [org.apache.camel.component.file.remote.SftpConsumer] - File did not match. Will skip this file: RemoteFile[..] TRACE 2019-04-05T15:25:03,728 [org.apache.camel.component.file.remote.SftpConsumer] - SftpFile[fileName=20170526, longName=dr-x------ 2 ftpadmin ftpadmin 0 Mar 12 02:16 20170526, dir=true] TRACE 2019-04-05T15:25:04,413 [org.apache.camel.component.file.remote.SftpConsumer] - File did not match. Will skip this file: RemoteFile[20170526] TRACE 2019-04-05T15:25:04,413 [org.apache.camel.component.file.remote.SftpConsumer] - SftpFile[fileName=20181119, longName=dr-x------ 2 ftpadmin ftpadmin 0 Mar 12 05:24 20181119, dir=true] TRACE 2019-04-05T15:25:05,117 [org.apache.camel.component.file.remote.SftpConsumer] - File did not match. Will skip this file: RemoteFile[20181119] TRACE 2019-04-05T15:25:05,117 [org.apache.camel.component.file.remote.SftpConsumer] - SftpFile[fileName=20181121, longName=dr-x------ 2 ftpadmin ftpadmin 0 Mar 12 05:25 20181121, dir=true] TRACE 2019-04-05T15:25:05,837 [org.apache.camel.component.file.remote.SftpConsumer] - File did not match. Will skip this file: RemoteFile[20181121] TRACE 2019-04-05T15:25:05,840 [org.apache.camel.component.file.remote.SftpConsumer] - SftpFile[fileName=20181122, longName=dr-x------ 2 ftpadmin ftpadmin 0 Mar 12 05:26 20181122, dir=true] TRACE 2019-04-05T15:25:06,561 [org.apache.camel.component.file.remote.SftpConsumer] - File did not match. Will skip this file: RemoteFile[20181122] TRACE 2019-04-05T15:25:06,563 [org.apache.camel.component.file.remote.SftpConsumer] - SftpFile[fileName=20181123, longName=dr-x------ 2 ftpadmin ftpadmin 0 Mar 12 05:27 20181123, dir=true] TRACE 2019-04-05T15:25:07,258 [org.apache.camel.component.file.remote.SftpConsumer] - Polling sub directory: /20181123 from: sftp://XXXX:22051?connectTimeout=90000&disconnect=true&filterDirectory=%24%7Bfile%3Aname%7D+starts+with+%27%24%7Bbean%3AdateofExchange%3Fmethod%3DforLoc%28%22MY%22%29%7D%27&flatten=true&include=.*IMG&knownHostsFile=C%3A%5Cprogram+files%5Cascertain%5CI2R-MystiQ-Engine%5Cknown_hosts&noop=true&password=xxxxxx&preferredAuthentications=password&reconnectDelay=30000&recursive=true&scheduler=quartz2&scheduler.cron=0+0%2F5+*+*+*+%3F&stepwise=false&username=XXXX_ftpuser TRACE 2019-04-05T15:25:07,260 [org.apache.camel.component.file.remote.SftpConsumer] - doPollDirectory from absolutePath: /20181123, dirName: 20181123 TRACE 2019-04-05T15:25:07,263 [org.apache.camel.component.file.remote.SftpConsumer] - Polling directory: /20181123 TRACE 2019-04-05T15:25:07,265 [org.apache.camel.component.file.remote.SftpOperations] - listFiles(/20181123) DEBUG 2019-04-05T15:25:07,281 [org.apache.camel.component.file.remote.SftpConsumer] - Caught exception Cannot list directory: /20181123 TRACE 2019-04-05T15:25:07,297 [org.apache.camel.component.file.remote.SftpConsumer] - Not ignoring file error Cannot list directory: /20181123 for /20181123 DEBUG 2019-04-05T15:25:07,297 [org.apache.camel.component.file.remote.SftpConsumer] - Error occurred during poll directory: due Cannot list directory: /20181123. Removing 0 files marked as in-progress. WARN 2019-04-05T15:25:07,297 [org.apache.camel.component.file.remote.RemoteFilePollingConsumerPollStrategy] - Trying to recover by force disconnecting from remote server and re-connecting at next poll: sftp://XXX@1XXXX:22051 DEBUG 2019-04-05T15:25:07,297 [org.apache.camel.component.file.remote.SftpConsumer] - Force disconnecting from: sftp://XXX@XXXX:22051 WARN 2019-04-05T15:25:07,297 [org.apache.camel.component.file.remote.SftpConsumer] - Consumer SftpConsumer[sftp://XXXX:22051?connectTimeout=90000&disconnect=true&filterDirectory=%24%7Bfile%3Aname%7D+starts+with+%27%24%7Bbean%3AdateofExchange%3Fmethod%3DforLoc%28%22MY%22%29%7D%27&flatten=true&include=.*IMG&knownHostsFile=C%3A%5Cprogram+files%5Cascertain%5CI2R-MystiQ-Engine%5Cknown_hosts&noop=true&password=xxxxxx&preferredAuthentications=password&reconnectDelay=30000&recursive=true&scheduler=quartz2&scheduler.cron=0+0%2F5+*+*+*+%3F&stepwise=false&username=XXXX_ftpuser] failed polling endpoint: sftp://XXXX:22051?connectTimeout=90000&disconnect=true&filterDirectory=%24%7Bfile%3Aname%7D+starts+with+%27%24%7Bbean%3AdateofExchange%3Fmethod%3DforLoc%28%22MY%22%29%7D%27&flatten=true&include=.*IMG&knownHostsFile=C%3A%5Cprogram+files%5Cascertain%5CI2R-MystiQ-Engine%5Cknown_hosts&noop=true&password=xxxxxx&preferredAuthentications=password&reconnectDelay=30000&recursive=true&scheduler=quartz2&scheduler.cron=0+0%2F5+*+*+*+%3F&stepwise=false&username=XXXX_ftpuser. Will try again at next poll. Caused by: [org.apache.camel.component.file.GenericFileOperationFailedException - Cannot list directory: /20181123] org.apache.camel.component.file.GenericFileOperationFailedException: Cannot list directory: /20181123 at org.apache.camel.component.file.remote.SftpOperations.listFiles(SftpOperations.java:660) ~[camel-ftp-2.21.1.jar!/:2.21.1] at org.apache.camel.component.file.remote.SftpConsumer.doPollDirectory(SftpConsumer.java:128) ~[camel-ftp-2.21.1.jar!/:2.21.1] at org.apache.camel.component.file.remote.RemoteFileConsumer.doSafePollSubDirectory(RemoteFileConsumer.java:260) ~[camel-ftp-2.21.1.jar!/:2.21.1] at org.apache.camel.component.file.remote.SftpConsumer.pollSubDirectory(SftpConsumer.java:96) ~[camel-ftp-2.21.1.jar!/:2.21.1] at org.apache.camel.component.file.remote.SftpConsumer.doPollDirectory(SftpConsumer.java:178) ~[camel-ftp-2.21.1.jar!/:2.21.1] at org.apache.camel.component.file.remote.SftpConsumer.pollDirectory(SftpConsumer.java:87) ~[camel-ftp-2.21.1.jar!/:2.21.1] at org.apache.camel.component.file.GenericFileConsumer.poll(GenericFileConsumer.java:124) ~[camel-core-2.21.1.jar!/:2.21.1] at org.apache.camel.impl.ScheduledPollConsumer.doRun(ScheduledPollConsumer.java:174) [camel-core-2.21.1.jar!/:2.21.1] at org.apache.camel.impl.ScheduledPollConsumer.run(ScheduledPollConsumer.java:101) [camel-core-2.21.1.jar!/:2.21.1] at org.apache.camel.pollconsumer.quartz2.QuartzScheduledPollConsumerJob.execute(QuartzScheduledPollConsumerJob.java:61) [camel-quartz2-2.21.1.jar!/:2.21.1] at org.quartz.core.JobRunShell.run(JobRunShell.java:202) [quartz-2.3.0.jar!/:?] at org.quartz.simpl.SimpleThreadPool$WorkerThread.run(SimpleThreadPool.java:573) [quartz-2.3.0.jar!/:?] Caused by: com.jcraft.jsch.SftpException: File not found: /20181123 at com.jcraft.jsch.ChannelSftp.throwStatusError(ChannelSftp.java:2873) ~[jsch-0.1.54.jar!/:?] at com.jcraft.jsch.ChannelSftp._stat(ChannelSftp.java:2225) ~[jsch-0.1.54.jar!/:?] at com.jcraft.jsch.ChannelSftp._stat(ChannelSftp.java:2242) ~[jsch-0.1.54.jar!/:?] at com.jcraft.jsch.ChannelSftp.ls(ChannelSftp.java:1592) ~[jsch-0.1.54.jar!/:?] at com.jcraft.jsch.ChannelSftp.ls(ChannelSftp.java:1553) ~[jsch-0.1.54.jar!/:?] at org.apache.camel.component.file.remote.SftpOperations.listFiles(SftpOperations.java:651) ~[camel-ftp-2.21.1.jar!/:2.21.1] ... 11 more }}When I try to hardcode that folder along with endpint URI, it simply can list that directory and poll files. This time there is no '/' before the directory while listing {{listFor(XXXX)}}*Endpoint URI*{{sftp://XXXX:22051/20181123?connectTimeout=90000&disconnect=true&flatten=true&include=.*IMG&knownHostsFile=C%3A%5Cprogram+files%5Cascertain%5CI2R-MystiQ-Engine%5Cknown_hosts&noop=true&password=xxxxxx&preferredAuthentications=password&reconnectDelay=30000&recursive=true&scheduler=quartz2&scheduler.cron=0+0%2F5+*+*+*+%3F&separator=Auto&stepwise=false&username=XXXX_ftpuser }}*TRACE LOG*{{TRACE 2019-04-05T18:40:00,009 [org.apache.camel.component.file.remote.SftpConsumer] - prePollCheck on sftp://XXX@XXXX:22051 DEBUG 2019-04-05T18:40:00,009 [org.apache.camel.component.file.remote.SftpConsumer] - Not connected/logged in, connecting to: sftp://XXX@XXXX:22051 TRACE 2019-04-05T18:40:00,009 [org.apache.camel.component.file.remote.SftpOperations] - Session isn't connected, trying to recreate and connect. DEBUG 2019-04-05T18:40:00,009 [org.apache.camel.component.file.remote.SftpOperations] - Using knownhosts file: C:\program files\ascertain\I2R-MystiQ-Engine\known_hosts DEBUG 2019-04-05T18:40:00,009 [org.apache.camel.component.file.remote.SftpOperations] - Using known hosts information from file: C:\program files\ascertain\I2R-MystiQ-Engine\known_hosts DEBUG 2019-04-05T18:40:00,025 [org.apache.camel.component.file.remote.SftpOperations] - Using StrickHostKeyChecking: no DEBUG 2019-04-05T18:40:00,025 [org.apache.camel.component.file.remote.SftpOperations] - Using PreferredAuthentications: password TRACE 2019-04-05T18:40:00,025 [org.apache.camel.component.file.remote.SftpOperations] - Connecting use connectTimeout: 90000 ... TRACE 2019-04-05T18:40:00,465 [org.apache.camel.component.file.remote.SftpOperations] - Channel isn't connected, trying to recreate and connect. TRACE 2019-04-05T18:40:00,465 [org.apache.camel.component.file.remote.SftpOperations] - Connecting use connectTimeout: 90000 ... DEBUG 2019-04-05T18:40:01,215 [org.apache.camel.component.file.remote.SftpOperations] - Connected to sftp://XXX@XXXX:22051 DEBUG 2019-04-05T18:40:01,215 [org.apache.camel.component.file.remote.SftpConsumer] - Connected and logged in to: sftp://XXX@XXXX:22051 TRACE 2019-04-05T18:40:01,215 [org.apache.camel.component.file.remote.SftpConsumer] - doPollDirectory from absolutePath: 20181123, dirName: null TRACE 2019-04-05T18:40:01,215 [org.apache.camel.component.file.remote.SftpConsumer] - Polling directory: 20181123 TRACE 2019-04-05T18:40:01,215 [org.apache.camel.component.file.remote.SftpOperations] - listFiles(20181123) TRACE 2019-04-05T18:40:02,621 [org.apache.camel.component.file.remote.SftpConsumer] - Found 6 in directory: 20181123 TRACE 2019-04-05T18:40:02,621 [org.apache.camel.component.file.remote.SftpConsumer] - SftpFile[fileName=., longName=dr-x------ 2 ftpadmin ftpadmin 0 Mar 12 05:27 ., dir=true] TRACE 2019-04-05T18:40:02,621 [org.apache.camel.component.file.remote.SftpConsumer] - File did not match. Will skip this file: RemoteFile[.] TRACE 2019-04-05T18:40:02,637 [org.apache.camel.component.file.remote.SftpConsumer] - SftpFile[fileName=.., longName=dr-x------ 2 ftpadmin ftpadmin 0 Mar 12 05:27 .., dir=true] TRACE 2019-04-05T18:40:02,637 [org.apache.camel.component.file.remote.SftpConsumer] - File did not match. Will skip this file: RemoteFile[..] TRACE 2019-04-05T18:40:02,637 [org.apache.camel.component.file.remote.SftpConsumer] - SftpFile[fileName=Consolidated, longName=dr-x------ 2 ftpadmin ftpadmin 0 Mar 12 05:26 Consolidated, dir=true] TRACE 2019-04-05T18:40:02,637 [org.apache.camel.component.file.remote.SftpConsumer] - Polling sub directory: 20181123/Consolidated from: sftp://XXXX:22051/20181123?connectTimeout=90000&disconnect=true&flatten=true&include=.*IMG&knownHostsFile=C%3A%5Cprogram+files%5Cascertain%5CI2R-MystiQ-Engine%5Cknown_hosts&noop=true&password=xxxxxx&preferredAuthentications=password&reconnectDelay=30000&recursive=true&scheduler=quartz2&scheduler.cron=0+0%2F5+*+*+*+%3F&separator=Auto&stepwise=false&username=XXXX_ftpuser TRACE 2019-04-05T18:40:02,637 [org.apache.camel.component.file.remote.SftpConsumer] - doPollDirectory from absolutePath: 20181123/Consolidated, dirName: Consolidated TRACE 2019-04-05T18:40:02,637 [org.apache.camel.component.file.remote.SftpConsumer] - Polling directory: 20181123/Consolidated TRACE 2019-04-05T18:40:02,637 [org.apache.camel.component.file.remote.SftpOperations] - listFiles(20181123/Consolidated) TRACE 2019-04-05T18:40:02,715 [org.apache.camel.component.file.remote.SftpConsumer] - Found 5 in directory: 20181123/Consolidated TRACE 2019-04-05T18:40:02,715 [org.apache.camel.component.file.remote.SftpConsumer] - SftpFile[fileName=., longName=dr-x------ 2 ftpadmin ftpadmin 0 Mar 12 05:26 ., dir=true] TRACE 2019-04-05T18:40:02,715 [org.apache.camel.component.file.remote.SftpConsumer] - File did not match. Will skip this file: RemoteFile[Consolidated/.] TRACE 2019-04-05T18:40:02,715 [org.apache.camel.component.file.remote.SftpConsumer] - SftpFile[fileName=.., longName=dr-x------ 2 ftpadmin ftpadmin 0 Mar 12 05:27 .., dir=true] TRACE 2019-04-05T18:40:02,715 [org.apache.camel.component.file.remote.SftpConsumer] - File did not match. Will skip this file: RemoteFile[Consolidated/..] TRACE 2019-04-05T18:40:02,715 [org.apache.camel.component.file.remote.SftpConsumer] - SftpFile[fileName=20181124020438943_021420181123INW.MYR, longName=-r-x------ 1 ftpadmin ftpadmin 408097 Nov 23 2018 20181124020438943_021420181123INW.MYR, dir=false] TRACE 2019-04-05T18:40:02,731 [org.apache.camel.component.file.remote.SftpConsumer] - File did not match. Will skip this file: RemoteFile[Consolidated/20181124020438943_021420181123INW.MYR] TRACE 2019-04-05T18:40:02,731 [org.apache.camel.component.file.remote.SftpConsumer] - SftpFile[fileName=20181124020439099_035820181123INW.MYR, longName=-r-x------ 1 ftpadmin ftpadmin 21689 Nov 23 2018 20181124020439099_035820181123INW.MYR, dir=false] TRACE 2019-04-05T18:40:02,731 [org.apache.camel.component.file.remote.SftpConsumer] - File did not match. Will skip this file: RemoteFile[Consolidated/20181124020439099_035820181123INW.MYR] TRACE 2019-04-05T18:40:02,731 [org.apache.camel.component.file.remote.SftpConsumer] - SftpFile[fileName=ToPPay, longName=dr-x------ 2 ftpadmin ftpadmin 0 Mar 12 06:41 ToPPay, dir=true] TRACE 2019-04-05T18:40:02,731 [org.apache.camel.component.file.remote.SftpConsumer] - Polling sub directory: 20181123/Consolidated/ToPPay from: sftp://XXXX:22051/20181123?connectTimeout=90000&disconnect=true&flatten=true&include=.*IMG&knownHostsFile=C%3A%5Cprogram+files%5Cascertain%5CI2R-MystiQ-Engine%5Cknown_hosts&noop=true&password=xxxxxx&preferredAuthentications=password&reconnectDelay=30000&recursive=true&scheduler=quartz2&scheduler.cron=0+0%2F5+*+*+*+%3F&separator=Auto&stepwise=false&username=XXXX_ftpuser TRACE 2019-04-05T18:40:02,731 [org.apache.camel.component.file.remote.SftpConsumer] - doPollDirectory from absolutePath: 20181123/Consolidated/ToPPay, dirName: ToPPay TRACE 2019-04-05T18:40:02,731 [org.apache.camel.component.file.remote.SftpConsumer] - Polling directory: 20181123/Consolidated/ToPPay TRACE 2019-04-05T18:40:02,731 [org.apache.camel.component.file.remote.SftpOperations] - listFiles(20181123/Consolidated/ToPPay) TRACE 2019-04-05T18:40:02,777 [org.apache.camel.component.file.remote.SftpConsumer] - Found 8 in directory: 20181123/Consolidated/ToPPay TRACE 2019-04-05T18:40:02,777 [org.apache.camel.component.file.remote.SftpConsumer] - SftpFile[fileName=., longName=dr-x------ 2 ftpadmin ftpadmin 0 Mar 12 06:41 ., dir=true] TRACE 2019-04-05T18:40:02,777 [org.apache.camel.component.file.remote.SftpConsumer] - File did not match. Will skip this file: RemoteFile[Consolidated/ToPPay/.] TRACE 2019-04-05T18:40:02,777 [org.apache.camel.component.file.remote.SftpConsumer] - SftpFile[fileName=.., longName=dr-x------ 2 ftpadmin ftpadmin 0 Mar 12 05:26 .., dir=true] TRACE 2019-04-05T18:40:02,777 [org.apache.camel.component.file.remote.SftpConsumer] - File did not match. Will skip this file: RemoteFile[Consolidated/ToPPay/..] TRACE 2019-04-05T18:40:02,793 [org.apache.camel.component.file.remote.SftpConsumer] - SftpFile[fileName=021420181123INW.MYR, longName=-r-x------ 1 ftpadmin ftpadmin 408097 Nov 23 2018 021420181123INW.MYR, dir=false] TRACE 2019-04-05T18:40:02,793 [org.apache.camel.component.file.remote.SftpConsumer] - File did not match. Will skip this file: RemoteFile[Consolidated/ToPPay/021420181123INW.MYR] TRACE 2019-04-05T18:40:02,793 [org.apache.camel.component.file.remote.SftpConsumer] - SftpFile[fileName=021420181123INW1.MYR, longName=-r-x------ 1 ftpadmin ftpadmin 579829 Nov 23 2018 021420181123INW1.MYR, dir=false] TRACE 2019-04-05T18:40:02,793 [org.apache.camel.component.file.remote.SftpConsumer] - File did not match. Will skip this file: RemoteFile[Consolidated/ToPPay/021420181123INW1.MYR] TRACE 2019-04-05T18:40:02,793 [org.apache.camel.component.file.remote.SftpConsumer] - SftpFile[fileName=035820181123INW.MYR, longName=-r-x------ 1 ftpadmin ftpadmin 21689 Nov 23 2018 035820181123INW.MYR, dir=false] TRACE 2019-04-05T18:40:02,793 [org.apache.camel.component.file.remote.SftpConsumer] - File did not match. Will skip this file: RemoteFile[Consolidated/ToPPay/035820181123INW.MYR] TRACE 2019-04-05T18:40:02,793 [org.apache.camel.component.file.remote.SftpConsumer] - SftpFile[fileName=035820181123INW1.MYR, longName=-r-x------ 1 ftpadmin ftpadmin 30954 Nov 23 2018 035820181123INW1.MYR, dir=false] TRACE 2019-04-05T18:40:02,793 [org.apache.camel.component.file.remote.SftpConsumer] - File did not match. Will skip this file: RemoteFile[Consolidated/ToPPay/035820181123INW1.MYR] TRACE 2019-04-05T18:40:02,809 [org.apache.camel.component.file.remote.SftpConsumer] - SftpFile[fileName=20181124020438943_021420181123INW.MYR, longName=-r-x------ 1 ftpadmin ftpadmin 408097 Nov 23 2018 20181124020438943_021420181123INW.MYR, dir=false] TRACE 2019-04-05T18:40:02,809 [org.apache.camel.component.file.remote.SftpConsumer] - File did not match. Will skip this file: RemoteFile[Consolidated/ToPPay/20181124020438943_021420181123INW.MYR] TRACE 2019-04-05T18:40:02,809 [org.apache.camel.component.file.remote.SftpConsumer] - SftpFile[fileName=20181124020439099_035820181123INW.MYR, longName=-r-x------ 1 ftpadmin ftpadmin 21689 Nov 23 2018 20181124020439099_035820181123INW.MYR, dir=false] TRACE 2019-04-05T18:40:02,809 [org.apache.camel.component.file.remote.SftpConsumer] - File did not match. Will skip this file: RemoteFile[Consolidated/ToPPay/20181124020439099_035820181123INW.MYR] TRACE 2019-04-05T18:40:02,809 [org.apache.camel.component.file.remote.SftpConsumer] - SftpFile[fileName=Data, longName=dr-x------ 2 ftpadmin ftpadmin 0 Mar 12 05:26 Data, dir=true] TRACE 2019-04-05T18:40:02,809 [org.apache.camel.component.file.remote.SftpConsumer] - Polling sub directory: 20181123/Data from: sftp://XXXX:22051/20181123?connectTimeout=90000&disconnect=true&flatten=true&include=.*IMG&knownHostsFile=C%3A%5Cprogram+files%5Cascertain%5CI2R-MystiQ-Engine%5Cknown_hosts&noop=true&password=xxxxxx&preferredAuthentications=password&reconnectDelay=30000&recursive=true&scheduler=quartz2&scheduler.cron=0+0%2F5+*+*+*+%3F&separator=Auto&stepwise=false&username=XXXX_ftpuser TRACE 2019-04-05T18:40:02,809 [org.apache.camel.component.file.remote.SftpConsumer] - doPollDirectory from absolutePath: 20181123/Data, dirName: Data TRACE 2019-04-05T18:40:02,809 [org.apache.camel.component.file.remote.SftpConsumer] - Polling directory: 20181123/Data TRACE 2019-04-05T18:40:02,809 [org.apache.camel.component.file.remote.SftpOperations] - listFiles(20181123/Data) TRACE 2019-04-05T18:40:02,871 [org.apache.camel.component.file.remote.SftpConsumer] - Found 501 in directory: 20181123/Data TRACE 2019-04-05T18:40:02,871 [org.apache.camel.component.file.remote.SftpConsumer] - SftpFile[fileName=., longName=dr-x------ 2 ftpadmin ftpadmin 0 Mar 12 05:26 ., dir=true] TRACE 2019-04-05T18:40:02,871 [org.apache.camel.component.file.remote.SftpConsumer] - File did not match. Will skip this file: RemoteFile[Data/.] TRACE 2019-04-05T18:40:02,871 [org.apache.camel.component.file.remote.SftpConsumer] - SftpFile[fileName=.., longName=dr-x------ 2 ftpadmin ftpadmin 0 Mar 12 05:27 .., dir=true] TRACE 2019-04-05T18:40:02,871 [org.apache.camel.component.file.remote.SftpConsumer] - File did not match. Will skip this file: RemoteFile[Data/..] TRACE 2019-04-05T18:40:02,871 [org.apache.camel.component.file.remote.SftpConsumer] - SftpFile[fileName=20181123021401015101004323IWNM.MMYR, longName=-r-x------ 1 ftpadmin ftpadmin 14846 Nov 23 2018 20181123021401015101004323IWNM.MMYR, dir=false] TRACE 2019-04-05T18:40:02,871 [org.apache.camel.component.file.remote.SftpConsumer] - File did not match. Will skip this file: RemoteFile[Data/20181123021401015101004323IWNM.MMYR] }}I am sure that the cause of the issue has to be the addition '/' prepending with directory name while listing {{listFor(/XXXX)}}. How can I avoid it ! .. using {{seperator}} parameter didn't effect i suppose it is only for producing files and not for consuming. I need to resolve this issue as soon as possible. Please suggest me some solution :(*EDITED :*I can reproduce the issue in latest version as well,I suppose the issue is when there is no base path only the '/' gets prepended which should not actually happenCode Snippet from SftpConsumer.java Camel 3.0.0.M1{{if (file.isDirectory()) \{ RemoteFile<SftpRemoteFile> remote = asRemoteFile(absolutePath, file, getEndpoint().getCharset()); if (endpoint.isRecursive() && depth < endpoint.getMaxDepth() && isValidFile(remote, true, files)) { // recursive scan and add the sub files and folders String subDirectory = file.getFilename(); String path = absolutePath + "/" + subDirectory; boolean canPollMore = pollSubDirectory(path, subDirectory, fileList, depth); if (!canPollMore) { return false; } } // we cannot use file.getAttrs().isLink on Windows, so we dont invoke the method // just assuming its a file we should poll } }}{quote}String path = absolutePath + "/" + subDirectory;{quote}
NullPointerException on opentracing example When running service1 from of the opentracing example an NullPointerException is logged to the standard out:{code}2019-04-05 10:33:54.620  INFO 23268 --- [           main] o.a.camel.spring.boot.RoutesCollector    : Starting CamelMainRunController to ensure the main thread keeps running[WARNING] java.lang.RuntimeException: java.lang.NullPointerException    at org.apache.camel.spring.boot.CamelSpringBootApplicationController.run (CamelSpringBootApplicationController.java:83)    at org.apache.camel.spring.boot.CamelMainRunController$DaemonTask.run (1m2Cam20melM1ainRunController.java:53)9    -04-05 10:33:54.622  INFO at5m23268 java.lang.Thread.run --- [           main] o.a.c.impl.DefaultStreamCachingStrategy  : StreamCaching in use with spool directory: /tmp/camel/camel-tmp-4e01e06f-baf2-4a4c-abce-89e2a14f7516 and rules: [Sp (Thread.java:748)ool > 128K body size]Caused by: java.lang.NullPointerException    at org.apache.camel.main.MainSupport.postProcessCamelContext (MainSupport.java:745)    at org.apache.camel.main.MainSupport.initCamelContext (MainSupport.java:676)    at org.apache.camel.main.Main.doStart (Main.java:107)    at org.apache.camel.support.service.ServiceSupport.start (ServiceSupport.java:86)    at org.apache.camel.main.MainSupport.run (MainSupport.java:203)    at org.apache.camel.spring.boot.CamelSpringBootApplicationController.run (CamelSpringBootApplicationController.java:78)    at org.apache.camel.spring.boot.CamelMainRunController$DaemonTask.run (CamelMainRunController.java:53)    at java.lang.Thread.run (Thread.java:748){code}Take a look at CAMEL-13386 on how to reproduce. Bug NullPointerException on opentracing example When running service1 from of the opentracing example an NullPointerException is logged to the standard out:{code}2019-04-05 10:33:54.620  INFO 23268 --- [           main] o.a.camel.spring.boot.RoutesCollector    : Starting CamelMainRunController to ensure the main thread keeps running[WARNING] java.lang.RuntimeException: java.lang.NullPointerException    at org.apache.camel.spring.boot.CamelSpringBootApplicationController.run (CamelSpringBootApplicationController.java:83)    at org.apache.camel.spring.boot.CamelMainRunController$DaemonTask.run (1m2Cam20melM1ainRunController.java:53)9    -04-05 10:33:54.622  INFO at5m23268 java.lang.Thread.run --- [           main] o.a.c.impl.DefaultStreamCachingStrategy  : StreamCaching in use with spool directory: /tmp/camel/camel-tmp-4e01e06f-baf2-4a4c-abce-89e2a14f7516 and rules: [Sp (Thread.java:748)ool > 128K body size]Caused by: java.lang.NullPointerException    at org.apache.camel.main.MainSupport.postProcessCamelContext (MainSupport.java:745)    at org.apache.camel.main.MainSupport.initCamelContext (MainSupport.java:676)    at org.apache.camel.main.Main.doStart (Main.java:107)    at org.apache.camel.support.service.ServiceSupport.start (ServiceSupport.java:86)    at org.apache.camel.main.MainSupport.run (MainSupport.java:203)    at org.apache.camel.spring.boot.CamelSpringBootApplicationController.run (CamelSpringBootApplicationController.java:78)    at org.apache.camel.spring.boot.CamelMainRunController$DaemonTask.run (CamelMainRunController.java:53)    at java.lang.Thread.run (Thread.java:748){code}Take a look at CAMEL-13386 on how to reproduce.
Wrong removing parameters logic in ServiceComponent. Component: camel-serviceMistake in class : org.apache.camel.component.service.ServiceComponent.java:83This error prevents the delegating component from receiving URI parameters.*Have:*{code:java}parameters.keySet().removeAll(parameters.keySet());{code}*Must be:*{code:java}parameters.keySet().removeAll(params.keySet());{code}  Bug Wrong removing parameters logic in ServiceComponent. Component: camel-serviceMistake in class : org.apache.camel.component.service.ServiceComponent.java:83This error prevents the delegating component from receiving URI parameters.*Have:*{code:java}parameters.keySet().removeAll(parameters.keySet());{code}*Must be:*{code:java}parameters.keySet().removeAll(params.keySet());{code} 
camel-twitter-direct-message doesn't filter by filterOld parameter DirectMessageConsumerHandler doesn't filter old messages when parameter filterOld=true Bug camel-twitter-direct-message doesn't filter by filterOld parameter DirectMessageConsumerHandler doesn't filter old messages when parameter filterOld=true
maven plugi validation fails with 3.0.0m1/m2 The camel plugin fails validation which passed fine in v2.latest.Also from the error-message it is not easy to understand what is really the problem?{noformat}INFO] [jenkins-event-spy] Generated /data/jenkins/workspace/c-jfr-server_feature_camel3-Y6VPXEFM3D7D7C2V3GQRGLFL7QLPEWEFUJY6V6RFK46FIDVYQ7SQ@tmp/withMavenca46cdd5/maven-spy-20190401-102256-4351026941413226375350.log[ERROR] Failed to execute goal org.apache.camel:camel-report-maven-plugin:3.0.0-M2:validate (default) on project jfr-srv-batch: Endpoint validation success: (1 = passed, 0 = invalid, 1 = incapable, 0 = unknown components, 0 = deprecated options)[ERROR] Simple validation error: (0 = passed, 1 = invalid)[ERROR] Duplicate route id validation success (0 = ids)[ERROR] Endpoint pair (seda/direct) validation success (0 = pairs)[ERROR] -> [Help 1]org.apache.maven.lifecycle.LifecycleExecutionException: Failed to execute goal org.apache.camel:camel-report-maven-plugin:3.0.0-M2:validate (default) on project jfr-srv-batch: Endpoint validation success: (1 = passed, 0 = invalid, 1 = incapable, 0 = unknown components, 0 = deprecated options)Simple validation error: (0 = passed, 1 = invalid)Duplicate route id validation success (0 = ids)Endpoint pair (seda/direct) validation success (0 = pairs)    at org.apache.maven.lifecycle.internal.MojoExecutor.execute (MojoExecutor.java:215)    at org.apache.maven.lifecycle.internal.MojoExecutor.execute (MojoExecutor.java:156)    at org.apache.maven.lifecycle.internal.MojoExecutor.execute (MojoExecutor.java:148)    at org.apache.maven.lifecycle.internal.LifecycleModuleBuilder.buildProject (LifecycleModuleBuilder.java:117)    at org.apache.maven.lifecycle.internal.builder.multithreaded.MultiThreadedBuilder$1.call (MultiThreadedBuilder.java:200)    at org.apache.maven.lifecycle.internal.builder.multithreaded.MultiThreadedBuilder$1.call (MultiThreadedBuilder.java:196)    at java.util.concurrent.FutureTask.run (FutureTask.java:264)    at java.util.concurrent.Executors$RunnableAdapter.call (Executors.java:515)    at java.util.concurrent.FutureTask.run (FutureTask.java:264)    at java.util.concurrent.ThreadPoolExecutor.runWorker (ThreadPoolExecutor.java:1128)    at java.util.concurrent.ThreadPoolExecutor$Worker.run (ThreadPoolExecutor.java:628)    at java.lang.Thread.run (Thread.java:835)Caused by: org.apache.maven.plugin.MojoExecutionException: Endpoint validation success: (1 = passed, 0 = invalid, 1 = incapable, 0 = unknown components, 0 = deprecated options)Simple validation error: (0 = passed, 1 = invalid)Duplicate route id validation success (0 = ids)Endpoint pair (seda/direct) validation success (0 = pairs)    at org.apache.camel.maven.ValidateMojo.execute (ValidateMojo.java:484)    at org.apache.maven.plugin.DefaultBuildPluginManager.executeMojo (DefaultBuildPluginManager.java:137)    at org.apache.maven.lifecycle.internal.MojoExecutor.execute (MojoExecutor.java:210)    at org.apache.maven.lifecycle.internal.MojoExecutor.execute (MojoExecutor.java:156)    at org.apache.maven.lifecycle.internal.MojoExecutor.execute (MojoExecutor.java:148)    at org.apache.maven.lifecycle.internal.LifecycleModuleBuilder.buildProject (LifecycleModuleBuilder.java:117)    at org.apache.maven.lifecycle.internal.builder.multithreaded.MultiThreadedBuilder$1.call (MultiThreadedBuilder.java:200)    at org.apache.maven.lifecycle.internal.builder.multithreaded.MultiThreadedBuilder$1.call (MultiThreadedBuilder.java:196)    at java.util.concurrent.FutureTask.run (FutureTask.java:264)    at java.util.concurrent.Executors$RunnableAdapter.call (Executors.java:515)    at java.util.concurrent.FutureTask.run (FutureTask.java:264)    at java.util.concurrent.ThreadPoolExecutor.runWorker (ThreadPoolExecutor.java:1128)    at java.util.concurrent.ThreadPoolExecutor$Worker.run (ThreadPoolExecutor.java:628)    at java.lang.Thread.run (Thread.java:835){noformat} Bug maven plugi validation fails with 3.0.0m1/m2 The camel plugin fails validation which passed fine in v2.latest.Also from the error-message it is not easy to understand what is really the problem?{noformat}INFO] [jenkins-event-spy] Generated /data/jenkins/workspace/c-jfr-server_feature_camel3-Y6VPXEFM3D7D7C2V3GQRGLFL7QLPEWEFUJY6V6RFK46FIDVYQ7SQ@tmp/withMavenca46cdd5/maven-spy-20190401-102256-4351026941413226375350.log[ERROR] Failed to execute goal org.apache.camel:camel-report-maven-plugin:3.0.0-M2:validate (default) on project jfr-srv-batch: Endpoint validation success: (1 = passed, 0 = invalid, 1 = incapable, 0 = unknown components, 0 = deprecated options)[ERROR] Simple validation error: (0 = passed, 1 = invalid)[ERROR] Duplicate route id validation success (0 = ids)[ERROR] Endpoint pair (seda/direct) validation success (0 = pairs)[ERROR] -> [Help 1]org.apache.maven.lifecycle.LifecycleExecutionException: Failed to execute goal org.apache.camel:camel-report-maven-plugin:3.0.0-M2:validate (default) on project jfr-srv-batch: Endpoint validation success: (1 = passed, 0 = invalid, 1 = incapable, 0 = unknown components, 0 = deprecated options)Simple validation error: (0 = passed, 1 = invalid)Duplicate route id validation success (0 = ids)Endpoint pair (seda/direct) validation success (0 = pairs)    at org.apache.maven.lifecycle.internal.MojoExecutor.execute (MojoExecutor.java:215)    at org.apache.maven.lifecycle.internal.MojoExecutor.execute (MojoExecutor.java:156)    at org.apache.maven.lifecycle.internal.MojoExecutor.execute (MojoExecutor.java:148)    at org.apache.maven.lifecycle.internal.LifecycleModuleBuilder.buildProject (LifecycleModuleBuilder.java:117)    at org.apache.maven.lifecycle.internal.builder.multithreaded.MultiThreadedBuilder$1.call (MultiThreadedBuilder.java:200)    at org.apache.maven.lifecycle.internal.builder.multithreaded.MultiThreadedBuilder$1.call (MultiThreadedBuilder.java:196)    at java.util.concurrent.FutureTask.run (FutureTask.java:264)    at java.util.concurrent.Executors$RunnableAdapter.call (Executors.java:515)    at java.util.concurrent.FutureTask.run (FutureTask.java:264)    at java.util.concurrent.ThreadPoolExecutor.runWorker (ThreadPoolExecutor.java:1128)    at java.util.concurrent.ThreadPoolExecutor$Worker.run (ThreadPoolExecutor.java:628)    at java.lang.Thread.run (Thread.java:835)Caused by: org.apache.maven.plugin.MojoExecutionException: Endpoint validation success: (1 = passed, 0 = invalid, 1 = incapable, 0 = unknown components, 0 = deprecated options)Simple validation error: (0 = passed, 1 = invalid)Duplicate route id validation success (0 = ids)Endpoint pair (seda/direct) validation success (0 = pairs)    at org.apache.camel.maven.ValidateMojo.execute (ValidateMojo.java:484)    at org.apache.maven.plugin.DefaultBuildPluginManager.executeMojo (DefaultBuildPluginManager.java:137)    at org.apache.maven.lifecycle.internal.MojoExecutor.execute (MojoExecutor.java:210)    at org.apache.maven.lifecycle.internal.MojoExecutor.execute (MojoExecutor.java:156)    at org.apache.maven.lifecycle.internal.MojoExecutor.execute (MojoExecutor.java:148)    at org.apache.maven.lifecycle.internal.LifecycleModuleBuilder.buildProject (LifecycleModuleBuilder.java:117)    at org.apache.maven.lifecycle.internal.builder.multithreaded.MultiThreadedBuilder$1.call (MultiThreadedBuilder.java:200)    at org.apache.maven.lifecycle.internal.builder.multithreaded.MultiThreadedBuilder$1.call (MultiThreadedBuilder.java:196)    at java.util.concurrent.FutureTask.run (FutureTask.java:264)    at java.util.concurrent.Executors$RunnableAdapter.call (Executors.java:515)    at java.util.concurrent.FutureTask.run (FutureTask.java:264)    at java.util.concurrent.ThreadPoolExecutor.runWorker (ThreadPoolExecutor.java:1128)    at java.util.concurrent.ThreadPoolExecutor$Worker.run (ThreadPoolExecutor.java:628)    at java.lang.Thread.run (Thread.java:835){noformat}
camel-stax - FileInputStream not closed The StAXProcessor.java class does not close the stream it opens.I had to modify it like this: public void process(Exchange exchange) throws Exception { InputSource is = exchange.getIn().getMandatoryBody(InputSource.class); XMLStreamReader stream = exchange.getIn().getMandatoryBody(XMLStreamReader.class); // Fermeture de la inputstream ici, car dans la version originale de la classe la stream reste ouverte. *try(InputStream inputStreamToClose = is.getByteStream()) {* XMLReader reader = new StaxStreamXMLReader(stream); ContentHandler handler; if (this.contentHandlerClass != null){ handler = (ContentHandler) this.contentHandlerClass.newInstance(); }else{ handler = this.contentHandler; }reader.setContentHandler(handler); reader.parse(is); if (ExchangeHelper.isOutCapable(exchange)){ exchange.getOut().setHeaders(exchange.getIn().getHeaders()); exchange.getOut().setBody(handler); }else{ exchange.getIn().setBody(handler); }} *finally**{ // Fermeture de la strem ValidatingStreamReader validatingStreamReader = (ValidatingStreamReader)stream; validatingStreamReader.closeCompletely(); }**}* Bug camel-stax - FileInputStream not closed The StAXProcessor.java class does not close the stream it opens.I had to modify it like this: public void process(Exchange exchange) throws Exception { InputSource is = exchange.getIn().getMandatoryBody(InputSource.class); XMLStreamReader stream = exchange.getIn().getMandatoryBody(XMLStreamReader.class); // Fermeture de la inputstream ici, car dans la version originale de la classe la stream reste ouverte. *try(InputStream inputStreamToClose = is.getByteStream()) {* XMLReader reader = new StaxStreamXMLReader(stream); ContentHandler handler; if (this.contentHandlerClass != null){ handler = (ContentHandler) this.contentHandlerClass.newInstance(); }else{ handler = this.contentHandler; }reader.setContentHandler(handler); reader.parse(is); if (ExchangeHelper.isOutCapable(exchange)){ exchange.getOut().setHeaders(exchange.getIn().getHeaders()); exchange.getOut().setBody(handler); }else{ exchange.getIn().setBody(handler); }} *finally**{ // Fermeture de la strem ValidatingStreamReader validatingStreamReader = (ValidatingStreamReader)stream; validatingStreamReader.closeCompletely(); }**}*
camel-jaxb - Error loading fallback type converter in Karaf To reproduce then unit test cia2 source code chapter10-camel-cxf-rest-karaf Bug camel-jaxb - Error loading fallback type converter in Karaf To reproduce then unit test cia2 source code chapter10-camel-cxf-rest-karaf
MLLP Endpoint 'maxConcurrentConsumers' configuration support If you provide 'maxConcurrentConsumers' query parameter on the endpoint URI, then, the route fails with error message _"There are 1 parameters that couldn't be set on the endpoint. Check the uriif the parameters are spelt correctly and that they are properties of the endpoint. Unknown parameters=[{maxConcurrentConsumers=xx}] "_As per docs, it should be supported as query parameter. Bug MLLP Endpoint 'maxConcurrentConsumers' configuration support If you provide 'maxConcurrentConsumers' query parameter on the endpoint URI, then, the route fails with error message _"There are 1 parameters that couldn't be set on the endpoint. Check the uriif the parameters are spelt correctly and that they are properties of the endpoint. Unknown parameters=[{maxConcurrentConsumers=xx}] "_As per docs, it should be supported as query parameter.
SEDA documentation does not track new bounded size value SEDA component has a bounded limit again thanks on work done for:"seda - Have a default queue size limit (CAMEL-12542)" the documentation here :https://cwiki.apache.org/confluence/display/CAMEL/SEDAdoes not reflect the change Bug SEDA documentation does not track new bounded size value SEDA component has a bounded limit again thanks on work done for:"seda - Have a default queue size limit (CAMEL-12542)" the documentation here :https://cwiki.apache.org/confluence/display/CAMEL/SEDAdoes not reflect the change
Sometimes SedaConsumer does not start and remains stuck Sometimes we notice that some of our routes get "stuck" and do not process anything.  Looking at the stacktrace for such a route we see something like this:{code:java}"Camel (SomeName) thread #648 - seda://someName" #1287 daemon prio=5 os_prio=0 tid=0x00007f23880cf000 nid=0x25006 waiting on condition [0x00007f1f23530000]   java.lang.Thread.State: WAITING (parking)        at sun.misc.Unsafe.park(Native Method)        - parking to wait for  <0x00000006e4beb8e0> (a java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject)        at java.util.concurrent.locks.LockSupport.park(LockSupport.java:175)        at java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject.await(AbstractQueuedSynchronizer.java:2039)        at java.util.concurrent.LinkedBlockingQueue.take(LinkedBlockingQueue.java:442)        at java.util.concurrent.ThreadPoolExecutor.getTask(ThreadPoolExecutor.java:1067)        at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1127)        at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617)        at java.lang.Thread.run(Thread.java:748){code}whereas we would instead normally expect to see something like this:{code:java}"Camel (SomeName) thread #840 - seda://someName" #1577 daemon prio=5 os_prio=0 tid=0x00007f227c02b000 nid=0x256fe waiting on condition [0x00007f1f0ca20000]   java.lang.Thread.State: TIMED_WAITING (parking)        at sun.misc.Unsafe.park(Native Method)        - parking to wait for  <0x00000006eb69c1f8> (a java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject)        at java.util.concurrent.locks.LockSupport.parkNanos(LockSupport.java:215)        at java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject.awaitNanos(AbstractQueuedSynchronizer.java:2078)        at java.util.concurrent.LinkedBlockingQueue.poll(LinkedBlockingQueue.java:467)        at org.apache.camel.component.seda.SedaConsumer.doRun(SedaConsumer.java:198)        at org.apache.camel.component.seda.SedaConsumer.run(SedaConsumer.java:154)        at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142)        at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617)        at java.lang.Thread.run(Thread.java:748){code}Note that whereas this latter example has SedaConsumer in the stacktrace polling for an exchange, the former example has no such SedaConsumer in the stacktrace and is stuck waiting for a new "task" to be given to the ThreadPoolExecutor.After adding debug logging, I see that the issue is as follows:The code in ServiceSupport here writes to the starting and started flags using one thread (call it Thread W):{code}    public void start() throws Exception {        if (isStarting() || isStarted()) {            // only start service if not already started            LOG.trace("Service already started");            return;        }        if (starting.compareAndSet(false, true)) {            LOG.trace("Starting service");            try {                doStart();                started.set(true);                starting.set(false);{code}and on a different thread (call it thread R) this code in ServiceSupport reads the starting and started flags:{code}    public boolean isRunAllowed() {        // if we have not yet initialized, then all options is false        boolean unused1 = !started.get() && !starting.get() && !stopping.get() && !stopped.get();        boolean unused2 = !suspending.get() && !suspended.get() && !shutdown.get() && !shuttingdown.get();        if (unused1 && unused2) {            return false;        }        return !isStoppingOrStopped();    }{code}So the order of events is:# Thread W: calls ServiceSupport.start()# Thread W: compareAndSet starting from false to true# Thread W: calls ServiceSupport.doStart() which eventually creates and starts Thread R# Thread R: calls SedaConsumer.doRun() which calls isRunAllowed()# Thread R: in isRunAllowed() reads started as false# Thread W: set started to true# Thread W: set starting to false# Thread R: in isRunAllowed() reads starting as false# Thread R: concludes that isRunAllowed is false# Thread R: the while loop in SedaConsumer.doRun is not executed and the thread will forever remain stuck waiting for a new "task" (on ThreadPoolExecutor.java:1067)One fix would be to swap reading of starting and started so that starting is read first, then started.Looking at the latest code in Camel 3.0.x, this code has been refactored to use a single "status" field instead of multiple different AtomicBoolean fields.  That should also fix this bug.  However, for completeness, I thought it best to log this bug anyway. Bug Sometimes SedaConsumer does not start and remains stuck Sometimes we notice that some of our routes get "stuck" and do not process anything.  Looking at the stacktrace for such a route we see something like this:{code:java}"Camel (SomeName) thread #648 - seda://someName" #1287 daemon prio=5 os_prio=0 tid=0x00007f23880cf000 nid=0x25006 waiting on condition [0x00007f1f23530000]   java.lang.Thread.State: WAITING (parking)        at sun.misc.Unsafe.park(Native Method)        - parking to wait for  <0x00000006e4beb8e0> (a java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject)        at java.util.concurrent.locks.LockSupport.park(LockSupport.java:175)        at java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject.await(AbstractQueuedSynchronizer.java:2039)        at java.util.concurrent.LinkedBlockingQueue.take(LinkedBlockingQueue.java:442)        at java.util.concurrent.ThreadPoolExecutor.getTask(ThreadPoolExecutor.java:1067)        at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1127)        at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617)        at java.lang.Thread.run(Thread.java:748){code}whereas we would instead normally expect to see something like this:{code:java}"Camel (SomeName) thread #840 - seda://someName" #1577 daemon prio=5 os_prio=0 tid=0x00007f227c02b000 nid=0x256fe waiting on condition [0x00007f1f0ca20000]   java.lang.Thread.State: TIMED_WAITING (parking)        at sun.misc.Unsafe.park(Native Method)        - parking to wait for  <0x00000006eb69c1f8> (a java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject)        at java.util.concurrent.locks.LockSupport.parkNanos(LockSupport.java:215)        at java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject.awaitNanos(AbstractQueuedSynchronizer.java:2078)        at java.util.concurrent.LinkedBlockingQueue.poll(LinkedBlockingQueue.java:467)        at org.apache.camel.component.seda.SedaConsumer.doRun(SedaConsumer.java:198)        at org.apache.camel.component.seda.SedaConsumer.run(SedaConsumer.java:154)        at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142)        at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617)        at java.lang.Thread.run(Thread.java:748){code}Note that whereas this latter example has SedaConsumer in the stacktrace polling for an exchange, the former example has no such SedaConsumer in the stacktrace and is stuck waiting for a new "task" to be given to the ThreadPoolExecutor.After adding debug logging, I see that the issue is as follows:The code in ServiceSupport here writes to the starting and started flags using one thread (call it Thread W):{code}    public void start() throws Exception {        if (isStarting() || isStarted()) {            // only start service if not already started            LOG.trace("Service already started");            return;        }        if (starting.compareAndSet(false, true)) {            LOG.trace("Starting service");            try {                doStart();                started.set(true);                starting.set(false);{code}and on a different thread (call it thread R) this code in ServiceSupport reads the starting and started flags:{code}    public boolean isRunAllowed() {        // if we have not yet initialized, then all options is false        boolean unused1 = !started.get() && !starting.get() && !stopping.get() && !stopped.get();        boolean unused2 = !suspending.get() && !suspended.get() && !shutdown.get() && !shuttingdown.get();        if (unused1 && unused2) {            return false;        }        return !isStoppingOrStopped();    }{code}So the order of events is:# Thread W: calls ServiceSupport.start()# Thread W: compareAndSet starting from false to true# Thread W: calls ServiceSupport.doStart() which eventually creates and starts Thread R# Thread R: calls SedaConsumer.doRun() which calls isRunAllowed()# Thread R: in isRunAllowed() reads started as false# Thread W: set started to true# Thread W: set starting to false# Thread R: in isRunAllowed() reads starting as false# Thread R: concludes that isRunAllowed is false# Thread R: the while loop in SedaConsumer.doRun is not executed and the thread will forever remain stuck waiting for a new "task" (on ThreadPoolExecutor.java:1067)One fix would be to swap reading of starting and started so that starting is read first, then started.Looking at the latest code in Camel 3.0.x, this code has been refactored to use a single "status" field instead of multiple different AtomicBoolean fields.  That should also fix this bug.  However, for completeness, I thought it best to log this bug anyway.
MLLP Component 'maxConcurrentConsumers' configuration is ignored If you set 'maxConcurrentConsumers' property in the MllpConfiguration object and assign that to MllpComponent, then, during creation of MllpEndpoint instance, that property is ignored and default value of 5 is used. Bug MLLP Component 'maxConcurrentConsumers' configuration is ignored If you set 'maxConcurrentConsumers' property in the MllpConfiguration object and assign that to MllpComponent, then, during creation of MllpEndpoint instance, that property is ignored and default value of 5 is used.
Partition revoke implemented to save offset state using KafkaConsumer.position API results in message loss Current implementation of org.apache.camel.component.kafka.KafkaConsumer.KafkaFetchRecords's onPartitionsRevoked, uses org.apache.kafka.clients.consumer.KafkaConsumer.position(partition). This approach causes message loss when multiple processes listening to same topic for point to point messaging (like a QUEUE) type implementation. Issue is noticed when partition gets assigned and then gets revoked in quick succession. Upon partition assignment, say at the beginning of processing offset is set to 0, and say there was no poll for this partition (may be due to earlier poll brought in bunch of records and they are still being processed). Subsequently, say partition got revoked, before polling.In this case, as onPartitionsRevoked looks at org.apache.kafka.clients.consumer.KafkaConsumer.position(partition) to save offset state and so 0 gets saved in this case in StateRepository implementation. When the same partition get assigned again, StateRepository.getState returns 0. Since Camel KafkaConsumer treats this as last processed offset, it adds 1 to it moving pointer to offset 1. Because of this, message at offset 0 never gets processed. Two fixes might be needed # a) onPartitionsRevoked should look at last processed offset (possibly store 'last processed offset' for each topic/partition in a memory map) and use it to save offset # b) Currently onPartitionsRevoked just saves offset state when an implementation of StateRepository configured. Ideally it should call KafkaFetchRecords.commitOffset so commitSync call goes through when partition revoked and no StateRepository implementation configured Bug Partition revoke implemented to save offset state using KafkaConsumer.position API results in message loss Current implementation of org.apache.camel.component.kafka.KafkaConsumer.KafkaFetchRecords's onPartitionsRevoked, uses org.apache.kafka.clients.consumer.KafkaConsumer.position(partition). This approach causes message loss when multiple processes listening to same topic for point to point messaging (like a QUEUE) type implementation. Issue is noticed when partition gets assigned and then gets revoked in quick succession. Upon partition assignment, say at the beginning of processing offset is set to 0, and say there was no poll for this partition (may be due to earlier poll brought in bunch of records and they are still being processed). Subsequently, say partition got revoked, before polling.In this case, as onPartitionsRevoked looks at org.apache.kafka.clients.consumer.KafkaConsumer.position(partition) to save offset state and so 0 gets saved in this case in StateRepository implementation. When the same partition get assigned again, StateRepository.getState returns 0. Since Camel KafkaConsumer treats this as last processed offset, it adds 1 to it moving pointer to offset 1. Because of this, message at offset 0 never gets processed. Two fixes might be needed # a) onPartitionsRevoked should look at last processed offset (possibly store 'last processed offset' for each topic/partition in a memory map) and use it to save offset # b) Currently onPartitionsRevoked just saves offset state when an implementation of StateRepository configured. Ideally it should call KafkaFetchRecords.commitOffset so commitSync call goes through when partition revoked and no StateRepository implementation configured
ConsumerRebalanceListener is not registered when topicIsPattern is turned off. Causing message loss or too many duplicates Not registering ConsumerRebalanceListener when topicIsPattern turned off, causes either too many duplicate messages getting delivered to message processing layer or causes message loss depending on autoOffsetReset flag value. Issue is noticed with below test scenarioTopic: e.g. TestMessageNumber of partitions: 25 (this is not completely relevant to issue)ConsumerUri: kafka:<kafka-broker-uris>?topic=TestMessage&groupId=TestMessage_GROUP&consumersCount=5&autoCommitEnable=false&offsetRepository=#<DB-state-repository>Number processes running consumers: 2 or more; e.g. two instances of Docker containers listening from same topic each with 5 consumer threads Please note that offset management is done in DB with an implementation of Camel's StateRepository interface to eliminate too duplicate messages arriving at the message processor (at most one message processing needed for my use case) When a second process instance (say second container) brought up, since ConsumerRebalanceListener is not registered, partitions start processing at earliest offsets if autoOffsetReset is set to earliest as expected. In this case, too many duplicate messages arrive at the message processing layer. If autoOffsetReset is set to latest, message loss occurs for certain partitions. If autoOffsetReset is set to none, no valid offset exception thrown by broker Issue would be noticed consistently when simulating slow message processing for the above test scenario   Bug ConsumerRebalanceListener is not registered when topicIsPattern is turned off. Causing message loss or too many duplicates Not registering ConsumerRebalanceListener when topicIsPattern turned off, causes either too many duplicate messages getting delivered to message processing layer or causes message loss depending on autoOffsetReset flag value. Issue is noticed with below test scenarioTopic: e.g. TestMessageNumber of partitions: 25 (this is not completely relevant to issue)ConsumerUri: kafka:<kafka-broker-uris>?topic=TestMessage&groupId=TestMessage_GROUP&consumersCount=5&autoCommitEnable=false&offsetRepository=#<DB-state-repository>Number processes running consumers: 2 or more; e.g. two instances of Docker containers listening from same topic each with 5 consumer threads Please note that offset management is done in DB with an implementation of Camel's StateRepository interface to eliminate too duplicate messages arriving at the message processor (at most one message processing needed for my use case) When a second process instance (say second container) brought up, since ConsumerRebalanceListener is not registered, partitions start processing at earliest offsets if autoOffsetReset is set to earliest as expected. In this case, too many duplicate messages arrive at the message processing layer. If autoOffsetReset is set to latest, message loss occurs for certain partitions. If autoOffsetReset is set to none, no valid offset exception thrown by broker Issue would be noticed consistently when simulating slow message processing for the above test scenario  
Camel with OSGi blueprint on Karaf should detect JMX 10:31:00.277 INFO [Blueprint Event Dispatcher: 1] Attempting to start CamelContext: camel-110:31:00.279 INFO [Blueprint Event Dispatcher: 1] Apache Camel 3.0.0-SNAPSHOT (CamelContext: camel-1) is starting10:31:00.281 INFO [Blueprint Event Dispatcher: 1] JMX is disabled Bug Camel with OSGi blueprint on Karaf should detect JMX 10:31:00.277 INFO [Blueprint Event Dispatcher: 1] Attempting to start CamelContext: camel-110:31:00.279 INFO [Blueprint Event Dispatcher: 1] Apache Camel 3.0.0-SNAPSHOT (CamelContext: camel-1) is starting10:31:00.281 INFO [Blueprint Event Dispatcher: 1] JMX is disabled
Dump JMX stats for null timestamps should not use 1970-1-1 as date Noticed thislastExchangeFailureTimestamp="1970-01-01T00:59:59.999+0100"  Bug Dump JMX stats for null timestamps should not use 1970-1-1 as date Noticed thislastExchangeFailureTimestamp="1970-01-01T00:59:59.999+0100" 
File producer - Issue with toD when using moveExisting See SOhttps://stackoverflow.com/questions/54890566/camel-file-component-create-a-file-and-if-already-exist-move-it-and-renamed-i/54910417#54910417And for the solution/workaround to use to instead of toD Bug File producer - Issue with toD when using moveExisting See SOhttps://stackoverflow.com/questions/54890566/camel-file-component-create-a-file-and-if-already-exist-move-it-and-renamed-i/54910417#54910417And for the solution/workaround to use to instead of toD
camel-rabbitmq - x-death header gets lost because of incorrect header value validation In `RabbitMQMessageConverter.java`, some kind of header value validation is done:{code:java}    private Object getValidRabbitMQHeaderValue(Object headerValue) {        if (headerValue instanceof String) {            return headerValue;        } else if (headerValue instanceof Number) {            return headerValue;        } else if (headerValue instanceof Boolean) {            return headerValue;        } else if (headerValue instanceof Date) {            return headerValue;        } else if (headerValue instanceof byte[]) {            return headerValue;        } else if (headerValue instanceof LongString) {            return headerValue;        }        return null;    }{code}While this is correct for the listed typed, this is incomplete. An example of this is the `x-death` header, as explained on https://www.rabbitmq.com/dlx.html#effects. This header is basically a `List<Map<String,Object>>`.If a message with such header is consumed and then propagated to another queue, the header will be lost. An example use case is consuming a dead-letter queue and propagating the messages to another queue, possible after some delay, until the `count` field in the `x-death` header reached a certain threshold.I am happy to provide a self-contained example if this would be helpful. Bug camel-rabbitmq - x-death header gets lost because of incorrect header value validation In `RabbitMQMessageConverter.java`, some kind of header value validation is done:{code:java}    private Object getValidRabbitMQHeaderValue(Object headerValue) {        if (headerValue instanceof String) {            return headerValue;        } else if (headerValue instanceof Number) {            return headerValue;        } else if (headerValue instanceof Boolean) {            return headerValue;        } else if (headerValue instanceof Date) {            return headerValue;        } else if (headerValue instanceof byte[]) {            return headerValue;        } else if (headerValue instanceof LongString) {            return headerValue;        }        return null;    }{code}While this is correct for the listed typed, this is incomplete. An example of this is the `x-death` header, as explained on https://www.rabbitmq.com/dlx.html#effects. This header is basically a `List<Map<String,Object>>`.If a message with such header is consumed and then propagated to another queue, the header will be lost. An example use case is consuming a dead-letter queue and propagating the messages to another queue, possible after some delay, until the `count` field in the `x-death` header reached a certain threshold.I am happy to provide a self-contained example if this would be helpful.
Camel stops consuming queue after restart of RabbitMQ broker I am consuming a RabbitMQ queue as following: {code:java}from("rabbitmq://localhost:5672?username=test&password=test&declare=false&queue=q&autoAck=false&threadPoolSize=1&exclusiveConsumer=true")   .to("log:receive");{code} When I restart the RabbitMQ broker, no messages are longer received in the log handler. According the management interface, all pending messages are in UNACKED state. This means that they are transmitted to the consumer, but not acknowledged. In other words, Camel was able to restore the connection after the restart, but fails to deliver to the log handler and acknowledge them afterwards. I did not test this, but I believe the consumer will eventually crash due to OOM. +*example*+ Please find a self-contained example on [https://github.com/pbillen/playground-camel-13267|https://github.com/pbillen/playground-camel-13267].You need a (local) Docker daemon to run this. Use it as following:  # Start with `mvn clean install -U`. # You notice in the logging that every 500ms, a message is sent and received. You can also log into the administrator interface on [http://localhost:15672|http://localhost:15672/] with login/password `test`. You will see the message pass through every 500ms. Great! # Now restart the RabbitMQ broker. Typically, find the container identifier with `docker ps` and then execute `docker restart <identifier>`. # After restart, you notice that every 500ms a message is sent, but not received. You can also log into the administrator interface and see that all messages are into the UNACKED state. Bug Camel stops consuming queue after restart of RabbitMQ broker I am consuming a RabbitMQ queue as following: {code:java}from("rabbitmq://localhost:5672?username=test&password=test&declare=false&queue=q&autoAck=false&threadPoolSize=1&exclusiveConsumer=true")   .to("log:receive");{code} When I restart the RabbitMQ broker, no messages are longer received in the log handler. According the management interface, all pending messages are in UNACKED state. This means that they are transmitted to the consumer, but not acknowledged. In other words, Camel was able to restore the connection after the restart, but fails to deliver to the log handler and acknowledge them afterwards. I did not test this, but I believe the consumer will eventually crash due to OOM. +*example*+ Please find a self-contained example on [https://github.com/pbillen/playground-camel-13267|https://github.com/pbillen/playground-camel-13267].You need a (local) Docker daemon to run this. Use it as following:  # Start with `mvn clean install -U`. # You notice in the logging that every 500ms, a message is sent and received. You can also log into the administrator interface on [http://localhost:15672|http://localhost:15672/] with login/password `test`. You will see the message pass through every 500ms. Great! # Now restart the RabbitMQ broker. Typically, find the container identifier with `docker ps` and then execute `docker restart <identifier>`. # After restart, you notice that every 500ms a message is sent, but not received. You can also log into the administrator interface and see that all messages are into the UNACKED state.
camel-rabbitmq - Using the  "new URl syntax" doesn't seem to work correctly When using the deprecated URL format{noformat}rabbitmq://hostname[:port]/exchange?[options]{noformat}(also still on the main page) the camel route works as expected.  However, when listening to the warning and using the "new syntax" (only defined in the repo):{noformat}rabbitmq:exchange?[options]{noformat}it does NOT work, and will fail to connect to rabbitmq at all, giving address errorsI have tried setting the hostname option (doesn't work, the component seems to ignore it), and tried setting springboot component parameters (doesn't seem to work, but I don't know of a way to test if they are even accessible.I can supply loglines on demand if needed.Also, in case it matters, in this case the hostname is an IP address. Bug camel-rabbitmq - Using the  "new URl syntax" doesn't seem to work correctly When using the deprecated URL format{noformat}rabbitmq://hostname[:port]/exchange?[options]{noformat}(also still on the main page) the camel route works as expected.  However, when listening to the warning and using the "new syntax" (only defined in the repo):{noformat}rabbitmq:exchange?[options]{noformat}it does NOT work, and will fail to connect to rabbitmq at all, giving address errorsI have tried setting the hostname option (doesn't work, the component seems to ignore it), and tried setting springboot component parameters (doesn't seem to work, but I don't know of a way to test if they are even accessible.I can supply loglines on demand if needed.Also, in case it matters, in this case the hostname is an IP address.
mock endpoint - Small glitch in logging excepted failure We dolog.info("Caught expected failure: {}", e);You cannot do {} with an exception. Bug mock endpoint - Small glitch in logging excepted failure We dolog.info("Caught expected failure: {}", e);You cannot do {} with an exception.
camel yammer component is accessing non-existent page When using camel-yammer component to receive relationships the component is (most likely) trying to access [non-existent page|https://www.yammer.com/api/v1/] and results in returning null. Bug camel yammer component is accessing non-existent page When using camel-yammer component to receive relationships the component is (most likely) trying to access [non-existent page|https://www.yammer.com/api/v1/] and results in returning null.
camel-restdsl-swagger xml generation can't find required method allowableValues(String) Reported on SOhttps://stackoverflow.com/questions/54405868/camel-restdsl-swagger-xml-generation-cant-find-required-method-allowablevalues?noredirect=1#comment95906957_54405868Look at the provided sample project on github and see if we can reproduce the issue and find out whats the issue is Bug camel-restdsl-swagger xml generation can't find required method allowableValues(String) Reported on SOhttps://stackoverflow.com/questions/54405868/camel-restdsl-swagger-xml-generation-cant-find-required-method-allowablevalues?noredirect=1#comment95906957_54405868Look at the provided sample project on github and see if we can reproduce the issue and find out whats the issue is
camel-example-spring-boot-master running error When running the spring-boot-master, as we use the spring-boot-web-starter by default,  I get the port is ready bound error when I start another instance.As the example doesn't use the web server anymore, the fix could we just remove the spring-boot-web-starter.  Bug camel-example-spring-boot-master running error When running the spring-boot-master, as we use the spring-boot-web-starter by default,  I get the port is ready bound error when I start another instance.As the example doesn't use the web server anymore, the fix could we just remove the spring-boot-web-starter. 
camel-kafka - consumer does not respect auto.commit.interval.ms with AutoCommitEnabled=true This is probably a side effect of CAMEL-12454: when auto commit enabled is enabled kafka consumer commits offsets as soon as an exchange is complete with no regard to the auto.commit.interval.ms setting, which may cause additional non-balanced load on the kafka cluster (see attached screenshot depicting kafka brokers cpu load right after upgrade from 2.20.3 to 2.23.0).Here is an example with debugging turned on for org.apache.camel.component.kafka.KafkaConsumer, as you can see Kafka consumer commits every 10-500 ms instead of once per 5 seconds:{code:java}2019-01-28 10:46:55.025  INFO 3324 --- [ontext_Worker-3] o.a.k.clients.consumer.ConsumerConfig    : ConsumerConfig values: 	auto.commit.interval.ms = 5000	auto.offset.reset = latest	bootstrap.servers = [192.168.56.10:9093]	check.crcs = true	client.id = 	connections.max.idle.ms = 540000	enable.auto.commit = true	exclude.internal.topics = true	fetch.max.bytes = 52428800	fetch.max.wait.ms = 500	fetch.min.bytes = 1	group.id = service_new	heartbeat.interval.ms = 3000	interceptor.classes = null	internal.leave.group.on.close = true	isolation.level = read_uncommitted	key.deserializer = class org.apache.kafka.common.serialization.StringDeserializer	max.partition.fetch.bytes = 1048576	max.poll.interval.ms = 300000	max.poll.records = 1000	metadata.max.age.ms = 300000	metric.reporters = []	metrics.num.samples = 2	metrics.recording.level = INFO	metrics.sample.window.ms = 30000	partition.assignment.strategy = [org.apache.kafka.clients.consumer.RangeAssignor]	receive.buffer.bytes = 65536	reconnect.backoff.max.ms = 1000	reconnect.backoff.ms = 50	request.timeout.ms = 40000	retry.backoff.ms = 100	sasl.jaas.config = null	sasl.kerberos.kinit.cmd = /usr/bin/kinit	sasl.kerberos.min.time.before.relogin = 60000	sasl.kerberos.service.name = null	sasl.kerberos.ticket.renew.jitter = 0.05	sasl.kerberos.ticket.renew.window.factor = 0.8	sasl.mechanism = GSSAPI	security.protocol = SSL	send.buffer.bytes = 131072	session.timeout.ms = 30000	ssl.cipher.suites = null	ssl.enabled.protocols = [TLSv1.2]	ssl.endpoint.identification.algorithm = null	ssl.key.password = null	ssl.keymanager.algorithm = SunX509	ssl.keystore.location = /usr/files/server.jks	ssl.keystore.password = [hidden]	ssl.keystore.type = JCEKS	ssl.protocol = TLS	ssl.provider = null	ssl.secure.random.implementation = null	ssl.trustmanager.algorithm = PKIX	ssl.truststore.location = /usr/files/truststore.jks	ssl.truststore.password = [hidden]	ssl.truststore.type = JCEKS	value.deserializer = class org.apache.kafka.common.serialization.StringDeserializer2019-01-28 10:46:55.160  INFO 3324 --- [ontext_Worker-3] o.a.kafka.common.utils.AppInfoParser     : Kafka version : 1.0.22019-01-28 10:46:55.160  INFO 3324 --- [ontext_Worker-3] o.a.kafka.common.utils.AppInfoParser     : Kafka commitId : 2a121f7b1d4028252019-01-28 10:46:55.160  INFO 3324 --- [ontext_Worker-3] o.a.camel.spring.SpringCamelContext      : Route: route1 started and consuming from: kafka:topic1,topic2,topic3?brokers=192.168.56.10:90932019-01-28 10:46:55.161  INFO 3324 --- [uponassignment]] o.a.camel.component.kafka.KafkaConsumer  : Subscribing topic1,topic2,topic3-Thread 0 to topic topic1,topic2,topic32019-01-28 10:46:55.161  INFO 3324 --- [uponassignment]] o.a.camel.component.kafka.KafkaConsumer  : Subscribing topic1,topic2,topic3-Thread 0 to topic topic1,topic2,topic32019-01-28 10:46:55.313  INFO 3324 --- [uponassignment]] o.a.k.c.c.internals.AbstractCoordinator  : [Consumer clientId=consumer-1, groupId=service_new] Discovered group coordinator 192.168.56.10:9093 (id: 2147483646 rack: null)2019-01-28 10:46:55.315  INFO 3324 --- [uponassignment]] o.a.k.c.c.internals.ConsumerCoordinator  : [Consumer clientId=consumer-1, groupId=service_new] Revoking previously assigned partitions []2019-01-28 10:46:55.316  INFO 3324 --- [uponassignment]] o.a.k.c.c.internals.AbstractCoordinator  : [Consumer clientId=consumer-1, groupId=service_new] (Re-)joining group2019-01-28 10:46:58.469  INFO 3324 --- [uponassignment]] o.a.k.c.c.internals.AbstractCoordinator  : [Consumer clientId=consumer-1, groupId=service_new] Successfully joined group with generation 32019-01-28 10:46:58.470  INFO 3324 --- [uponassignment]] o.a.k.c.c.internals.ConsumerCoordinator  : [Consumer clientId=consumer-1, groupId=service_new] Setting newly assigned partitions [topic3-1, topic3-0, topic2-1, topic1-0, topic2-0, topic1-1]2019-01-28 10:47:24.953 DEBUG 3324 --- [uponassignment]] o.a.camel.component.kafka.KafkaConsumer  : Auto commitSync topic1,topic2,topic3-Thread 0 from topic topic1,topic2,topic3 with offset: 32212019-01-28 10:47:24.953 DEBUG 3324 --- [uponassignment]] o.a.camel.component.kafka.KafkaConsumer  : Auto commitSync topic1,topic2,topic3-Thread 0 from topic topic1,topic2,topic3 with offset: 32212019-01-28 10:47:24.957 DEBUG 3324 --- [uponassignment]] o.a.camel.component.kafka.KafkaConsumer  : Auto commitSync topic1,topic2,topic3-Thread 0 from topic topic1,topic2,topic3 with offset: 32222019-01-28 10:47:24.957 DEBUG 3324 --- [uponassignment]] o.a.camel.component.kafka.KafkaConsumer  : Auto commitSync topic1,topic2,topic3-Thread 0 from topic topic1,topic2,topic3 with offset: 32222019-01-28 10:47:24.964 DEBUG 3324 --- [uponassignment]] o.a.camel.component.kafka.KafkaConsumer  : Auto commitSync topic1,topic2,topic3-Thread 0 from topic topic1,topic2,topic3 with offset: 33252019-01-28 10:47:24.964 DEBUG 3324 --- [uponassignment]] o.a.camel.component.kafka.KafkaConsumer  : Auto commitSync topic1,topic2,topic3-Thread 0 from topic topic1,topic2,topic3 with offset: 33252019-01-28 10:47:25.005 DEBUG 3324 --- [uponassignment]] o.a.camel.component.kafka.KafkaConsumer  : Auto commitSync topic1,topic2,topic3-Thread 0 from topic topic1,topic2,topic3 with offset: 32232019-01-28 10:47:25.005 DEBUG 3324 --- [uponassignment]] o.a.camel.component.kafka.KafkaConsumer  : Auto commitSync topic1,topic2,topic3-Thread 0 from topic topic1,topic2,topic3 with offset: 32232019-01-28 10:47:25.515 DEBUG 3324 --- [uponassignment]] o.a.camel.component.kafka.KafkaConsumer  : Auto commitSync topic1,topic2,topic3-Thread 0 from topic topic1,topic2,topic3 with offset: 33262019-01-28 10:47:25.515 DEBUG 3324 --- [uponassignment]] o.a.camel.component.kafka.KafkaConsumer  : Auto commitSync topic1,topic2,topic3-Thread 0 from topic topic1,topic2,topic3 with offset: 33262019-01-28 10:47:26.005 DEBUG 3324 --- [uponassignment]] o.a.camel.component.kafka.KafkaConsumer  : Auto commitSync topic1,topic2,topic3-Thread 0 from topic topic1,topic2,topic3 with offset: 32242019-01-28 10:47:26.005 DEBUG 3324 --- [uponassignment]] o.a.camel.component.kafka.KafkaConsumer  : Auto commitSync topic1,topic2,topic3-Thread 0 from topic topic1,topic2,topic3 with offset: 32242019-01-28 10:47:26.528 DEBUG 3324 --- [uponassignment]] o.a.camel.component.kafka.KafkaConsumer  : Auto commitSync topic1,topic2,topic3-Thread 0 from topic topic1,topic2,topic3 with offset: 33272019-01-28 10:47:26.528 DEBUG 3324 --- [uponassignment]] o.a.camel.component.kafka.KafkaConsumer  : Auto commitSync topic1,topic2,topic3-Thread 0 from topic topic1,topic2,topic3 with offset: 33272019-01-28 10:47:27.014 DEBUG 3324 --- [uponassignment]] o.a.camel.component.kafka.KafkaConsumer  : Auto commitSync topic1,topic2,topic3-Thread 0 from topic topic1,topic2,topic3 with offset: 32252019-01-28 10:47:27.014 DEBUG 3324 --- [uponassignment]] o.a.camel.component.kafka.KafkaConsumer  : Auto commitSync topic1,topic2,topic3-Thread 0 from topic topic1,topic2,topic3 with offset: 32252019-01-28 10:47:27.512 DEBUG 3324 --- [uponassignment]] o.a.camel.component.kafka.KafkaConsumer  : Auto commitSync topic1,topic2,topic3-Thread 0 from topic topic1,topic2,topic3 with offset: 33282019-01-28 10:47:27.512 DEBUG 3324 --- [uponassignment]] o.a.camel.component.kafka.KafkaConsumer  : Auto commitSync topic1,topic2,topic3-Thread 0 from topic topic1,topic2,topic3 with offset: 33282019-01-28 10:47:28.001 DEBUG 3324 --- [uponassignment]] o.a.camel.component.kafka.KafkaConsumer  : Auto commitSync topic1,topic2,topic3-Thread 0 from topic topic1,topic2,topic3 with offset: 32262019-01-28 10:47:28.001 DEBUG 3324 --- [uponassignment]] o.a.camel.component.kafka.KafkaConsumer  : Auto commitSync topic1,topic2,topic3-Thread 0 from topic topic1,topic2,topic3 with offset: 32262019-01-28 10:47:28.497 DEBUG 3324 --- [uponassignment]] o.a.camel.component.kafka.KafkaConsumer  : Auto commitSync topic1,topic2,topic3-Thread 0 from topic topic1,topic2,topic3 with offset: 33292019-01-28 10:47:28.497 DEBUG 3324 --- [uponassignment]] o.a.camel.component.kafka.KafkaConsumer  : Auto commitSync topic1,topic2,topic3-Thread 0 from topic topic1,topic2,topic3 with offset: 33292019-01-28 10:47:29.024 DEBUG 3324 --- [uponassignment]] o.a.camel.component.kafka.KafkaConsumer  : Auto commitSync topic1,topic2,topic3-Thread 0 from topic topic1,topic2,topic3 with offset: 33302019-01-28 10:47:29.024 DEBUG 3324 --- [uponassignment]] o.a.camel.component.kafka.KafkaConsumer  : Auto commitSync topic1,topic2,topic3-Thread 0 from topic topic1,topic2,topic3 with offset: 33302019-01-28 10:47:29.521 DEBUG 3324 --- [uponassignment]] o.a.camel.component.kafka.KafkaConsumer  : Auto commitSync topic1,topic2,topic3-Thread 0 from topic topic1,topic2,topic3 with offset: 32272019-01-28 10:47:29.521 DEBUG 3324 --- [uponassignment]] o.a.camel.component.kafka.KafkaConsumer  : Auto commitSync topic1,topic2,topic3-Thread 0 from topic topic1,topic2,topic3 with offset: 32272019-01-28 10:47:30.012 DEBUG 3324 --- [uponassignment]] o.a.camel.component.kafka.KafkaConsumer  : Auto commitSync topic1,topic2,topic3-Thread 0 from topic topic1,topic2,topic3 with offset: 32282019-01-28 10:47:30.012 DEBUG 3324 --- [uponassignment]] o.a.camel.component.kafka.KafkaConsumer  : Auto commitSync topic1,topic2,topic3-Thread 0 from topic topic1,topic2,topic3 with offset: 3228{code}When downgraded to camel-kafka 2.20.3 commits are done correctly (once every auto.commit.interval.ms) and there are no messages from o.a.camel.component.kafka.KafkaConsumer in the debug log.Running with debugger showed that this code actually never gets executed in 2.20.3: https://github.com/apache/camel/blob/2.20.x/components/camel-kafka/src/main/java/org/apache/camel/component/kafka/KafkaConsumer.java#L382 and we seem to rely on the auto-commit feature of the Kafka client itself, not the camel-kafka wrapper. Bug camel-kafka - consumer does not respect auto.commit.interval.ms with AutoCommitEnabled=true This is probably a side effect of CAMEL-12454: when auto commit enabled is enabled kafka consumer commits offsets as soon as an exchange is complete with no regard to the auto.commit.interval.ms setting, which may cause additional non-balanced load on the kafka cluster (see attached screenshot depicting kafka brokers cpu load right after upgrade from 2.20.3 to 2.23.0).Here is an example with debugging turned on for org.apache.camel.component.kafka.KafkaConsumer, as you can see Kafka consumer commits every 10-500 ms instead of once per 5 seconds:{code:java}2019-01-28 10:46:55.025  INFO 3324 --- [ontext_Worker-3] o.a.k.clients.consumer.ConsumerConfig    : ConsumerConfig values: 	auto.commit.interval.ms = 5000	auto.offset.reset = latest	bootstrap.servers = [192.168.56.10:9093]	check.crcs = true	client.id = 	connections.max.idle.ms = 540000	enable.auto.commit = true	exclude.internal.topics = true	fetch.max.bytes = 52428800	fetch.max.wait.ms = 500	fetch.min.bytes = 1	group.id = service_new	heartbeat.interval.ms = 3000	interceptor.classes = null	internal.leave.group.on.close = true	isolation.level = read_uncommitted	key.deserializer = class org.apache.kafka.common.serialization.StringDeserializer	max.partition.fetch.bytes = 1048576	max.poll.interval.ms = 300000	max.poll.records = 1000	metadata.max.age.ms = 300000	metric.reporters = []	metrics.num.samples = 2	metrics.recording.level = INFO	metrics.sample.window.ms = 30000	partition.assignment.strategy = [org.apache.kafka.clients.consumer.RangeAssignor]	receive.buffer.bytes = 65536	reconnect.backoff.max.ms = 1000	reconnect.backoff.ms = 50	request.timeout.ms = 40000	retry.backoff.ms = 100	sasl.jaas.config = null	sasl.kerberos.kinit.cmd = /usr/bin/kinit	sasl.kerberos.min.time.before.relogin = 60000	sasl.kerberos.service.name = null	sasl.kerberos.ticket.renew.jitter = 0.05	sasl.kerberos.ticket.renew.window.factor = 0.8	sasl.mechanism = GSSAPI	security.protocol = SSL	send.buffer.bytes = 131072	session.timeout.ms = 30000	ssl.cipher.suites = null	ssl.enabled.protocols = [TLSv1.2]	ssl.endpoint.identification.algorithm = null	ssl.key.password = null	ssl.keymanager.algorithm = SunX509	ssl.keystore.location = /usr/files/server.jks	ssl.keystore.password = [hidden]	ssl.keystore.type = JCEKS	ssl.protocol = TLS	ssl.provider = null	ssl.secure.random.implementation = null	ssl.trustmanager.algorithm = PKIX	ssl.truststore.location = /usr/files/truststore.jks	ssl.truststore.password = [hidden]	ssl.truststore.type = JCEKS	value.deserializer = class org.apache.kafka.common.serialization.StringDeserializer2019-01-28 10:46:55.160  INFO 3324 --- [ontext_Worker-3] o.a.kafka.common.utils.AppInfoParser     : Kafka version : 1.0.22019-01-28 10:46:55.160  INFO 3324 --- [ontext_Worker-3] o.a.kafka.common.utils.AppInfoParser     : Kafka commitId : 2a121f7b1d4028252019-01-28 10:46:55.160  INFO 3324 --- [ontext_Worker-3] o.a.camel.spring.SpringCamelContext      : Route: route1 started and consuming from: kafka:topic1,topic2,topic3?brokers=192.168.56.10:90932019-01-28 10:46:55.161  INFO 3324 --- [uponassignment]] o.a.camel.component.kafka.KafkaConsumer  : Subscribing topic1,topic2,topic3-Thread 0 to topic topic1,topic2,topic32019-01-28 10:46:55.161  INFO 3324 --- [uponassignment]] o.a.camel.component.kafka.KafkaConsumer  : Subscribing topic1,topic2,topic3-Thread 0 to topic topic1,topic2,topic32019-01-28 10:46:55.313  INFO 3324 --- [uponassignment]] o.a.k.c.c.internals.AbstractCoordinator  : [Consumer clientId=consumer-1, groupId=service_new] Discovered group coordinator 192.168.56.10:9093 (id: 2147483646 rack: null)2019-01-28 10:46:55.315  INFO 3324 --- [uponassignment]] o.a.k.c.c.internals.ConsumerCoordinator  : [Consumer clientId=consumer-1, groupId=service_new] Revoking previously assigned partitions []2019-01-28 10:46:55.316  INFO 3324 --- [uponassignment]] o.a.k.c.c.internals.AbstractCoordinator  : [Consumer clientId=consumer-1, groupId=service_new] (Re-)joining group2019-01-28 10:46:58.469  INFO 3324 --- [uponassignment]] o.a.k.c.c.internals.AbstractCoordinator  : [Consumer clientId=consumer-1, groupId=service_new] Successfully joined group with generation 32019-01-28 10:46:58.470  INFO 3324 --- [uponassignment]] o.a.k.c.c.internals.ConsumerCoordinator  : [Consumer clientId=consumer-1, groupId=service_new] Setting newly assigned partitions [topic3-1, topic3-0, topic2-1, topic1-0, topic2-0, topic1-1]2019-01-28 10:47:24.953 DEBUG 3324 --- [uponassignment]] o.a.camel.component.kafka.KafkaConsumer  : Auto commitSync topic1,topic2,topic3-Thread 0 from topic topic1,topic2,topic3 with offset: 32212019-01-28 10:47:24.953 DEBUG 3324 --- [uponassignment]] o.a.camel.component.kafka.KafkaConsumer  : Auto commitSync topic1,topic2,topic3-Thread 0 from topic topic1,topic2,topic3 with offset: 32212019-01-28 10:47:24.957 DEBUG 3324 --- [uponassignment]] o.a.camel.component.kafka.KafkaConsumer  : Auto commitSync topic1,topic2,topic3-Thread 0 from topic topic1,topic2,topic3 with offset: 32222019-01-28 10:47:24.957 DEBUG 3324 --- [uponassignment]] o.a.camel.component.kafka.KafkaConsumer  : Auto commitSync topic1,topic2,topic3-Thread 0 from topic topic1,topic2,topic3 with offset: 32222019-01-28 10:47:24.964 DEBUG 3324 --- [uponassignment]] o.a.camel.component.kafka.KafkaConsumer  : Auto commitSync topic1,topic2,topic3-Thread 0 from topic topic1,topic2,topic3 with offset: 33252019-01-28 10:47:24.964 DEBUG 3324 --- [uponassignment]] o.a.camel.component.kafka.KafkaConsumer  : Auto commitSync topic1,topic2,topic3-Thread 0 from topic topic1,topic2,topic3 with offset: 33252019-01-28 10:47:25.005 DEBUG 3324 --- [uponassignment]] o.a.camel.component.kafka.KafkaConsumer  : Auto commitSync topic1,topic2,topic3-Thread 0 from topic topic1,topic2,topic3 with offset: 32232019-01-28 10:47:25.005 DEBUG 3324 --- [uponassignment]] o.a.camel.component.kafka.KafkaConsumer  : Auto commitSync topic1,topic2,topic3-Thread 0 from topic topic1,topic2,topic3 with offset: 32232019-01-28 10:47:25.515 DEBUG 3324 --- [uponassignment]] o.a.camel.component.kafka.KafkaConsumer  : Auto commitSync topic1,topic2,topic3-Thread 0 from topic topic1,topic2,topic3 with offset: 33262019-01-28 10:47:25.515 DEBUG 3324 --- [uponassignment]] o.a.camel.component.kafka.KafkaConsumer  : Auto commitSync topic1,topic2,topic3-Thread 0 from topic topic1,topic2,topic3 with offset: 33262019-01-28 10:47:26.005 DEBUG 3324 --- [uponassignment]] o.a.camel.component.kafka.KafkaConsumer  : Auto commitSync topic1,topic2,topic3-Thread 0 from topic topic1,topic2,topic3 with offset: 32242019-01-28 10:47:26.005 DEBUG 3324 --- [uponassignment]] o.a.camel.component.kafka.KafkaConsumer  : Auto commitSync topic1,topic2,topic3-Thread 0 from topic topic1,topic2,topic3 with offset: 32242019-01-28 10:47:26.528 DEBUG 3324 --- [uponassignment]] o.a.camel.component.kafka.KafkaConsumer  : Auto commitSync topic1,topic2,topic3-Thread 0 from topic topic1,topic2,topic3 with offset: 33272019-01-28 10:47:26.528 DEBUG 3324 --- [uponassignment]] o.a.camel.component.kafka.KafkaConsumer  : Auto commitSync topic1,topic2,topic3-Thread 0 from topic topic1,topic2,topic3 with offset: 33272019-01-28 10:47:27.014 DEBUG 3324 --- [uponassignment]] o.a.camel.component.kafka.KafkaConsumer  : Auto commitSync topic1,topic2,topic3-Thread 0 from topic topic1,topic2,topic3 with offset: 32252019-01-28 10:47:27.014 DEBUG 3324 --- [uponassignment]] o.a.camel.component.kafka.KafkaConsumer  : Auto commitSync topic1,topic2,topic3-Thread 0 from topic topic1,topic2,topic3 with offset: 32252019-01-28 10:47:27.512 DEBUG 3324 --- [uponassignment]] o.a.camel.component.kafka.KafkaConsumer  : Auto commitSync topic1,topic2,topic3-Thread 0 from topic topic1,topic2,topic3 with offset: 33282019-01-28 10:47:27.512 DEBUG 3324 --- [uponassignment]] o.a.camel.component.kafka.KafkaConsumer  : Auto commitSync topic1,topic2,topic3-Thread 0 from topic topic1,topic2,topic3 with offset: 33282019-01-28 10:47:28.001 DEBUG 3324 --- [uponassignment]] o.a.camel.component.kafka.KafkaConsumer  : Auto commitSync topic1,topic2,topic3-Thread 0 from topic topic1,topic2,topic3 with offset: 32262019-01-28 10:47:28.001 DEBUG 3324 --- [uponassignment]] o.a.camel.component.kafka.KafkaConsumer  : Auto commitSync topic1,topic2,topic3-Thread 0 from topic topic1,topic2,topic3 with offset: 32262019-01-28 10:47:28.497 DEBUG 3324 --- [uponassignment]] o.a.camel.component.kafka.KafkaConsumer  : Auto commitSync topic1,topic2,topic3-Thread 0 from topic topic1,topic2,topic3 with offset: 33292019-01-28 10:47:28.497 DEBUG 3324 --- [uponassignment]] o.a.camel.component.kafka.KafkaConsumer  : Auto commitSync topic1,topic2,topic3-Thread 0 from topic topic1,topic2,topic3 with offset: 33292019-01-28 10:47:29.024 DEBUG 3324 --- [uponassignment]] o.a.camel.component.kafka.KafkaConsumer  : Auto commitSync topic1,topic2,topic3-Thread 0 from topic topic1,topic2,topic3 with offset: 33302019-01-28 10:47:29.024 DEBUG 3324 --- [uponassignment]] o.a.camel.component.kafka.KafkaConsumer  : Auto commitSync topic1,topic2,topic3-Thread 0 from topic topic1,topic2,topic3 with offset: 33302019-01-28 10:47:29.521 DEBUG 3324 --- [uponassignment]] o.a.camel.component.kafka.KafkaConsumer  : Auto commitSync topic1,topic2,topic3-Thread 0 from topic topic1,topic2,topic3 with offset: 32272019-01-28 10:47:29.521 DEBUG 3324 --- [uponassignment]] o.a.camel.component.kafka.KafkaConsumer  : Auto commitSync topic1,topic2,topic3-Thread 0 from topic topic1,topic2,topic3 with offset: 32272019-01-28 10:47:30.012 DEBUG 3324 --- [uponassignment]] o.a.camel.component.kafka.KafkaConsumer  : Auto commitSync topic1,topic2,topic3-Thread 0 from topic topic1,topic2,topic3 with offset: 32282019-01-28 10:47:30.012 DEBUG 3324 --- [uponassignment]] o.a.camel.component.kafka.KafkaConsumer  : Auto commitSync topic1,topic2,topic3-Thread 0 from topic topic1,topic2,topic3 with offset: 3228{code}When downgraded to camel-kafka 2.20.3 commits are done correctly (once every auto.commit.interval.ms) and there are no messages from o.a.camel.component.kafka.KafkaConsumer in the debug log.Running with debugger showed that this code actually never gets executed in 2.20.3: https://github.com/apache/camel/blob/2.20.x/components/camel-kafka/src/main/java/org/apache/camel/component/kafka/KafkaConsumer.java#L382 and we seem to rely on the auto-commit feature of the Kafka client itself, not the camel-kafka wrapper.
Potential bug in BeanExpression/HttpMessage I think I found a potential bug when using a bean to set a property if a message is coming through http. I wanted to check here before opening a bug in case I am missing something. It is very similar to the following bug which has already been fixed: [https://stackoverflow.com/questions/40293128/camel-rest-service-throws-exception-when-returning-null/40317432#40317432]. The difference is that instead of returning null, an exception is thrown from the bean method. When that happen, I see the same behavior as described in the stackoverflow post above.  I included an example on how to reproduce at the end of this email. Here is what I think happens: Problem starts in BeanExpression: 1. The exchange is copied, BeanExpression: line 194: Exchange resultExchange = ExchangeHelper.createCopy(exchange, true) 2. The out body is then retrieved from the exchange, BeanExpression: line 201: result = resultExchange.getOut().getBody(); 3. Since out() is null, the in() message is copied to the out(), this makes a copy of the HttpMessage, which is copied along with the original ServletRequest (which contains a closed stream) DefaultExchange.class line 317. 4. To copy the message from in to out, the method newInstance() from HttpMessage class is called. HttpMessage line 85 5. At this point, the new instance of HttpMessage tries to read the stream from the original message which is already closed, IOException. Example just below, I would be expecting the EXCEPTION_CAUGHT to be the RuntimeException I throw but instead it's a RuntimeBeanExpressionException effectively wrapping a IOException. {code:java}public void configureTestException() {  restDefinitionV1 = restDefinitionV1    .get("/throwException")    .route()     .onException(Exception.class)       .process(exchange -> {System.out.println("Caught exception of type: " + exchange.getProperty(Exchange.EXCEPTION_CAUGHT).getClass());} )       .handled(true)     .end()       .setProperty("test").method(new TestBean(), "throwException")     .endRest();}               public static class TestBean {  public void throwException() {    throw new RuntimeException("Excepting this exception to be handled by onException");  }}{code} I will try to provide an actual unit test shortly. Bug Potential bug in BeanExpression/HttpMessage I think I found a potential bug when using a bean to set a property if a message is coming through http. I wanted to check here before opening a bug in case I am missing something. It is very similar to the following bug which has already been fixed: [https://stackoverflow.com/questions/40293128/camel-rest-service-throws-exception-when-returning-null/40317432#40317432]. The difference is that instead of returning null, an exception is thrown from the bean method. When that happen, I see the same behavior as described in the stackoverflow post above.  I included an example on how to reproduce at the end of this email. Here is what I think happens: Problem starts in BeanExpression: 1. The exchange is copied, BeanExpression: line 194: Exchange resultExchange = ExchangeHelper.createCopy(exchange, true) 2. The out body is then retrieved from the exchange, BeanExpression: line 201: result = resultExchange.getOut().getBody(); 3. Since out() is null, the in() message is copied to the out(), this makes a copy of the HttpMessage, which is copied along with the original ServletRequest (which contains a closed stream) DefaultExchange.class line 317. 4. To copy the message from in to out, the method newInstance() from HttpMessage class is called. HttpMessage line 85 5. At this point, the new instance of HttpMessage tries to read the stream from the original message which is already closed, IOException. Example just below, I would be expecting the EXCEPTION_CAUGHT to be the RuntimeException I throw but instead it's a RuntimeBeanExpressionException effectively wrapping a IOException. {code:java}public void configureTestException() {  restDefinitionV1 = restDefinitionV1    .get("/throwException")    .route()     .onException(Exception.class)       .process(exchange -> {System.out.println("Caught exception of type: " + exchange.getProperty(Exchange.EXCEPTION_CAUGHT).getClass());} )       .handled(true)     .end()       .setProperty("test").method(new TestBean(), "throwException")     .endRest();}               public static class TestBean {  public void throwException() {    throw new RuntimeException("Excepting this exception to be handled by onException");  }}{code} I will try to provide an actual unit test shortly.
Context MBean not unregistered on startup failure In Camel-2.23.x a failure to start the context would call ServiceSupport.doStop(). This is no longer the case. Instead, a CamelContextStartupFailureEvent is thrown and services that might previously have been started are never stopped.As a result or (side effect) the context MBean may remain registered if the startup failure occurred after its initial registration.  Bug Context MBean not unregistered on startup failure In Camel-2.23.x a failure to start the context would call ServiceSupport.doStop(). This is no longer the case. Instead, a CamelContextStartupFailureEvent is thrown and services that might previously have been started are never stopped.As a result or (side effect) the context MBean may remain registered if the startup failure occurred after its initial registration. 
Output of route-profile is empty if there are same route-id for multiple camel-contexts. * Unzip the attached reproducer. * Build it using 'mvn clean install'. * Deploy it in Fuse with command 'bundle:install -s mvn:com.mycompany/camel-blueprint-cbr/1.0.0-SNAPSHOT'. * If we execute route-profile command, we find that output is empty or no output.karaf@root()> route-profile cbr-example-context1 1-route Profile Camel Context: cbr-example-context1 Id Count Last (ms) Delta (ms) Mean (ms) Min (ms) Max (ms) Total (ms) Self (ms) karaf@root()> Bug Output of route-profile is empty if there are same route-id for multiple camel-contexts. * Unzip the attached reproducer. * Build it using 'mvn clean install'. * Deploy it in Fuse with command 'bundle:install -s mvn:com.mycompany/camel-blueprint-cbr/1.0.0-SNAPSHOT'. * If we execute route-profile command, we find that output is empty or no output.karaf@root()> route-profile cbr-example-context1 1-route Profile Camel Context: cbr-example-context1 Id Count Last (ms) Delta (ms) Mean (ms) Min (ms) Max (ms) Total (ms) Self (ms) karaf@root()>
camel-undertow - When using SSL with rest-dsl and api-doc then you can get a port already bound exception For example this route cannot startup{code}	public void configure() throws Exception {		restConfiguration().scheme("https").component("undertow").port(7777).contextPath("/").host("0.0.0.0")            .apiContextPath("/swagger.json")				.dataFormatProperty("prettyPrint", "true")				.apiProperty("api.schemes", "https")				.apiProperty("api.title", "Rest swagger")				.apiProperty("api.description", "Camel Rest App with Swagger");		rest("/user").get().to("direct:start");		from("direct:start").setBody().constant("Hi Camels");	}{code}With a{code}Caused by: java.net.BindException: Address already in use        at sun.nio.ch.Net.bind0(Native Method) ~[na:1.8.0_181]        at sun.nio.ch.Net.bind(Net.java:433) ~[na:1.8.0_181]        at sun.nio.ch.Net.bind(Net.java:425) ~[na:1.8.0_181]        at sun.nio.ch.ServerSocketChannelImpl.bind(ServerSocketChannelImpl.java:223) ~[na:1.8.0_181]        at sun.nio.ch.ServerSocketAdaptor.bind(ServerSocketAdaptor.java:74) ~[na:1.8.0_181]...{code} Bug camel-undertow - When using SSL with rest-dsl and api-doc then you can get a port already bound exception For example this route cannot startup{code}	public void configure() throws Exception {		restConfiguration().scheme("https").component("undertow").port(7777).contextPath("/").host("0.0.0.0")            .apiContextPath("/swagger.json")				.dataFormatProperty("prettyPrint", "true")				.apiProperty("api.schemes", "https")				.apiProperty("api.title", "Rest swagger")				.apiProperty("api.description", "Camel Rest App with Swagger");		rest("/user").get().to("direct:start");		from("direct:start").setBody().constant("Hi Camels");	}{code}With a{code}Caused by: java.net.BindException: Address already in use        at sun.nio.ch.Net.bind0(Native Method) ~[na:1.8.0_181]        at sun.nio.ch.Net.bind(Net.java:433) ~[na:1.8.0_181]        at sun.nio.ch.Net.bind(Net.java:425) ~[na:1.8.0_181]        at sun.nio.ch.ServerSocketChannelImpl.bind(ServerSocketChannelImpl.java:223) ~[na:1.8.0_181]        at sun.nio.ch.ServerSocketAdaptor.bind(ServerSocketAdaptor.java:74) ~[na:1.8.0_181]...{code}
camel-restlet - sending PATCH operation should include body We currently only include body for PUT and POST. But we should include the body for PATCH as well. Bug camel-restlet - sending PATCH operation should include body We currently only include body for PUT and POST. But we should include the body for PATCH as well.
camel-jetty - If multiple bundles uses the same context-path (pathspec) then Jetty should fail If you have 2 bundles that both uses the same context-path with a jetty consumer, then the last installed bundle will be routing the incoming requests, and the first installed will not be in use, and if you uninstall the 2nd bundle then the 1st bundle will still not be in use and jetty will return a 404.We should detect that there is already another jetty consumer with the same context-path to be routing when creating a jetty connector listener and then fail if so. Bug camel-jetty - If multiple bundles uses the same context-path (pathspec) then Jetty should fail If you have 2 bundles that both uses the same context-path with a jetty consumer, then the last installed bundle will be routing the incoming requests, and the first installed will not be in use, and if you uninstall the 2nd bundle then the 1st bundle will still not be in use and jetty will return a 404.We should detect that there is already another jetty consumer with the same context-path to be routing when creating a jetty connector listener and then fail if so.
xquery syntax problem in SpringDSL with spring-boot this JAVADSL sytnax does not exist / supported in SpringDSL setHeader("myHeader").xquery("resource:classpath:myxquery.txt", String.class)It will cause the problem if return type is String instead of DomReulst or xmlString for xquery, when we use SpringDSL instead of JAVADSL we tried all version >= 2.22, same problem  Bug xquery syntax problem in SpringDSL with spring-boot this JAVADSL sytnax does not exist / supported in SpringDSL setHeader("myHeader").xquery("resource:classpath:myxquery.txt", String.class)It will cause the problem if return type is String instead of DomReulst or xmlString for xquery, when we use SpringDSL instead of JAVADSL we tried all version >= 2.22, same problem 
SftpEndpoint does not allow to use custom process strategy SftpEndpoint always create generic file strategy even processStrategy object is set in endpoint, same code is used in FtpEndpoint so it's not working also{code:java}@Overrideprotected RemoteFileConsumer<SftpRemoteFile> buildConsumer(Processor processor) {    return new SftpConsumer(this, processor, createRemoteFileOperations(), createGenericFileStrategy());}{code}it is working in FileEnpoint{code:java}protected FileConsumer newFileConsumer(Processor processor, GenericFileOperations<File> operations) {    return new FileConsumer(this, processor, operations, processStrategy != null ? processStrategy : createGenericFileStrategy());}{code} Bug SftpEndpoint does not allow to use custom process strategy SftpEndpoint always create generic file strategy even processStrategy object is set in endpoint, same code is used in FtpEndpoint so it's not working also{code:java}@Overrideprotected RemoteFileConsumer<SftpRemoteFile> buildConsumer(Processor processor) {    return new SftpConsumer(this, processor, createRemoteFileOperations(), createGenericFileStrategy());}{code}it is working in FileEnpoint{code:java}protected FileConsumer newFileConsumer(Processor processor, GenericFileOperations<File> operations) {    return new FileConsumer(this, processor, operations, processStrategy != null ? processStrategy : createGenericFileStrategy());}{code}
camel-core-osgi: OsgiServiceRegistry.onContextStop never gets called. There is also a second problem with how the registry is being managed within the OsgiDefaultCamelContext.  OsgiServiceRegistry is currently extends LifecycleStrategySupport which is suppose to unload the serviceReferenceQueue onContextStop.  However the registry is never getting added to the CamelContext to manage the Lifecycle because the overridden createRegistry method in OsgiDefaultCamelContext is not being called.  This is because the registry is being set in the constructor of OsgiDefaultCamelContext with{code:java}super(registry);{code}this calls the DefaultCamelContext implementation of createRegistry which does not add the registry to lifecyclemanagement since{code:java}OsgiCamelContextHelper.wrapRegistry(this, registry, bundleContext);{code}is never called. See CAMEL-12969 for screen captures.  Bug camel-core-osgi: OsgiServiceRegistry.onContextStop never gets called. There is also a second problem with how the registry is being managed within the OsgiDefaultCamelContext.  OsgiServiceRegistry is currently extends LifecycleStrategySupport which is suppose to unload the serviceReferenceQueue onContextStop.  However the registry is never getting added to the CamelContext to manage the Lifecycle because the overridden createRegistry method in OsgiDefaultCamelContext is not being called.  This is because the registry is being set in the constructor of OsgiDefaultCamelContext with{code:java}super(registry);{code}this calls the DefaultCamelContext implementation of createRegistry which does not add the registry to lifecyclemanagement since{code:java}OsgiCamelContextHelper.wrapRegistry(this, registry, bundleContext);{code}is never called. See CAMEL-12969 for screen captures. 
Route coverage: When and otherwise are not marked as covered - use a route with a choice with when and otherwise inside.- launch mvn test camel:route-coverage- when and otherwise are marked with a 0 count even if they were usedexamples of the CBR examples available in Eclipse Fuse Tooling:{noformat}Route:	cbr-route  Line #      Count   Route  ------      -----   -----      33          5   from      34          5     log      35          5     choice      36          0       when      38          2         log      39          2         to      41          0       when      43          2         log      44          2         to      46          0       otherwise      47          1         log      48          1         to      51          5     logCoverage: 10 out of 13 (76.9%){noformat}we can notice that elements inside when and otherwise are well counted but when and otherwise are at 0 Bug Route coverage: When and otherwise are not marked as covered - use a route with a choice with when and otherwise inside.- launch mvn test camel:route-coverage- when and otherwise are marked with a 0 count even if they were usedexamples of the CBR examples available in Eclipse Fuse Tooling:{noformat}Route:	cbr-route  Line #      Count   Route  ------      -----   -----      33          5   from      34          5     log      35          5     choice      36          0       when      38          2         log      39          2         to      41          0       when      43          2         log      44          2         to      46          0       otherwise      47          1         log      48          1         to      51          5     logCoverage: 10 out of 13 (76.9%){noformat}we can notice that elements inside when and otherwise are well counted but when and otherwise are at 0
Camel Maven Plugin: false postives with directOrSedaPairCheck In one of my RouteBuilders I instantiate and include some routes with {{RouteBuilder::includeRoutes}}. When I run {{mvn camel:validate}}, these routes generate the "Sending to non existing direct queue name" error. The routes work though.Here is the Route. I can make a smaller example, but I won't if I don't need to.{code:java|title=HealthRoute.java}import java.sql.Connection;import java.sql.SQLException;import java.util.HashMap;import javax.sql.DataSource;import org.apache.camel.BeanInject;import org.apache.camel.Exchange;import org.apache.camel.Processor;import org.apache.camel.builder.RouteBuilder;import org.apache.camel.json.simple.JsonObject;import org.slf4j.Logger;import org.slf4j.LoggerFactory;/** * An HTTP service that validates some application configuration properties. The * validation status is returned as simply "true" or "false" with error messages * printed to the log. */public class HealthRoute extends RouteBuilder {    private static final String ROUTE_CHECK_SUBMIT_ASSESSMENTS_ENDPOINT = "checkSubmitAssessmentsEndpoint";    private static final String ROUTE_CHECK_QUERY_ENDPOINT = "checkQueryEndpoint";    private static final String DATABASE_REACHABLE = "isDatabaseReachable";    @BeanInject(value = "dataSource")    private DataSource dataSource;    private static final Logger LOGGER = LoggerFactory.getLogger(HealthRoute1.class);    @Override    public void configure() throws Exception {        from("servlet:smoketest?servletName=HealthServlet")                .to("direct:" + ROUTE_CHECK_QUERY_ENDPOINT)                .to("direct:" + ROUTE_CHECK_SUBMIT_ASSESSMENTS_ENDPOINT)                .process(new CheckDatabaseConnection())                .process(exchange -> {                    HashMap<String, Object> hashMap = new HashMap<>();                    hashMap.put("isQueryEndpointReachable", exchange.getProperty(ROUTE_CHECK_QUERY_ENDPOINT));                    hashMap.put("isSubmitAssessmentsEndpointReachable", exchange.getProperty(ROUTE_CHECK_SUBMIT_ASSESSMENTS_ENDPOINT));                    hashMap.put(DATABASE_REACHABLE, exchange.getProperty(DATABASE_REACHABLE));                    exchange.getIn().setBody(new JsonObject(hashMap).toJson());                })                .setHeader("Content-Type", constant("application/json"));        String queryHumanSubjectsUri = getContext().resolvePropertyPlaceholders("{{queryHumanSubjectsUri}}").replaceAll("https?://", "");        String submitExternalAssessmentsUri = getContext().resolvePropertyPlaceholders("{{submitExternalAssessmentsUri}}").replaceAll("https?://", "");        includeRoutes(new CheckEndpointRoute(ROUTE_CHECK_QUERY_ENDPOINT, queryHumanSubjectsUri));        includeRoutes(new CheckEndpointRoute(ROUTE_CHECK_SUBMIT_ASSESSMENTS_ENDPOINT, submitExternalAssessmentsUri));    }    /**     * Smoke tests the availability of a given HTTP resource by issuing a GET     * request. If the request throws an exception an error flag is set on the     * Exchange.     */    private static class CheckEndpointRoute extends RouteBuilder {        private final String routeId;        private final String uri;        public CheckEndpointRoute(String routeId, String uri) {            this.routeId = routeId;            this.uri = uri;        }        @Override        public void configure() throws Exception {            from("direct:" + routeId)                    .doTry()                    .to("https4:"                            + uri                            + "?sslContextParameters=#sslParameters"                            + "&bridgeEndpoint=true"                            + "&x509HostnameVerifier=#hostnameVerifier")                    .setProperty(routeId, constant(true))                    .doCatch(Exception.class)                    .to("log:com.cgi.best.HealthRoute?level=ERROR&showCaughtException=true")                    .setProperty(routeId, constant(false))                    .end();        }    }    /**     * Smoke tests the availability of the database by executing a standard     * database health query.     */    private class CheckDatabaseConnection implements Processor {        @Override        public void process(Exchange exchange) throws Exception {            try (Connection connection = dataSource.getConnection()) {                connection.createStatement().execute("select * from dual");                exchange.setProperty(DATABASE_REACHABLE, true);            } catch (SQLException ex) {                LOGGER.error("Database test query failed.", ex);                exchange.setProperty(DATABASE_REACHABLE, false);            }        }    }}{code}{code}$ mvn camel:validate[INFO] Scanning for projects...[INFO][INFO] ------------------------------------------------------------------------[INFO] Building BestAdapter 1.0-SNAPSHOT[INFO] ------------------------------------------------------------------------[INFO][INFO] --- camel-maven-plugin:2.23.0:validate (default-cli) @ BestAdapter ---[INFO] Detected Camel version used in project: 2.23.0[INFO] Validating using Camel version: 2.23.0[INFO] Endpoint validation success: (16 = passed, 0 = invalid, 2 = incapable, 0 = unknown components, 0 = deprecated options)[INFO] Simple validation success: (3 = passed, 0 = invalid)[WARNING] Endpoint pair (seda/direct) validation error at: com.cgi.best.HealthRoute.configure(HealthRoute.java:45)        direct:checkQueryEndpoint                                checkQueryEndpoint      Sending to non existing direct queue name[WARNING] Endpoint pair (seda/direct) validation error at: com.cgi.best.HealthRoute.configure(HealthRoute.java:45)        direct:checkSubmitAssessmentsEndpoint                                checkSubmitAssessmentsEndpoint  Sending to non existing direct queue name[WARNING] Endpoint pair (seda/direct) validation error at: com.cgi.best.HealthRoute1.configure(HealthRoute1.java:45)        direct:checkQueryEndpoint                                checkQueryEndpoint      Sending to non existing direct queue name[WARNING] Endpoint pair (seda/direct) validation error at: com.cgi.best.HealthRoute1.configure(HealthRoute1.java:45)        direct:checkSubmitAssessmentsEndpoint                                checkSubmitAssessmentsEndpoint  Sending to non existing direct queue name[WARNING] Endpoint pair (seda/direct) validation error: (2 = pairs, 4 = non-pairs)[INFO] Duplicate route id validation success (3 = ids)[INFO] ------------------------------------------------------------------------[INFO] BUILD FAILURE[INFO] ------------------------------------------------------------------------[INFO] Total time: 3.030 s[INFO] Finished at: 2018-11-30T08:55:31-08:00[INFO] Final Memory: 21M/398M[INFO] ------------------------------------------------------------------------[ERROR] Failed to execute goal org.apache.camel:camel-maven-plugin:2.23.0:validate (default-cli) on project BestAdapter: Endpoint validation success: (16 = passed, 0 = invalid, 2 = incapable, 0 = unknown components, 0 = deprecated options)[ERROR] Simple validation success: (3 = passed, 0 = invalid)[ERROR] Duplicate route id validation success (3 = ids)[ERROR] Endpoint pair (seda/direct) validation error: (2 = pairs, 4 = non-pairs)[ERROR] -> [Help 1][ERROR][ERROR] To see the full stack trace of the errors, re-run Maven with the -e switch.[ERROR] Re-run Maven using the -X switch to enable full debug logging.[ERROR][ERROR] For more information about the errors and possible solutions, please read the following articles:[ERROR] [Help 1] http://cwiki.apache.org/confluence/display/MAVEN/MojoExecutionException{code} Bug Camel Maven Plugin: false postives with directOrSedaPairCheck In one of my RouteBuilders I instantiate and include some routes with {{RouteBuilder::includeRoutes}}. When I run {{mvn camel:validate}}, these routes generate the "Sending to non existing direct queue name" error. The routes work though.Here is the Route. I can make a smaller example, but I won't if I don't need to.{code:java|title=HealthRoute.java}import java.sql.Connection;import java.sql.SQLException;import java.util.HashMap;import javax.sql.DataSource;import org.apache.camel.BeanInject;import org.apache.camel.Exchange;import org.apache.camel.Processor;import org.apache.camel.builder.RouteBuilder;import org.apache.camel.json.simple.JsonObject;import org.slf4j.Logger;import org.slf4j.LoggerFactory;/** * An HTTP service that validates some application configuration properties. The * validation status is returned as simply "true" or "false" with error messages * printed to the log. */public class HealthRoute extends RouteBuilder {    private static final String ROUTE_CHECK_SUBMIT_ASSESSMENTS_ENDPOINT = "checkSubmitAssessmentsEndpoint";    private static final String ROUTE_CHECK_QUERY_ENDPOINT = "checkQueryEndpoint";    private static final String DATABASE_REACHABLE = "isDatabaseReachable";    @BeanInject(value = "dataSource")    private DataSource dataSource;    private static final Logger LOGGER = LoggerFactory.getLogger(HealthRoute1.class);    @Override    public void configure() throws Exception {        from("servlet:smoketest?servletName=HealthServlet")                .to("direct:" + ROUTE_CHECK_QUERY_ENDPOINT)                .to("direct:" + ROUTE_CHECK_SUBMIT_ASSESSMENTS_ENDPOINT)                .process(new CheckDatabaseConnection())                .process(exchange -> {                    HashMap<String, Object> hashMap = new HashMap<>();                    hashMap.put("isQueryEndpointReachable", exchange.getProperty(ROUTE_CHECK_QUERY_ENDPOINT));                    hashMap.put("isSubmitAssessmentsEndpointReachable", exchange.getProperty(ROUTE_CHECK_SUBMIT_ASSESSMENTS_ENDPOINT));                    hashMap.put(DATABASE_REACHABLE, exchange.getProperty(DATABASE_REACHABLE));                    exchange.getIn().setBody(new JsonObject(hashMap).toJson());                })                .setHeader("Content-Type", constant("application/json"));        String queryHumanSubjectsUri = getContext().resolvePropertyPlaceholders("{{queryHumanSubjectsUri}}").replaceAll("https?://", "");        String submitExternalAssessmentsUri = getContext().resolvePropertyPlaceholders("{{submitExternalAssessmentsUri}}").replaceAll("https?://", "");        includeRoutes(new CheckEndpointRoute(ROUTE_CHECK_QUERY_ENDPOINT, queryHumanSubjectsUri));        includeRoutes(new CheckEndpointRoute(ROUTE_CHECK_SUBMIT_ASSESSMENTS_ENDPOINT, submitExternalAssessmentsUri));    }    /**     * Smoke tests the availability of a given HTTP resource by issuing a GET     * request. If the request throws an exception an error flag is set on the     * Exchange.     */    private static class CheckEndpointRoute extends RouteBuilder {        private final String routeId;        private final String uri;        public CheckEndpointRoute(String routeId, String uri) {            this.routeId = routeId;            this.uri = uri;        }        @Override        public void configure() throws Exception {            from("direct:" + routeId)                    .doTry()                    .to("https4:"                            + uri                            + "?sslContextParameters=#sslParameters"                            + "&bridgeEndpoint=true"                            + "&x509HostnameVerifier=#hostnameVerifier")                    .setProperty(routeId, constant(true))                    .doCatch(Exception.class)                    .to("log:com.cgi.best.HealthRoute?level=ERROR&showCaughtException=true")                    .setProperty(routeId, constant(false))                    .end();        }    }    /**     * Smoke tests the availability of the database by executing a standard     * database health query.     */    private class CheckDatabaseConnection implements Processor {        @Override        public void process(Exchange exchange) throws Exception {            try (Connection connection = dataSource.getConnection()) {                connection.createStatement().execute("select * from dual");                exchange.setProperty(DATABASE_REACHABLE, true);            } catch (SQLException ex) {                LOGGER.error("Database test query failed.", ex);                exchange.setProperty(DATABASE_REACHABLE, false);            }        }    }}{code}{code}$ mvn camel:validate[INFO] Scanning for projects...[INFO][INFO] ------------------------------------------------------------------------[INFO] Building BestAdapter 1.0-SNAPSHOT[INFO] ------------------------------------------------------------------------[INFO][INFO] --- camel-maven-plugin:2.23.0:validate (default-cli) @ BestAdapter ---[INFO] Detected Camel version used in project: 2.23.0[INFO] Validating using Camel version: 2.23.0[INFO] Endpoint validation success: (16 = passed, 0 = invalid, 2 = incapable, 0 = unknown components, 0 = deprecated options)[INFO] Simple validation success: (3 = passed, 0 = invalid)[WARNING] Endpoint pair (seda/direct) validation error at: com.cgi.best.HealthRoute.configure(HealthRoute.java:45)        direct:checkQueryEndpoint                                checkQueryEndpoint      Sending to non existing direct queue name[WARNING] Endpoint pair (seda/direct) validation error at: com.cgi.best.HealthRoute.configure(HealthRoute.java:45)        direct:checkSubmitAssessmentsEndpoint                                checkSubmitAssessmentsEndpoint  Sending to non existing direct queue name[WARNING] Endpoint pair (seda/direct) validation error at: com.cgi.best.HealthRoute1.configure(HealthRoute1.java:45)        direct:checkQueryEndpoint                                checkQueryEndpoint      Sending to non existing direct queue name[WARNING] Endpoint pair (seda/direct) validation error at: com.cgi.best.HealthRoute1.configure(HealthRoute1.java:45)        direct:checkSubmitAssessmentsEndpoint                                checkSubmitAssessmentsEndpoint  Sending to non existing direct queue name[WARNING] Endpoint pair (seda/direct) validation error: (2 = pairs, 4 = non-pairs)[INFO] Duplicate route id validation success (3 = ids)[INFO] ------------------------------------------------------------------------[INFO] BUILD FAILURE[INFO] ------------------------------------------------------------------------[INFO] Total time: 3.030 s[INFO] Finished at: 2018-11-30T08:55:31-08:00[INFO] Final Memory: 21M/398M[INFO] ------------------------------------------------------------------------[ERROR] Failed to execute goal org.apache.camel:camel-maven-plugin:2.23.0:validate (default-cli) on project BestAdapter: Endpoint validation success: (16 = passed, 0 = invalid, 2 = incapable, 0 = unknown components, 0 = deprecated options)[ERROR] Simple validation success: (3 = passed, 0 = invalid)[ERROR] Duplicate route id validation success (3 = ids)[ERROR] Endpoint pair (seda/direct) validation error: (2 = pairs, 4 = non-pairs)[ERROR] -> [Help 1][ERROR][ERROR] To see the full stack trace of the errors, re-run Maven with the -e switch.[ERROR] Re-run Maven using the -X switch to enable full debug logging.[ERROR][ERROR] For more information about the errors and possible solutions, please read the following articles:[ERROR] [Help 1] http://cwiki.apache.org/confluence/display/MAVEN/MojoExecutionException{code}
camel-core-osgi: Slow Memory Leak in OsgiServiceRegistry The OsgiServiceRegistry has a slow memory leak in the serviceReferenceQueue.  Currently every time a service is looked up by any method an item is added to the serviceReferenceQueue.  This is required because of OSGi ServiceReference counting.  However left unchecked the system just continues to add ConcurrentLinkedQueue$Node objects until memory is exhausted.!ServiceReferenceQueueLeak.PNG! .  There is also a second problem with how the registry is being managed within the OsgiDefaultCamelContext.  OsgiServiceRegistry is currently extends LifecycleStrategySupport which is suppose to unload the serviceReferenceQueue onContextStop.  However the registry is never getting added to the CamelContext to manage the Lifecycle because the overridden createRegistry method in OsgiDefaultCamelContext is not being called.  This is because the registry is being set in the constructor of OsgiDefaultCamelContext with{code:java}super(registry);{code}this calls the DefaultCamelContext implementation of createRegistry which does not add the registry to lifecyclemanagement since{code:java}OsgiCamelContextHelper.wrapRegistry(this, registry, bundleContext);{code}is never called. See serviceReferenceQueue  pre context stop  !ServiceReferenceQueuePreContextStop.PNG!!karafCamelContextStop.PNG!See serviceReferenceQueue   post context stop (still contain objects)  !ServiceReferenceQueuePostContextStop.PNG!Both issues would have existed for some time but may have gone unnoticed because the leak was so slow (ConcurrentLinkedQueue$Node takes up very little memory).  It appears the removal of the cache in https://issues.apache.org/jira/browse/CAMEL-9631 makes the leak occur more quickly.  I have a patch that involves reintroducing the cache but with an invalidation strategy using the OSGi ServiceListener that leverages a single clean up thread to remain non-blocking.  I'm working on an upstream adaptation and will post a PR for community review.   Bug camel-core-osgi: Slow Memory Leak in OsgiServiceRegistry The OsgiServiceRegistry has a slow memory leak in the serviceReferenceQueue.  Currently every time a service is looked up by any method an item is added to the serviceReferenceQueue.  This is required because of OSGi ServiceReference counting.  However left unchecked the system just continues to add ConcurrentLinkedQueue$Node objects until memory is exhausted.!ServiceReferenceQueueLeak.PNG! .  There is also a second problem with how the registry is being managed within the OsgiDefaultCamelContext.  OsgiServiceRegistry is currently extends LifecycleStrategySupport which is suppose to unload the serviceReferenceQueue onContextStop.  However the registry is never getting added to the CamelContext to manage the Lifecycle because the overridden createRegistry method in OsgiDefaultCamelContext is not being called.  This is because the registry is being set in the constructor of OsgiDefaultCamelContext with{code:java}super(registry);{code}this calls the DefaultCamelContext implementation of createRegistry which does not add the registry to lifecyclemanagement since{code:java}OsgiCamelContextHelper.wrapRegistry(this, registry, bundleContext);{code}is never called. See serviceReferenceQueue  pre context stop  !ServiceReferenceQueuePreContextStop.PNG!!karafCamelContextStop.PNG!See serviceReferenceQueue   post context stop (still contain objects)  !ServiceReferenceQueuePostContextStop.PNG!Both issues would have existed for some time but may have gone unnoticed because the leak was so slow (ConcurrentLinkedQueue$Node takes up very little memory).  It appears the removal of the cache in https://issues.apache.org/jira/browse/CAMEL-9631 makes the leak occur more quickly.  I have a patch that involves reintroducing the cache but with an invalidation strategy using the OSGi ServiceListener that leverages a single clean up thread to remain non-blocking.  I'm working on an upstream adaptation and will post a PR for community review.  
DefaultFluentProducerTemplate is not thread safe (endpoint, etc.) The DefaultFluentProducerTemplate saves state between method calls. This leads to unexpected behavior when the javadoc specifies that it should be thread safe.For example: # thread 1 calls fluentProducerTemplate.to("direct:a").send("message1"); # thread 2 calls fluentProducerTemplate.to("direct:b").send("message2");If these are run in parallel, the sequence of calls can be: # thread 1 calls to("direct:a") - endpoint in the object is direct:a # thread 2 calls to("direct:b") - endpoint in the object is direct:b # *thread 1 calls send("message1") - this gets sent incorrectly to direct:b* # thread 2 calls send("message2") - this gets sent correctly to direct:bEndpoint is one example, but almost all fields in this class share this behavior. It should be clearly documented which fields can be used fluently over multiple threads, and which cannot. As the API is today, all methods returning 'this' should be made thread-safe (state is only local to the caller) so that the fluent interface works as expected. Bug DefaultFluentProducerTemplate is not thread safe (endpoint, etc.) The DefaultFluentProducerTemplate saves state between method calls. This leads to unexpected behavior when the javadoc specifies that it should be thread safe.For example: # thread 1 calls fluentProducerTemplate.to("direct:a").send("message1"); # thread 2 calls fluentProducerTemplate.to("direct:b").send("message2");If these are run in parallel, the sequence of calls can be: # thread 1 calls to("direct:a") - endpoint in the object is direct:a # thread 2 calls to("direct:b") - endpoint in the object is direct:b # *thread 1 calls send("message1") - this gets sent incorrectly to direct:b* # thread 2 calls send("message2") - this gets sent correctly to direct:bEndpoint is one example, but almost all fields in this class share this behavior. It should be clearly documented which fields can be used fluently over multiple threads, and which cannot. As the API is today, all methods returning 'this' should be made thread-safe (state is only local to the caller) so that the fluent interface works as expected.
Spring Boot Auto-Configuration via application.properties does not work I am trying to configure camel with spring boot to use active MQ. But the jms connection factory (activemq) gets not picked up automatically during auto configuration. Thus, I tried to configure it via application.properties{code:java}camel.component.jms.connection-factory=org.apache.activemq.ActiveMQConnectionFactory{code}But then I get an error on startup stating, that the expected datatype is {code:java}javax.jms.ConnectionFactory{code}and not{code:java}String{code}The only solutions I have found is not using autoconfiguration and configuring *JmsComponent* by hand or using a *ComponentCustomizer* programatically. This seems to be a Bug, as other component auto configurations expect a String as connectionFactory property.  Bug Spring Boot Auto-Configuration via application.properties does not work I am trying to configure camel with spring boot to use active MQ. But the jms connection factory (activemq) gets not picked up automatically during auto configuration. Thus, I tried to configure it via application.properties{code:java}camel.component.jms.connection-factory=org.apache.activemq.ActiveMQConnectionFactory{code}But then I get an error on startup stating, that the expected datatype is {code:java}javax.jms.ConnectionFactory{code}and not{code:java}String{code}The only solutions I have found is not using autoconfiguration and configuring *JmsComponent* by hand or using a *ComponentCustomizer* programatically. This seems to be a Bug, as other component auto configurations expect a String as connectionFactory property. 
onWhen predicate with onException can not bind to method with exception subclass parameter Inspired by this example for "Camel in Action, Second Edition" (page 510):{code:java}public final class MyHttpUtil {    public static boolean isIllegalDataError(        HttpOperationFailedException cause) {        int code = cause.getStatusCode();        if (code != 500) {            return false;            }        return "ILLEGAL DATA".equals(cause.getResponseBody().toString());    }}onException(HttpOperationFailedException.class)    .onWhen(bean(MyHttpUtil.class, "isIllegalData"))    .handled(true)    .to("file:/rider/files/illegal");{code}I expected this (simplified test) to pass:{code:java}public class OnWhenBindMethodWithExceptionSubclassParameterTest extends CamelTestSupport {    public static class IOExceptionMatcher {        public static boolean matches(IOException e) {            // real logic omited            return true;        }    }    @Override    protected RouteBuilder createRouteBuilder() throws Exception {        return new RouteBuilder() {            public void configure() {                onException(IOException.class)                    .onWhen(method(IOExceptionMatcher.class))                    .to("mock:ioexception");                from("seda:start")                    .throwException(new IOException());            }        };    }    @Test    public void test() throws Exception {        getMockEndpoint("mock:ioexception").expectedMessageCount(1);        template.sendBody("seda:start", "Hello World");        assertMockEndpointsSatisfied();    }}{code}but it fails with with:{noformat}java.lang.AssertionError: mock://ioexception Received message count. Expected: <1> but was: <0>{noformat}The workaround is to replace the {{IOException}} parameter of {{IOExceptionMatcher#matches}} with an generic {{Exception}}:{code:java}public static class IOExceptionMatcher {    public static boolean matches(Exception e) {        if (e instanceof IOException) {            return true;        }        return false;    }}{code}but this is not as elegant and more error prone. Bug onWhen predicate with onException can not bind to method with exception subclass parameter Inspired by this example for "Camel in Action, Second Edition" (page 510):{code:java}public final class MyHttpUtil {    public static boolean isIllegalDataError(        HttpOperationFailedException cause) {        int code = cause.getStatusCode();        if (code != 500) {            return false;            }        return "ILLEGAL DATA".equals(cause.getResponseBody().toString());    }}onException(HttpOperationFailedException.class)    .onWhen(bean(MyHttpUtil.class, "isIllegalData"))    .handled(true)    .to("file:/rider/files/illegal");{code}I expected this (simplified test) to pass:{code:java}public class OnWhenBindMethodWithExceptionSubclassParameterTest extends CamelTestSupport {    public static class IOExceptionMatcher {        public static boolean matches(IOException e) {            // real logic omited            return true;        }    }    @Override    protected RouteBuilder createRouteBuilder() throws Exception {        return new RouteBuilder() {            public void configure() {                onException(IOException.class)                    .onWhen(method(IOExceptionMatcher.class))                    .to("mock:ioexception");                from("seda:start")                    .throwException(new IOException());            }        };    }    @Test    public void test() throws Exception {        getMockEndpoint("mock:ioexception").expectedMessageCount(1);        template.sendBody("seda:start", "Hello World");        assertMockEndpointsSatisfied();    }}{code}but it fails with with:{noformat}java.lang.AssertionError: mock://ioexception Received message count. Expected: <1> but was: <0>{noformat}The workaround is to replace the {{IOException}} parameter of {{IOExceptionMatcher#matches}} with an generic {{Exception}}:{code:java}public static class IOExceptionMatcher {    public static boolean matches(Exception e) {        if (e instanceof IOException) {            return true;        }        return false;    }}{code}but this is not as elegant and more error prone.
camel-http4 - The sslContextParameters option should be documented on endpoint as well Reported on gitterhttps://gitter.im/apache/apache-camel?at=5be0bcd7de33dd0c96d547b3 Bug camel-http4 - The sslContextParameters option should be documented on endpoint as well Reported on gitterhttps://gitter.im/apache/apache-camel?at=5be0bcd7de33dd0c96d547b3
Route contract validate does not throw validation exception when validation fails This route will not throw validation exception when expected{code}                validator().type("xml").withUri("validator:org/apache/camel/impl/validate.xsd");                from("direct:in").inputTypeWithValidate("xml")                    .to("mock:result");{code} Bug Route contract validate does not throw validation exception when validation fails This route will not throw validation exception when expected{code}                validator().type("xml").withUri("validator:org/apache/camel/impl/validate.xsd");                from("direct:in").inputTypeWithValidate("xml")                    .to("mock:result");{code}
WeaveByType not working for OnExceptionDefinition in camel 2.21.0 Below is my route{code:java}OnException(Exception.class).handled(true).process(EXCEPTION_PROCESSOR).end()from("file:").process(SOME_PROCESSOR).to("file:");{code}During testing i want to investigate each exchange which goes through OnException block , for which i tried below{code:java}weaveByType(OnExceptionDefinition.class).after()                    .to(assertEndpoint){code}when i ran the test i got below error{code:java}java.lang.IllegalArgumentException: There are no outputs which matches: OnExceptionDefinition in the route{code}Could you please help in resolving this issue? Please note i have tried adding code mentioned below in test class, but still the same issue. {code:java}@Overridepublic boolean isUseAdviceWith() {    return true;}{code} Bug WeaveByType not working for OnExceptionDefinition in camel 2.21.0 Below is my route{code:java}OnException(Exception.class).handled(true).process(EXCEPTION_PROCESSOR).end()from("file:").process(SOME_PROCESSOR).to("file:");{code}During testing i want to investigate each exchange which goes through OnException block , for which i tried below{code:java}weaveByType(OnExceptionDefinition.class).after()                    .to(assertEndpoint){code}when i ran the test i got below error{code:java}java.lang.IllegalArgumentException: There are no outputs which matches: OnExceptionDefinition in the route{code}Could you please help in resolving this issue? Please note i have tried adding code mentioned below in test class, but still the same issue. {code:java}@Overridepublic boolean isUseAdviceWith() {    return true;}{code}
Camel Jms headers missing if producer endpoint has transferExchange=true The JMS headers are not being extracted if you use transferExchange=true. Bug Camel Jms headers missing if producer endpoint has transferExchange=true The JMS headers are not being extracted if you use transferExchange=true.
splitter with grouping looses encoding property Reported on user list and today also on gitterhttp://camel.465427.n5.nabble.com/File-Encoding-falls-back-to-default-encoding-while-grouping-after-split-using-tokenize-td5797769.htmlJakob Krejberg Ørhøj @jakoborhoj_twitter Sep 28 12:30Hello. I've been battling with some encoding issues when using split().tokenize() in Camel. I am having the same issue as described in: http://camel.465427.n5.nabble.com/File-Encoding-falls-back-to-default-encoding-while-grouping-after-split-using-tokenize-td5797769.html. Is it a bug that Camel does not pass the exchange to the converter so that it can get the encoding set in the exchange? Currently it will always default to UTF-8 as I see it. Bug splitter with grouping looses encoding property Reported on user list and today also on gitterhttp://camel.465427.n5.nabble.com/File-Encoding-falls-back-to-default-encoding-while-grouping-after-split-using-tokenize-td5797769.htmlJakob Krejberg Orhoj @jakoborhoj_twitter Sep 28 12:30Hello. I've been battling with some encoding issues when using split().tokenize() in Camel. I am having the same issue as described in: http://camel.465427.n5.nabble.com/File-Encoding-falls-back-to-default-encoding-while-grouping-after-split-using-tokenize-td5797769.html. Is it a bug that Camel does not pass the exchange to the converter so that it can get the encoding set in the exchange? Currently it will always default to UTF-8 as I see it.
Type Converter Loader Exception: Elasticsearch-Rest cannot find any in package defined {code:java}{{Error creating bean with name 'servletEndpointRegistrar' defined in class path resource [org/springframework/boot/actuate/autoconfigure/endpoint/web/ServletEndpointManagementContextConfiguration$WebMvcServletEndpointManagementContextConfiguration.class]: Bean instantiation via factory method failed; nested exception is org.springframework.beans.BeanInstantiationException: Failed to instantiate [org.springframework.boot.actuate.endpoint.web.ServletEndpointRegistrar]: Factory method 'servletEndpointRegistrar' threw exception; nested exception is org.springframework.beans.factory.UnsatisfiedDependencyException: Error creating bean with name 'routeControllerEndpoint' defined in class path resource [org/apache/camel/spring/boot/actuate/endpoint/CamelRouteControllerEndpointAutoConfiguration.class]: Unsatisfied dependency expressed through method 'routeControllerEndpoint' parameter 0; nested exception is org.springframework.beans.factory.BeanCreationException: Error creating bean with name 'camelContext' defined in class path resource [org/apache/camel/spring/boot/CamelAutoConfiguration.class]: Bean instantiation via factory method failed; nested exception is org.springframework.beans.BeanInstantiationException: Failed to instantiate [org.apache.camel.CamelContext]: Factory method 'camelContext' threw exception; nested exception is org.apache.camel.RuntimeCamelException: org.apache.camel.TypeConverterLoaderException: Failed to load type converters because of: Cannot find any type converter classes from the following packages: [org.apache.camel.component.elasticsearch.converter] }}{code}  A possible solution to this is to use FQN class names instead of package name Bug Type Converter Loader Exception: Elasticsearch-Rest cannot find any in package defined {code:java}{{Error creating bean with name 'servletEndpointRegistrar' defined in class path resource [org/springframework/boot/actuate/autoconfigure/endpoint/web/ServletEndpointManagementContextConfiguration$WebMvcServletEndpointManagementContextConfiguration.class]: Bean instantiation via factory method failed; nested exception is org.springframework.beans.BeanInstantiationException: Failed to instantiate [org.springframework.boot.actuate.endpoint.web.ServletEndpointRegistrar]: Factory method 'servletEndpointRegistrar' threw exception; nested exception is org.springframework.beans.factory.UnsatisfiedDependencyException: Error creating bean with name 'routeControllerEndpoint' defined in class path resource [org/apache/camel/spring/boot/actuate/endpoint/CamelRouteControllerEndpointAutoConfiguration.class]: Unsatisfied dependency expressed through method 'routeControllerEndpoint' parameter 0; nested exception is org.springframework.beans.factory.BeanCreationException: Error creating bean with name 'camelContext' defined in class path resource [org/apache/camel/spring/boot/CamelAutoConfiguration.class]: Bean instantiation via factory method failed; nested exception is org.springframework.beans.BeanInstantiationException: Failed to instantiate [org.apache.camel.CamelContext]: Factory method 'camelContext' threw exception; nested exception is org.apache.camel.RuntimeCamelException: org.apache.camel.TypeConverterLoaderException: Failed to load type converters because of: Cannot find any type converter classes from the following packages: [org.apache.camel.component.elasticsearch.converter] }}{code}  A possible solution to this is to use FQN class names instead of package name
camel-json-validator - Potential issue with reading from streams See SOhttps://stackoverflow.com/questions/52228692/camel-json-validator-throws-stream-closed-exception?noredirect=1#comment91912061_52228692 Bug camel-json-validator - Potential issue with reading from streams See SOhttps://stackoverflow.com/questions/52228692/camel-json-validator-throws-stream-closed-exception?noredirect=1#comment91912061_52228692
camel-http-common HttpSendDynamicAware setting port to -1 when port is not defined in uri If the route qualifies for SendDyanamicAware processing within the camel-http or camel-http4 component and the route does not specify a port it is getting set to -1.  This should simply assume port 80 or 443 based on http vs https.  Logic exists to trim those ports if they are specified however if you omit them your get the following exception: {code:java}2018-09-21T16:20:32,797 | ERROR | Camel (camel-2) thread #10 - NettyEventExecutorGroup | AbstractErrorListProcessor       | 26 - com.somebundle - 1.0.76 | Error Handled for route: http://0.0.0.0:8880/%7BsiteId%7D/%7Bcountry%7D/somepath?httpMethodRestrict=GETorg.apache.camel.ResolveEndpointFailedException: Failed to resolve endpoint: https4://somedomain.com:-1?bridgeEndpoint=true due to: Expected scheme-specific part at index 6: https:    at org.apache.camel.impl.DefaultCamelContext.getEndpoint(DefaultCamelContext.java:758) ~[91:org.apache.camel.camel-core:2.22.0]    at org.apache.camel.util.CamelContextHelper.getMandatoryEndpoint(CamelContextHelper.java:80) ~[91:org.apache.camel.camel-core:2.22.0]    at org.apache.camel.util.ExchangeHelper.resolveEndpoint(ExchangeHelper.java:91) ~[91:org.apache.camel.camel-core:2.22.0]    at org.apache.camel.processor.SendDynamicProcessor.resolveEndpoint(SendDynamicProcessor.java:239) ~[91:org.apache.camel.camel-core:2.22.0]    at org.apache.camel.processor.SendDynamicProcessor.process(SendDynamicProcessor.java:132) ~[91:org.apache.camel.camel-core:2.22.0]    at org.apache.camel.processor.interceptor.TraceInterceptor.process(TraceInterceptor.java:181) ~[91:org.apache.camel.camel-core:2.22.0]    at org.apache.camel.processor.InterceptorToAsyncProcessorBridge.process(InterceptorToAsyncProcessorBridge.java:67) ~[91:org.apache.camel.camel-core:2.22.0]{code} Bug camel-http-common HttpSendDynamicAware setting port to -1 when port is not defined in uri If the route qualifies for SendDyanamicAware processing within the camel-http or camel-http4 component and the route does not specify a port it is getting set to -1.  This should simply assume port 80 or 443 based on http vs https.  Logic exists to trim those ports if they are specified however if you omit them your get the following exception: {code:java}2018-09-21T16:20:32,797 | ERROR | Camel (camel-2) thread #10 - NettyEventExecutorGroup | AbstractErrorListProcessor       | 26 - com.somebundle - 1.0.76 | Error Handled for route: http://0.0.0.0:8880/%7BsiteId%7D/%7Bcountry%7D/somepath?httpMethodRestrict=GETorg.apache.camel.ResolveEndpointFailedException: Failed to resolve endpoint: https4://somedomain.com:-1?bridgeEndpoint=true due to: Expected scheme-specific part at index 6: https:    at org.apache.camel.impl.DefaultCamelContext.getEndpoint(DefaultCamelContext.java:758) ~[91:org.apache.camel.camel-core:2.22.0]    at org.apache.camel.util.CamelContextHelper.getMandatoryEndpoint(CamelContextHelper.java:80) ~[91:org.apache.camel.camel-core:2.22.0]    at org.apache.camel.util.ExchangeHelper.resolveEndpoint(ExchangeHelper.java:91) ~[91:org.apache.camel.camel-core:2.22.0]    at org.apache.camel.processor.SendDynamicProcessor.resolveEndpoint(SendDynamicProcessor.java:239) ~[91:org.apache.camel.camel-core:2.22.0]    at org.apache.camel.processor.SendDynamicProcessor.process(SendDynamicProcessor.java:132) ~[91:org.apache.camel.camel-core:2.22.0]    at org.apache.camel.processor.interceptor.TraceInterceptor.process(TraceInterceptor.java:181) ~[91:org.apache.camel.camel-core:2.22.0]    at org.apache.camel.processor.InterceptorToAsyncProcessorBridge.process(InterceptorToAsyncProcessorBridge.java:67) ~[91:org.apache.camel.camel-core:2.22.0]{code}
Fix MQTT URI param typo The URI params 'willQos' and 'qualityOfService' of the MQTT component have a typo in their enum description. Bug Fix MQTT URI param typo The URI params 'willQos' and 'qualityOfService' of the MQTT component have a typo in their enum description.
camel-restdsl-swagger-plugin doesn't convert integer default value to string When generating a RouteBuilder from a swagger that defines default parameter values of type integer, there is no conversion to a string when setting it:Swagger:"limit":{ "name":"limit", "in":"query", "type":"integer", "minimum":1, "default":20, "description":"the limit of the results for the collections query" },RouteBuilder:.param() .name("limit") .type(RestParamType.query) .dataType("integer") .defaultValue(20) .required(false) .description("the limit of the results for the collections query") .endParam()defaultValue only accepts parameters of type string and therefore the generated code can't be compiled and needs to be corrected manually.    Bug camel-restdsl-swagger-plugin doesn't convert integer default value to string When generating a RouteBuilder from a swagger that defines default parameter values of type integer, there is no conversion to a string when setting it:Swagger:"limit":{ "name":"limit", "in":"query", "type":"integer", "minimum":1, "default":20, "description":"the limit of the results for the collections query" },RouteBuilder:.param() .name("limit") .type(RestParamType.query) .dataType("integer") .defaultValue(20) .required(false) .description("the limit of the results for the collections query") .endParam()defaultValue only accepts parameters of type string and therefore the generated code can't be compiled and needs to be corrected manually.   
swagger-java - Provide more clear exception when model class is not visible to ClassResolver Within an OSGi the camel-swagger-java component be run within a different bundle than the routes and models required to generate the swagger document.  In this case the swagger code may not be able to read the model.  Currently this generates a Nullpointer Exception and the swagger document does not get rendered. Would prefer that the exception be more specific to help developers with debugging.  Also toyed with the idea of converting to a LOG statement instead of an exception but it may be better to fail fast. {code:java}org.apache.camel.camel-swagger-java - 2.22.0 | Error rendering Swagger API due nulljava.lang.NullPointerException: null    at org.apache.camel.swagger.RestModelConverters.readClass(RestModelConverters.java:32) ~[108:org.apache.camel.camel-swagger-java:2.22.0]    at org.apache.camel.swagger.RestSwaggerReader.appendModels(RestSwaggerReader.java:755) ~[108:org.apache.camel.camel-swagger-java:2.22.0]    at org.apache.camel.swagger.RestSwaggerReader.parse(RestSwaggerReader.java:227) ~[108:org.apache.camel.camel-swagger-java:2.22.0]    at org.apache.camel.swagger.RestSwaggerReader.read(RestSwaggerReader.java:113) ~[108:org.apache.camel.camel-swagger-java:2.22.0]    at org.apache.camel.swagger.RestSwaggerSupport.renderResourceListing(RestSwaggerSupport.java:210) ~[108:org.apache.camel.camel-swagger-java:2.22.0]    at org.apache.camel.swagger.RestSwaggerProcessor.process(RestSwaggerProcessor.java:119) [108:org.apache.camel.camel-swagger-java:2.22.0]    at org.apache.camel.component.rest.RestApiProducer.process(RestApiProducer.java:36) [89:org.apache.camel.camel-core:2.22.0]    at org.apache.camel.util.AsyncProcessorConverterHelper$ProcessorToAsyncProcessorBridge.process(AsyncProcessorConverterHelper.java:61) [89:org.apache.camel.camel-core:2.22.0]    at org.apache.camel.processor.SendProcessor.process(SendProcessor.java:148) [89:org.apache.camel.camel-core:2.22.0]    at org.apache.camel.processor.interceptor.TraceInterceptor.process(TraceInterceptor.java:181) [89:org.apache.camel.camel-core:2.22.0]    at org.apache.camel.processor.DelegateAsyncProcessor.process(DelegateAsyncProcessor.java:110) [89:org.apache.camel.camel-core:2.22.0]    at org.apache.camel.processor.RedeliveryErrorHandler.process(RedeliveryErrorHandler.java:548) [89:org.apache.camel.camel-core:2.22.0]    at org.apache.camel.processor.CamelInternalProcessor.process(CamelInternalProcessor.java:201) [89:org.apache.camel.camel-core:2.22.0]    at org.apache.camel.processor.CamelInternalProcessor.process(CamelInternalProcessor.java:201) [89:org.apache.camel.camel-core:2.22.0]    at org.apache.camel.component.netty4.handlers.ServerChannelHandler.processAsynchronously(ServerChannelHandler.java:141) [105:org.apache.camel.camel-netty4:2.22.0]    at org.apache.camel.component.netty4.handlers.ServerChannelHandler.channelRead0(ServerChannelHandler.java:112) [105:org.apache.camel.camel-netty4:2.22.0]    at org.apache.camel.component.netty4.http.handlers.HttpServerChannelHandler.channelRead0(HttpServerChannelHandler.java:213) [106:org.apache.camel.camel-netty4-http:2.22.0]    at io.netty.channel.SimpleChannelInboundHandler.channelRead(SimpleChannelInboundHandler.java:105) [55:io.netty.transport:4.1.25.Final]    at org.apache.camel.component.netty4.http.handlers.HttpServerMultiplexChannelHandler.channelRead0(HttpServerMultiplexChannelHandler.java:113) [106:org.apache.camel.camel-netty4-http:2.22.0]    at io.netty.channel.SimpleChannelInboundHandler.channelRead(SimpleChannelInboundHandler.java:105) [55:io.netty.transport:4.1.25.Final]    at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:362) [55:io.netty.transport:4.1.25.Final]    at io.netty.channel.AbstractChannelHandlerContext.access$600(AbstractChannelHandlerContext.java:38) [55:io.netty.transport:4.1.25.Final]    at io.netty.channel.AbstractChannelHandlerContext$7.run(AbstractChannelHandlerContext.java:353) [55:io.netty.transport:4.1.25.Final]    at io.netty.util.concurrent.DefaultEventExecutor.run(DefaultEventExecutor.java:66) [51:io.netty.common:4.1.25.Final]    at io.netty.util.concurrent.SingleThreadEventExecutor$5.run(SingleThreadEventExecutor.java:884) [51:io.netty.common:4.1.25.Final]    at java.lang.Thread.run(Thread.java:748) [?:?]{code} Bug swagger-java - Provide more clear exception when model class is not visible to ClassResolver Within an OSGi the camel-swagger-java component be run within a different bundle than the routes and models required to generate the swagger document.  In this case the swagger code may not be able to read the model.  Currently this generates a Nullpointer Exception and the swagger document does not get rendered. Would prefer that the exception be more specific to help developers with debugging.  Also toyed with the idea of converting to a LOG statement instead of an exception but it may be better to fail fast. {code:java}org.apache.camel.camel-swagger-java - 2.22.0 | Error rendering Swagger API due nulljava.lang.NullPointerException: null    at org.apache.camel.swagger.RestModelConverters.readClass(RestModelConverters.java:32) ~[108:org.apache.camel.camel-swagger-java:2.22.0]    at org.apache.camel.swagger.RestSwaggerReader.appendModels(RestSwaggerReader.java:755) ~[108:org.apache.camel.camel-swagger-java:2.22.0]    at org.apache.camel.swagger.RestSwaggerReader.parse(RestSwaggerReader.java:227) ~[108:org.apache.camel.camel-swagger-java:2.22.0]    at org.apache.camel.swagger.RestSwaggerReader.read(RestSwaggerReader.java:113) ~[108:org.apache.camel.camel-swagger-java:2.22.0]    at org.apache.camel.swagger.RestSwaggerSupport.renderResourceListing(RestSwaggerSupport.java:210) ~[108:org.apache.camel.camel-swagger-java:2.22.0]    at org.apache.camel.swagger.RestSwaggerProcessor.process(RestSwaggerProcessor.java:119) [108:org.apache.camel.camel-swagger-java:2.22.0]    at org.apache.camel.component.rest.RestApiProducer.process(RestApiProducer.java:36) [89:org.apache.camel.camel-core:2.22.0]    at org.apache.camel.util.AsyncProcessorConverterHelper$ProcessorToAsyncProcessorBridge.process(AsyncProcessorConverterHelper.java:61) [89:org.apache.camel.camel-core:2.22.0]    at org.apache.camel.processor.SendProcessor.process(SendProcessor.java:148) [89:org.apache.camel.camel-core:2.22.0]    at org.apache.camel.processor.interceptor.TraceInterceptor.process(TraceInterceptor.java:181) [89:org.apache.camel.camel-core:2.22.0]    at org.apache.camel.processor.DelegateAsyncProcessor.process(DelegateAsyncProcessor.java:110) [89:org.apache.camel.camel-core:2.22.0]    at org.apache.camel.processor.RedeliveryErrorHandler.process(RedeliveryErrorHandler.java:548) [89:org.apache.camel.camel-core:2.22.0]    at org.apache.camel.processor.CamelInternalProcessor.process(CamelInternalProcessor.java:201) [89:org.apache.camel.camel-core:2.22.0]    at org.apache.camel.processor.CamelInternalProcessor.process(CamelInternalProcessor.java:201) [89:org.apache.camel.camel-core:2.22.0]    at org.apache.camel.component.netty4.handlers.ServerChannelHandler.processAsynchronously(ServerChannelHandler.java:141) [105:org.apache.camel.camel-netty4:2.22.0]    at org.apache.camel.component.netty4.handlers.ServerChannelHandler.channelRead0(ServerChannelHandler.java:112) [105:org.apache.camel.camel-netty4:2.22.0]    at org.apache.camel.component.netty4.http.handlers.HttpServerChannelHandler.channelRead0(HttpServerChannelHandler.java:213) [106:org.apache.camel.camel-netty4-http:2.22.0]    at io.netty.channel.SimpleChannelInboundHandler.channelRead(SimpleChannelInboundHandler.java:105) [55:io.netty.transport:4.1.25.Final]    at org.apache.camel.component.netty4.http.handlers.HttpServerMultiplexChannelHandler.channelRead0(HttpServerMultiplexChannelHandler.java:113) [106:org.apache.camel.camel-netty4-http:2.22.0]    at io.netty.channel.SimpleChannelInboundHandler.channelRead(SimpleChannelInboundHandler.java:105) [55:io.netty.transport:4.1.25.Final]    at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:362) [55:io.netty.transport:4.1.25.Final]    at io.netty.channel.AbstractChannelHandlerContext.access$600(AbstractChannelHandlerContext.java:38) [55:io.netty.transport:4.1.25.Final]    at io.netty.channel.AbstractChannelHandlerContext$7.run(AbstractChannelHandlerContext.java:353) [55:io.netty.transport:4.1.25.Final]    at io.netty.util.concurrent.DefaultEventExecutor.run(DefaultEventExecutor.java:66) [51:io.netty.common:4.1.25.Final]    at io.netty.util.concurrent.SingleThreadEventExecutor$5.run(SingleThreadEventExecutor.java:884) [51:io.netty.common:4.1.25.Final]    at java.lang.Thread.run(Thread.java:748) [?:?]{code}
camel-spring-redis - When stopping consumer it should stop the message listener The consumer needs to remove the message listener when its stopping so it wont continue to receive messages, which otherwise can happen when shutting down Camel graceful. Bug camel-spring-redis - When stopping consumer it should stop the message listener The consumer needs to remove the message listener when its stopping so it wont continue to receive messages, which otherwise can happen when shutting down Camel graceful.
CamelCatalog - Should be JMX compliant We have this errorFailedorg.apache.camel.catalog.CamelCatalogMBeanExporterTest.testMBeanExporterFailing for the past 8 builds (Since Unstable#599 )Took 7 ms.Error Messageorg.apache.camel.catalog.CamelCatalog: Method org.apache.camel.catalog.CamelCatalog.setSuggestionStrategy has parameter or return type that cannot be translated into an open typeStacktracejavax.management.NotCompliantMBeanException: org.apache.camel.catalog.CamelCatalog: Method org.apache.camel.catalog.CamelCatalog.setSuggestionStrategy has parameter or return type that cannot be translated into an open type	at org.apache.camel.catalog.CamelCatalogMBeanExporterTest.testMBeanExporter(CamelCatalogMBeanExporterTest.java:35)Caused by: java.lang.IllegalArgumentException: Method org.apache.camel.catalog.CamelCatalog.setSuggestionStrategy has parameter or return type that cannot be translated into an open type	at org.apache.camel.catalog.CamelCatalogMBeanExporterTest.testMBeanExporter(CamelCatalogMBeanExporterTest.java:35)Caused by: javax.management.openmbean.OpenDataException: Cannot convert type: org.apache.camel.catalog.SuggestionStrategy	at org.apache.camel.catalog.CamelCatalogMBeanExporterTest.testMBeanExporter(CamelCatalogMBeanExporterTest.java:35)Caused by: javax.management.openmbean.OpenDataException: Can't map org.apache.camel.catalog.SuggestionStrategy to an open data type	at org.apache.camel.catalog.CamelCatalogMBeanExporterTest.testMBeanExporter(CamelCatalogMBeanExporterTest.java:35) Bug CamelCatalog - Should be JMX compliant We have this errorFailedorg.apache.camel.catalog.CamelCatalogMBeanExporterTest.testMBeanExporterFailing for the past 8 builds (Since Unstable#599 )Took 7 ms.Error Messageorg.apache.camel.catalog.CamelCatalog: Method org.apache.camel.catalog.CamelCatalog.setSuggestionStrategy has parameter or return type that cannot be translated into an open typeStacktracejavax.management.NotCompliantMBeanException: org.apache.camel.catalog.CamelCatalog: Method org.apache.camel.catalog.CamelCatalog.setSuggestionStrategy has parameter or return type that cannot be translated into an open type	at org.apache.camel.catalog.CamelCatalogMBeanExporterTest.testMBeanExporter(CamelCatalogMBeanExporterTest.java:35)Caused by: java.lang.IllegalArgumentException: Method org.apache.camel.catalog.CamelCatalog.setSuggestionStrategy has parameter or return type that cannot be translated into an open type	at org.apache.camel.catalog.CamelCatalogMBeanExporterTest.testMBeanExporter(CamelCatalogMBeanExporterTest.java:35)Caused by: javax.management.openmbean.OpenDataException: Cannot convert type: org.apache.camel.catalog.SuggestionStrategy	at org.apache.camel.catalog.CamelCatalogMBeanExporterTest.testMBeanExporter(CamelCatalogMBeanExporterTest.java:35)Caused by: javax.management.openmbean.OpenDataException: Can't map org.apache.camel.catalog.SuggestionStrategy to an open data type	at org.apache.camel.catalog.CamelCatalogMBeanExporterTest.testMBeanExporter(CamelCatalogMBeanExporterTest.java:35)
Using StubComponent can block routes depending on MEP As the name implies and per the documentation 'stub:' should be a no-op.However, if the exchange pattarn is InOut, routes are actually blocked waiting for a response.Discovered against camel 2.16.3Confirmed against Camel 2.22.0 (see attached test-case)  Bug Using StubComponent can block routes depending on MEP As the name implies and per the documentation 'stub:' should be a no-op.However, if the exchange pattarn is InOut, routes are actually blocked waiting for a response.Discovered against camel 2.16.3Confirmed against Camel 2.22.0 (see attached test-case) 
OPTIONS Http request on REST resource returns incorrect content of Allow header I have a REST resource which consumes multiple Http methods (for example GET, POST and PUT). If I send OPTIONS request to resource and I expect to receive Allow Http header with this content:Allow: GET,POST,PUT,OPTIONSThat does not happen because I receive header which contains only two methods one of them is OPTIONS.Allow: GET,OPTIONSI have try multiple implementations and only camel-restlet works as I expect. These components contain bug:camel-undertowcamel-servletcamel-jettycamel-netty4-http Bug OPTIONS Http request on REST resource returns incorrect content of Allow header I have a REST resource which consumes multiple Http methods (for example GET, POST and PUT). If I send OPTIONS request to resource and I expect to receive Allow Http header with this content:Allow: GET,POST,PUT,OPTIONSThat does not happen because I receive header which contains only two methods one of them is OPTIONS.Allow: GET,OPTIONSI have try multiple implementations and only camel-restlet works as I expect. These components contain bug:camel-undertowcamel-servletcamel-jettycamel-netty4-http
Temporary reply queues being created with main endpoint autoAck setting As discussed here:[http://camel.465427.n5.nabble.com/Camel-with-Rabbitmq-messages-in-temp-reply-queue-not-being-acked-td5822286.html]When temporary reply queues are used on InOut capable routes with autoAck set to false on the main queue(s) the reply messages keep piling up in the temporary queue in an un-acked state until a consumer restart.This can be prevented with a change to the TemporaryQueueReplyManager line 139 to always start the consumer of temprary queues with auto acknowledge mode of true.Changing this:    private void start() throws IOException {        tag = channel.basicConsume(getReplyTo(), endpoint.isAutoAck(), this);    }To:    private void start() throws IOException {        tag = channel.basicConsume(getReplyTo(), *true*, this);    }  Bug Temporary reply queues being created with main endpoint autoAck setting As discussed here:[http://camel.465427.n5.nabble.com/Camel-with-Rabbitmq-messages-in-temp-reply-queue-not-being-acked-td5822286.html]When temporary reply queues are used on InOut capable routes with autoAck set to false on the main queue(s) the reply messages keep piling up in the temporary queue in an un-acked state until a consumer restart.This can be prevented with a change to the TemporaryQueueReplyManager line 139 to always start the consumer of temprary queues with auto acknowledge mode of true.Changing this:    private void start() throws IOException {        tag = channel.basicConsume(getReplyTo(), endpoint.isAutoAck(), this);    }To:    private void start() throws IOException {        tag = channel.basicConsume(getReplyTo(), *true*, this);    } 
Olingo4Component creates and ignores HttpAsyncClientBuilder The Olingo4Component will create an instance of HttpAsyncClientBuilder is the provided Olingo4Configuration does not contain one. The new instance of HttpAsyncClientBuilder will be configured with timeout settings, proxy and SSL, but will never be used.Extract from Olingo4Component.createOlingo4App:{code:java}Object clientBuilder = configuration.getHttpAsyncClientBuilder();if (clientBuilder == null) {    HttpAsyncClientBuilder asyncClientBuilder = HttpAsyncClientBuilder.create();    Builder requestConfigBuilder = RequestConfig.custom();    requestConfigBuilder.setConnectTimeout(configuration.getConnectTimeout());    requestConfigBuilder.setSocketTimeout(configuration.getSocketTimeout());    HttpHost proxy = configuration.getProxy();    if (proxy != null) {        requestConfigBuilder.setProxy(proxy);    }    asyncClientBuilder.setDefaultRequestConfig(requestConfigBuilder.build());    SSLContextParameters sslContextParameters = configuration.getSslContextParameters();    if (sslContextParameters == null) {        sslContextParameters = this.retrieveGlobalSslContextParameters();    }    if (sslContextParameters == null) {        sslContextParameters = new SSLContextParameters();    }    try {        asyncClientBuilder.setSSLContext(sslContextParameters.createSSLContext(this.getCamelContext()));    } catch (GeneralSecurityException var8) {        throw ObjectHelper.wrapRuntimeCamelException(var8);    } catch (IOException var9) {        throw ObjectHelper.wrapRuntimeCamelException(var9);    }}Olingo4AppImpl olingo4App;if (clientBuilder != null && !(clientBuilder instanceof HttpAsyncClientBuilder)) {    olingo4App = new Olingo4AppImpl(configuration.getServiceUri(), (HttpClientBuilder)clientBuilder);} else {    olingo4App = new Olingo4AppImpl(configuration.getServiceUri(), (HttpAsyncClientBuilder)clientBuilder);}{code}The class Olingo4AppImpl gets a null clientBuilder reference and then instantiates its own:{code:java}public Olingo4AppImpl(String serviceUri, HttpAsyncClientBuilder builder) {    this.odataClient = ODataClientFactory.getClient();    this.odataReader = this.odataClient.getReader();    this.odataWriter = this.odataClient.getWriter();    this.setServiceUri(serviceUri);    CloseableHttpAsyncClient asyncClient;    if (builder == null) {        asyncClient = HttpAsyncClients.createDefault();    } else {        asyncClient = builder.build();    }    asyncClient.start();    this.client = asyncClient;    this.contentType = DEFAULT_CONTENT_TYPE;}{code}Because of this, none of the Olingo4Configuration settings are used and for example connect and socket timeout defaults to -1. Bug Olingo4Component creates and ignores HttpAsyncClientBuilder The Olingo4Component will create an instance of HttpAsyncClientBuilder is the provided Olingo4Configuration does not contain one. The new instance of HttpAsyncClientBuilder will be configured with timeout settings, proxy and SSL, but will never be used.Extract from Olingo4Component.createOlingo4App:{code:java}Object clientBuilder = configuration.getHttpAsyncClientBuilder();if (clientBuilder == null) {    HttpAsyncClientBuilder asyncClientBuilder = HttpAsyncClientBuilder.create();    Builder requestConfigBuilder = RequestConfig.custom();    requestConfigBuilder.setConnectTimeout(configuration.getConnectTimeout());    requestConfigBuilder.setSocketTimeout(configuration.getSocketTimeout());    HttpHost proxy = configuration.getProxy();    if (proxy != null) {        requestConfigBuilder.setProxy(proxy);    }    asyncClientBuilder.setDefaultRequestConfig(requestConfigBuilder.build());    SSLContextParameters sslContextParameters = configuration.getSslContextParameters();    if (sslContextParameters == null) {        sslContextParameters = this.retrieveGlobalSslContextParameters();    }    if (sslContextParameters == null) {        sslContextParameters = new SSLContextParameters();    }    try {        asyncClientBuilder.setSSLContext(sslContextParameters.createSSLContext(this.getCamelContext()));    } catch (GeneralSecurityException var8) {        throw ObjectHelper.wrapRuntimeCamelException(var8);    } catch (IOException var9) {        throw ObjectHelper.wrapRuntimeCamelException(var9);    }}Olingo4AppImpl olingo4App;if (clientBuilder != null && !(clientBuilder instanceof HttpAsyncClientBuilder)) {    olingo4App = new Olingo4AppImpl(configuration.getServiceUri(), (HttpClientBuilder)clientBuilder);} else {    olingo4App = new Olingo4AppImpl(configuration.getServiceUri(), (HttpAsyncClientBuilder)clientBuilder);}{code}The class Olingo4AppImpl gets a null clientBuilder reference and then instantiates its own:{code:java}public Olingo4AppImpl(String serviceUri, HttpAsyncClientBuilder builder) {    this.odataClient = ODataClientFactory.getClient();    this.odataReader = this.odataClient.getReader();    this.odataWriter = this.odataClient.getWriter();    this.setServiceUri(serviceUri);    CloseableHttpAsyncClient asyncClient;    if (builder == null) {        asyncClient = HttpAsyncClients.createDefault();    } else {        asyncClient = builder.build();    }    asyncClient.start();    this.client = asyncClient;    this.contentType = DEFAULT_CONTENT_TYPE;}{code}Because of this, none of the Olingo4Configuration settings are used and for example connect and socket timeout defaults to -1.
TypeConverters are not registered to all contexts When using multiple Camel contexts in CDI, auto-discovered TypeConverters are registered only to the first encoutered context. Bug TypeConverters are not registered to all contexts When using multiple Camel contexts in CDI, auto-discovered TypeConverters are registered only to the first encoutered context.
Kafka manual commit to file repository doesn't work properly (using Spring boot) I'im trying to save the Kafka offset into FileStateRepository, the offset is correctly writing but it is not reading at route start so camel will read all the topic every time {code:java}@Componentpublic class Route extends RouteBuilder {    @Override    public void configure() throws Exception {        from(kafka())                .to("log:TEST?level=INFO")                .process(Route::commitKafka);    }    private String kafka() {        String kafkaEndpoint = "kafka:";        kafkaEndpoint += "topictest";        kafkaEndpoint += "?brokers=";        kafkaEndpoint += "localhost:9092";        kafkaEndpoint += "&groupId=";        kafkaEndpoint += "TEST";        kafkaEndpoint += "&autoOffsetReset=";        kafkaEndpoint += "earliest";        kafkaEndpoint += "&autoCommitEnable=";        kafkaEndpoint += false;        kafkaEndpoint += "&allowManualCommit=";        kafkaEndpoint += true;        kafkaEndpoint += "&offsetRepository=";        kafkaEndpoint += "#fileStore";        return kafkaEndpoint;    }    @Bean(name = "fileStore")    private FileStateRepository fileStateRepository() {        FileStateRepository fileStateRepository = FileStateRepository.fileStateRepository(new File("/kafka/offset_repo/repo.dat"));        // This will be empty        // System.out.println(fileStateRepository.getCache());        return fileStateRepository;    }    private static void commitKafka(Exchange exchange) {        KafkaManualCommit manual = exchange.getIn().getHeader(KafkaConstants.MANUAL_COMMIT, KafkaManualCommit.class);        manual.commitSync();    }}{code}  Bug Kafka manual commit to file repository doesn't work properly (using Spring boot) I'im trying to save the Kafka offset into FileStateRepository, the offset is correctly writing but it is not reading at route start so camel will read all the topic every time {code:java}@Componentpublic class Route extends RouteBuilder {    @Override    public void configure() throws Exception {        from(kafka())                .to("log:TEST?level=INFO")                .process(Route::commitKafka);    }    private String kafka() {        String kafkaEndpoint = "kafka:";        kafkaEndpoint += "topictest";        kafkaEndpoint += "?brokers=";        kafkaEndpoint += "localhost:9092";        kafkaEndpoint += "&groupId=";        kafkaEndpoint += "TEST";        kafkaEndpoint += "&autoOffsetReset=";        kafkaEndpoint += "earliest";        kafkaEndpoint += "&autoCommitEnable=";        kafkaEndpoint += false;        kafkaEndpoint += "&allowManualCommit=";        kafkaEndpoint += true;        kafkaEndpoint += "&offsetRepository=";        kafkaEndpoint += "#fileStore";        return kafkaEndpoint;    }    @Bean(name = "fileStore")    private FileStateRepository fileStateRepository() {        FileStateRepository fileStateRepository = FileStateRepository.fileStateRepository(new File("/kafka/offset_repo/repo.dat"));        // This will be empty        // System.out.println(fileStateRepository.getCache());        return fileStateRepository;    }    private static void commitKafka(Exchange exchange) {        KafkaManualCommit manual = exchange.getIn().getHeader(KafkaConstants.MANUAL_COMMIT, KafkaManualCommit.class);        manual.commitSync();    }}{code} 
java.util.ConcurrentModificationException at org.apache.camel.impl.DefaultExchange.createProperties(DefaultExchange.java:550) in 2.20.1 A concurrent access exception occurs during our load tests while consuming messages from a rabbitmq queue.The call stack embedded below shows that the issue is related to an "optimization" which was introduced in https://issues.apache.org/jira/browse/CAMEL-11330 to replace a ConcurrentHashMap with a regular one from version 2.19.5 to 2.20.0 onward.The faulty code is still present in latest 2.22.0.   Bug java.util.ConcurrentModificationException at org.apache.camel.impl.DefaultExchange.createProperties(DefaultExchange.java:550) in 2.20.1 A concurrent access exception occurs during our load tests while consuming messages from a rabbitmq queue.The call stack embedded below shows that the issue is related to an "optimization" which was introduced in https://issues.apache.org/jira/browse/CAMEL-11330 to replace a ConcurrentHashMap with a regular one from version 2.19.5 to 2.20.0 onward.The faulty code is still present in latest 2.22.0.  
relative paths can remove scheme from xslt URI When using relative paths in an XSLT referenced from another one, the used URI scheme may be ignored.e.g. in case of an XSLT specified by URI "classpath:location/master.xsl",  that includes another one:  <xsl:include href="../child.xsl"/>In this case, the URI of child.xsl is resolved as just "child.xsl" instead of "classpath:child.xsl", omitting the URI scheme.The cause is XsltUriResolver, in which FileUtil.compactPath() is used to calculate the relative URI, but this call ignores the colon separator and considers "classpath:location" as a single path part.I'm creating a pull request which passes the URI without scheme to FileUtil.compactPath(). Bug relative paths can remove scheme from xslt URI When using relative paths in an XSLT referenced from another one, the used URI scheme may be ignored.e.g. in case of an XSLT specified by URI "classpath:location/master.xsl",  that includes another one:  <xsl:include href="../child.xsl"/>In this case, the URI of child.xsl is resolved as just "child.xsl" instead of "classpath:child.xsl", omitting the URI scheme.The cause is XsltUriResolver, in which FileUtil.compactPath() is used to calculate the relative URI, but this call ignores the colon separator and considers "classpath:location" as a single path part.I'm creating a pull request which passes the URI without scheme to FileUtil.compactPath().
UseOriginalAggregationStrategy in outer loops Using splitters with the UseOriginalAggregationStrategy +in a loop+ causes the splitter to return always the same original exchange. {code:java}// my code is similar to the following one:from("direct:myLoop")  .loop(simple("{{export.maxLoopsPerRun}}"))    .setHeader(...) // changing header fields    .split(body(), new UseOriginalAggregationStrategy(null, false))      .to("direct:handleRecord")    .end()    .log("${in.headers}") // the headers of the exchange of the very first loop iteration  .end(){code}Reason: Once the original exchange is set by UseOriginalAggregationStrategy#setOriginal(Exchange), it is not updated any more for loop iterations > 1.  Bug UseOriginalAggregationStrategy in outer loops Using splitters with the UseOriginalAggregationStrategy +in a loop+ causes the splitter to return always the same original exchange. {code:java}// my code is similar to the following one:from("direct:myLoop")  .loop(simple("{{export.maxLoopsPerRun}}"))    .setHeader(...) // changing header fields    .split(body(), new UseOriginalAggregationStrategy(null, false))      .to("direct:handleRecord")    .end()    .log("${in.headers}") // the headers of the exchange of the very first loop iteration  .end(){code}Reason: Once the original exchange is set by UseOriginalAggregationStrategy#setOriginal(Exchange), it is not updated any more for loop iterations > 1. 
Optimising toD via SendDynamicAware component removes the 3rd octet from IP address IP address 10.192.1.10 is optimized as 10.192.10{code:java}DEBUG in SendDynamicProcessor:264 [main] - DynamicSendTo sendTo(netty4-http:http://10.192.1.10:8080/client/alerts/summary?throwExceptionOnFailure=false) using ProducerCache with default cache sizeDEBUG in SendDynamicProcessor:125 [Camel (camel-1) thread #6 - seda://alertSummary] - Optimising toD via SendDynamicAware component: netty4-http to use static uri: netty4-http:http:10.192.10:8080/path?throwExceptionOnFailure=false{code}The issue seems to be in AbstractCamelCatalog class, method "doAsEndpointUri(String scheme, Map<String, String> properties, String ampersand, boolean encode) throws URISyntaxException" Bug Optimising toD via SendDynamicAware component removes the 3rd octet from IP address IP address 10.192.1.10 is optimized as 10.192.10{code:java}DEBUG in SendDynamicProcessor:264 [main] - DynamicSendTo sendTo(netty4-http:http://10.192.1.10:8080/client/alerts/summary?throwExceptionOnFailure=false) using ProducerCache with default cache sizeDEBUG in SendDynamicProcessor:125 [Camel (camel-1) thread #6 - seda://alertSummary] - Optimising toD via SendDynamicAware component: netty4-http to use static uri: netty4-http:http:10.192.10:8080/path?throwExceptionOnFailure=false{code}The issue seems to be in AbstractCamelCatalog class, method "doAsEndpointUri(String scheme, Map<String, String> properties, String ampersand, boolean encode) throws URISyntaxException"
camel-zipkin - Root Span Id is not reported if the route calls multiple route Camel-Zipkin does not report traces with root span id when there are multiple routes. For example:  {code:java}from("direct:foo")        .delay(1000)        .to("direct:bar")        .to("direct:moo")        .to("direct:tar");from("direct:bar")        .delay(2000);from("direct:moo")        .delay(1000);from("direct:tar")        .delay(3000);{code}Root SpanId(TraceId) should be for service-name = direct:foo and the trace in UI should show all the 4 routes in one sequence. But it breaks. Check the attached screenshot: Traces Breaking.pngI looked into the code and figured out why its happening. Here is the code which is breaking the functionality.Class Name: ZipkinTracer.ZipkinRoutePolicyInside onExchangeBegin() method  {code:java}// add on completion after the route is done, but before the consumer writes the response// this allows us to track the zipkin event before returning the response which is the right timeexchange.addOnCompletion(new SynchronizationAdapter() {    @Override    public void onAfterRoute(Route route, Exchange exchange) {        String serviceName = getServiceName(exchange, route.getEndpoint(), true, false);        Brave brave = getBrave(serviceName);        if (brave != null) {            serverResponse(brave, serviceName, exchange);        }    }    @Override    public String toString() {        return "ZipkinTracerOnCompletion[" + routeId + "]";    }});{code}  Using onAfterRoute() :  if the exchange is being routed through multiple routes, there will be callbacks for each route.I have fix for it: If I use onExchangeDone() instead of above code. The traces are reported properly.  Check screenshots.[https://zipkin.io/pages/instrumenting.html]*Note* This process must be repeated if the service makes multiple downstream calls. That is each subsequent span will have the same trace id and parent id, but a new and different span id. Bug camel-zipkin - Root Span Id is not reported if the route calls multiple route Camel-Zipkin does not report traces with root span id when there are multiple routes. For example:  {code:java}from("direct:foo")        .delay(1000)        .to("direct:bar")        .to("direct:moo")        .to("direct:tar");from("direct:bar")        .delay(2000);from("direct:moo")        .delay(1000);from("direct:tar")        .delay(3000);{code}Root SpanId(TraceId) should be for service-name = direct:foo and the trace in UI should show all the 4 routes in one sequence. But it breaks. Check the attached screenshot: Traces Breaking.pngI looked into the code and figured out why its happening. Here is the code which is breaking the functionality.Class Name: ZipkinTracer.ZipkinRoutePolicyInside onExchangeBegin() method  {code:java}// add on completion after the route is done, but before the consumer writes the response// this allows us to track the zipkin event before returning the response which is the right timeexchange.addOnCompletion(new SynchronizationAdapter() {    @Override    public void onAfterRoute(Route route, Exchange exchange) {        String serviceName = getServiceName(exchange, route.getEndpoint(), true, false);        Brave brave = getBrave(serviceName);        if (brave != null) {            serverResponse(brave, serviceName, exchange);        }    }    @Override    public String toString() {        return "ZipkinTracerOnCompletion[" + routeId + "]";    }});{code}  Using onAfterRoute() :  if the exchange is being routed through multiple routes, there will be callbacks for each route.I have fix for it: If I use onExchangeDone() instead of above code. The traces are reported properly.  Check screenshots.[https://zipkin.io/pages/instrumenting.html]*Note* This process must be repeated if the service makes multiple downstream calls. That is each subsequent span will have the same trace id and parent id, but a new and different span id.
ExchangeSentEvent not fired if no EventNotifier is accepting ExchangeSendingEvent Due to changes in CAMEL-11346, many processors (including SendProcessor) no longer send ExchangeSentEvent when processing is done. The StopWatch object is not created when EventHelper.notifyExchangeSending returns false. If no EventNotifier is registered to receive that event, it will be false. But an EventNotifier may still be registered to receive ExchangeSentEvent. The StopWatch should be created when there is an EventNotifier registered for ExchangeSentEvent even when ExchangeSendingEvent is not, unless those events are always required to be paired together. Bug ExchangeSentEvent not fired if no EventNotifier is accepting ExchangeSendingEvent Due to changes in CAMEL-11346, many processors (including SendProcessor) no longer send ExchangeSentEvent when processing is done. The StopWatch object is not created when EventHelper.notifyExchangeSending returns false. If no EventNotifier is registered to receive that event, it will be false. But an EventNotifier may still be registered to receive ExchangeSentEvent. The StopWatch should be created when there is an EventNotifier registered for ExchangeSentEvent even when ExchangeSendingEvent is not, unless those events are always required to be paired together.
DefaultFluentProducerTemplate is not thread safe I think we have rediscovered the CAMEL-10820 bug. A body of one request gets replaced with a body of proceeding request, in our case we use *request()* method instead of *asyncSend()*.We use camel together with spring-boot. Consider following code: {code:java}@Servicepublic class UseCamelService {   private FluentProducerTemplate producer;   @Autowired   public UseCamelService(FluentProducerTemplate producer) {      this.producer = producer;   }   public String getValueFromCamel(String body) {      return producer.to("route").withBody(body).request(String.class);   }}{code}If *UseCamelService.getValueFromCamel()* gets called from two different threads it is possible for the latter one to override the body of the first one. Bug DefaultFluentProducerTemplate is not thread safe I think we have rediscovered the CAMEL-10820 bug. A body of one request gets replaced with a body of proceeding request, in our case we use *request()* method instead of *asyncSend()*.We use camel together with spring-boot. Consider following code: {code:java}@Servicepublic class UseCamelService {   private FluentProducerTemplate producer;   @Autowired   public UseCamelService(FluentProducerTemplate producer) {      this.producer = producer;   }   public String getValueFromCamel(String body) {      return producer.to("route").withBody(body).request(String.class);   }}{code}If *UseCamelService.getValueFromCamel()* gets called from two different threads it is possible for the latter one to override the body of the first one.
Camel Tracing is not working for route with redelivery strategy Camel Tracing is not being executed if there is redelivery strategy defined. In our context we have switched on the camel Tracer with the following:{code:java}    public static void main(String[] args) throws Exception {        DefaultCamelContext context = new DefaultCamelContext();        context.addRoutes(new RouteBuilder() {            @Override            public void configure() throws Exception {                // If errorHandler with redelivery is removed then tracer output is visible again.                errorHandler(new DefaultErrorHandlerBuilder().maximumRedeliveries(3).redeliveryDelay(2000L));                from("direct:start").process(new Processor() {                    public void process(Exchange exchange) throws Exception {                        System.out.println("PROCESSED");                    }                });            }        });        // Enable Tracer.        context.setTracing(true);        context.start();        ProducerTemplate template = context.createProducerTemplate();        template.sendBody("direct:start", "foo");    }{code}We noticed that we were missing output from the tracer that we were excepting.If you remove the errohandler with redelivery you can see the output we expected: {code:java}[main] INFO org.apache.camel.processor.interceptor.Tracer - ID-rmm-xxx-xxx-x-x >>> (route1) from(direct://start) --> Processor@0x130d63be <<< Pattern:InOnly, Headers:{breadcrumbId=ID-rmm-xxx-xxx-x-x}, BodyType:String, Body:foo{code}  Bug Camel Tracing is not working for route with redelivery strategy Camel Tracing is not being executed if there is redelivery strategy defined. In our context we have switched on the camel Tracer with the following:{code:java}    public static void main(String[] args) throws Exception {        DefaultCamelContext context = new DefaultCamelContext();        context.addRoutes(new RouteBuilder() {            @Override            public void configure() throws Exception {                // If errorHandler with redelivery is removed then tracer output is visible again.                errorHandler(new DefaultErrorHandlerBuilder().maximumRedeliveries(3).redeliveryDelay(2000L));                from("direct:start").process(new Processor() {                    public void process(Exchange exchange) throws Exception {                        System.out.println("PROCESSED");                    }                });            }        });        // Enable Tracer.        context.setTracing(true);        context.start();        ProducerTemplate template = context.createProducerTemplate();        template.sendBody("direct:start", "foo");    }{code}We noticed that we were missing output from the tracer that we were excepting.If you remove the errohandler with redelivery you can see the output we expected: {code:java}[main] INFO org.apache.camel.processor.interceptor.Tracer - ID-rmm-xxx-xxx-x-x >>> (route1) from(direct://start) --> Processor@0x130d63be <<< Pattern:InOnly, Headers:{breadcrumbId=ID-rmm-xxx-xxx-x-x}, BodyType:String, Body:foo{code} 
Camel bean component invokes cached instance of bean (that impl processor) in Registry Related SO question: [https://stackoverflow.com/questions/51108913/camel-bean-component-invokes-cached-instance-of-named-dependent-bean]Every invocation of bean component should query Registry for actual instance. Now it is cached in {{BeanProcessor#delegate}} variable, even if endpoint parameter {{cache=false}} specified.This behavior breaks java-ee compliance: [https://docs.oracle.com/javaee/7/api/javax/enterprise/context/Dependent.html]{quote}Every invocation of the [{{Context.get(Contextual, CreationalContext)}}|https://docs.oracle.com/javaee/7/api/javax/enterprise/context/spi/Context.html#get-javax.enterprise.context.spi.Contextual-javax.enterprise.context.spi.CreationalContext-] operation of the context object for the {{@Dependent}} scope returns a new instance of the given bean.{quote}Marking this as Major, because upgrading of Camel from 2.19.x to 2.2x.x leads to unpredictable results in CDI environment. Since this is tied to CDI environment, this issue is hard to notice even in well junit covered application and can result in major issues in pre-production or production environment.Full reproducible project with unit test and deployable WAR package, which passes with 2.19.x and lower. Fails with 2.20.x and higher [on Github|https://github.com/bedlaj/camel-dependent-bean]. Attachments are based on version 2.21.1 Bug Camel bean component invokes cached instance of bean (that impl processor) in Registry Related SO question: [https://stackoverflow.com/questions/51108913/camel-bean-component-invokes-cached-instance-of-named-dependent-bean]Every invocation of bean component should query Registry for actual instance. Now it is cached in {{BeanProcessor#delegate}} variable, even if endpoint parameter {{cache=false}} specified.This behavior breaks java-ee compliance: [https://docs.oracle.com/javaee/7/api/javax/enterprise/context/Dependent.html]{quote}Every invocation of the [{{Context.get(Contextual, CreationalContext)}}|https://docs.oracle.com/javaee/7/api/javax/enterprise/context/spi/Context.html#get-javax.enterprise.context.spi.Contextual-javax.enterprise.context.spi.CreationalContext-] operation of the context object for the {{@Dependent}} scope returns a new instance of the given bean.{quote}Marking this as Major, because upgrading of Camel from 2.19.x to 2.2x.x leads to unpredictable results in CDI environment. Since this is tied to CDI environment, this issue is hard to notice even in well junit covered application and can result in major issues in pre-production or production environment.Full reproducible project with unit test and deployable WAR package, which passes with 2.19.x and lower. Fails with 2.20.x and higher [on Github|https://github.com/bedlaj/camel-dependent-bean]. Attachments are based on version 2.21.1
Rest Producer - Query Parameters : Wrong query parameter name is used when header substitution is performed  CAMEL-11050 [https://github.com/apache/camel/commit/35638b280be7ca43031ea4c5d937590f30495e70]Introduced a bug in this line [https://github.com/apache/camel/blob/6938a4ea6b68e295fae48f52e8e7cb2628f161a3/camel-core/src/main/java/org/apache/camel/component/rest/RestProducer.java#L409] The fix is (probably) to replace the line with :params.put(entry.getKey(), value);    Bug Rest Producer - Query Parameters : Wrong query parameter name is used when header substitution is performed  CAMEL-11050 [https://github.com/apache/camel/commit/35638b280be7ca43031ea4c5d937590f30495e70]Introduced a bug in this line [https://github.com/apache/camel/blob/6938a4ea6b68e295fae48f52e8e7cb2628f161a3/camel-core/src/main/java/org/apache/camel/component/rest/RestProducer.java#L409] The fix is (probably) to replace the line with :params.put(entry.getKey(), value);   
Type converter confusion when camel-cxf and camel-mail are in same classpath The CxfRsProducer needs to find a converter to take the String body of an exchange message and turn it into an Object[]. However when camel-mail is present in the classpath the converter search method picks:   com.sun.mail.imap.SortTerm[] org.apache.camel.component.mail.MailConverters.toSortTerm(String msg)  This causes the CxfRsProducer to bomb on a NoSuchMethodException.   If camel-mail is removed, the CxfRsProducer client works, finding the right String -> Object[] converter.[Issue discussed here on Camel user mailing list|http://camel.465427.n5.nabble.com/Type-converter-misbehavior-with-camel-cxf-and-camel-mail-td5820546.html]  Bug Type converter confusion when camel-cxf and camel-mail are in same classpath The CxfRsProducer needs to find a converter to take the String body of an exchange message and turn it into an Object[]. However when camel-mail is present in the classpath the converter search method picks:   com.sun.mail.imap.SortTerm[] org.apache.camel.component.mail.MailConverters.toSortTerm(String msg)  This causes the CxfRsProducer to bomb on a NoSuchMethodException.   If camel-mail is removed, the CxfRsProducer client works, finding the right String -> Object[] converter.[Issue discussed here on Camel user mailing list|http://camel.465427.n5.nabble.com/Type-converter-misbehavior-with-camel-cxf-and-camel-mail-td5820546.html] 
Surviving Header AGGREGATION_COMPLETE_ALL_GROUPS_INCLUSIVE affects following aggregations When AGGREGATION_COMPLETE_ALL_GROUPS_INCLUSIVE is once set true it survives current aggregation processing and affects in unexpected way following aggregation by triggering "forceCompletionOfAllGroups()" againin next code snippet might be needed some additional handling when the header is true:{code:java}protected void doProcess(Exchange exchange) throws Exception {...        // check for the special header to force completion of all groups (inclusive of the message)        boolean completeAllGroupsInclusive = exchange.getIn().getHeader(Exchange.AGGREGATION_COMPLETE_ALL_GROUPS_INCLUSIVE, false, boolean.class);        if (completeAllGroupsInclusive) {            forceCompletionOfAllGroups();        }...{code}this consideration is made by analysing similar behavior and lifecycle of header AGGREGATION_COMPLETE_ALL_GROUPS:{code:java}private List<Exchange> doAggregation(String key, Exchange newExchange) throws CamelExchangeException {......                // check for the special exchange property to force completion of all groups        boolean completeAllGroups = answer.getProperty(Exchange.AGGREGATION_COMPLETE_ALL_GROUPS, false, boolean.class);        if (completeAllGroups) {            // remove the exchange property so we do not complete again            answer.removeProperty(Exchange.AGGREGATION_COMPLETE_ALL_GROUPS);            forceCompletionOfAllGroups();        } else if (isCompletionOnNewCorrelationGroup() && originalExchange == null) {            // its a new group so force complete of all existing groups            forceCompletionOfAllGroups();        }...{code} Bug Surviving Header AGGREGATION_COMPLETE_ALL_GROUPS_INCLUSIVE affects following aggregations When AGGREGATION_COMPLETE_ALL_GROUPS_INCLUSIVE is once set true it survives current aggregation processing and affects in unexpected way following aggregation by triggering "forceCompletionOfAllGroups()" againin next code snippet might be needed some additional handling when the header is true:{code:java}protected void doProcess(Exchange exchange) throws Exception {...        // check for the special header to force completion of all groups (inclusive of the message)        boolean completeAllGroupsInclusive = exchange.getIn().getHeader(Exchange.AGGREGATION_COMPLETE_ALL_GROUPS_INCLUSIVE, false, boolean.class);        if (completeAllGroupsInclusive) {            forceCompletionOfAllGroups();        }...{code}this consideration is made by analysing similar behavior and lifecycle of header AGGREGATION_COMPLETE_ALL_GROUPS:{code:java}private List<Exchange> doAggregation(String key, Exchange newExchange) throws CamelExchangeException {......                // check for the special exchange property to force completion of all groups        boolean completeAllGroups = answer.getProperty(Exchange.AGGREGATION_COMPLETE_ALL_GROUPS, false, boolean.class);        if (completeAllGroups) {            // remove the exchange property so we do not complete again            answer.removeProperty(Exchange.AGGREGATION_COMPLETE_ALL_GROUPS);            forceCompletionOfAllGroups();        } else if (isCompletionOnNewCorrelationGroup() && originalExchange == null) {            // its a new group so force complete of all existing groups            forceCompletionOfAllGroups();        }...{code}
Seda component forgets URI setting when duplicates are present when {color:#008000}blockWhenFull=true&blockWhenFull=true {color}{color:#333333}is set twice the option is not set at all{color}{color:#333333}it might out of context but from my point of view the last one should win (as it is in a properties file){color}{color:#333333}of if an error should be thrown could also be welcome{color} {color:#333333}I quickly adapted{color} SedaComponentConfigurationAndDocumentationTest (I know, it uses now deprecated stuff) and the result is an array of set values ( 2 in this case) and the test fails.kind regardsG.  Bug Seda component forgets URI setting when duplicates are present when {color:#008000}blockWhenFull=true&blockWhenFull=true {color}{color:#333333}is set twice the option is not set at all{color}{color:#333333}it might out of context but from my point of view the last one should win (as it is in a properties file){color}{color:#333333}of if an error should be thrown could also be welcome{color} {color:#333333}I quickly adapted{color} SedaComponentConfigurationAndDocumentationTest (I know, it uses now deprecated stuff) and the result is an array of set values ( 2 in this case) and the test fails.kind regardsG. 
outputTypeWithValidate (or inputTypeWithValidate) + validator()... doesn't work as expected {code:java}package org.mike.tests;import org.apache.camel.ValidationException;import org.apache.camel.builder.RouteBuilder;import org.apache.camel.test.junit4.CamelTestSupport;import org.junit.Test;public class ValidatorTests extends CamelTestSupport {    @Override    protected RouteBuilder createRouteBuilder() throws Exception {        return new RouteBuilder() {            @Override            public void configure() throws Exception {                validator()                        .type(String.class)                        .withExpression(bodyAs(String.class).isEqualToIgnoreCase("valid"));                onException(ValidationException.class)                        .handled(true)                        .log("Invalid predicate: ${exception.message}")                        .to("mock:invalid");                from("direct:in")                        //.validate(bodyAs(String.class).isEqualToIgnoreCase("valid"))                        .outputTypeWithValidate(String.class) // or .inputTypeWithValidate(String.class)                        .to("mock:out");            }        };    }    @Test    public void testValid() throws InterruptedException {        getMockEndpoint("mock:out").expectedMessageCount(1);        getMockEndpoint("mock:invalid").expectedMessageCount(0);        template.sendBody("direct:in", "valid");        assertMockEndpointsSatisfied();    }    @Test    public void testInvalid() throws InterruptedException {        getMockEndpoint("mock:out").expectedMessageCount(0);        getMockEndpoint("mock:invalid").expectedMessageCount(1);        template.sendBody("direct:in", "wrong");        assertMockEndpointsSatisfied();    }}{code}Expected result: both tests passActual result: 'testValid' - passed, 'testInvalid' - failedIf uncomment line 25 & comment 26{code:java}.validate(bodyAs(String.class).isEqualToIgnoreCase("valid"))//.inputTypeWithValidate(String.class){code}tests will OK Other test case with same results {code:java}package org.mike.tests;import org.apache.camel.Message;import org.apache.camel.ValidationException;import org.apache.camel.builder.RouteBuilder;import org.apache.camel.impl.JndiRegistry;import org.apache.camel.spi.DataType;import org.apache.camel.spi.Validator;import org.apache.camel.test.junit4.CamelTestSupport;import org.junit.Test;import org.slf4j.Logger;import org.slf4j.LoggerFactory;public class BeanValidatorTest extends CamelTestSupport {    @Override    protected RouteBuilder createRouteBuilder() throws Exception {        return new RouteBuilder() {            @Override            public void configure() throws Exception {                validator()                        .type("toValidate")                        .withBean("testValidator");                onException(ValidationException.class)                        .handled(true)                        .log("Invalid validation: ${exception.message}")                        .to("mock:invalid");                from("direct:in")                        .outputTypeWithValidate("toValidate")                        .to("mock:out");            }        };    }    public static class TestValidator extends Validator {        private static final Logger LOG = LoggerFactory.getLogger(TestValidator.class);        @Override        public void validate(Message message, DataType type) throws ValidationException {            Object body = message.getBody();            LOG.info("Validating : [{}]", body);            if (body instanceof String && body.equals("valid")) {                LOG.info("OK");            } else {                throw new ValidationException(message.getExchange(), "Wrong content");            }        }    }    @Override    protected JndiRegistry createRegistry() throws Exception {        JndiRegistry registry = super.createRegistry();        registry.bind("testValidator", new TestValidator());        return registry;    }    @Test    public void testValid() throws InterruptedException {        getMockEndpoint("mock:out").expectedMessageCount(1);        getMockEndpoint("mock:invalid").expectedMessageCount(0);        template.sendBody("direct:in", "valid");        assertMockEndpointsSatisfied();    }    @Test    public void testInvalid() throws InterruptedException {        getMockEndpoint("mock:out").expectedMessageCount(0);        getMockEndpoint("mock:invalid").expectedMessageCount(1);        template.sendBody("direct:in", "wrong");        assertMockEndpointsSatisfied();    }}{code} Bug outputTypeWithValidate (or inputTypeWithValidate) + validator()... doesn't work as expected {code:java}package org.mike.tests;import org.apache.camel.ValidationException;import org.apache.camel.builder.RouteBuilder;import org.apache.camel.test.junit4.CamelTestSupport;import org.junit.Test;public class ValidatorTests extends CamelTestSupport {    @Override    protected RouteBuilder createRouteBuilder() throws Exception {        return new RouteBuilder() {            @Override            public void configure() throws Exception {                validator()                        .type(String.class)                        .withExpression(bodyAs(String.class).isEqualToIgnoreCase("valid"));                onException(ValidationException.class)                        .handled(true)                        .log("Invalid predicate: ${exception.message}")                        .to("mock:invalid");                from("direct:in")                        //.validate(bodyAs(String.class).isEqualToIgnoreCase("valid"))                        .outputTypeWithValidate(String.class) // or .inputTypeWithValidate(String.class)                        .to("mock:out");            }        };    }    @Test    public void testValid() throws InterruptedException {        getMockEndpoint("mock:out").expectedMessageCount(1);        getMockEndpoint("mock:invalid").expectedMessageCount(0);        template.sendBody("direct:in", "valid");        assertMockEndpointsSatisfied();    }    @Test    public void testInvalid() throws InterruptedException {        getMockEndpoint("mock:out").expectedMessageCount(0);        getMockEndpoint("mock:invalid").expectedMessageCount(1);        template.sendBody("direct:in", "wrong");        assertMockEndpointsSatisfied();    }}{code}Expected result: both tests passActual result: 'testValid' - passed, 'testInvalid' - failedIf uncomment line 25 & comment 26{code:java}.validate(bodyAs(String.class).isEqualToIgnoreCase("valid"))//.inputTypeWithValidate(String.class){code}tests will OK Other test case with same results {code:java}package org.mike.tests;import org.apache.camel.Message;import org.apache.camel.ValidationException;import org.apache.camel.builder.RouteBuilder;import org.apache.camel.impl.JndiRegistry;import org.apache.camel.spi.DataType;import org.apache.camel.spi.Validator;import org.apache.camel.test.junit4.CamelTestSupport;import org.junit.Test;import org.slf4j.Logger;import org.slf4j.LoggerFactory;public class BeanValidatorTest extends CamelTestSupport {    @Override    protected RouteBuilder createRouteBuilder() throws Exception {        return new RouteBuilder() {            @Override            public void configure() throws Exception {                validator()                        .type("toValidate")                        .withBean("testValidator");                onException(ValidationException.class)                        .handled(true)                        .log("Invalid validation: ${exception.message}")                        .to("mock:invalid");                from("direct:in")                        .outputTypeWithValidate("toValidate")                        .to("mock:out");            }        };    }    public static class TestValidator extends Validator {        private static final Logger LOG = LoggerFactory.getLogger(TestValidator.class);        @Override        public void validate(Message message, DataType type) throws ValidationException {            Object body = message.getBody();            LOG.info("Validating : [{}]", body);            if (body instanceof String && body.equals("valid")) {                LOG.info("OK");            } else {                throw new ValidationException(message.getExchange(), "Wrong content");            }        }    }    @Override    protected JndiRegistry createRegistry() throws Exception {        JndiRegistry registry = super.createRegistry();        registry.bind("testValidator", new TestValidator());        return registry;    }    @Test    public void testValid() throws InterruptedException {        getMockEndpoint("mock:out").expectedMessageCount(1);        getMockEndpoint("mock:invalid").expectedMessageCount(0);        template.sendBody("direct:in", "valid");        assertMockEndpointsSatisfied();    }    @Test    public void testInvalid() throws InterruptedException {        getMockEndpoint("mock:out").expectedMessageCount(0);        getMockEndpoint("mock:invalid").expectedMessageCount(1);        template.sendBody("direct:in", "wrong");        assertMockEndpointsSatisfied();    }}{code}
camel-catalog - Transacted and Policy should not have outputs These 2 eips should not have output: true in the camel-catalog json meta-data.For Camel 3.0 we will change their base class in the model so they are no outputs Bug camel-catalog - Transacted and Policy should not have outputs These 2 eips should not have output: true in the camel-catalog json meta-data.For Camel 3.0 we will change their base class in the model so they are no outputs
Camel does not have logic that checks that it should only retry when its a new/changed file Hello,I am reading a file using the stream camel component. The behaviour expected is the following : # Read the stream # When the file roll over, start the reading the file from the beginingMy code :{{from("stream:file?fileName=myfile&scanStream=true&scanStreamDelay=1000&retry=true") }}The problem with the code above is that the same file is read every 1000ms. The component don't check is the file was rolled over.Thanks in advance. Bug Camel does not have logic that checks that it should only retry when its a new/changed file Hello,I am reading a file using the stream camel component. The behaviour expected is the following : # Read the stream # When the file roll over, start the reading the file from the beginingMy code :{{from("stream:file?fileName=myfile&scanStream=true&scanStreamDelay=1000&retry=true") }}The problem with the code above is that the same file is read every 1000ms. The component don't check is the file was rolled over.Thanks in advance.
We should avoid the address setting of CxfRsEndpointConfigurer  When using the CxfRsEndpointConfigurer to do the setting, the address setting from the Message header could be override.  We just need to make sure the address can be override from message header. Bug We should avoid the address setting of CxfRsEndpointConfigurer  When using the CxfRsEndpointConfigurer to do the setting, the address setting from the Message header could be override.  We just need to make sure the address can be override from message header.
Content Based Router in Java DSL may not resolve property placeholders in when predicates Reported on gitter Bug Content Based Router in Java DSL may not resolve property placeholders in when predicates Reported on gitter
camel-kafka component commits the offset as soon as it is retrieved I am trying the maual commit from consumer below is the code snippet, i want to consume and  commit the message after 2 mins of its arrival in the topic. My consumer retrieves and checks the time difference if it is above 2 mins then it should commit. But message once retrieved and not committed manually. I am expecting it to come back but it does not comeback ever.  when i try creating kafka consumer it works finepublic void configure() throws Exception {from("kafka:BENEFITSLOADER.LOAD?brokers=xxxx:9092,xxxx:9092,xxxx:9092&groupId=BENEFITSLOADER&consumersCount=1&pollTimeoutMs=1000&autoCommitEnable=false&allowManualCommit=true&maxPollRecords=1").process(new Processor() { @Override public void process(Exchange exchange) throws Exception { Long msgDateTime = (Long) exchange.getIn().getHeaders().get(KafkaConstants.TIMESTAMP); System.out.println("Message : " + (exchange.getIn().getHeaders())); System.out.println("Message : " + (exchange.getIn().getBody())); Date msgDate = new Date(msgDateTime); Date currentDate = new Date(); long diff = currentDate.getTime() - msgDate.getTime(); long diffMinutes = diff / (60 * 1000) % 60; System.out.println("Difference in Minutes " + diffMinutes); KafkaManualCommit manualCommit = exchange.getIn().getHeader(KafkaConstants.MANUAL_COMMIT, KafkaManualCommit.class);if(diffMinutes > 2) { System.out.println("Commiting Message " + exchange.getIn().getBody());  manualCommit.commitSync();  }  } }); } }  Code that works fine public class TestKafkaConsumer { static Consumer<String, String> consumer = null; static ConsumerRecord<String,String> fetchedRecord;  static ConsumerRecords<String, String> records; public static void main(String... args) {String topicName = "BENEFITSLOADER.LOAD"; consumer = createConsumer(); consumer.subscribe(Collections.singletonList(topicName));try { while (true) {  if(fetchedRecord == null) records = consumer.poll(1000);   records.forEach(record -> {  fetchedRecord = record;  });  if(fetchedRecord != null) { Date msgDate = new Date(fetchedRecord.timestamp()); Date date = new Date(System.currentTimeMillis()); long diff = date.getTime() - msgDate.getTime(); long diffMinutes = diff / (60 * 1000) % 60;  System.out.printf("Consumer Record:(%s, %s, %d, %d)\n", fetchedRecord.key(), fetchedRecord.value(), fetchedRecord.partition(), fetchedRecord.offset()); if(diffMinutes > 2) { System.out.printf("Consumer Record Commiting:(%s, %s, %d, %d)\n", fetchedRecord.key(), fetchedRecord.value(), fetchedRecord.partition(), fetchedRecord.offset()); consumer.commitSync(); System.out.println("Commited"); fetchedRecord = null; } }  } }catch (Exception ex) { ex.printStackTrace(); } finally {  consumer.close(); }}private static Consumer<String, String> createConsumer() { Properties props = new Properties(); props.put(ConsumerConfig.BOOTSTRAP_SERVERS_CONFIG, "xxx:9092,xxx:9092,xxx:9093"); props.put(ConsumerConfig.GROUP_ID_CONFIG, "BENEFITSLOADER"); props.put(ConsumerConfig.KEY_DESERIALIZER_CLASS_CONFIG, StringDeserializer.class.getName()); props.put(ConsumerConfig.VALUE_DESERIALIZER_CLASS_CONFIG, StringDeserializer.class.getName()); props.put(ConsumerConfig.ENABLE_AUTO_COMMIT_CONFIG, false); props.put(ConsumerConfig.MAX_POLL_RECORDS_CONFIG, 1); return new KafkaConsumer<>(props); }} Bug camel-kafka component commits the offset as soon as it is retrieved I am trying the maual commit from consumer below is the code snippet, i want to consume and  commit the message after 2 mins of its arrival in the topic. My consumer retrieves and checks the time difference if it is above 2 mins then it should commit. But message once retrieved and not committed manually. I am expecting it to come back but it does not comeback ever.  when i try creating kafka consumer it works finepublic void configure() throws Exception {from("kafka:BENEFITSLOADER.LOAD?brokers=xxxx:9092,xxxx:9092,xxxx:9092&groupId=BENEFITSLOADER&consumersCount=1&pollTimeoutMs=1000&autoCommitEnable=false&allowManualCommit=true&maxPollRecords=1").process(new Processor() { @Override public void process(Exchange exchange) throws Exception { Long msgDateTime = (Long) exchange.getIn().getHeaders().get(KafkaConstants.TIMESTAMP); System.out.println("Message : " + (exchange.getIn().getHeaders())); System.out.println("Message : " + (exchange.getIn().getBody())); Date msgDate = new Date(msgDateTime); Date currentDate = new Date(); long diff = currentDate.getTime() - msgDate.getTime(); long diffMinutes = diff / (60 * 1000) % 60; System.out.println("Difference in Minutes " + diffMinutes); KafkaManualCommit manualCommit = exchange.getIn().getHeader(KafkaConstants.MANUAL_COMMIT, KafkaManualCommit.class);if(diffMinutes > 2) { System.out.println("Commiting Message " + exchange.getIn().getBody());  manualCommit.commitSync();  }  } }); } }  Code that works fine public class TestKafkaConsumer { static Consumer<String, String> consumer = null; static ConsumerRecord<String,String> fetchedRecord;  static ConsumerRecords<String, String> records; public static void main(String... args) {String topicName = "BENEFITSLOADER.LOAD"; consumer = createConsumer(); consumer.subscribe(Collections.singletonList(topicName));try { while (true) {  if(fetchedRecord == null) records = consumer.poll(1000);   records.forEach(record -> {  fetchedRecord = record;  });  if(fetchedRecord != null) { Date msgDate = new Date(fetchedRecord.timestamp()); Date date = new Date(System.currentTimeMillis()); long diff = date.getTime() - msgDate.getTime(); long diffMinutes = diff / (60 * 1000) % 60;  System.out.printf("Consumer Record:(%s, %s, %d, %d)\n", fetchedRecord.key(), fetchedRecord.value(), fetchedRecord.partition(), fetchedRecord.offset()); if(diffMinutes > 2) { System.out.printf("Consumer Record Commiting:(%s, %s, %d, %d)\n", fetchedRecord.key(), fetchedRecord.value(), fetchedRecord.partition(), fetchedRecord.offset()); consumer.commitSync(); System.out.println("Commited"); fetchedRecord = null; } }  } }catch (Exception ex) { ex.printStackTrace(); } finally {  consumer.close(); }}private static Consumer<String, String> createConsumer() { Properties props = new Properties(); props.put(ConsumerConfig.BOOTSTRAP_SERVERS_CONFIG, "xxx:9092,xxx:9092,xxx:9093"); props.put(ConsumerConfig.GROUP_ID_CONFIG, "BENEFITSLOADER"); props.put(ConsumerConfig.KEY_DESERIALIZER_CLASS_CONFIG, StringDeserializer.class.getName()); props.put(ConsumerConfig.VALUE_DESERIALIZER_CLASS_CONFIG, StringDeserializer.class.getName()); props.put(ConsumerConfig.ENABLE_AUTO_COMMIT_CONFIG, false); props.put(ConsumerConfig.MAX_POLL_RECORDS_CONFIG, 1); return new KafkaConsumer<>(props); }}
Camel servlet component throw "IOException: Stream closed" during route processing for HTTP get request with custom processor If i just build a simple Route like this to proxy a incoming Get request to external host:{code:java}    @Override    public void configure() throws Exception {        from(format("servlet://%s?httpMethodRestrict=GET&servletName=%s", RETRIEVE_PATH, servletName))                .process((exchange) -> {                    exchange.getOut().setHeader(Exchange.HTTP_URI, "https://some.external.system/");                }).to("https4:something");    }{code}The following exception is thrown:{code:java}org.apache.camel.RuntimeCamelException: java.io.IOException: Stream closed	at org.apache.camel.http.common.HttpMessage.createBody(HttpMessage.java:80)	at org.apache.camel.impl.MessageSupport.getBody(MessageSupport.java:54)	at org.apache.camel.processor.DefaultExchangeFormatter.getBodyTypeAsString(DefaultExchangeFormatter.java:468)	at org.apache.camel.processor.DefaultExchangeFormatter.format(DefaultExchangeFormatter.java:126)	at org.apache.camel.processor.CamelLogProcessor.process(CamelLogProcessor.java:88)	at org.apache.camel.component.log.LogProducer.process(LogProducer.java:40)	at org.apache.camel.processor.SendProcessor.process(SendProcessor.java:148)	at org.apache.camel.processor.RedeliveryErrorHandler.process(RedeliveryErrorHandler.java:548)	at org.apache.camel.processor.CamelInternalProcessor.process(CamelInternalProcessor.java:201)	at org.apache.camel.processor.Pipeline.process(Pipeline.java:138)	at org.apache.camel.processor.Pipeline.process(Pipeline.java:101)	at org.apache.camel.processor.CamelInternalProcessor.process(CamelInternalProcessor.java:201)	at org.apache.camel.processor.DelegateAsyncProcessor.process(DelegateAsyncProcessor.java:97)	at org.apache.camel.http.common.CamelServlet.doService(CamelServlet.java:208)	at org.apache.camel.http.common.CamelServlet.service(CamelServlet.java:78)	at javax.servlet.http.HttpServlet.service(HttpServlet.java:742)	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:231)	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166)	at org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:52)	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193)	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166)	at org.springframework.boot.actuate.trace.WebRequestTraceFilter.doFilterInternal(WebRequestTraceFilter.java:110)	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:107)	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193)	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166)	at org.springframework.web.filter.RequestContextFilter.doFilterInternal(RequestContextFilter.java:99)	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:107)	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193)	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166)	at org.springframework.web.filter.HttpPutFormContentFilter.doFilterInternal(HttpPutFormContentFilter.java:108)	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:107)	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193)	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166)	at org.springframework.web.filter.HiddenHttpMethodFilter.doFilterInternal(HiddenHttpMethodFilter.java:81)	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:107)	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193)	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166)	at org.springframework.web.filter.CharacterEncodingFilter.doFilterInternal(CharacterEncodingFilter.java:197)	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:107)	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193)	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166)	at org.springframework.boot.actuate.autoconfigure.MetricsFilter.doFilterInternal(MetricsFilter.java:106)	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:107)	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193)	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166)	at org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:199)	at org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:96)	at org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:504)	at org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:140)	at org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:81)	at org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:87)	at org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:342)	at org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:803)	at org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:66)	at org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:790)	at org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1459)	at org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:49)	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)	at org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:61)	at java.lang.Thread.run(Thread.java:748)Caused by: java.io.IOException: Stream closed	at org.apache.catalina.connector.InputBuffer.read(InputBuffer.java:346)	at org.apache.catalina.connector.CoyoteInputStream.read(CoyoteInputStream.java:152)	at org.apache.camel.util.IOHelper.copy(IOHelper.java:202)	at org.apache.camel.util.IOHelper.copy(IOHelper.java:174)	at org.apache.camel.util.IOHelper.copyAndCloseInput(IOHelper.java:234)	at org.apache.camel.util.IOHelper.copyAndCloseInput(IOHelper.java:230)	at org.apache.camel.http.common.HttpHelper.readResponseBodyFromInputStream(HttpHelper.java:245)	at org.apache.camel.http.common.HttpHelper.readRequestBodyFromServletRequest(HttpHelper.java:196)	at org.apache.camel.http.common.DefaultHttpBinding.parseBody(DefaultHttpBinding.java:577)	at org.apache.camel.http.common.HttpMessage.createBody(HttpMessage.java:78)	... 60 more{code}*Workaround / Additional notice:* * If I rewrite my example route to work without a processor, {{.setHeader(Exchange.HTTP_URI, constant("https://some.external.system/"))}} everything works, so it seems to be an issue with the processor handling. Nevertheless, processor logic should also work. * even if i use a simple {{to("log:com.mycompany.order?showAll=true&multiline=true")}} the issue occurs as well. So it has nothing to with the camel-http4 producer. * Adding "mapHttpMessageBody=false" to the servlet definition seems to be a proper workaround for my example, since I only proxy GET requests which never have a body in the request. * I already debug into the camel code, but i am not 100% sure if this is the correct place to fix: {{org.apache.camel.http.common.DefaultHttpBinding.parseBody(HttpMessage)}} - here it might make sense to skip body parsing for certain HTTP methods (e.g. GET) * I found two quiet similar issues on the mailing list: ** [http://camel.465427.n5.nabble.com/Stream-closed-exception-when-using-camel-as-http-proxy-with-tomcat-servlet-tt5809653.html#none] ** [http://camel.465427.n5.nabble.com/IOException-Stream-closed-when-forwarding-HTTP-request-td5796802.html] Bug Camel servlet component throw "IOException: Stream closed" during route processing for HTTP get request with custom processor If i just build a simple Route like this to proxy a incoming Get request to external host:{code:java}    @Override    public void configure() throws Exception {        from(format("servlet://%s?httpMethodRestrict=GET&servletName=%s", RETRIEVE_PATH, servletName))                .process((exchange) -> {                    exchange.getOut().setHeader(Exchange.HTTP_URI, "https://some.external.system/");                }).to("https4:something");    }{code}The following exception is thrown:{code:java}org.apache.camel.RuntimeCamelException: java.io.IOException: Stream closed	at org.apache.camel.http.common.HttpMessage.createBody(HttpMessage.java:80)	at org.apache.camel.impl.MessageSupport.getBody(MessageSupport.java:54)	at org.apache.camel.processor.DefaultExchangeFormatter.getBodyTypeAsString(DefaultExchangeFormatter.java:468)	at org.apache.camel.processor.DefaultExchangeFormatter.format(DefaultExchangeFormatter.java:126)	at org.apache.camel.processor.CamelLogProcessor.process(CamelLogProcessor.java:88)	at org.apache.camel.component.log.LogProducer.process(LogProducer.java:40)	at org.apache.camel.processor.SendProcessor.process(SendProcessor.java:148)	at org.apache.camel.processor.RedeliveryErrorHandler.process(RedeliveryErrorHandler.java:548)	at org.apache.camel.processor.CamelInternalProcessor.process(CamelInternalProcessor.java:201)	at org.apache.camel.processor.Pipeline.process(Pipeline.java:138)	at org.apache.camel.processor.Pipeline.process(Pipeline.java:101)	at org.apache.camel.processor.CamelInternalProcessor.process(CamelInternalProcessor.java:201)	at org.apache.camel.processor.DelegateAsyncProcessor.process(DelegateAsyncProcessor.java:97)	at org.apache.camel.http.common.CamelServlet.doService(CamelServlet.java:208)	at org.apache.camel.http.common.CamelServlet.service(CamelServlet.java:78)	at javax.servlet.http.HttpServlet.service(HttpServlet.java:742)	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:231)	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166)	at org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:52)	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193)	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166)	at org.springframework.boot.actuate.trace.WebRequestTraceFilter.doFilterInternal(WebRequestTraceFilter.java:110)	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:107)	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193)	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166)	at org.springframework.web.filter.RequestContextFilter.doFilterInternal(RequestContextFilter.java:99)	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:107)	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193)	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166)	at org.springframework.web.filter.HttpPutFormContentFilter.doFilterInternal(HttpPutFormContentFilter.java:108)	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:107)	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193)	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166)	at org.springframework.web.filter.HiddenHttpMethodFilter.doFilterInternal(HiddenHttpMethodFilter.java:81)	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:107)	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193)	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166)	at org.springframework.web.filter.CharacterEncodingFilter.doFilterInternal(CharacterEncodingFilter.java:197)	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:107)	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193)	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166)	at org.springframework.boot.actuate.autoconfigure.MetricsFilter.doFilterInternal(MetricsFilter.java:106)	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:107)	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193)	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166)	at org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:199)	at org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:96)	at org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:504)	at org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:140)	at org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:81)	at org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:87)	at org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:342)	at org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:803)	at org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:66)	at org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:790)	at org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1459)	at org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:49)	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)	at org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:61)	at java.lang.Thread.run(Thread.java:748)Caused by: java.io.IOException: Stream closed	at org.apache.catalina.connector.InputBuffer.read(InputBuffer.java:346)	at org.apache.catalina.connector.CoyoteInputStream.read(CoyoteInputStream.java:152)	at org.apache.camel.util.IOHelper.copy(IOHelper.java:202)	at org.apache.camel.util.IOHelper.copy(IOHelper.java:174)	at org.apache.camel.util.IOHelper.copyAndCloseInput(IOHelper.java:234)	at org.apache.camel.util.IOHelper.copyAndCloseInput(IOHelper.java:230)	at org.apache.camel.http.common.HttpHelper.readResponseBodyFromInputStream(HttpHelper.java:245)	at org.apache.camel.http.common.HttpHelper.readRequestBodyFromServletRequest(HttpHelper.java:196)	at org.apache.camel.http.common.DefaultHttpBinding.parseBody(DefaultHttpBinding.java:577)	at org.apache.camel.http.common.HttpMessage.createBody(HttpMessage.java:78)	... 60 more{code}*Workaround / Additional notice:* * If I rewrite my example route to work without a processor, {{.setHeader(Exchange.HTTP_URI, constant("https://some.external.system/"))}} everything works, so it seems to be an issue with the processor handling. Nevertheless, processor logic should also work. * even if i use a simple {{to("log:com.mycompany.order?showAll=true&multiline=true")}} the issue occurs as well. So it has nothing to with the camel-http4 producer. * Adding "mapHttpMessageBody=false" to the servlet definition seems to be a proper workaround for my example, since I only proxy GET requests which never have a body in the request. * I already debug into the camel code, but i am not 100% sure if this is the correct place to fix: {{org.apache.camel.http.common.DefaultHttpBinding.parseBody(HttpMessage)}} - here it might make sense to skip body parsing for certain HTTP methods (e.g. GET) * I found two quiet similar issues on the mailing list: ** [http://camel.465427.n5.nabble.com/Stream-closed-exception-when-using-camel-as-http-proxy-with-tomcat-servlet-tt5809653.html#none] ** [http://camel.465427.n5.nabble.com/IOException-Stream-closed-when-forwarding-HTTP-request-td5796802.html]
route-coverage : report summary problem Consider the example code given in CAMEL-12483When running camel:route-coverage the report show to many passes for the routes. It looks like the RouteCoverageEventNotifier files holds the sum of all tests, and not just the values for the single test method.  {code:java}Class:  dk.smor.MySpringBootRouterRoute:  myRouteId  Line #      Count   Route  ------      -----   -----      11          8   from      13          8     log      15          8     choice      16          2       setBody      18          2       log      20          2       setBody      22          2       log      24          2       setBody      26          2       log      28          2       setBody      30          2       logCoverage: 11 out of 11 (100.0%){code}each log statement should only have been passed 1 time. And a total for 4 passes for the whole route.   Bug route-coverage : report summary problem Consider the example code given in CAMEL-12483When running camel:route-coverage the report show to many passes for the routes. It looks like the RouteCoverageEventNotifier files holds the sum of all tests, and not just the values for the single test method.  {code:java}Class:  dk.smor.MySpringBootRouterRoute:  myRouteId  Line #      Count   Route  ------      -----   -----      11          8   from      13          8     log      15          8     choice      16          2       setBody      18          2       log      20          2       setBody      22          2       log      24          2       setBody      26          2       log      28          2       setBody      30          2       logCoverage: 11 out of 11 (100.0%){code}each log statement should only have been passed 1 time. And a total for 4 passes for the whole route.  
Camel-jms: ClassNotFoundException: org.springframework.messaging.handler.annotation.support.MessageHandlerMethodFactory in Spring-Boot Not sure if this is a Camel bug, but I'm using activemq-camel 5.14.5 in a spring-boot 1.5.12 application.After upgrading from Camel 2.21.0 to 2.21.1 start-up fails with:{noformat}2018-05-07 09:45:34.213 ERROR 7992 --- [  restartedMain] o.s.boot.SpringApplication               : Application startup failedorg.springframework.beans.factory.BeanCreationException: Error creating bean with name 'org.springframework.jms.config.internalJmsListenerAnnotationProcessor' defined in class path resource [org/springframework/jms/annotation/JmsBootstrapConfiguration.class]: Bean instantiation via factory method failed; nested exception is org.springframework.beans.BeanInstantiationException: Failed to instantiate [org.springframework.jms.annotation.JmsListenerAnnotationBeanPostProcessor]: Factory method 'jmsListenerAnnotationProcessor' threw exception; nested exception is java.lang.NoClassDefFoundError: org/springframework/messaging/handler/annotation/support/MessageHandlerMethodFactory	at org.springframework.beans.factory.support.ConstructorResolver.instantiateUsingFactoryMethod(ConstructorResolver.java:599) ~[spring-beans-4.3.16.RELEASE.jar:4.3.16.RELEASE]	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.instantiateUsingFactoryMethod(AbstractAutowireCapableBeanFactory.java:1177) ~[spring-beans-4.3.16.RELEASE.jar:4.3.16.RELEASE]	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBeanInstance(AbstractAutowireCapableBeanFactory.java:1071) ~[spring-beans-4.3.16.RELEASE.jar:4.3.16.RELEASE]	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:513) ~[spring-beans-4.3.16.RELEASE.jar:4.3.16.RELEASE]	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:483) ~[spring-beans-4.3.16.RELEASE.jar:4.3.16.RELEASE]	at org.springframework.beans.factory.support.AbstractBeanFactory$1.getObject(AbstractBeanFactory.java:312) ~[spring-beans-4.3.16.RELEASE.jar:4.3.16.RELEASE]	at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:230) ~[spring-beans-4.3.16.RELEASE.jar:4.3.16.RELEASE]	at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:308) ~[spring-beans-4.3.16.RELEASE.jar:4.3.16.RELEASE]	at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:202) ~[spring-beans-4.3.16.RELEASE.jar:4.3.16.RELEASE]	at org.springframework.context.support.PostProcessorRegistrationDelegate.registerBeanPostProcessors(PostProcessorRegistrationDelegate.java:225) ~[spring-context-4.3.16.RELEASE.jar:4.3.16.RELEASE]	at org.springframework.context.support.AbstractApplicationContext.registerBeanPostProcessors(AbstractApplicationContext.java:703) ~[spring-context-4.3.16.RELEASE.jar:4.3.16.RELEASE]	at org.springframework.context.support.AbstractApplicationContext.refresh(AbstractApplicationContext.java:528) ~[spring-context-4.3.16.RELEASE.jar:4.3.16.RELEASE]	at org.springframework.boot.SpringApplication.refresh(SpringApplication.java:693) [spring-boot-1.5.12.RELEASE.jar:1.5.12.RELEASE]	at org.springframework.boot.SpringApplication.refreshContext(SpringApplication.java:360) [spring-boot-1.5.12.RELEASE.jar:1.5.12.RELEASE]	at org.springframework.boot.SpringApplication.run(SpringApplication.java:303) [spring-boot-1.5.12.RELEASE.jar:1.5.12.RELEASE]	at org.springframework.boot.SpringApplication.run(SpringApplication.java:1118) [spring-boot-1.5.12.RELEASE.jar:1.5.12.RELEASE]	at org.springframework.boot.SpringApplication.run(SpringApplication.java:1107) [spring-boot-1.5.12.RELEASE.jar:1.5.12.RELEASE]	at de.telekom.dms.FlexKommBusinessServicesApplication.main(FlexKommBusinessServicesApplication.java:10) [classes/:na]	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) ~[na:1.8.0_121]	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) ~[na:1.8.0_121]	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) ~[na:1.8.0_121]	at java.lang.reflect.Method.invoke(Method.java:498) ~[na:1.8.0_121]	at org.springframework.boot.devtools.restart.RestartLauncher.run(RestartLauncher.java:49) [spring-boot-devtools-1.5.12.RELEASE.jar:1.5.12.RELEASE]Caused by: org.springframework.beans.BeanInstantiationException: Failed to instantiate [org.springframework.jms.annotation.JmsListenerAnnotationBeanPostProcessor]: Factory method 'jmsListenerAnnotationProcessor' threw exception; nested exception is java.lang.NoClassDefFoundError: org/springframework/messaging/handler/annotation/support/MessageHandlerMethodFactory	at org.springframework.beans.factory.support.SimpleInstantiationStrategy.instantiate(SimpleInstantiationStrategy.java:189) ~[spring-beans-4.3.16.RELEASE.jar:4.3.16.RELEASE]	at org.springframework.beans.factory.support.ConstructorResolver.instantiateUsingFactoryMethod(ConstructorResolver.java:588) ~[spring-beans-4.3.16.RELEASE.jar:4.3.16.RELEASE]	... 22 common frames omittedCaused by: java.lang.NoClassDefFoundError: org/springframework/messaging/handler/annotation/support/MessageHandlerMethodFactory	at java.lang.ClassLoader.defineClass1(Native Method) ~[na:1.8.0_121]	at java.lang.ClassLoader.defineClass(ClassLoader.java:763) ~[na:1.8.0_121]	at java.security.SecureClassLoader.defineClass(SecureClassLoader.java:142) ~[na:1.8.0_121]	at java.net.URLClassLoader.defineClass(URLClassLoader.java:467) ~[na:1.8.0_121]	at java.net.URLClassLoader.access$100(URLClassLoader.java:73) ~[na:1.8.0_121]	at java.net.URLClassLoader$1.run(URLClassLoader.java:368) ~[na:1.8.0_121]	at java.net.URLClassLoader$1.run(URLClassLoader.java:362) ~[na:1.8.0_121]	at java.security.AccessController.doPrivileged(Native Method) ~[na:1.8.0_121]	at java.net.URLClassLoader.findClass(URLClassLoader.java:361) ~[na:1.8.0_121]	at java.lang.ClassLoader.loadClass(ClassLoader.java:424) ~[na:1.8.0_121]	at sun.misc.Launcher$AppClassLoader.loadClass(Launcher.java:331) ~[na:1.8.0_121]	at java.lang.ClassLoader.loadClass(ClassLoader.java:357) ~[na:1.8.0_121]	at org.springframework.jms.annotation.JmsListenerAnnotationBeanPostProcessor.<init>(JmsListenerAnnotationBeanPostProcessor.java:103) ~[spring-jms-4.3.16.RELEASE.jar:4.3.16.RELEASE]	at org.springframework.jms.annotation.JmsBootstrapConfiguration.jmsListenerAnnotationProcessor(JmsBootstrapConfiguration.java:47) ~[spring-jms-4.3.16.RELEASE.jar:4.3.16.RELEASE]	at org.springframework.jms.annotation.JmsBootstrapConfiguration$$EnhancerBySpringCGLIB$$1878cc3d.CGLIB$jmsListenerAnnotationProcessor$1(<generated>) ~[spring-jms-4.3.16.RELEASE.jar:4.3.16.RELEASE]	at org.springframework.jms.annotation.JmsBootstrapConfiguration$$EnhancerBySpringCGLIB$$1878cc3d$$FastClassBySpringCGLIB$$265c8d54.invoke(<generated>) ~[spring-jms-4.3.16.RELEASE.jar:4.3.16.RELEASE]	at org.springframework.cglib.proxy.MethodProxy.invokeSuper(MethodProxy.java:228) ~[spring-core-4.3.16.RELEASE.jar:4.3.16.RELEASE]	at org.springframework.context.annotation.ConfigurationClassEnhancer$BeanMethodInterceptor.intercept(ConfigurationClassEnhancer.java:358) ~[spring-context-4.3.16.RELEASE.jar:4.3.16.RELEASE]	at org.springframework.jms.annotation.JmsBootstrapConfiguration$$EnhancerBySpringCGLIB$$1878cc3d.jmsListenerAnnotationProcessor(<generated>) ~[spring-jms-4.3.16.RELEASE.jar:4.3.16.RELEASE]	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) ~[na:1.8.0_121]	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) ~[na:1.8.0_121]	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) ~[na:1.8.0_121]	at java.lang.reflect.Method.invoke(Method.java:498) ~[na:1.8.0_121]	at org.springframework.beans.factory.support.SimpleInstantiationStrategy.instantiate(SimpleInstantiationStrategy.java:162) ~[spring-beans-4.3.16.RELEASE.jar:4.3.16.RELEASE]	... 23 common frames omittedCaused by: java.lang.ClassNotFoundException: org.springframework.messaging.handler.annotation.support.MessageHandlerMethodFactory	at java.net.URLClassLoader.findClass(URLClassLoader.java:381) ~[na:1.8.0_121]	at java.lang.ClassLoader.loadClass(ClassLoader.java:424) ~[na:1.8.0_121]	at sun.misc.Launcher$AppClassLoader.loadClass(Launcher.java:331) ~[na:1.8.0_121]	at java.lang.ClassLoader.loadClass(ClassLoader.java:357) ~[na:1.8.0_121]	... 47 common frames omitted{noformat}The cause is https://issues.apache.org/jira/browse/CAMEL-12447, because when I add{code}<dependency>    <groupId>org.springframework</groupId>    <artifactId>spring-messaging</artifactId></dependency>{code}everything works fine again. Bug Camel-jms: ClassNotFoundException: org.springframework.messaging.handler.annotation.support.MessageHandlerMethodFactory in Spring-Boot Not sure if this is a Camel bug, but I'm using activemq-camel 5.14.5 in a spring-boot 1.5.12 application.After upgrading from Camel 2.21.0 to 2.21.1 start-up fails with:{noformat}2018-05-07 09:45:34.213 ERROR 7992 --- [  restartedMain] o.s.boot.SpringApplication               : Application startup failedorg.springframework.beans.factory.BeanCreationException: Error creating bean with name 'org.springframework.jms.config.internalJmsListenerAnnotationProcessor' defined in class path resource [org/springframework/jms/annotation/JmsBootstrapConfiguration.class]: Bean instantiation via factory method failed; nested exception is org.springframework.beans.BeanInstantiationException: Failed to instantiate [org.springframework.jms.annotation.JmsListenerAnnotationBeanPostProcessor]: Factory method 'jmsListenerAnnotationProcessor' threw exception; nested exception is java.lang.NoClassDefFoundError: org/springframework/messaging/handler/annotation/support/MessageHandlerMethodFactory	at org.springframework.beans.factory.support.ConstructorResolver.instantiateUsingFactoryMethod(ConstructorResolver.java:599) ~[spring-beans-4.3.16.RELEASE.jar:4.3.16.RELEASE]	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.instantiateUsingFactoryMethod(AbstractAutowireCapableBeanFactory.java:1177) ~[spring-beans-4.3.16.RELEASE.jar:4.3.16.RELEASE]	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBeanInstance(AbstractAutowireCapableBeanFactory.java:1071) ~[spring-beans-4.3.16.RELEASE.jar:4.3.16.RELEASE]	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:513) ~[spring-beans-4.3.16.RELEASE.jar:4.3.16.RELEASE]	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:483) ~[spring-beans-4.3.16.RELEASE.jar:4.3.16.RELEASE]	at org.springframework.beans.factory.support.AbstractBeanFactory$1.getObject(AbstractBeanFactory.java:312) ~[spring-beans-4.3.16.RELEASE.jar:4.3.16.RELEASE]	at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:230) ~[spring-beans-4.3.16.RELEASE.jar:4.3.16.RELEASE]	at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:308) ~[spring-beans-4.3.16.RELEASE.jar:4.3.16.RELEASE]	at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:202) ~[spring-beans-4.3.16.RELEASE.jar:4.3.16.RELEASE]	at org.springframework.context.support.PostProcessorRegistrationDelegate.registerBeanPostProcessors(PostProcessorRegistrationDelegate.java:225) ~[spring-context-4.3.16.RELEASE.jar:4.3.16.RELEASE]	at org.springframework.context.support.AbstractApplicationContext.registerBeanPostProcessors(AbstractApplicationContext.java:703) ~[spring-context-4.3.16.RELEASE.jar:4.3.16.RELEASE]	at org.springframework.context.support.AbstractApplicationContext.refresh(AbstractApplicationContext.java:528) ~[spring-context-4.3.16.RELEASE.jar:4.3.16.RELEASE]	at org.springframework.boot.SpringApplication.refresh(SpringApplication.java:693) [spring-boot-1.5.12.RELEASE.jar:1.5.12.RELEASE]	at org.springframework.boot.SpringApplication.refreshContext(SpringApplication.java:360) [spring-boot-1.5.12.RELEASE.jar:1.5.12.RELEASE]	at org.springframework.boot.SpringApplication.run(SpringApplication.java:303) [spring-boot-1.5.12.RELEASE.jar:1.5.12.RELEASE]	at org.springframework.boot.SpringApplication.run(SpringApplication.java:1118) [spring-boot-1.5.12.RELEASE.jar:1.5.12.RELEASE]	at org.springframework.boot.SpringApplication.run(SpringApplication.java:1107) [spring-boot-1.5.12.RELEASE.jar:1.5.12.RELEASE]	at de.telekom.dms.FlexKommBusinessServicesApplication.main(FlexKommBusinessServicesApplication.java:10) [classes/:na]	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) ~[na:1.8.0_121]	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) ~[na:1.8.0_121]	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) ~[na:1.8.0_121]	at java.lang.reflect.Method.invoke(Method.java:498) ~[na:1.8.0_121]	at org.springframework.boot.devtools.restart.RestartLauncher.run(RestartLauncher.java:49) [spring-boot-devtools-1.5.12.RELEASE.jar:1.5.12.RELEASE]Caused by: org.springframework.beans.BeanInstantiationException: Failed to instantiate [org.springframework.jms.annotation.JmsListenerAnnotationBeanPostProcessor]: Factory method 'jmsListenerAnnotationProcessor' threw exception; nested exception is java.lang.NoClassDefFoundError: org/springframework/messaging/handler/annotation/support/MessageHandlerMethodFactory	at org.springframework.beans.factory.support.SimpleInstantiationStrategy.instantiate(SimpleInstantiationStrategy.java:189) ~[spring-beans-4.3.16.RELEASE.jar:4.3.16.RELEASE]	at org.springframework.beans.factory.support.ConstructorResolver.instantiateUsingFactoryMethod(ConstructorResolver.java:588) ~[spring-beans-4.3.16.RELEASE.jar:4.3.16.RELEASE]	... 22 common frames omittedCaused by: java.lang.NoClassDefFoundError: org/springframework/messaging/handler/annotation/support/MessageHandlerMethodFactory	at java.lang.ClassLoader.defineClass1(Native Method) ~[na:1.8.0_121]	at java.lang.ClassLoader.defineClass(ClassLoader.java:763) ~[na:1.8.0_121]	at java.security.SecureClassLoader.defineClass(SecureClassLoader.java:142) ~[na:1.8.0_121]	at java.net.URLClassLoader.defineClass(URLClassLoader.java:467) ~[na:1.8.0_121]	at java.net.URLClassLoader.access$100(URLClassLoader.java:73) ~[na:1.8.0_121]	at java.net.URLClassLoader$1.run(URLClassLoader.java:368) ~[na:1.8.0_121]	at java.net.URLClassLoader$1.run(URLClassLoader.java:362) ~[na:1.8.0_121]	at java.security.AccessController.doPrivileged(Native Method) ~[na:1.8.0_121]	at java.net.URLClassLoader.findClass(URLClassLoader.java:361) ~[na:1.8.0_121]	at java.lang.ClassLoader.loadClass(ClassLoader.java:424) ~[na:1.8.0_121]	at sun.misc.Launcher$AppClassLoader.loadClass(Launcher.java:331) ~[na:1.8.0_121]	at java.lang.ClassLoader.loadClass(ClassLoader.java:357) ~[na:1.8.0_121]	at org.springframework.jms.annotation.JmsListenerAnnotationBeanPostProcessor.<init>(JmsListenerAnnotationBeanPostProcessor.java:103) ~[spring-jms-4.3.16.RELEASE.jar:4.3.16.RELEASE]	at org.springframework.jms.annotation.JmsBootstrapConfiguration.jmsListenerAnnotationProcessor(JmsBootstrapConfiguration.java:47) ~[spring-jms-4.3.16.RELEASE.jar:4.3.16.RELEASE]	at org.springframework.jms.annotation.JmsBootstrapConfiguration$$EnhancerBySpringCGLIB$$1878cc3d.CGLIB$jmsListenerAnnotationProcessor$1(<generated>) ~[spring-jms-4.3.16.RELEASE.jar:4.3.16.RELEASE]	at org.springframework.jms.annotation.JmsBootstrapConfiguration$$EnhancerBySpringCGLIB$$1878cc3d$$FastClassBySpringCGLIB$$265c8d54.invoke(<generated>) ~[spring-jms-4.3.16.RELEASE.jar:4.3.16.RELEASE]	at org.springframework.cglib.proxy.MethodProxy.invokeSuper(MethodProxy.java:228) ~[spring-core-4.3.16.RELEASE.jar:4.3.16.RELEASE]	at org.springframework.context.annotation.ConfigurationClassEnhancer$BeanMethodInterceptor.intercept(ConfigurationClassEnhancer.java:358) ~[spring-context-4.3.16.RELEASE.jar:4.3.16.RELEASE]	at org.springframework.jms.annotation.JmsBootstrapConfiguration$$EnhancerBySpringCGLIB$$1878cc3d.jmsListenerAnnotationProcessor(<generated>) ~[spring-jms-4.3.16.RELEASE.jar:4.3.16.RELEASE]	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) ~[na:1.8.0_121]	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) ~[na:1.8.0_121]	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) ~[na:1.8.0_121]	at java.lang.reflect.Method.invoke(Method.java:498) ~[na:1.8.0_121]	at org.springframework.beans.factory.support.SimpleInstantiationStrategy.instantiate(SimpleInstantiationStrategy.java:162) ~[spring-beans-4.3.16.RELEASE.jar:4.3.16.RELEASE]	... 23 common frames omittedCaused by: java.lang.ClassNotFoundException: org.springframework.messaging.handler.annotation.support.MessageHandlerMethodFactory	at java.net.URLClassLoader.findClass(URLClassLoader.java:381) ~[na:1.8.0_121]	at java.lang.ClassLoader.loadClass(ClassLoader.java:424) ~[na:1.8.0_121]	at sun.misc.Launcher$AppClassLoader.loadClass(Launcher.java:331) ~[na:1.8.0_121]	at java.lang.ClassLoader.loadClass(ClassLoader.java:357) ~[na:1.8.0_121]	... 47 common frames omitted{noformat}The cause is https://issues.apache.org/jira/browse/CAMEL-12447, because when I add{code}<dependency>    <groupId>org.springframework</groupId>    <artifactId>spring-messaging</artifactId></dependency>{code}everything works fine again.
route-coverage : endChoice() problem When running {code:java}mvn camel:route-coverage{code}on routes that use endChoice() you get a NullPointerException. {code:java}[WARNING] Error parsing java file c:\workspace\kk\coverage\src\main\java\dk\smor\MySpringBootRouter.java code due nulljava.lang.NullPointerExceptionat org.apache.camel.parser.helper.CamelJavaTreeParserHelper.parseCamelRouteTree(CamelJavaTreeParserHelper.java:132)at org.apache.camel.parser.RouteBuilderParser.parseRouteBuilderTree(RouteBuilderParser.java:80)at org.apache.camel.maven.RouteCoverageMojo.execute(RouteCoverageMojo.java:158)at org.apache.maven.plugin.DefaultBuildPluginManager.executeMojo(DefaultBuildPluginManager.java:134)at org.apache.maven.lifecycle.internal.MojoExecutor.execute(MojoExecutor.java:207)at org.apache.maven.lifecycle.internal.MojoExecutor.execute(MojoExecutor.java:153)at org.apache.maven.lifecycle.internal.MojoExecutor.execute(MojoExecutor.java:145)at org.apache.maven.lifecycle.internal.LifecycleModuleBuilder.buildProject(LifecycleModuleBuilder.java:116)at org.apache.maven.lifecycle.internal.LifecycleModuleBuilder.buildProject(LifecycleModuleBuilder.java:80)at org.apache.maven.lifecycle.internal.builder.singlethreaded.SingleThreadedBuilder.build(SingleThreadedBuilder.java:51)at org.apache.maven.lifecycle.internal.LifecycleStarter.execute(LifecycleStarter.java:128)at org.apache.maven.DefaultMaven.doExecute(DefaultMaven.java:307)at org.apache.maven.DefaultMaven.doExecute(DefaultMaven.java:193)at org.apache.maven.DefaultMaven.execute(DefaultMaven.java:106)at org.apache.maven.cli.MavenCli.execute(MavenCli.java:863)at org.apache.maven.cli.MavenCli.doMain(MavenCli.java:288)at org.apache.maven.cli.MavenCli.main(MavenCli.java:199)at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)at java.lang.reflect.Method.invoke(Method.java:498)at org.codehaus.plexus.classworlds.launcher.Launcher.launchEnhanced(Launcher.java:289)at org.codehaus.plexus.classworlds.launcher.Launcher.launch(Launcher.java:229)at org.codehaus.plexus.classworlds.launcher.Launcher.mainWithExitCode(Launcher.java:415)at org.codehaus.plexus.classworlds.launcher.Launcher.main(Launcher.java:356){code}I have attached a zip file with some example code to re-produce the problem.The example code has 2 routes, 1 with endChoice() and 1 without. The 2 route should behave equally. Bug route-coverage : endChoice() problem When running {code:java}mvn camel:route-coverage{code}on routes that use endChoice() you get a NullPointerException. {code:java}[WARNING] Error parsing java file c:\workspace\kk\coverage\src\main\java\dk\smor\MySpringBootRouter.java code due nulljava.lang.NullPointerExceptionat org.apache.camel.parser.helper.CamelJavaTreeParserHelper.parseCamelRouteTree(CamelJavaTreeParserHelper.java:132)at org.apache.camel.parser.RouteBuilderParser.parseRouteBuilderTree(RouteBuilderParser.java:80)at org.apache.camel.maven.RouteCoverageMojo.execute(RouteCoverageMojo.java:158)at org.apache.maven.plugin.DefaultBuildPluginManager.executeMojo(DefaultBuildPluginManager.java:134)at org.apache.maven.lifecycle.internal.MojoExecutor.execute(MojoExecutor.java:207)at org.apache.maven.lifecycle.internal.MojoExecutor.execute(MojoExecutor.java:153)at org.apache.maven.lifecycle.internal.MojoExecutor.execute(MojoExecutor.java:145)at org.apache.maven.lifecycle.internal.LifecycleModuleBuilder.buildProject(LifecycleModuleBuilder.java:116)at org.apache.maven.lifecycle.internal.LifecycleModuleBuilder.buildProject(LifecycleModuleBuilder.java:80)at org.apache.maven.lifecycle.internal.builder.singlethreaded.SingleThreadedBuilder.build(SingleThreadedBuilder.java:51)at org.apache.maven.lifecycle.internal.LifecycleStarter.execute(LifecycleStarter.java:128)at org.apache.maven.DefaultMaven.doExecute(DefaultMaven.java:307)at org.apache.maven.DefaultMaven.doExecute(DefaultMaven.java:193)at org.apache.maven.DefaultMaven.execute(DefaultMaven.java:106)at org.apache.maven.cli.MavenCli.execute(MavenCli.java:863)at org.apache.maven.cli.MavenCli.doMain(MavenCli.java:288)at org.apache.maven.cli.MavenCli.main(MavenCli.java:199)at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)at java.lang.reflect.Method.invoke(Method.java:498)at org.codehaus.plexus.classworlds.launcher.Launcher.launchEnhanced(Launcher.java:289)at org.codehaus.plexus.classworlds.launcher.Launcher.launch(Launcher.java:229)at org.codehaus.plexus.classworlds.launcher.Launcher.mainWithExitCode(Launcher.java:415)at org.codehaus.plexus.classworlds.launcher.Launcher.main(Launcher.java:356){code}I have attached a zip file with some example code to re-produce the problem.The example code has 2 routes, 1 with endChoice() and 1 without. The 2 route should behave equally.
Undertow consumer with http4 producer results in Undertow throwing NullPointerException I have a very simple setup of Camel (standalone).My route is as follows:{code:java}public class Application {    public static void main(String... args) throws Exception {        Main main = new Main();        main.addRouteBuilder(new RouteBuilder() {            @Override            public void configure() throws Exception {                restConfiguration().port(8080);                rest("/pi")                        .get()                        .route()                        .setExchangePattern(ExchangePattern.InOut)                        .to("https4://api.pi.delivery/v1/pi?bridgeEndpoint=true");            }        });        main.run();    }}{code}Call the endpoint with: {noformat}curl "http://localhost:8080/pi?start=0&numberOfDigits=10"{noformat} When using camel-undertow for consumer and camel-http4 for producer, I get a NullPointerException.{code:java}java.lang.NullPointerException: nullat io.undertow.io.AsyncSenderImpl.send(AsyncSenderImpl.java:141) ~[undertow-core-1.4.23.Final.jar:1.4.23.Final]at io.undertow.io.AsyncSenderImpl.send(AsyncSenderImpl.java:285) ~[undertow-core-1.4.23.Final.jar:1.4.23.Final]at org.apache.camel.component.undertow.UndertowConsumer.handleRequest(UndertowConsumer.java:142) ~[camel-undertow-2.21.0.jar:2.21.0]at io.undertow.server.Connectors.executeRootHandler(Connectors.java:336) ~[undertow-core-1.4.23.Final.jar:1.4.23.Final]at io.undertow.server.HttpServerExchange$1.run(HttpServerExchange.java:830) ~[undertow-core-1.4.23.Final.jar:1.4.23.Final]at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142) ~[na:1.8.0_102]at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617) ~[na:1.8.0_102]at java.lang.Thread.run(Thread.java:745) ~[na:1.8.0_102]{code}However, if I switch out the camel-undertow dependency with camel-jetty, the above route configuration works just fine. Bug Undertow consumer with http4 producer results in Undertow throwing NullPointerException I have a very simple setup of Camel (standalone).My route is as follows:{code:java}public class Application {    public static void main(String... args) throws Exception {        Main main = new Main();        main.addRouteBuilder(new RouteBuilder() {            @Override            public void configure() throws Exception {                restConfiguration().port(8080);                rest("/pi")                        .get()                        .route()                        .setExchangePattern(ExchangePattern.InOut)                        .to("https4://api.pi.delivery/v1/pi?bridgeEndpoint=true");            }        });        main.run();    }}{code}Call the endpoint with: {noformat}curl "http://localhost:8080/pi?start=0&numberOfDigits=10"{noformat} When using camel-undertow for consumer and camel-http4 for producer, I get a NullPointerException.{code:java}java.lang.NullPointerException: nullat io.undertow.io.AsyncSenderImpl.send(AsyncSenderImpl.java:141) ~[undertow-core-1.4.23.Final.jar:1.4.23.Final]at io.undertow.io.AsyncSenderImpl.send(AsyncSenderImpl.java:285) ~[undertow-core-1.4.23.Final.jar:1.4.23.Final]at org.apache.camel.component.undertow.UndertowConsumer.handleRequest(UndertowConsumer.java:142) ~[camel-undertow-2.21.0.jar:2.21.0]at io.undertow.server.Connectors.executeRootHandler(Connectors.java:336) ~[undertow-core-1.4.23.Final.jar:1.4.23.Final]at io.undertow.server.HttpServerExchange$1.run(HttpServerExchange.java:830) ~[undertow-core-1.4.23.Final.jar:1.4.23.Final]at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142) ~[na:1.8.0_102]at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617) ~[na:1.8.0_102]at java.lang.Thread.run(Thread.java:745) ~[na:1.8.0_102]{code}However, if I switch out the camel-undertow dependency with camel-jetty, the above route configuration works just fine.
How to do dynamic redirecting for rest and soap calls in Apache Camel without bothering what the request method type(post/get/update/delete) and request payload. Incoming REST Url: [http://localhost:8888/carParking/carCheckOut]Redirect URL  will be like: Redirect Url – [http://\|http://issues.apache.org/]{localhost:9090}/\{MainController}/\{requestParam}Example: [http://camelRouteHost:9090/carParking/carCheckIn|http://camelroutehost:9090/carParking/carCheckIn]I just want to redirect the rest/soap url without bothering method type(post/put etc..) and request payload(json/xml)And i just want to display same result what my actual endpoint is giving.   Bug How to do dynamic redirecting for rest and soap calls in Apache Camel without bothering what the request method type(post/get/update/delete) and request payload. Incoming REST Url: [http://localhost:8888/carParking/carCheckOut]Redirect URL  will be like: Redirect Url - [http://\|http://issues.apache.org/]{localhost:9090}/\{MainController}/\{requestParam}Example: [http://camelRouteHost:9090/carParking/carCheckIn|http://camelroutehost:9090/carParking/carCheckIn]I just want to redirect the rest/soap url without bothering method type(post/put etc..) and request payload(json/xml)And i just want to display same result what my actual endpoint is giving.  
FatJarRouter no longer exists Inthe documentation, FatJarRouter is referenced as the entry point for spring boot apps [http://camel.apache.org/spring-boot.html] This is no longer the case.  If I read this PR correctly, [https://github.com/apache/camel/pull/1222] , users have to implement it the normal way in spring boot, just using a main method. Bug FatJarRouter no longer exists Inthe documentation, FatJarRouter is referenced as the entry point for spring boot apps [http://camel.apache.org/spring-boot.html] This is no longer the case.  If I read this PR correctly, [https://github.com/apache/camel/pull/1222] , users have to implement it the normal way in spring boot, just using a main method.
file consumer - Should not use readlock by default The file consumer should use readLock=none by default, which is also what the documentation says. However its reconfigured to markerFile which is a little mistake.  Bug file consumer - Should not use readlock by default The file consumer should use readLock=none by default, which is also what the documentation says. However its reconfigured to markerFile which is a little mistake. 
camel-kafka - AutoCommitEnabled=false should not auto commit Reported on gitterJohn Culleton @jcullet Apr 17 17:22Hi All - I'm running into an issue with the camel-kafka component when attempting to disable auto commit behavior. On camel 2.21, I'm finding that the offset is being committed even when "autoCommitEnable=false" is specified. When running through a debugger, I see that the offset commit is happening here: https://github.com/apache/camel/blob/0f98938e3b6ea15a2e022c707bf21a2af4ed7e0d/components/camel-kafka/src/main/java/org/apache/camel/component/kafka/KafkaConsumer.java#L382. Based on the conditional, I think it would always evaluate to true when autoCommitEnable is set to false? Bug camel-kafka - AutoCommitEnabled=false should not auto commit Reported on gitterJohn Culleton @jcullet Apr 17 17:22Hi All - I'm running into an issue with the camel-kafka component when attempting to disable auto commit behavior. On camel 2.21, I'm finding that the offset is being committed even when "autoCommitEnable=false" is specified. When running through a debugger, I see that the offset commit is happening here: https://github.com/apache/camel/blob/0f98938e3b6ea15a2e022c707bf21a2af4ed7e0d/components/camel-kafka/src/main/java/org/apache/camel/component/kafka/KafkaConsumer.java#L382. Based on the conditional, I think it would always evaluate to true when autoCommitEnable is set to false?
