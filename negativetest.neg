scheduled poll consumer - Add option to limit number of polls In the timer/scheduler component you can set a max number of polls so the consumer stop after that.We could add something similar so you can eg tell the consumer to run only once etc. Improvement scheduled poll consumer - Add option to limit number of polls In the timer/scheduler component you can set a max number of polls so the consumer stop after that.We could add something similar so you can eg tell the consumer to run only once etc.
DefaultRegistry - findByType should return merged result incl fallback Reported by Luca in camel-quarkus Improvement DefaultRegistry - findByType should return merged result incl fallback Reported by Luca in camel-quarkus
Orderes RoutesBuilder RoutesBuilder are now loaded according to the order the user add them but in some cases it may be needed to load them according to an order.We should then make the RoutesBuilder interface extends Ordered and take it into account i.e. in MainSupport. Improvement Orderes RoutesBuilder RoutesBuilder are now loaded according to the order the user add them but in some cases it may be needed to load them according to an order.We should then make the RoutesBuilder interface extends Ordered and take it into account i.e. in MainSupport.
Move process control from Main to MainSupport org.apache.camel.main.MainSupport is now in charge to parse command line arguments, keep the process up according to some policies, intercepts shutdown events and so on.To make it easier to re-use MainSupport in other projects such as camel-quarkus where as example there's no control over command line arguments, it would be nice to move the process control logic to org.apache.camel.main.Main.[~davsclaus] does it make sense or there is something I haven't taken into account ? Improvement Move process control from Main to MainSupport org.apache.camel.main.MainSupport is now in charge to parse command line arguments, keep the process up according to some policies, intercepts shutdown events and so on.To make it easier to re-use MainSupport in other projects such as camel-quarkus where as example there's no control over command line arguments, it would be nice to move the process control logic to org.apache.camel.main.Main.[~davsclaus] does it make sense or there is something I haven't taken into account ?
SJMS-Batch does not support CompletionAware aggregators SJMS-Batch isn't aware of the CompletionAwareAggregationStrategy interface and so never calls the completion method.This prevents SJMS-Batch from working as expected with built in aggregators such as org.apache.camel.processor.aggregate.GroupedBodyAggregationStrategy - the aggregated message remains as an exchange header instead of being the message body.  Improvement SJMS-Batch does not support CompletionAware aggregators SJMS-Batch isn't aware of the CompletionAwareAggregationStrategy interface and so never calls the completion method.This prevents SJMS-Batch from working as expected with built in aggregators such as org.apache.camel.processor.aggregate.GroupedBodyAggregationStrategy - the aggregated message remains as an exchange header instead of being the message body. 
camel-core vs camel-core-engine The camel-core-engine trims camel-core using maven exclusions which may lead to unexpected result as if both are present in the dependencies tree, then one may win over the other depending of the maven resolution. Improvement camel-core vs camel-core-engine The camel-core-engine trims camel-core using maven exclusions which may lead to unexpected result as if both are present in the dependencies tree, then one may win over the other depending of the maven resolution.
Create a configuration service instead of leveraging the properties component As today the way camel resolves properties/configuration is trough the Properties Component which leads to a chicken and egg problem as:- camel core depends on properties component- the properties component depends on camel coreWe should probably have a proper configuration service part of camel core that can eventually be leveraged by the Properties Component. Improvement Create a configuration service instead of leveraging the properties component As today the way camel resolves properties/configuration is trough the Properties Component which leads to a chicken and egg problem as:- camel core depends on properties component- the properties component depends on camel coreWe should probably have a proper configuration service part of camel core that can eventually be leveraged by the Properties Component.
camel3 - Rename camel-management-impl to camel-management Lets avoid the -impl in the name as its the only Camel artifact that has this ending. Task camel3 - Rename camel-management-impl to camel-management Lets avoid the -impl in the name as its the only Camel artifact that has this ending.
SNMP Component support ‘snmp walk’ The current version, the SNMP Component can not support 'snmp walk'.Although the source code has appear 'GET_NEXT' in SnmpActionType.java, but no found in processor.Now, i add the 'snmp walk' and in my application it run successfully.So, if it need add to the next camel version, please check.Thanks! New Feature SNMP Component support 'snmp walk' The current version, the SNMP Component can not support 'snmp walk'.Although the source code has appear 'GET_NEXT' in SnmpActionType.java, but no found in processor.Now, i add the 'snmp walk' and in my application it run successfully.So, if it need add to the next camel version, please check.Thanks!
camel3 - ApiEndpoint should extend ScheduledPollEndpoint As the ApiConsumer is scheduled poll based, but the endpoint was not its base class. Then options get out of sync and not documented either. Improvement camel3 - ApiEndpoint should extend ScheduledPollEndpoint As the ApiConsumer is scheduled poll based, but the endpoint was not its base class. Then options get out of sync and not documented either.
camel-seda - SedaConsumer should extend DefaultConsumer So its like the other components where we extend default classes Improvement camel-seda - SedaConsumer should extend DefaultConsumer So its like the other components where we extend default classes
camel3 - camel-http - Remove deprecate url rewrite UrlRewrite has been deprecated on 2.x, and should be removed for 3 Task camel3 - camel-http - Remove deprecate url rewrite UrlRewrite has been deprecated on 2.x, and should be removed for 3
camel3 - Deprecate and remove consumer.xxx syntax for delay options You can configure them on the endpoint directly, so consumer.delay=5000 should just be delay=5000 and so on. Task camel3 - Deprecate and remove consumer.xxx syntax for delay options You can configure them on the endpoint directly, so consumer.delay=5000 should just be delay=5000 and so on.
camel3 - components - Use BeanIntrospection instead of IntrospectionSupport They should use BeanIntrosepction which you can get from camel context Task camel3 - components - Use BeanIntrospection instead of IntrospectionSupport They should use BeanIntrosepction which you can get from camel context
camel3 - JMX can clear its bean introspection cache after all MBeans have been registered Those are no longer needed and it can free up a bit of memory hold by the cache. Mind the cache is weak anyway, but this makes it more explicit Task camel3 - JMX can clear its bean introspection cache after all MBeans have been registered Those are no longer needed and it can free up a bit of memory hold by the cache. Mind the cache is weak anyway, but this makes it more explicit
Component options - Only include if they have @Metadata Properties component include some options which should not be there, as we should only take the getter/setter pairs that have @Metadata annotation Task Component options - Only include if they have @Metadata Properties component include some options which should not be there, as we should only take the getter/setter pairs that have @Metadata annotation
camel-main-plugin - Dont run it automatic on compile Lets just add instructions in the readme and avoid running it on each build. Its used for setting up the project for tooling support, and if you want to have it to do auto-detection of certain JMS clients - eg ActiveMQ vs Artemis and adapt the project accordingly. Improvement camel-main-plugin - Dont run it automatic on compile Lets just add instructions in the readme and avoid running it on each build. Its used for setting up the project for tooling support, and if you want to have it to do auto-detection of certain JMS clients - eg ActiveMQ vs Artemis and adapt the project accordingly.
camel3 - TypeConverter(loader = true) rename to generateLoader We are using generateConfigurer for fast endpoint configurer, so lets rename this for type converter loader to generateLoader on these annotations Improvement camel3 - TypeConverter(loader = true) rename to generateLoader We are using generateConfigurer for fast endpoint configurer, so lets rename this for type converter loader to generateLoader on these annotations
camel3 - Fast configuring of endpoint options Like we did for fast property placeholders on EIPs we can optimize endpoints as well, by using the apt compiler plugin to generate a configurer classes that uses direct java method invocations and then the property builder support class can detect that we have such a configurer and use it, when it looks for the setter.  Improvement camel3 - Fast configuring of endpoint options Like we did for fast property placeholders on EIPs we can optimize endpoints as well, by using the apt compiler plugin to generate a configurer classes that uses direct java method invocations and then the property builder support class can detect that we have such a configurer and use it, when it looks for the setter. 
camel3 - Optimize XmlConverterLoader I wonder if we can optimize XmlConverterLoader this to init the getXmlConverter once only and avoid synchronized.It does take a bit time to load according to the yourkit profiler Improvement camel3 - Optimize XmlConverterLoader I wonder if we can optimize XmlConverterLoader this to init the getXmlConverter once only and avoid synchronized.It does take a bit time to load according to the yourkit profiler
camel3 - Property placeholders on EIP models can be optimized We do a bit of introspection on each model class to fin its getter/setter properties, which we can then use for property placeholders.org.apache.camel.model.ProcessorDefinitionHelper#resolvePropertyPlaceholdersWe should look at optimising this Improvement camel3 - Property placeholders on EIP models can be optimized We do a bit of introspection on each model class to fin its getter/setter properties, which we can then use for property placeholders.org.apache.camel.model.ProcessorDefinitionHelper#resolvePropertyPlaceholdersWe should look at optimising this
Support room password in camel-xmpp Camel-xmpp does not support room passwords at the moment. With small patch it could. Patch file included. Improvement Support room password in camel-xmpp Camel-xmpp does not support room passwords at the moment. With small patch it could. Patch file included.
Make PropertyBindingSupport a fluent builder only PropertyBindingSupport provides a number of flag to customize how properties should be bound to a target object and it is likely possible that in the future more flags are required so instead of adding yet another overloaded method for each flag we should turn PropertyBindingSupport intop a fluent builder Improvement Make PropertyBindingSupport a fluent builder only PropertyBindingSupport provides a number of flag to customize how properties should be bound to a target object and it is likely possible that in the future more flags are required so instead of adding yet another overloaded method for each flag we should turn PropertyBindingSupport intop a fluent builder
camel-telegram - Do not show authorizationToken in uri We should hide this sensitive information, this requires to migrate it from uri path to uri parameter instead.  Improvement camel-telegram - Do not show authorizationToken in uri We should hide this sensitive information, this requires to migrate it from uri path to uri parameter instead. 
camel3 - FactoryFinder - Return null if not found instead of exception When starting Camel we attempt to find custom factories for SPI. But this means we end up throwing 40+ exceptions just for a basic Camel route. We can optimize this to use null as response for "no factory exists". Improvement camel3 - FactoryFinder - Return null if not found instead of exception When starting Camel we attempt to find custom factories for SPI. But this means we end up throwing 40+ exceptions just for a basic Camel route. We can optimize this to use null as response for "no factory exists".
Properties component - Check ENV before JVM System property We should favour using OS ENV properties over JVM system properties out of the box, for the same keys. This works the best with containers and cloud platforms. Improvement Properties component - Check ENV before JVM System property We should favour using OS ENV properties over JVM system properties out of the box, for the same keys. This works the best with containers and cloud platforms.
Deprecate transferExchange option Its a bad design to transfer Camel Exchange Java objects over the wire. Lets deprecate it in 2.x and remove in 3.0.The camel-jms component has this option, and some of the http too, and others maybe. Improvement Deprecate transferExchange option Its a bad design to transfer Camel Exchange Java objects over the wire. Lets deprecate it in 2.x and remove in 3.0.The camel-jms component has this option, and some of the http too, and others maybe.
DefaultExchangeHolder - Do not propgate exchange id The exchange id should not be preserved as it should not mutate the existing ids Improvement DefaultExchangeHolder - Do not propgate exchange id The exchange id should not be preserved as it should not mutate the existing ids
ResolveEndpointFailedException should mask sensitive information in uri Misconfiguration of routes throws ResolveEndpointFailedException.This exception prints sensitive information like passwords which should be masked. Improvement ResolveEndpointFailedException should mask sensitive information in uri Misconfiguration of routes throws ResolveEndpointFailedException.This exception prints sensitive information like passwords which should be masked.
camel3 - Always log ERROR if failed to start CamelContext As starting Camel mail fail then lets ensure we always get the exception logged as we rethrow it out of start of camel context, and it may be that some runtimes may not log this, so you can have harder time find out why it failed. Improvement camel3 - Always log ERROR if failed to start CamelContext As starting Camel mail fail then lets ensure we always get the exception logged as we rethrow it out of start of camel context, and it may be that some runtimes may not log this, so you can have harder time find out why it failed.
camel-cdi: Remove support for multiple context via @ContextName (was: NPE with recent camel-cdi changes) {code}Exception 0 :javax.enterprise.inject.InjectionException: Error adding routes of type [org.wildfly.camel.test.cdi.subA.RouteBuilderB] to Camel context [contextB]	at org.apache.camel.cdi.CdiCamelExtension.addRouteToContext(CdiCamelExtension.java:467)	at org.apache.camel.cdi.CdiCamelExtension.afterDeploymentValidation(CdiCamelExtension.java:410)	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)	at java.lang.reflect.Method.invoke(Method.java:498)	at org.jboss.weld.injection.StaticMethodInjectionPoint.invoke(StaticMethodInjectionPoint.java:95)	at org.jboss.weld.injection.MethodInvocationStrategy$SpecialParamPlusBeanManagerStrategy.invoke(MethodInvocationStrategy.java:187)	at org.jboss.weld.event.ObserverMethodImpl.sendEvent(ObserverMethodImpl.java:330)	at org.jboss.weld.event.ExtensionObserverMethodImpl.sendEvent(ExtensionObserverMethodImpl.java:123)	at org.jboss.weld.event.ObserverMethodImpl.sendEvent(ObserverMethodImpl.java:308)	at org.jboss.weld.event.ObserverMethodImpl.notify(ObserverMethodImpl.java:286)	at javax.enterprise.inject.spi.ObserverMethod.notify(ObserverMethod.java:124)	at org.jboss.weld.util.Observers.notify(Observers.java:166)	at org.jboss.weld.event.ObserverNotifier.notifySyncObservers(ObserverNotifier.java:285)	at org.jboss.weld.event.ObserverNotifier.notify(ObserverNotifier.java:273)	at org.jboss.weld.event.ObserverNotifier.fireEvent(ObserverNotifier.java:177)	at org.jboss.weld.event.ObserverNotifier.fireEvent(ObserverNotifier.java:171)	at org.jboss.weld.bootstrap.events.AbstractContainerEvent.fire(AbstractContainerEvent.java:53)	at org.jboss.weld.bootstrap.events.AbstractDeploymentContainerEvent.fire(AbstractDeploymentContainerEvent.java:35)	at org.jboss.weld.bootstrap.events.AfterDeploymentValidationImpl.fire(AfterDeploymentValidationImpl.java:28)	at org.jboss.weld.bootstrap.WeldStartup.validateBeans(WeldStartup.java:505)	at org.jboss.weld.bootstrap.WeldBootstrap.validateBeans(WeldBootstrap.java:93)	at org.jboss.as.weld.WeldStartService.start(WeldStartService.java:98)	at org.jboss.msc.service.ServiceControllerImpl$StartTask.startService(ServiceControllerImpl.java:1737)	at org.jboss.msc.service.ServiceControllerImpl$StartTask.execute(ServiceControllerImpl.java:1699)	at org.jboss.msc.service.ServiceControllerImpl$ControllerTask.run(ServiceControllerImpl.java:1557)	at org.jboss.threads.ContextClassLoaderSavingRunnable.run(ContextClassLoaderSavingRunnable.java:35)	at org.jboss.threads.EnhancedQueueExecutor.safeRun(EnhancedQueueExecutor.java:1982)	at org.jboss.threads.EnhancedQueueExecutor$ThreadBody.doRunTask(EnhancedQueueExecutor.java:1486)	at org.jboss.threads.EnhancedQueueExecutor$ThreadBody.run(EnhancedQueueExecutor.java:1377)	at java.lang.Thread.run(Thread.java:748)Caused by: javax.enterprise.inject.InjectionException: Camel annotations post processing of [InjectionTarget for Managed Bean [class org.wildfly.camel.test.cdi.subA.RouteBuilderB] with qualifiers [@Any @ContextName]] failed!	at org.apache.camel.cdi.CamelBeanInjectionTarget.inject(CamelBeanInjectionTarget.java:44)	at org.jboss.weld.bean.ManagedBean.create(ManagedBean.java:161)	at org.jboss.weld.contexts.unbound.DependentContextImpl.get(DependentContextImpl.java:70)	at org.jboss.weld.bean.ContextualInstanceStrategy$DefaultContextualInstanceStrategy.get(ContextualInstanceStrategy.java:100)	at org.jboss.weld.bean.ContextualInstance.get(ContextualInstance.java:50)	at org.jboss.weld.manager.BeanManagerImpl.getReference(BeanManagerImpl.java:694)	at org.jboss.weld.manager.BeanManagerImpl.getReference(BeanManagerImpl.java:717)	at org.jboss.weld.util.ForwardingBeanManager.getReference(ForwardingBeanManager.java:64)	at org.jboss.weld.bean.builtin.BeanManagerProxy.getReference(BeanManagerProxy.java:87)	at org.apache.camel.cdi.BeanManagerHelper.getReference(BeanManagerHelper.java:53)	at org.apache.camel.cdi.CdiCamelExtension.addRouteToContext(CdiCamelExtension.java:452)	... 31 moreCaused by: java.lang.NullPointerException	at org.apache.camel.support.CamelContextHelper.getEndpointInjection(CamelContextHelper.java:187)	at org.apache.camel.impl.engine.CamelPostProcessorHelper.doGetEndpointInjection(CamelPostProcessorHelper.java:160)	at org.apache.camel.impl.engine.CamelPostProcessorHelper.getEndpointInjection(CamelPostProcessorHelper.java:150)	at org.apache.camel.impl.engine.CamelPostProcessorHelper.getInjectionValue(CamelPostProcessorHelper.java:228)	at org.apache.camel.impl.engine.DefaultCamelBeanPostProcessor.injectField(DefaultCamelBeanPostProcessor.java:210)	at org.apache.camel.impl.engine.DefaultCamelBeanPostProcessor.injectField(DefaultCamelBeanPostProcessor.java:204)	at org.apache.camel.impl.engine.DefaultCamelBeanPostProcessor.lambda$injectFields$0(DefaultCamelBeanPostProcessor.java:181)	at org.apache.camel.util.ReflectionHelper.doWithFields(ReflectionHelper.java:108)	at org.apache.camel.impl.engine.DefaultCamelBeanPostProcessor.injectFields(DefaultCamelBeanPostProcessor.java:166)	at org.apache.camel.impl.engine.DefaultCamelBeanPostProcessor.postProcessBeforeInitialization(DefaultCamelBeanPostProcessor.java:91)	at org.apache.camel.cdi.CamelBeanInjectionTarget.inject(CamelBeanInjectionTarget.java:41)	... 41 moreException 1 :javax.enterprise.inject.InjectionException: Error adding routes of type [org.wildfly.camel.test.cdi.subA.RouteBuilderA] to Camel context [contextA]	at org.apache.camel.cdi.CdiCamelExtension.addRouteToContext(CdiCamelExtension.java:467)	at org.apache.camel.cdi.CdiCamelExtension.afterDeploymentValidation(CdiCamelExtension.java:410)	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)	at java.lang.reflect.Method.invoke(Method.java:498)	at org.jboss.weld.injection.StaticMethodInjectionPoint.invoke(StaticMethodInjectionPoint.java:95)	at org.jboss.weld.injection.MethodInvocationStrategy$SpecialParamPlusBeanManagerStrategy.invoke(MethodInvocationStrategy.java:187)	at org.jboss.weld.event.ObserverMethodImpl.sendEvent(ObserverMethodImpl.java:330)	at org.jboss.weld.event.ExtensionObserverMethodImpl.sendEvent(ExtensionObserverMethodImpl.java:123)	at org.jboss.weld.event.ObserverMethodImpl.sendEvent(ObserverMethodImpl.java:308)	at org.jboss.weld.event.ObserverMethodImpl.notify(ObserverMethodImpl.java:286)	at javax.enterprise.inject.spi.ObserverMethod.notify(ObserverMethod.java:124)	at org.jboss.weld.util.Observers.notify(Observers.java:166)	at org.jboss.weld.event.ObserverNotifier.notifySyncObservers(ObserverNotifier.java:285)	at org.jboss.weld.event.ObserverNotifier.notify(ObserverNotifier.java:273)	at org.jboss.weld.event.ObserverNotifier.fireEvent(ObserverNotifier.java:177)	at org.jboss.weld.event.ObserverNotifier.fireEvent(ObserverNotifier.java:171)	at org.jboss.weld.bootstrap.events.AbstractContainerEvent.fire(AbstractContainerEvent.java:53)	at org.jboss.weld.bootstrap.events.AbstractDeploymentContainerEvent.fire(AbstractDeploymentContainerEvent.java:35)	at org.jboss.weld.bootstrap.events.AfterDeploymentValidationImpl.fire(AfterDeploymentValidationImpl.java:28)	at org.jboss.weld.bootstrap.WeldStartup.validateBeans(WeldStartup.java:505)	at org.jboss.weld.bootstrap.WeldBootstrap.validateBeans(WeldBootstrap.java:93)	at org.jboss.as.weld.WeldStartService.start(WeldStartService.java:98)	at org.jboss.msc.service.ServiceControllerImpl$StartTask.startService(ServiceControllerImpl.java:1737)	at org.jboss.msc.service.ServiceControllerImpl$StartTask.execute(ServiceControllerImpl.java:1699)	at org.jboss.msc.service.ServiceControllerImpl$ControllerTask.run(ServiceControllerImpl.java:1557)	at org.jboss.threads.ContextClassLoaderSavingRunnable.run(ContextClassLoaderSavingRunnable.java:35)	at org.jboss.threads.EnhancedQueueExecutor.safeRun(EnhancedQueueExecutor.java:1982)	at org.jboss.threads.EnhancedQueueExecutor$ThreadBody.doRunTask(EnhancedQueueExecutor.java:1486)	at org.jboss.threads.EnhancedQueueExecutor$ThreadBody.run(EnhancedQueueExecutor.java:1377)	at java.lang.Thread.run(Thread.java:748)Caused by: javax.enterprise.inject.InjectionException: Camel annotations post processing of [InjectionTarget for Managed Bean [class org.wildfly.camel.test.cdi.subA.RouteBuilderA] with qualifiers [@Any @ContextName]] failed!	at org.apache.camel.cdi.CamelBeanInjectionTarget.inject(CamelBeanInjectionTarget.java:44)	at org.jboss.weld.bean.ManagedBean.create(ManagedBean.java:161)	at org.jboss.weld.contexts.unbound.DependentContextImpl.get(DependentContextImpl.java:70)	at org.jboss.weld.bean.ContextualInstanceStrategy$DefaultContextualInstanceStrategy.get(ContextualInstanceStrategy.java:100)	at org.jboss.weld.bean.ContextualInstance.get(ContextualInstance.java:50)	at org.jboss.weld.manager.BeanManagerImpl.getReference(BeanManagerImpl.java:694)	at org.jboss.weld.manager.BeanManagerImpl.getReference(BeanManagerImpl.java:717)	at org.jboss.weld.util.ForwardingBeanManager.getReference(ForwardingBeanManager.java:64)	at org.jboss.weld.bean.builtin.BeanManagerProxy.getReference(BeanManagerProxy.java:87)	at org.apache.camel.cdi.BeanManagerHelper.getReference(BeanManagerHelper.java:53)	at org.apache.camel.cdi.CdiCamelExtension.addRouteToContext(CdiCamelExtension.java:452)	... 31 moreCaused by: java.lang.NullPointerException	at org.apache.camel.support.CamelContextHelper.getEndpointInjection(CamelContextHelper.java:187)	at org.apache.camel.impl.engine.CamelPostProcessorHelper.doGetEndpointInjection(CamelPostProcessorHelper.java:160)	at org.apache.camel.impl.engine.CamelPostProcessorHelper.getEndpointInjection(CamelPostProcessorHelper.java:150)	at org.apache.camel.impl.engine.CamelPostProcessorHelper.getInjectionValue(CamelPostProcessorHelper.java:228)	at org.apache.camel.impl.engine.DefaultCamelBeanPostProcessor.injectField(DefaultCamelBeanPostProcessor.java:210)	at org.apache.camel.impl.engine.DefaultCamelBeanPostProcessor.injectField(DefaultCamelBeanPostProcessor.java:204)	at org.apache.camel.impl.engine.DefaultCamelBeanPostProcessor.lambda$injectFields$0(DefaultCamelBeanPostProcessor.java:181)	at org.apache.camel.util.ReflectionHelper.doWithFields(ReflectionHelper.java:108)	at org.apache.camel.impl.engine.DefaultCamelBeanPostProcessor.injectFields(DefaultCamelBeanPostProcessor.java:166)	at org.apache.camel.impl.engine.DefaultCamelBeanPostProcessor.postProcessBeforeInitialization(DefaultCamelBeanPostProcessor.java:91)	at org.apache.camel.cdi.CamelBeanInjectionTarget.inject(CamelBeanInjectionTarget.java:41)	... 41 more"}}}}{code}CrossRef: https://github.com/wildfly-extras/wildfly-camel/issues/2859 Improvement camel-cdi: Remove support for multiple context via @ContextName (was: NPE with recent camel-cdi changes) {code}Exception 0 :javax.enterprise.inject.InjectionException: Error adding routes of type [org.wildfly.camel.test.cdi.subA.RouteBuilderB] to Camel context [contextB]	at org.apache.camel.cdi.CdiCamelExtension.addRouteToContext(CdiCamelExtension.java:467)	at org.apache.camel.cdi.CdiCamelExtension.afterDeploymentValidation(CdiCamelExtension.java:410)	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)	at java.lang.reflect.Method.invoke(Method.java:498)	at org.jboss.weld.injection.StaticMethodInjectionPoint.invoke(StaticMethodInjectionPoint.java:95)	at org.jboss.weld.injection.MethodInvocationStrategy$SpecialParamPlusBeanManagerStrategy.invoke(MethodInvocationStrategy.java:187)	at org.jboss.weld.event.ObserverMethodImpl.sendEvent(ObserverMethodImpl.java:330)	at org.jboss.weld.event.ExtensionObserverMethodImpl.sendEvent(ExtensionObserverMethodImpl.java:123)	at org.jboss.weld.event.ObserverMethodImpl.sendEvent(ObserverMethodImpl.java:308)	at org.jboss.weld.event.ObserverMethodImpl.notify(ObserverMethodImpl.java:286)	at javax.enterprise.inject.spi.ObserverMethod.notify(ObserverMethod.java:124)	at org.jboss.weld.util.Observers.notify(Observers.java:166)	at org.jboss.weld.event.ObserverNotifier.notifySyncObservers(ObserverNotifier.java:285)	at org.jboss.weld.event.ObserverNotifier.notify(ObserverNotifier.java:273)	at org.jboss.weld.event.ObserverNotifier.fireEvent(ObserverNotifier.java:177)	at org.jboss.weld.event.ObserverNotifier.fireEvent(ObserverNotifier.java:171)	at org.jboss.weld.bootstrap.events.AbstractContainerEvent.fire(AbstractContainerEvent.java:53)	at org.jboss.weld.bootstrap.events.AbstractDeploymentContainerEvent.fire(AbstractDeploymentContainerEvent.java:35)	at org.jboss.weld.bootstrap.events.AfterDeploymentValidationImpl.fire(AfterDeploymentValidationImpl.java:28)	at org.jboss.weld.bootstrap.WeldStartup.validateBeans(WeldStartup.java:505)	at org.jboss.weld.bootstrap.WeldBootstrap.validateBeans(WeldBootstrap.java:93)	at org.jboss.as.weld.WeldStartService.start(WeldStartService.java:98)	at org.jboss.msc.service.ServiceControllerImpl$StartTask.startService(ServiceControllerImpl.java:1737)	at org.jboss.msc.service.ServiceControllerImpl$StartTask.execute(ServiceControllerImpl.java:1699)	at org.jboss.msc.service.ServiceControllerImpl$ControllerTask.run(ServiceControllerImpl.java:1557)	at org.jboss.threads.ContextClassLoaderSavingRunnable.run(ContextClassLoaderSavingRunnable.java:35)	at org.jboss.threads.EnhancedQueueExecutor.safeRun(EnhancedQueueExecutor.java:1982)	at org.jboss.threads.EnhancedQueueExecutor$ThreadBody.doRunTask(EnhancedQueueExecutor.java:1486)	at org.jboss.threads.EnhancedQueueExecutor$ThreadBody.run(EnhancedQueueExecutor.java:1377)	at java.lang.Thread.run(Thread.java:748)Caused by: javax.enterprise.inject.InjectionException: Camel annotations post processing of [InjectionTarget for Managed Bean [class org.wildfly.camel.test.cdi.subA.RouteBuilderB] with qualifiers [@Any @ContextName]] failed!	at org.apache.camel.cdi.CamelBeanInjectionTarget.inject(CamelBeanInjectionTarget.java:44)	at org.jboss.weld.bean.ManagedBean.create(ManagedBean.java:161)	at org.jboss.weld.contexts.unbound.DependentContextImpl.get(DependentContextImpl.java:70)	at org.jboss.weld.bean.ContextualInstanceStrategy$DefaultContextualInstanceStrategy.get(ContextualInstanceStrategy.java:100)	at org.jboss.weld.bean.ContextualInstance.get(ContextualInstance.java:50)	at org.jboss.weld.manager.BeanManagerImpl.getReference(BeanManagerImpl.java:694)	at org.jboss.weld.manager.BeanManagerImpl.getReference(BeanManagerImpl.java:717)	at org.jboss.weld.util.ForwardingBeanManager.getReference(ForwardingBeanManager.java:64)	at org.jboss.weld.bean.builtin.BeanManagerProxy.getReference(BeanManagerProxy.java:87)	at org.apache.camel.cdi.BeanManagerHelper.getReference(BeanManagerHelper.java:53)	at org.apache.camel.cdi.CdiCamelExtension.addRouteToContext(CdiCamelExtension.java:452)	... 31 moreCaused by: java.lang.NullPointerException	at org.apache.camel.support.CamelContextHelper.getEndpointInjection(CamelContextHelper.java:187)	at org.apache.camel.impl.engine.CamelPostProcessorHelper.doGetEndpointInjection(CamelPostProcessorHelper.java:160)	at org.apache.camel.impl.engine.CamelPostProcessorHelper.getEndpointInjection(CamelPostProcessorHelper.java:150)	at org.apache.camel.impl.engine.CamelPostProcessorHelper.getInjectionValue(CamelPostProcessorHelper.java:228)	at org.apache.camel.impl.engine.DefaultCamelBeanPostProcessor.injectField(DefaultCamelBeanPostProcessor.java:210)	at org.apache.camel.impl.engine.DefaultCamelBeanPostProcessor.injectField(DefaultCamelBeanPostProcessor.java:204)	at org.apache.camel.impl.engine.DefaultCamelBeanPostProcessor.lambda$injectFields$0(DefaultCamelBeanPostProcessor.java:181)	at org.apache.camel.util.ReflectionHelper.doWithFields(ReflectionHelper.java:108)	at org.apache.camel.impl.engine.DefaultCamelBeanPostProcessor.injectFields(DefaultCamelBeanPostProcessor.java:166)	at org.apache.camel.impl.engine.DefaultCamelBeanPostProcessor.postProcessBeforeInitialization(DefaultCamelBeanPostProcessor.java:91)	at org.apache.camel.cdi.CamelBeanInjectionTarget.inject(CamelBeanInjectionTarget.java:41)	... 41 moreException 1 :javax.enterprise.inject.InjectionException: Error adding routes of type [org.wildfly.camel.test.cdi.subA.RouteBuilderA] to Camel context [contextA]	at org.apache.camel.cdi.CdiCamelExtension.addRouteToContext(CdiCamelExtension.java:467)	at org.apache.camel.cdi.CdiCamelExtension.afterDeploymentValidation(CdiCamelExtension.java:410)	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)	at java.lang.reflect.Method.invoke(Method.java:498)	at org.jboss.weld.injection.StaticMethodInjectionPoint.invoke(StaticMethodInjectionPoint.java:95)	at org.jboss.weld.injection.MethodInvocationStrategy$SpecialParamPlusBeanManagerStrategy.invoke(MethodInvocationStrategy.java:187)	at org.jboss.weld.event.ObserverMethodImpl.sendEvent(ObserverMethodImpl.java:330)	at org.jboss.weld.event.ExtensionObserverMethodImpl.sendEvent(ExtensionObserverMethodImpl.java:123)	at org.jboss.weld.event.ObserverMethodImpl.sendEvent(ObserverMethodImpl.java:308)	at org.jboss.weld.event.ObserverMethodImpl.notify(ObserverMethodImpl.java:286)	at javax.enterprise.inject.spi.ObserverMethod.notify(ObserverMethod.java:124)	at org.jboss.weld.util.Observers.notify(Observers.java:166)	at org.jboss.weld.event.ObserverNotifier.notifySyncObservers(ObserverNotifier.java:285)	at org.jboss.weld.event.ObserverNotifier.notify(ObserverNotifier.java:273)	at org.jboss.weld.event.ObserverNotifier.fireEvent(ObserverNotifier.java:177)	at org.jboss.weld.event.ObserverNotifier.fireEvent(ObserverNotifier.java:171)	at org.jboss.weld.bootstrap.events.AbstractContainerEvent.fire(AbstractContainerEvent.java:53)	at org.jboss.weld.bootstrap.events.AbstractDeploymentContainerEvent.fire(AbstractDeploymentContainerEvent.java:35)	at org.jboss.weld.bootstrap.events.AfterDeploymentValidationImpl.fire(AfterDeploymentValidationImpl.java:28)	at org.jboss.weld.bootstrap.WeldStartup.validateBeans(WeldStartup.java:505)	at org.jboss.weld.bootstrap.WeldBootstrap.validateBeans(WeldBootstrap.java:93)	at org.jboss.as.weld.WeldStartService.start(WeldStartService.java:98)	at org.jboss.msc.service.ServiceControllerImpl$StartTask.startService(ServiceControllerImpl.java:1737)	at org.jboss.msc.service.ServiceControllerImpl$StartTask.execute(ServiceControllerImpl.java:1699)	at org.jboss.msc.service.ServiceControllerImpl$ControllerTask.run(ServiceControllerImpl.java:1557)	at org.jboss.threads.ContextClassLoaderSavingRunnable.run(ContextClassLoaderSavingRunnable.java:35)	at org.jboss.threads.EnhancedQueueExecutor.safeRun(EnhancedQueueExecutor.java:1982)	at org.jboss.threads.EnhancedQueueExecutor$ThreadBody.doRunTask(EnhancedQueueExecutor.java:1486)	at org.jboss.threads.EnhancedQueueExecutor$ThreadBody.run(EnhancedQueueExecutor.java:1377)	at java.lang.Thread.run(Thread.java:748)Caused by: javax.enterprise.inject.InjectionException: Camel annotations post processing of [InjectionTarget for Managed Bean [class org.wildfly.camel.test.cdi.subA.RouteBuilderA] with qualifiers [@Any @ContextName]] failed!	at org.apache.camel.cdi.CamelBeanInjectionTarget.inject(CamelBeanInjectionTarget.java:44)	at org.jboss.weld.bean.ManagedBean.create(ManagedBean.java:161)	at org.jboss.weld.contexts.unbound.DependentContextImpl.get(DependentContextImpl.java:70)	at org.jboss.weld.bean.ContextualInstanceStrategy$DefaultContextualInstanceStrategy.get(ContextualInstanceStrategy.java:100)	at org.jboss.weld.bean.ContextualInstance.get(ContextualInstance.java:50)	at org.jboss.weld.manager.BeanManagerImpl.getReference(BeanManagerImpl.java:694)	at org.jboss.weld.manager.BeanManagerImpl.getReference(BeanManagerImpl.java:717)	at org.jboss.weld.util.ForwardingBeanManager.getReference(ForwardingBeanManager.java:64)	at org.jboss.weld.bean.builtin.BeanManagerProxy.getReference(BeanManagerProxy.java:87)	at org.apache.camel.cdi.BeanManagerHelper.getReference(BeanManagerHelper.java:53)	at org.apache.camel.cdi.CdiCamelExtension.addRouteToContext(CdiCamelExtension.java:452)	... 31 moreCaused by: java.lang.NullPointerException	at org.apache.camel.support.CamelContextHelper.getEndpointInjection(CamelContextHelper.java:187)	at org.apache.camel.impl.engine.CamelPostProcessorHelper.doGetEndpointInjection(CamelPostProcessorHelper.java:160)	at org.apache.camel.impl.engine.CamelPostProcessorHelper.getEndpointInjection(CamelPostProcessorHelper.java:150)	at org.apache.camel.impl.engine.CamelPostProcessorHelper.getInjectionValue(CamelPostProcessorHelper.java:228)	at org.apache.camel.impl.engine.DefaultCamelBeanPostProcessor.injectField(DefaultCamelBeanPostProcessor.java:210)	at org.apache.camel.impl.engine.DefaultCamelBeanPostProcessor.injectField(DefaultCamelBeanPostProcessor.java:204)	at org.apache.camel.impl.engine.DefaultCamelBeanPostProcessor.lambda$injectFields$0(DefaultCamelBeanPostProcessor.java:181)	at org.apache.camel.util.ReflectionHelper.doWithFields(ReflectionHelper.java:108)	at org.apache.camel.impl.engine.DefaultCamelBeanPostProcessor.injectFields(DefaultCamelBeanPostProcessor.java:166)	at org.apache.camel.impl.engine.DefaultCamelBeanPostProcessor.postProcessBeforeInitialization(DefaultCamelBeanPostProcessor.java:91)	at org.apache.camel.cdi.CamelBeanInjectionTarget.inject(CamelBeanInjectionTarget.java:41)	... 41 more"}}}}{code}CrossRef: https://github.com/wildfly-extras/wildfly-camel/issues/2859
Move @InvokeOnHeader/@InvokeOnHeaders to org.apache.camel.spi package Contributions is welcome, there is a number of components that are using these annotations which needs to be updated too Improvement Move @InvokeOnHeader/@InvokeOnHeaders to org.apache.camel.spi package Contributions is welcome, there is a number of components that are using these annotations which needs to be updated too
camel3 - Camel annotations with context ids should be deprecated We do not recommend having 2+ camel contexts per application / deployment unit. So we should deprecate these on these annotations as they should be for the current context only. Improvement camel3 - Camel annotations with context ids should be deprecated We do not recommend having 2+ camel contexts per application / deployment unit. So we should deprecate these on these annotations as they should be for the current context only.
camel3 - Message API - Deprecate OUT http://mail-archives.apache.org/mod_mbox/camel-dev/201907.mbox/%3CCAGB5yNkyx9LYk40UwGQdq_%2BiZH%3DOrqOifnqp%2BNL7vmv2TSJvnw%40mail.gmail.com%3E Improvement camel3 - Message API - Deprecate OUT http://mail-archives.apache.org/mod_mbox/camel-dev/201907.mbox/%3CCAGB5yNkyx9LYk40UwGQdq_%2BiZH%3DOrqOifnqp%2BNL7vmv2TSJvnw%40mail.gmail.com%3E
camel-zipfile - Accept an iterator as body for zip Accept iterator or Java 8 Stream as body to produce a zip file this will avoid to use the memory for big file (for some use case we can't get an inputStream)For example it would be very nice to be able to do this:{code:java}from("timer:foo?repeatCount=1")                .setBody(constant(Stream.of("v1", "v2")))                .setHeader(Exchange.FILE_NAME, constant("report.txt"))                .marshal().zipFile()                .to("file:output/directory");{code}(https://stackoverflow.com/questions/50295432/zip-and-unzip-a-large-file-without-loading-the-entire-file-in-memory-in-apache-c) Improvement camel-zipfile - Accept an iterator as body for zip Accept iterator or Java 8 Stream as body to produce a zip file this will avoid to use the memory for big file (for some use case we can't get an inputStream)For example it would be very nice to be able to do this:{code:java}from("timer:foo?repeatCount=1")                .setBody(constant(Stream.of("v1", "v2")))                .setHeader(Exchange.FILE_NAME, constant("report.txt"))                .marshal().zipFile()                .to("file:output/directory");{code}(https://stackoverflow.com/questions/50295432/zip-and-unzip-a-large-file-without-loading-the-entire-file-in-memory-in-apache-c)
elasticsearch-rest producer closes connection when route is reloaded from xml and stays closed When setting camel.springboot.xmlRoutesReloadDirectory, any route using the Elasticsearch rest producer will cause a shutdown of the http client. When reloading a route, the route will be stopped and client.close() is being called on RestClient. The shared http client will not be able to handle new requets because the reactor status is STOPPED. Improvement elasticsearch-rest producer closes connection when route is reloaded from xml and stays closed When setting camel.springboot.xmlRoutesReloadDirectory, any route using the Elasticsearch rest producer will cause a shutdown of the http client. When reloading a route, the route will be stopped and client.close() is being called on RestClient. The shared http client will not be able to handle new requets because the reactor status is STOPPED.
StartupListener runs before routes are started, contrary to Javadoc The Javadoc ([https://static.javadoc.io/org.apache.camel/camel-core/2.23.3/org/apache/camel/StartupListener.html]) for StartupListener is misleading (italics for emphasis):{quote}This can be used to perform any custom work when the entire [{{CamelContext}}|https://static.javadoc.io/org.apache.camel/camel-core/2.23.3/org/apache/camel/CamelContext.html] has been initialized and *almost* started. _For example this ensures that all Camel routes have been started and are up and running, before this callback is invoked._{quote}However, routes are not started within the callback. The following code, for example, {code:java}DefaultCamelContext context = new DefaultCamelContext();context.addStartupListener((c, alreadyStarted) -> {    c.createProducerTemplate().sendBody("direct:doesNotExistYet", new Object());});context.addRoutes(new RouteBuilder() {    @Override    public void configure() {        from("direct:doesNotExistYet").bean((Consumer<Object>) System.out::println);    }});context.start();{code}fails with{code}Caused by: org.apache.camel.component.direct.DirectConsumerNotAvailableException: No consumers available on endpoint: direct://doesNotExistYet. Exchange[ID-x-1563396556957-0-1]	at org.apache.camel.component.direct.DirectProducer.process(DirectProducer.java:69)	at org.apache.camel.processor.SharedCamelInternalProcessor.process(SharedCamelInternalProcessor.java:186)	at org.apache.camel.processor.SharedCamelInternalProcessor.process(SharedCamelInternalProcessor.java:86)	at org.apache.camel.impl.ProducerCache$1.doInProducer(ProducerCache.java:541)	at org.apache.camel.impl.ProducerCache$1.doInProducer(ProducerCache.java:506)	at org.apache.camel.impl.ProducerCache.doInProducer(ProducerCache.java:369)	at org.apache.camel.impl.ProducerCache.sendExchange(ProducerCache.java:506)	at org.apache.camel.impl.ProducerCache.send(ProducerCache.java:229)	at org.apache.camel.impl.DefaultProducerTemplate.send(DefaultProducerTemplate.java:144)	at org.apache.camel.impl.DefaultProducerTemplate.sendBody(DefaultProducerTemplate.java:161)	... 12 more{code}I am aware that using ExtendedStartupListener or an EventNotifier makes this work, but it would be great if the Javadoc was updated (assuming this is intended behavior, I am not sure). Improvement StartupListener runs before routes are started, contrary to Javadoc The Javadoc ([https://static.javadoc.io/org.apache.camel/camel-core/2.23.3/org/apache/camel/StartupListener.html]) for StartupListener is misleading (italics for emphasis):{quote}This can be used to perform any custom work when the entire [{{CamelContext}}|https://static.javadoc.io/org.apache.camel/camel-core/2.23.3/org/apache/camel/CamelContext.html] has been initialized and *almost* started. _For example this ensures that all Camel routes have been started and are up and running, before this callback is invoked._{quote}However, routes are not started within the callback. The following code, for example, {code:java}DefaultCamelContext context = new DefaultCamelContext();context.addStartupListener((c, alreadyStarted) -> {    c.createProducerTemplate().sendBody("direct:doesNotExistYet", new Object());});context.addRoutes(new RouteBuilder() {    @Override    public void configure() {        from("direct:doesNotExistYet").bean((Consumer<Object>) System.out::println);    }});context.start();{code}fails with{code}Caused by: org.apache.camel.component.direct.DirectConsumerNotAvailableException: No consumers available on endpoint: direct://doesNotExistYet. Exchange[ID-x-1563396556957-0-1]	at org.apache.camel.component.direct.DirectProducer.process(DirectProducer.java:69)	at org.apache.camel.processor.SharedCamelInternalProcessor.process(SharedCamelInternalProcessor.java:186)	at org.apache.camel.processor.SharedCamelInternalProcessor.process(SharedCamelInternalProcessor.java:86)	at org.apache.camel.impl.ProducerCache$1.doInProducer(ProducerCache.java:541)	at org.apache.camel.impl.ProducerCache$1.doInProducer(ProducerCache.java:506)	at org.apache.camel.impl.ProducerCache.doInProducer(ProducerCache.java:369)	at org.apache.camel.impl.ProducerCache.sendExchange(ProducerCache.java:506)	at org.apache.camel.impl.ProducerCache.send(ProducerCache.java:229)	at org.apache.camel.impl.DefaultProducerTemplate.send(DefaultProducerTemplate.java:144)	at org.apache.camel.impl.DefaultProducerTemplate.sendBody(DefaultProducerTemplate.java:161)	... 12 more{code}I am aware that using ExtendedStartupListener or an EventNotifier makes this work, but it would be great if the Javadoc was updated (assuming this is intended behavior, I am not sure).
camel3 - Property placeholder - Deprecate changing prefix/suffix tokens This causes some issues and its better we stick to one model the default of using {{ }} which is the Camel style. Improvement camel3 - Property placeholder - Deprecate changing prefix/suffix tokens This causes some issues and its better we stick to one model the default of using {{ }} which is the Camel style.
camel3 - Remove poor mans debugger We have an old debugger implementation that just have callbacks before|after a processor in the routes which you can then from camel-test override the before/after methods to have debugging in the editor.We should remove this as its using the intercept strategy which is intended not to be so much in use. So lets cleanup a bit of cruft. There is already the newer backlog debugger that hawtio and other tools uses for debugging. Improvement camel3 - Remove poor mans debugger We have an old debugger implementation that just have callbacks before|after a processor in the routes which you can then from camel-test override the before/after methods to have debugging in the editor.We should remove this as its using the intercept strategy which is intended not to be so much in use. So lets cleanup a bit of cruft. There is already the newer backlog debugger that hawtio and other tools uses for debugging.
Document for XStream JSON not proper The document of Json Xtream [https://github.com/apache/camel/blob/master/components/camel-xstream/src/main/docs/json-xstream-dataformat.adoc] is exactly identical to Xstream [https://github.com/apache/camel/blob/master/components/camel-xstream/src/main/docs/xstream-dataformat.adoc.] Although both uses same component, but JSON xtream document should have document on how to convert JSON to object and vis versa. But it also talks about XML. This needs to be improved. Improvement Document for XStream JSON not proper The document of Json Xtream [https://github.com/apache/camel/blob/master/components/camel-xstream/src/main/docs/json-xstream-dataformat.adoc] is exactly identical to Xstream [https://github.com/apache/camel/blob/master/components/camel-xstream/src/main/docs/xstream-dataformat.adoc.] Although both uses same component, but JSON xtream document should have document on how to convert JSON to object and vis versa. But it also talks about XML. This needs to be improved.
parent/pom.xml - use dash in version properties We should only use dashes in the names, eg         <javax.el-api-version>2.2.5</javax.el-api-version>        <javax.el-version>2.2.5</javax.el-version>        <javax.el3-version>3.0.0</javax.el3-version>        <javax.el-api-hibernate-validator-version>3.0.1-b04</javax.el-api-hibernate-validator-version>        <javax.el-hibernate-validator-version>3.0.1-b10</javax.el-hibernate-validator-version>Should bejavax-el-version and so forth. Also check if all of them are still in use?Contributions is welcome Task parent/pom.xml - use dash in version properties We should only use dashes in the names, eg         <javax.el-api-version>2.2.5</javax.el-api-version>        <javax.el-version>2.2.5</javax.el-version>        <javax.el3-version>3.0.0</javax.el3-version>        <javax.el-api-hibernate-validator-version>3.0.1-b04</javax.el-api-hibernate-validator-version>        <javax.el-hibernate-validator-version>3.0.1-b10</javax.el-hibernate-validator-version>Should bejavax-el-version and so forth. Also check if all of them are still in use?Contributions is welcome
Camel main - Support bean post processing on @BindToRegistry When creating a new bean such as@BindToRegistrypublic MyBean myBean() {  return new MyBean();}We can have a way to support bean post processing so we can do ioc injection on the created bean.There can maybe be an option on camel main you can turn on | off. Also we can support this for fields only, if you dont need to do any customization@BindToRegistryprivate MyBean myBean Improvement Camel main - Support bean post processing on @BindToRegistry When creating a new bean such as@BindToRegistrypublic MyBean myBean() {  return new MyBean();}We can have a way to support bean post processing so we can do ioc injection on the created bean.There can maybe be an option on camel main you can turn on | off. Also we can support this for fields only, if you dont need to do any customization@BindToRegistryprivate MyBean myBean
Converting to boolean should always be strict When converting to boolean (primitive) we should be strict and only allow this for a set of known types and values. Improvement Converting to boolean should always be strict When converting to boolean (primitive) we should be strict and only allow this for a set of known types and values.
NotifyBuilder MockComponent methods are deprecated and there is no replacement Several methods of the NotifyBuilder that receive MockComponent as a parameter are deprecated and are going to be removed from version 3+, but there is no viable replacement at the moment.From related email conversation ([http://mail-archives.apache.org/mod_mbox/camel-users/201907.mbox/%3CMWHPR11MB138984E7FFB0DA82C043F4F395FA0%40MWHPR11MB1389.namprd11.prod.outlook.com%3E]):Claus> Well we can take a look at adding some kind of SPI interface that advice with can use and then mock implement that.And then potentially other components can be used too (in theory). Task NotifyBuilder MockComponent methods are deprecated and there is no replacement Several methods of the NotifyBuilder that receive MockComponent as a parameter are deprecated and are going to be removed from version 3+, but there is no viable replacement at the moment.From related email conversation ([http://mail-archives.apache.org/mod_mbox/camel-users/201907.mbox/%3CMWHPR11MB138984E7FFB0DA82C043F4F395FA0%40MWHPR11MB1389.namprd11.prod.outlook.com%3E]):Claus> Well we can take a look at adding some kind of SPI interface that advice with can use and then mock implement that.And then potentially other components can be used too (in theory).
Endpoint DSL - Do not generate path parameters as they cannot be set individually For examplebean("").beanName("myBean")is not working, you should dobean("myBean");For the former to work we need to allow to dobean().beanName()...And have the endpoint DSL know its a path parameter and built the uri correctly which is hard as this requires camel-catalog to build the uri as it knows all the complexity of building with path parameters.  Improvement Endpoint DSL - Do not generate path parameters as they cannot be set individually For examplebean("").beanName("myBean")is not working, you should dobean("myBean");For the former to work we need to allow to dobean().beanName()...And have the endpoint DSL know its a path parameter and built the uri correctly which is hard as this requires camel-catalog to build the uri as it knows all the complexity of building with path parameters. 
Endpoint DSL - Add to javadoc if an option is required When an option has required=true in the metadata we should add that to the endpoint DSL javadoc, eg{code}        /**         * Whether the topic is persistent or non-persistent.         * The option is a <code>java.lang.String</code> type.         * @group common         */        default PulsarEndpointConsumerBuilder persistence(String persistence) {            setProperty("persistence", persistence);            return this;        }{code}This option is required. Also not sure if @group is a valid javadoc syntax Improvement Endpoint DSL - Add to javadoc if an option is required When an option has required=true in the metadata we should add that to the endpoint DSL javadoc, eg{code}        /**         * Whether the topic is persistent or non-persistent.         * The option is a <code>java.lang.String</code> type.         * @group common         */        default PulsarEndpointConsumerBuilder persistence(String persistence) {            setProperty("persistence", persistence);            return this;        }{code}This option is required. Also not sure if @group is a valid javadoc syntax
Properties component - Make it simpler by removing not often used stuff We can remove the properties component that is using uris, egproperties:myKeyWhich would create an endpoint with myKey as the url (eg delegate). But you can do that today with {{myKey}}.Also we can remove the support for using location paths that has not been pre-configured, as that makes it more complex in terms of init logic. As we want to be able to optimize for property placeholders during build time and whatnot Improvement Properties component - Make it simpler by removing not often used stuff We can remove the properties component that is using uris, egproperties:myKeyWhich would create an endpoint with myKey as the url (eg delegate). But you can do that today with {{myKey}}.Also we can remove the support for using location paths that has not been pre-configured, as that makes it more complex in terms of init logic. As we want to be able to optimize for property placeholders during build time and whatnot
Properties component - Remove complexity of augemented properties parser The need for CAMEL-4520 is not needed and makes the logic too complex. Lets remove this stuff and just use the simpler parser Improvement Properties component - Remove complexity of augemented properties parser The need for CAMEL-4520 is not needed and makes the logic too complex. Lets remove this stuff and just use the simpler parser
If a javax.mail.Session gets referred to using the "session" URL parameter, Apache Camel Mail ignored its hostnames. {color:#658aba}A javax.mail.Session injected using JNDI can refer to one host per protocol. Referring to such a session using the URL query string parameter session=#jndiName seems to ignore the hosts the session is bound to:{color}{color:#658aba}My first try was simply e.g. "smtp://?session=#jndiName". Now Apache Camel Mail complains about a missing hostname.{color}{color:#658aba}So I tried "smtp://localhost?session=#jndiName" expecting that "localhost" would have been overridden using the SMTP host the session refers to, which is not the case. Camel complains that no SMTP server was listening on the host named "localhost".{color}{color:#658aba}The workaround that works – but is somehow redundant in my opinion – is:{color}{{{color:#3381ff}@Resource{color}(mappedName = {color:#658aba}"jndiName"{color})}} {{ {color:#000080}private {color}Session {color:#1948a6}mySession{color};}}{{{color:#658aba}...to("smtp://"+{color}{color:#1948a6}mySession{color}.getProperty({color:#658aba}"mail.smtp.host"{color})+"{color:#658aba}?session=#jndiName")...{color}}}{color:#658aba}The same also applies to the IMAP server (and likely to the other protocols supported by Java Mail as well).{color}{color:#658aba}It would be nice iff referring to a JNDI injected session would take the session as-is to simplify the URL.{color}{color:#658aba}I found an example for using the "session" parameter: "MailUsingCustomSessionTest". It would be helpful to have another example at hand that either takes the hostname from the session as my example above or that does not contain a hostname at all, given, Apache Camel Mail will support that in the future.{color} Improvement If a javax.mail.Session gets referred to using the "session" URL parameter, Apache Camel Mail ignored its hostnames. {color:#658aba}A javax.mail.Session injected using JNDI can refer to one host per protocol. Referring to such a session using the URL query string parameter session=#jndiName seems to ignore the hosts the session is bound to:{color}{color:#658aba}My first try was simply e.g. "smtp://?session=#jndiName". Now Apache Camel Mail complains about a missing hostname.{color}{color:#658aba}So I tried "smtp://localhost?session=#jndiName" expecting that "localhost" would have been overridden using the SMTP host the session refers to, which is not the case. Camel complains that no SMTP server was listening on the host named "localhost".{color}{color:#658aba}The workaround that works - but is somehow redundant in my opinion - is:{color}{{{color:#3381ff}@Resource{color}(mappedName = {color:#658aba}"jndiName"{color})}} {{ {color:#000080}private {color}Session {color:#1948a6}mySession{color};}}{{{color:#658aba}...to("smtp://"+{color}{color:#1948a6}mySession{color}.getProperty({color:#658aba}"mail.smtp.host"{color})+"{color:#658aba}?session=#jndiName")...{color}}}{color:#658aba}The same also applies to the IMAP server (and likely to the other protocols supported by Java Mail as well).{color}{color:#658aba}It would be nice iff referring to a JNDI injected session would take the session as-is to simplify the URL.{color}{color:#658aba}I found an example for using the "session" parameter: "MailUsingCustomSessionTest". It would be helpful to have another example at hand that either takes the hostname from the session as my example above or that does not contain a hostname at all, given, Apache Camel Mail will support that in the future.{color}
Properties component - Optimise to not call loadProperties to frequently The camel-properties calls loadProperties to load all the properties. But it tend to do this for each parseUri for custom PropertiesSource and other means which can be optimised.The cache is based on properties location only. Improvement Properties component - Optimise to not call loadProperties to frequently The camel-properties calls loadProperties to load all the properties. But it tend to do this for each parseUri for custom PropertiesSource and other means which can be optimised.The cache is based on properties location only.
PropertiesSource to resolve a single property CAMEL-13705 introduces support for property sources such as MP Config and others and at the moment it does require to load all the properties upfront on source initialization.It would be nice to have an additional method to resolve a single property as some back-and may perform some I/O to resolve properties and get alll of them could be expensive.So the properties component should:- leverage PropertiesSource::loadPropertiers() when is is required to know all the properties (i.e. when auto configure components in camel main)- leverage a new PropertiesSource::resolveProperty(String) when it just need to resolve a single property Improvement PropertiesSource to resolve a single property CAMEL-13705 introduces support for property sources such as MP Config and others and at the moment it does require to load all the properties upfront on source initialization.It would be nice to have an additional method to resolve a single property as some back-and may perform some I/O to resolve properties and get alll of them could be expensive.So the properties component should:- leverage PropertiesSource::loadPropertiers() when is is required to know all the properties (i.e. when auto configure components in camel main)- leverage a new PropertiesSource::resolveProperty(String) when it just need to resolve a single property
Properties component should work with Eclipse MicroProfile Config We should integrate with MP Config so you can build MP apps and have Camel's properties component use their properties.We should allow to auto-detect this if eg a camel-microprofile-config is on the classpath and then setup this bridge automatic. New Feature Properties component should work with Eclipse MicroProfile Config We should integrate with MP Config so you can build MP apps and have Camel's properties component use their properties.We should allow to auto-detect this if eg a camel-microprofile-config is on the classpath and then setup this bridge automatic.
camel-main-maven-plugin - Only download sources JAR if really neesed We can improve the logic to detect if there are new components and then only if so, download sources jar if needed for options that need documentation. Improvement camel-main-maven-plugin - Only download sources JAR if really neesed We can improve the logic to detect if there are new components and then only if so, download sources jar if needed for options that need documentation.
URISupport - Mask accessToken and clientSecret in uri logging We should also mask accessToken and clientSecret in uri outputs as they are sensitive data. Improvement URISupport - Mask accessToken and clientSecret in uri logging We should also mask accessToken and clientSecret in uri outputs as they are sensitive data.
camel-core - Injector allow to create beans via static factory methods We should support creating beans via static factory methods that they sometime have instead of constructors, such ascamel.component.quartz2.scheduler-factory=#class:org.quartz.impl.DirectSchedulerFactory#getInstance Improvement camel-core - Injector allow to create beans via static factory methods We should support creating beans via static factory methods that they sometime have instead of constructors, such ascamel.component.quartz2.scheduler-factory=#class:org.quartz.impl.DirectSchedulerFactory#getInstance
Easier way to extend PropertiesComponent The current implementation of the PropertiesComponent is very oriented to paths and location and it is not very easy to provide alternative back-ends i.e MP Config or HashiCorp Vault.We may need to re-think the PropertiesComponent interface and reason in term of ordered "property sources", like:{code}ProertiesComponent cp = new ProertiesComponent()cp.addSource(new ValutPropertiesSource())cp.addSource(new PathPropertiesSource())cp.addSource(PropertiesSource.wrap(properties))...{code} Improvement Easier way to extend PropertiesComponent The current implementation of the PropertiesComponent is very oriented to paths and location and it is not very easy to provide alternative back-ends i.e MP Config or HashiCorp Vault.We may need to re-think the PropertiesComponent interface and reason in term of ordered "property sources", like:{code}ProertiesComponent cp = new ProertiesComponent()cp.addSource(new ValutPropertiesSource())cp.addSource(new PathPropertiesSource())cp.addSource(PropertiesSource.wrap(properties))...{code}
camel-main - Add option to ignore unknown options For example if you have OS ENV variables set that will not be in use because a component is not being used or something.  Improvement camel-main - Add option to ignore unknown options For example if you have OS ENV variables set that will not be in use because a component is not being used or something. 
Camel main - Setting boolean option should have strict conversition If you set an option likecamel.main.allow-use-original-message=123Then its set as false, because we do a Boolean.valueOf convertion which just checks if its "true" or not. Instead we should only allow string values of "true" or "false" otherwise its a invalid value. Improvement Camel main - Setting boolean option should have strict conversition If you set an option likecamel.main.allow-use-original-message=123Then its set as false, because we do a Boolean.valueOf convertion which just checks if its "true" or not. Instead we should only allow string values of "true" or "false" otherwise its a invalid value.
camel-main - Add option for verbose logging of configuration So end users can just set an optioncamel.main.configuration-logging=trueOr something like that to get verbose INFO logging of how all these configurations are computed so you can use that to track if something seems not correct. Improvement camel-main - Add option for verbose logging of configuration So end users can just set an optioncamel.main.configuration-logging=trueOr something like that to get verbose INFO logging of how all these configurations are computed so you can use that to track if something seems not correct.
camel-rabbitmq  Thread name for route set to endpoint uri change thread name of rabbitmq routes from "RabbitMQConsumer" to  its endpoint uri Improvement camel-rabbitmq  Thread name for route set to endpoint uri change thread name of rabbitmq routes from "RabbitMQConsumer" to  its endpoint uri
camel-main - configuring properties report better error if missing JARs on classpath Look into if we are not reporting a good error if you configure an option for a component that is not on the classpath etc. Improvement camel-main - configuring properties report better error if missing JARs on classpath Look into if we are not reporting a good error if you configure an option for a component that is not on the classpath etc.
camel-main - Allow ENV variables to configure any option Any of the options you can configure via application.properties such as:camel.main.namecamel.component.xxx=yyyAnd so on should be configurable via ENV variables which will override any existing configuration. This is good practice in containers and also how SB can do etc. New Feature camel-main - Allow ENV variables to configure any option Any of the options you can configure via application.properties such as:camel.main.namecamel.component.xxx=yyyAnd so on should be configurable via ENV variables which will override any existing configuration. This is good practice in containers and also how SB can do etc.
Attachments API on Message - Deprecate and remove We should consider making the Camel Message API more simpler and remove stuff that are seldom in use, or can be component specific.The javax.attachment is removed from JDK11 onwards and its not really much in use in the future. Improvement Attachments API on Message - Deprecate and remove We should consider making the Camel Message API more simpler and remove stuff that are seldom in use, or can be component specific.The javax.attachment is removed from JDK11 onwards and its not really much in use in the future.
Move AttachmentConverterLoader out of camel-core The javax.attachments API are not standard in Java 11. We should make this converter optional from camel-core and move to somewhere else. Improvement Move AttachmentConverterLoader out of camel-core The javax.attachments API are not standard in Java 11. We should make this converter optional from camel-core and move to somewhere else.
camel-main - Optimise main configurer This method takes approx 60 millis on my laptoporg.apache.camel.main.DefaultConfigurationConfigurer#afterPropertiesSetI suspects its all those lambda's that are loaded on classpath and only in use if there is a bean to lookup. The logic can be improved to use old fashioned code with some if != nullIf I disable all of those then its down to 4 millis on my laptop Improvement camel-main - Optimise main configurer This method takes approx 60 millis on my laptoporg.apache.camel.main.DefaultConfigurationConfigurer#afterPropertiesSetI suspects its all those lambda's that are loaded on classpath and only in use if there is a bean to lookup. The logic can be improved to use old fashioned code with some if != nullIf I disable all of those then its down to 4 millis on my laptop
Simple language - Body as one line Add function to return the message body as a one line string. This can be useful in some situations where you want to be able to do this from logging point of view via Log EIP New Feature Simple language - Body as one line Add function to return the message body as a one line string. This can be useful in some situations where you want to be able to do this from logging point of view via Log EIP
camel-main-maven-plugin - Add groups to tooling metadata We can add groups as documented in SB metamodelhttps://docs.spring.io/spring-boot/docs/current/reference/html/configuration-metadata.html#configuration-metadata-formatThen we can have groups for- main- per componentWith a description of each group, eg the component description etc. This gives a little bit more documentation for the end users. Improvement camel-main-maven-plugin - Add groups to tooling metadata We can add groups as documented in SB metamodelhttps://docs.spring.io/spring-boot/docs/current/reference/html/configuration-metadata.html#configuration-metadata-formatThen we can have groups for- main- per componentWith a description of each group, eg the component description etc. This gives a little bit more documentation for the end users.
camel3 - SPI classpath discovery - Combine into a single lookup We do a bunch of SPI classpath discover for 3rd party plugins and even for components like camel-bean and whatnot. (its those resolvers).For a quicker startup we can group these standard lookups into a single classpath scan (notice Camel only does that if you have not set an explicit SPI vis its setter). Improvement camel3 - SPI classpath discovery - Combine into a single lookup We do a bunch of SPI classpath discover for 3rd party plugins and even for components like camel-bean and whatnot. (its those resolvers).For a quicker startup we can group these standard lookups into a single classpath scan (notice Camel only does that if you have not set an explicit SPI vis its setter).
camel-main-maven-plugin - Generate tooling metadata To assist editing Camel Main and eg application.properties then we could "fool" tooling by generating Spring Boot metadata json files, so tools see these files and offer their code completions.Then you can use ctrl + space for type completions when typingcamel.component.jms New Feature camel-main-maven-plugin - Generate tooling metadata To assist editing Camel Main and eg application.properties then we could "fool" tooling by generating Spring Boot metadata json files, so tools see these files and offer their code completions.Then you can use ctrl + space for type completions when typingcamel.component.jms
Refine ProcessorDefinition output handling The ProcessDefinition class is the base class for most of the DSL / Definitions and defines a  number of methods related to outputs such as:{code:java}public abstract List<ProcessorDefinition<?>> getOutputs();public abstract boolean isOutputSupported();{code}The information about the ability to handle outputs is thus available at runtime only which complicates the creation of alternative DSLs (i.e https://github.com/apache/camel-k-runtime/issues/80) Improvement Refine ProcessorDefinition output handling The ProcessDefinition class is the base class for most of the DSL / Definitions and defines a  number of methods related to outputs such as:{code:java}public abstract List<ProcessorDefinition<?>> getOutputs();public abstract boolean isOutputSupported();{code}The information about the ability to handle outputs is thus available at runtime only which complicates the creation of alternative DSLs (i.e https://github.com/apache/camel-k-runtime/issues/80)
Simpler attribute names in the XML DSL Some part of the DSL expose verbose properties as example, the set header definition, has ha setHeaderName property which leads to an XML like:{code:xml}<setHeader headerName="Something"/>{code}This is not wrong but the context gives enough information so it can be rewritten as:{code:xml}<setHeader name="Something"/>{code}Which makes it shorter and does not impact comprehension.  Improvement Simpler attribute names in the XML DSL Some part of the DSL expose verbose properties as example, the set header definition, has ha setHeaderName property which leads to an XML like:{code:xml}<setHeader headerName="Something"/>{code}This is not wrong but the context gives enough information so it can be rewritten as:{code:xml}<setHeader name="Something"/>{code}Which makes it shorter and does not impact comprehension. 
reifiers classes should be public Refiers classes are now package private that make it impossible to reuse them for example in a custom processor factory like what it is done by Hystrix: https://github.com/apache/camel/blob/master/components/camel-hystrix/src/main/java/org/apache/camel/component/hystrix/processor/HystrixProcessorFactory.java Improvement reifiers classes should be public Refiers classes are now package private that make it impossible to reuse them for example in a custom processor factory like what it is done by Hystrix: https://github.com/apache/camel/blob/master/components/camel-hystrix/src/main/java/org/apache/camel/component/hystrix/processor/HystrixProcessorFactory.java
Properties component - loadProperties to return properties in order The API    Properties loadProperties();    Properties loadProperties(String... locations);But the Properties is a Hashtable that is unordered, but it would be better if we could get this as Map so we can use LinkedHashMap so they are in order. This would work better with the order the end users may define in their application.properties files etccamel.component.jms.configuration.connectionFactory=#class:org.apache.activemq.artemis.jms.client.ActiveMQJMSConnectionFactorycamel.component.jms.configuration.connectionFactory.brokerUrl=localhost:61616 Improvement Properties component - loadProperties to return properties in order The API    Properties loadProperties();    Properties loadProperties(String... locations);But the Properties is a Hashtable that is unordered, but it would be better if we could get this as Map so we can use LinkedHashMap so they are in order. This would work better with the order the end users may define in their application.properties files etccamel.component.jms.configuration.connectionFactory=#class:org.apache.activemq.artemis.jms.client.ActiveMQJMSConnectionFactorycamel.component.jms.configuration.connectionFactory.brokerUrl=localhost:61616
camel-main - Add support for auto binding to components by interface type and discover impl class on classpath This can make convention over configuration nicer. For example some components requires a ConnectionFactory etc and if we can auto-discover that on the classpath there is only 1 implementation of such interface, we can try to auto create the instance and configure it on the component.This should be an option you can turn on|off. New Feature camel-main - Add support for auto binding to components by interface type and discover impl class on classpath This can make convention over configuration nicer. For example some components requires a ConnectionFactory etc and if we can auto-discover that on the classpath there is only 1 implementation of such interface, we can try to auto create the instance and configure it on the component.This should be an option you can turn on|off.
camel-spring - NPE in NotifyBuilder during testing Just noticed some NPEs while doing test of camel-spring019-06-13 15:02:08,902 WARN  EventHelper - Error notifying event ID-davsclaus-pro-local-1560430811107-235-1 exchange created: Exchange[ID-davsclaus-pro-local-1560430811107-235-1]. This exception will be ignored.  java.lang.NullPointerException: null	at org.apache.camel.builder.NotifyBuilder$3.onExchange(NotifyBuilder.java:194) ~[camel-core-3.0.0-SNAPSHOT.jar:3.0.0-SNAPSHOT]	at org.apache.camel.builder.NotifyBuilder$EventPredicateSupport.onExchangeCreated(NotifyBuilder.java:1293) ~[camel-core-3.0.0-SNAPSHOT.jar:3.0.0-SNAPSHOT]	at org.apache.camel.builder.NotifyBuilder$CompoundEventPredicate.onExchangeCreated(NotifyBuilder.java:1381) ~[camel-core-3.0.0-SNAPSHOT.jar:3.0.0-SNAPSHOT]	at org.apache.camel.builder.NotifyBuilder$ExchangeNotifier.onExchangeCreated(NotifyBuilder.java:1154) ~[camel-core-3.0.0-SNAPSHOT.jar:3.0.0-SNAPSHOT]	at org.apache.camel.builder.NotifyBuilder$ExchangeNotifier.notify(NotifyBuilder.java:1135) ~[camel-core-3.0.0-SNAPSHOT.jar:3.0.0-SNAPSHOT]	at org.apache.camel.support.EventHelper.doNotifyEvent(EventHelper.java:288) [camel-support-3.0.0-SNAPSHOT.jar:3.0.0-SNAPSHOT]	at org.apache.camel.support.EventHelper.doNotify(EventHelper.java:27 Test camel-spring - NPE in NotifyBuilder during testing Just noticed some NPEs while doing test of camel-spring019-06-13 15:02:08,902 WARN  EventHelper - Error notifying event ID-davsclaus-pro-local-1560430811107-235-1 exchange created: Exchange[ID-davsclaus-pro-local-1560430811107-235-1]. This exception will be ignored.  java.lang.NullPointerException: null	at org.apache.camel.builder.NotifyBuilder$3.onExchange(NotifyBuilder.java:194) ~[camel-core-3.0.0-SNAPSHOT.jar:3.0.0-SNAPSHOT]	at org.apache.camel.builder.NotifyBuilder$EventPredicateSupport.onExchangeCreated(NotifyBuilder.java:1293) ~[camel-core-3.0.0-SNAPSHOT.jar:3.0.0-SNAPSHOT]	at org.apache.camel.builder.NotifyBuilder$CompoundEventPredicate.onExchangeCreated(NotifyBuilder.java:1381) ~[camel-core-3.0.0-SNAPSHOT.jar:3.0.0-SNAPSHOT]	at org.apache.camel.builder.NotifyBuilder$ExchangeNotifier.onExchangeCreated(NotifyBuilder.java:1154) ~[camel-core-3.0.0-SNAPSHOT.jar:3.0.0-SNAPSHOT]	at org.apache.camel.builder.NotifyBuilder$ExchangeNotifier.notify(NotifyBuilder.java:1135) ~[camel-core-3.0.0-SNAPSHOT.jar:3.0.0-SNAPSHOT]	at org.apache.camel.support.EventHelper.doNotifyEvent(EventHelper.java:288) [camel-support-3.0.0-SNAPSHOT.jar:3.0.0-SNAPSHOT]	at org.apache.camel.support.EventHelper.doNotify(EventHelper.java:27
camel3 - SPI for ReactiveHelper so we can plugin different reactive engines Today we use ReactiveHelper.callback(callback) to execute works in Camel routing engine. We should have a SPI so we can plugin 3rd party. Improvement camel3 - SPI for ReactiveHelper so we can plugin different reactive engines Today we use ReactiveHelper.callback(callback) to execute works in Camel routing engine. We should have a SPI so we can plugin 3rd party.
Camel main - Allow to configure rest dsl configuration So you can configure in application.properties etc, some of the rest dsl configuration you would otherwise have to configure with restConfiguration() in the java dsl Improvement Camel main - Allow to configure rest dsl configuration So you can configure in application.properties etc, some of the rest dsl configuration you would otherwise have to configure with restConfiguration() in the java dsl
Deprecate and remove ReloadStrategy This should be deprecated in camel 2.x and removed in 3.0.This makes the modularization of camel 3 better, and its also only used as a developer/demo thing and not for production usage. And today there are better alternatives with camel k, and camel-quarkus etc, for hot re-load that can load the entire app and not only a xml route. Improvement Deprecate and remove ReloadStrategy This should be deprecated in camel 2.x and removed in 3.0.This makes the modularization of camel 3 better, and its also only used as a developer/demo thing and not for production usage. And today there are better alternatives with camel k, and camel-quarkus etc, for hot re-load that can load the entire app and not only a xml route.
Camel Main - Move to camel-main ccomponent Lets see if we can move the main classes from camel-core to camel-main so they get more separated and become more reusable in other parts.We have a common set of options to configure on camel context itself, and all the configuration of components etc. That logic can be more shared for camel main, camel k, camel spring boot, and others etc. Improvement Camel Main - Move to camel-main ccomponent Lets see if we can move the main classes from camel-core to camel-main so they get more separated and become more reusable in other parts.We have a common set of options to configure on camel context itself, and all the configuration of components etc. That logic can be more shared for camel main, camel k, camel spring boot, and others etc.
camel3 - Move FileWatcherReloadStrategy out of camel-core For example to camel-support etc Improvement camel3 - Move FileWatcherReloadStrategy out of camel-core For example to camel-support etc
camel-rest - Should separate consumer and producer component names You may end up with using rest-dsl and rest component together, and have a rest endpoint that is shared among them. Then the endpoint will have a componentName option set to the consumer, such as jetty. And then when the same endpoint is used for creating the rest producer (eg to rest) then it would fail. We should separate these two options. Improvement camel-rest - Should separate consumer and producer component names You may end up with using rest-dsl and rest component together, and have a rest endpoint that is shared among them. Then the endpoint will have a componentName option set to the consumer, such as jetty. And then when the same endpoint is used for creating the rest producer (eg to rest) then it would fail. We should separate these two options.
camel-spring-boot - Add option to include/exclude routes based on their ids So you can for example do an unit test where you want to only test a specific route and then filter out everyone else. Currently you can filter on route builder and xml files level, but not on route ids. New Feature camel-spring-boot - Add option to include/exclude routes based on their ids So you can for example do an unit test where you want to only test a specific route and then filter out everyone else. Currently you can filter on route builder and xml files level, but not on route ids.
Support setup proxy host and port on Telegram As we may run the camel-telegram application behind a proxy, it could be handy if camel-telegram support setting http proxy.  Improvement Support setup proxy host and port on Telegram As we may run the camel-telegram application behind a proxy, it could be handy if camel-telegram support setting http proxy. 
Claim check - Allow to use dynamic key via simple language Asked on user forumhttp://camel.465427.n5.nabble.com/Using-dynamic-expression-as-claimCheck-key-tp5835356.html Improvement Claim check - Allow to use dynamic key via simple language Asked on user forumhttp://camel.465427.n5.nabble.com/Using-dynamic-expression-as-claimCheck-key-tp5835356.html
Splitter tokenize doesn't really accept every regex Hi, Neither{code:java}.split().tokenize("\r?\n", true, 2, true){code}nor {code:java}.split().tokenize("\r\n|\n", true, 2, true){code}work. The latter expression insert a "|" instead of correctly split rows on \r\n or \n.       Improvement Splitter tokenize doesn't really accept every regex Hi, Neither{code:java}.split().tokenize("\r?\n", true, 2, true){code}nor {code:java}.split().tokenize("\r\n|\n", true, 2, true){code}work. The latter expression insert a "|" instead of correctly split rows on \r\n or \n.      
camel apt - Avoid generating TypeConverter META-INF file when we generate TypeConverterLoader We can optimize this to only have the newer TypeConverterLoader file which has all the type converters that are optimized. And then in tooling/apt avoid generate both TypeConverter and TypeConverterLoaded meta files. Improvement camel apt - Avoid generating TypeConverter META-INF file when we generate TypeConverterLoader We can optimize this to only have the newer TypeConverterLoader file which has all the type converters that are optimized. And then in tooling/apt avoid generate both TypeConverter and TypeConverterLoaded meta files.
Camel main - Calling init should initialize as much as possible So we can eager init as much as possible when running Camel Main, by calling main.init() method. This can be used to warmup Camel. Improvement Camel main - Calling init should initialize as much as possible So we can eager init as much as possible when running Camel Main, by calling main.init() method. This can be used to warmup Camel.
Camel Injector - Add method for creating a new instance without bean processing There are use-cases where we for example loads the type converter loaded that creates an instance of the class, but we use the injector which does bean post processing by scanning methods for injecting fields / and other autowriting via those Camel annotations. But these type converters are basic and dont need this. There can be some other factory classes too, so lets have a basic injector method so you can choose. Improvement Camel Injector - Add method for creating a new instance without bean processing There are use-cases where we for example loads the type converter loaded that creates an instance of the class, but we use the injector which does bean post processing by scanning methods for injecting fields / and other autowriting via those Camel annotations. But these type converters are basic and dont need this. There can be some other factory classes too, so lets have a basic injector method so you can choose.
Camel main - Configuration class should support automatic autowire by type In such a configuration class{code}public class MyConfiguration {    @BindToRegistry    public ClientConfiguration myClientConfig() {        ClientConfiguration cc = new ClientConfiguration();        cc.setMaxConnections(5);        return cc;    }    @BindToRegistry    public MyBean myBean(@PropertyInject("hi") String hi, @PropertyInject("bye") String bye) {        // this will create an instance of this bean with the name of the method (eg myBean)        return new MyBean(hi, bye);    }    @BindToRegistry    public AmazonS3 myAmazon(@BeanInject("myClientConfig") ClientConfiguration config) {        return AmazonS3Client.builder().withRegion("US-EAST-1").withClientConfiguration(config).build();    }    public void configure() {        // this method is optional and can be removed if no additional configuration is needed.    }}{code}We could detect that the myAmazon method has a parameter of type ClientConfiguration which we can attempt to lookup as singleton bean. Then you can do{code}    @BindToRegistry    public AmazonS3 myAmazon(ClientConfiguration config) {code} Improvement Camel main - Configuration class should support automatic autowire by type In such a configuration class{code}public class MyConfiguration {    @BindToRegistry    public ClientConfiguration myClientConfig() {        ClientConfiguration cc = new ClientConfiguration();        cc.setMaxConnections(5);        return cc;    }    @BindToRegistry    public MyBean myBean(@PropertyInject("hi") String hi, @PropertyInject("bye") String bye) {        // this will create an instance of this bean with the name of the method (eg myBean)        return new MyBean(hi, bye);    }    @BindToRegistry    public AmazonS3 myAmazon(@BeanInject("myClientConfig") ClientConfiguration config) {        return AmazonS3Client.builder().withRegion("US-EAST-1").withClientConfiguration(config).build();    }    public void configure() {        // this method is optional and can be removed if no additional configuration is needed.    }}{code}We could detect that the myAmazon method has a parameter of type ClientConfiguration which we can attempt to lookup as singleton bean. Then you can do{code}    @BindToRegistry    public AmazonS3 myAmazon(ClientConfiguration config) {code}
camel-blueprint - Many WARNs about overriding type converters Noticed these during testing CiA2 book2019-05-27 06:47:06,045 [main           ] WARN  DefaultTypeConverter           - Overriding type converter from: org.apache.camel.support.SimpleTypeConverter@659f226a to: StaticMethodTypeConverter: public static org.restlet.data.Method org.apache.camel.component.restlet.converter.RestletConverter.toMethod(java.lang.String)2019-05-27 06:47:06,045 [main           ] WARN  DefaultTypeConverter           - Overriding type converter from: org.apache.camel.support.SimpleTypeConverter@2e463f4 to: StaticMethodTypeConverter: public static org.restlet.data.Method[] org.apache.camel.component.restlet.converter.RestletConverter.toMethods(java.lang.String)2019-05-27 06:47:06,045 [main           ] WARN  DefaultTypeConverter           - Overriding type converter from: org.apache.camel.support.SimpleTypeConverter@32ec9c90 to: StaticMethodTypeConverter: public static org.restlet.data.MediaType[] org.apache.camel.component.restlet.converter.RestletConverter.toMediaTypes(java.lang.String)2019-05-27 06:47:06,046 [main           ] WARN  DefaultTypeConverter           - Overriding type converter from: org.apache.camel.support.SimpleTypeConverter@36ab3814 to: StaticMethodTypeConverter: public static org.restlet.data.MediaType org.apache.camel.component.restlet.converter.RestletConverter.toMediaType(java.lang.String)2019-05-27 06:47:06,046 [main           ] WARN  DefaultTypeConverter           - Overriding type converter from: org.apache.camel.support.SimpleTypeConverter@467233e4 to: StaticMethodTypeConverter: public static java.io.InputStream org.apache.camel.http.common.HttpConverter.toInputStream(org.apache.camel.http.common.HttpMessage,org.apache.camel.Exchange) throws java.lang.Exception2019-05-27 06:47:06,046 [main           ] WARN  DefaultTypeConverter           - Overriding type converter from: org.apache.camel.support.SimpleTypeConverter@427a12b6 to: StaticMethodTypeConverter: public static java.io.InputStream org.apache.camel.http.common.HttpConverter.toInputStream(javax.servlet.http.HttpServletRequest,org.apache.camel.Exchange) throws java.io.IOException2019-05-27 06:47:06,046 [main           ] WARN  DefaultTypeConverter           - Overriding type converter from: org.apache.camel.support.SimpleTypeConverter@6025d790 to: StaticMethodTypeConverter: public static java.io.BufferedReader org.apache.camel.http.common.HttpConverter.toReader(org.apache.camel.http.common.HttpMessage) throws java.io.IOException2019-05-27 06:47:06,046 [main           ] WARN  DefaultTypeConverter           - Overriding type converter from: org.apache.camel.support.SimpleTypeConverter@af7e376 to: StaticMethodTypeConverter: public static javax.servlet.http.HttpServletResponse org.apache.camel.http.common.HttpConverter.toServletResponse(org.apache.camel.Message)2019-05-27 06:47:06,046 [main           ] WARN  DefaultTypeConverter           - Overriding type converter from: org.apache.camel.support.SimpleTypeConverter@5dcd0cdf to: StaticMethodTypeConverter: public static javax.servlet.http.HttpServletRequest org.apache.camel.http.common.HttpConverter.toServletRequest(org.apache.camel.Message)2019-05-27 06:47:06,047 [main           ] WARN  DefaultTypeConverter           - Overriding type converter from: org.apache.camel.support.SimpleTypeConverter@4fb04a72 to: StaticMethodTypeConverter: public static javax.servlet.ServletInputStream org.apache.camel.http.common.HttpConverter.toServletInputStream(org.apache.camel.http.common.HttpMessage) throws java.io.IOException2019-05-27 06:47:06,047 [main           ] WARN  DefaultTypeConverter           - Overriding type converter from: org.apache.camel.support.SimpleTypeConverter@1a07bf6 to: StaticMethodTypeConverter: public static java.io.InputStream org.apache.camel.spring.converter.ResourceConverter.convertToInputStream(org.springframework.core.io.Resource) throws java.io.IOException2019-05-27 06:47:06,047 [main           ] WARN  DefaultTypeConverter           - Overriding type converter from: org.apache.camel.support.SimpleTypeConverter@34d713a2 to: StaticMethodTypeConverter: public static java.lang.Object[] org.apache.camel.component.cxf.converter.CxfConverter.toArray(java.lang.Object)2019-05-27 06:47:06,047 [main           ] WARN  DefaultTypeConverter           - Overriding type converter from: org.apache.camel.support.SimpleTypeConverter@36aab105 to: StaticMethodTypeConverter: public static java.io.InputStream org.apache.camel.component.cxf.converter.CxfConverter.toInputStream(javax.ws.rs.core.Response,org.apache.camel.Exchange)2019-05-27 06:47:06,047 [main           ] WARN  DefaultTypeConverter           - Overriding type converter from: org.apache.camel.support.SimpleTypeConverter@889a8a8 to: StaticMethodTypeConverter: public static javax.xml.namespace.QName org.apache.camel.component.cxf.converter.CxfConverter.toQName(java.lang.String)2019-05-27 06:47:06,047 [main           ] WARN  DefaultTypeConverter           - Overriding type converter from: org.apache.camel.support.SimpleTypeConverter@f29353f to: StaticMethodTypeConverter: public static org.apache.cxf.message.MessageContentsList org.apache.camel.component.cxf.converter.CxfConverter.toMessageContentsList(java.lang.Object[])2019-05-27 06:47:06,047 [main           ] WARN  DefaultTypeConverter           - Overriding type converter from: org.apache.camel.support.SimpleTypeConverter@36f7d7b to: StaticMethodTypeConverter: public static org.apache.camel.component.cxf.DataFormat org.apache.camel.component.cxf.converter.CxfConverter.toDataFormat(java.lang.String)2019-05-27 06:47:06,047 [main           ] WARN  DefaultTypeConverter           - Overriding type converter from: org.apache.camel.support.SimpleTypeConverter@60aec68a to: StaticMethodTypeConverter: public static java.lang.String org.apache.camel.component.cxf.converter.CxfConverter.soapMessageToString(javax.xml.soap.SOAPMessage,org.apache.camel.Exchange) throws javax.xml.soap.SOAPException,java.io.IOException2019-05-27 06:47:06,047 [main           ] WARN  DefaultTypeConverter           - Overriding type converter from: org.apache.camel.support.SimpleTypeConverter@25a7fedf to: StaticMethodTypeConverter: public static java.io.InputStream org.apache.camel.component.cxf.converter.CxfConverter.soapMessageToInputStream(javax.xml.soap.SOAPMessage,org.apache.camel.Exchange) throws javax.xml.soap.SOAPException,java.io.IOException2019-05-27 06:47:06,047 [main           ] WARN  DefaultTypeConverter           - Overriding type converter from: org.apache.camel.support.SimpleTypeConverter@6361b799 to: StaticMethodTypeConverter: public static org.w3c.dom.NodeList org.apache.camel.component.cxf.converter.CxfPayloadConverter.cxfPayloadToNodeList(org.apache.camel.component.cxf.CxfPayload,org.apache.camel.Exchange)2019-05-27 06:47:06,047 [main           ] WARN  DefaultTypeConverter           - Overriding type converter from: org.apache.camel.support.SimpleTypeConverter@1b9d9a2b to: StaticMethodTypeConverter: public static org.w3c.dom.Node org.apache.camel.component.cxf.converter.CxfPayloadConverter.cxfPayLoadToNode(org.apache.camel.component.cxf.CxfPayload,org.apache.camel.Exchange)2019-05-27 06:47:06,047 [main           ] WARN  DefaultTypeConverter           - Overriding type converter from: org.apache.camel.support.SimpleTypeConverter@d919544 to: StaticMethodTypeConverter: public static org.apache.camel.component.cxf.CxfPayload org.apache.camel.component.cxf.converter.CxfPayloadConverter.nodeListToCxfPayload(org.w3c.dom.NodeList,org.apache.camel.Exchange)2019-05-27 06:47:06,047 [main           ] WARN  DefaultTypeConverter           - Overriding type converter from: org.apache.camel.support.SimpleTypeConverter@17dad32f to: StaticMethodTypeConverter: public static org.apache.camel.component.cxf.CxfPayload org.apache.camel.component.cxf.converter.CxfPayloadConverter.elementToCxfPayload(org.w3c.dom.Element,org.apache.camel.Exchange)2019-05-27 06:47:06,047 [main           ] WARN  DefaultTypeConverter           - Overriding type converter from: org.apache.camel.support.SimpleTypeConverter@79696332 to: StaticMethodTypeConverter: public static org.apache.camel.component.cxf.CxfPayload org.apache.camel.component.cxf.converter.CxfPayloadConverter.documentToCxfPayload(org.w3c.dom.Document,org.apache.camel.Exchange)2019-05-27 06:47:06,048 [main           ] WARN  DefaultTypeConverter           - Overriding type converter from: org.apache.camel.support.SimpleTypeConverter@ed2f2f6 to: StaticMethodTypeConverter: public static org.apache.camel.component.cxf.CxfPayload org.apache.camel.component.cxf.converter.CxfPayloadConverter.sourceToCxfPayload(javax.xml.transform.Source,org.apache.camel.Exchange)2019-05-27 06:47:06,048 [main           ] WARN  DefaultTypeConverter           - Overriding type converter from: org.apache.camel.support.SimpleTypeConverter@fe87ddd to: StaticMethodTypeConverter: public static org.apache.camel.StreamCache org.apache.camel.component.cxf.converter.CxfPayloadConverter.cxfPayLoadToStreamCache(org.apache.camel.component.cxf.CxfPayload,org.apache.camel.Exchange)2019-05-27 06:47:06,048 [main           ] WARN  DefaultTypeConverter           - Overriding type converter from: org.apache.camel.support.SimpleTypeConverter@4eea94a4 to: StaticMethodTypeConverter: public static javax.xml.transform.Source org.apache.camel.component.cxf.converter.CxfPayloadConverter.cxfPayLoadToSource(org.apache.camel.component.cxf.CxfPayload,org.apache.camel.Exchange)2019-05-27 06:47:06,048 [main           ] WARN  DefaultTypeConverter           - Overriding type converter from: org.apache.camel.support.SimpleTypeConverter@29be997f to: StaticMethodTypeConverter: public static java.io.InputStream org.apache.camel.component.file.GenericFileConverter.genericFileToInputStream(org.apache.camel.component.file.GenericFile,org.apache.camel.Exchange) throws java.io.IOException2019-05-27 06:47:06,048 [main           ] WARN  DefaultTypeConverter           - Overriding type converter from: org.apache.camel.support.SimpleTypeConverter@33eb6758 to: StaticMethodTypeConverter: public static java.lang.String org.apache.camel.component.file.GenericFileConverter.genericFileToString(org.apache.camel.component.file.GenericFile,org.apache.camel.Exchange) throws java.io.IOException,org.apache.camel.NoTypeConversionAvailableException2019-05-27 06:47:06,048 [main           ] WARN  DefaultTypeConverter           - Overriding type converter from: org.apache.camel.support.SimpleTypeConverter@f8a6243 to: StaticMethodTypeConverter: public static java.io.Serializable org.apache.camel.component.file.GenericFileConverter.genericFileToSerializable(org.apache.camel.component.file.GenericFile,org.apache.camel.Exchange) throws java.io.IOException2019-05-27 06:47:06,048 [main           ] WARN  DefaultTypeConverter           - Overriding type converter from: org.apache.camel.support.SimpleTypeConverter@7f9e8421 to: StaticMethodTypeConverter: public static org.apache.camel.StreamCache org.apache.camel.converter.stream.StreamCacheConverter.convertToStreamCache(java.io.ByteArrayInputStream,org.apache.camel.Exchange) throws java.io.IOException2019-05-27 06:47:06,048 [main           ] WARN  DefaultTypeConverter           - Overriding type converter from: org.apache.camel.support.SimpleTypeConverter@23da79eb to: StaticMethodTypeConverter: public static org.apache.camel.StreamCache org.apache.camel.converter.stream.StreamCacheConverter.convertToStreamCache(java.io.InputStream,org.apache.camel.Exchange) throws java.io.IOException2019-05-27 06:47:06,048 [main           ] WARN  DefaultTypeConverter           - Overriding type converter from: org.apache.camel.support.SimpleTypeConverter@168b4cb0 to: StaticMethodTypeConverter: public static org.apache.camel.StreamCache org.apache.camel.converter.stream.StreamCacheConverter.convertToStreamCache(org.apache.camel.converter.stream.CachedOutputStream,org.apache.camel.Exchange) throws java.io.IOException2019-05-27 06:47:06,048 [main           ] WARN  DefaultTypeConverter           - Overriding type converter from: org.apache.camel.support.SimpleTypeConverter@3e05586b to: StaticMethodTypeConverter: public static org.apache.camel.StreamCache org.apache.camel.converter.stream.StreamCacheConverter.convertToStreamCache(java.io.Reader,org.apache.camel.Exchange) throws java.io.IOException2019-05-27 06:47:06,048 [main           ] WARN  DefaultTypeConverter           - Overriding type converter from: org.apache.camel.support.SimpleTypeConverter@35b17c06 to: StaticMethodTypeConverter: public static org.apache.camel.StreamCache org.apache.camel.converter.stream.StreamCacheConverter.convertToStreamCache(javax.xml.transform.stream.StreamSource,org.apache.camel.Exchange) throws java.io.IOException2019-05-27 06:47:06,048 [main           ] WARN  DefaultTypeConverter           - Overriding type converter from: org.apache.camel.support.SimpleTypeConverter@45545e7a to: StaticMethodTypeConverter: public static org.apache.camel.StreamCache org.apache.camel.converter.stream.StreamCacheConverter.convertToStreamCache(org.apache.camel.StringSource)2019-05-27 06:47:06,048 [main           ] WARN  DefaultTypeConverter           - Overriding type converter from: org.apache.camel.support.SimpleTypeConverter@9f674ac to: StaticMethodTypeConverter: public static org.apache.camel.StreamCache org.apache.camel.converter.stream.StreamCacheConverter.convertToStreamCache(org.apache.camel.BytesSource)2019-05-27 06:47:06,048 [main           ] WARN  DefaultTypeConverter           - Overriding type converter from: org.apache.camel.support.SimpleTypeConverter@1da4b3f9 to: StaticMethodTypeConverter: public static org.apache.camel.StreamCache org.apache.camel.converter.stream.StreamCacheConverter.convertToStreamCache(javax.xml.transform.sax.SAXSource,org.apache.camel.Exchange) throws javax.xml.transform.TransformerException2019-05-27 06:47:06,048 [main           ] WARN  DefaultTypeConverter           - Overriding type converter from: org.apache.camel.support.SimpleTypeConverter@23cbbd07 to: StaticMethodTypeConverter: public static java.nio.ByteBuffer org.apache.camel.converter.stream.StreamCacheConverter.convertToByteBuffer(org.apache.camel.StreamCache,org.apache.camel.Exchange) throws java.io.IOException2019-05-27 06:47:06,048 [main           ] WARN  DefaultTypeConverter           - Overriding type converter from: org.apache.camel.support.SimpleTypeConverter@448b808a to: StaticMethodTypeConverter: public static java.io.Serializable org.apache.camel.converter.stream.StreamCacheConverter.convertToSerializable(org.apache.camel.StreamCache,org.apache.camel.Exchange) throws java.io.IOException2019-05-27 06:47:06,048 [main           ] WARN  DefaultTypeConverter           - Overriding type converter from: org.apache.camel.support.SimpleTypeConverter@7e62cfa3 to: StaticMethodTypeConverter: public static byte[] org.apache.camel.converter.stream.StreamCacheConverter.convertToByteArray(org.apache.camel.StreamCache,org.apache.camel.Exchange) throws java.io.IOException2019-05-27 06:47:06,049 [main           ] WARN  DefaultTypeConverter           - Overriding type converter from: StaticMethodTypeConverter: public static org.apache.camel.StreamCache org.apache.camel.converter.stream.StreamCacheConverter.convertToStreamCache(java.io.ByteArrayInputStream,org.apache.camel.Exchange) throws java.io.IOException to: StaticMethodTypeConverter: public static org.apache.camel.StreamCache org.apache.camel.converter.stream.StreamCacheConverter.convertToStreamCache(java.io.ByteArrayInputStream,org.apache.camel.Exchange) throws java.io.IOException2019-05-27 06:47:06,049 [main           ] WARN  DefaultTypeConverter           - Overriding type converter from: StaticMethodTypeConverter: public static org.apache.camel.StreamCache org.apache.camel.converter.stream.StreamCacheConverter.convertToStreamCache(java.io.InputStream,org.apache.camel.Exchange) throws java.io.IOException to: StaticMethodTypeConverter: public static org.apache.camel.StreamCache org.apache.camel.converter.stream.StreamCacheConverter.convertToStreamCache(java.io.InputStream,org.apache.camel.Exchange) throws java.io.IOException2019-05-27 06:47:06,049 [main           ] WARN  DefaultTypeConverter           - Overriding type converter from: StaticMethodTypeConverter: public static org.apache.camel.StreamCache org.apache.camel.converter.stream.StreamCacheConverter.convertToStreamCache(org.apache.camel.converter.stream.CachedOutputStream,org.apache.camel.Exchange) throws java.io.IOException to: StaticMethodTypeConverter: public static org.apache.camel.StreamCache org.apache.camel.converter.stream.StreamCacheConverter.convertToStreamCache(org.apache.camel.converter.stream.CachedOutputStream,org.apache.camel.Exchange) throws java.io.IOException2019-05-27 06:47:06,049 [main           ] WARN  DefaultTypeConverter           - Overriding type converter from: StaticMethodTypeConverter: public static org.apache.camel.StreamCache org.apache.camel.converter.stream.StreamCacheConverter.convertToStreamCache(java.io.Reader,org.apache.camel.Exchange) throws java.io.IOException to: StaticMethodTypeConverter: public static org.apache.camel.StreamCache org.apache.camel.converter.stream.StreamCacheConverter.convertToStreamCache(java.io.Reader,org.apache.camel.Exchange) throws java.io.IOException2019-05-27 06:47:06,049 [main           ] WARN  DefaultTypeConverter           - Overriding type converter from: StaticMethodTypeConverter: public static org.apache.camel.StreamCache org.apache.camel.converter.stream.StreamCacheConverter.convertToStreamCache(javax.xml.transform.stream.StreamSource,org.apache.camel.Exchange) throws java.io.IOException to: StaticMethodTypeConverter: public static org.apache.camel.StreamCache org.apache.camel.converter.stream.StreamCacheConverter.convertToStreamCache(javax.xml.transform.stream.StreamSource,org.apache.camel.Exchange) throws java.io.IOException2019-05-27 06:47:06,049 [main           ] WARN  DefaultTypeConverter           - Overriding type converter from: StaticMethodTypeConverter: public static org.apache.camel.StreamCache org.apache.camel.converter.stream.StreamCacheConverter.convertToStreamCache(org.apache.camel.StringSource) to: StaticMethodTypeConverter: public static org.apache.camel.StreamCache org.apache.camel.converter.stream.StreamCacheConverter.convertToStreamCache(org.apache.camel.StringSource)2019-05-27 06:47:06,049 [main           ] WARN  DefaultTypeConverter           - Overriding type converter from: StaticMethodTypeConverter: public static org.apache.camel.StreamCache org.apache.camel.converter.stream.StreamCacheConverter.convertToStreamCache(org.apache.camel.BytesSource) to: StaticMethodTypeConverter: public static org.apache.camel.StreamCache org.apache.camel.converter.stream.StreamCacheConverter.convertToStreamCache(org.apache.camel.BytesSource)2019-05-27 06:47:06,050 [main           ] WARN  DefaultTypeConverter           - Overriding type converter from: StaticMethodTypeConverter: public static org.apache.camel.StreamCache org.apache.camel.converter.stream.StreamCacheConverter.convertToStreamCache(javax.xml.transform.sax.SAXSource,org.apache.camel.Exchange) throws javax.xml.transform.TransformerException to: StaticMethodTypeConverter: public static org.apache.camel.StreamCache org.apache.camel.converter.stream.StreamCacheConverter.convertToStreamCache(javax.xml.transform.sax.SAXSource,org.apache.camel.Exchange) throws javax.xml.transform.TransformerException2019-05-27 06:47:06,050 [main           ] WARN  DefaultTypeConverter           - Overriding type converter from: StaticMethodTypeConverter: public static java.nio.ByteBuffer org.apache.camel.converter.stream.StreamCacheConverter.convertToByteBuffer(org.apache.camel.StreamCache,org.apache.camel.Exchange) throws java.io.IOException to: StaticMethodTypeConverter: public static java.nio.ByteBuffer org.apache.camel.converter.stream.StreamCacheConverter.convertToByteBuffer(org.apache.camel.StreamCache,org.apache.camel.Exchange) throws java.io.IOException2019-05-27 06:47:06,050 [main           ] WARN  DefaultTypeConverter           - Overriding type converter from: StaticMethodTypeConverter: public static java.io.Serializable org.apache.camel.converter.stream.StreamCacheConverter.convertToSerializable(org.apache.camel.StreamCache,org.apache.camel.Exchange) throws java.io.IOException to: StaticMethodTypeConverter: public static java.io.Serializable org.apache.camel.converter.stream.StreamCacheConverter.convertToSerializable(org.apache.camel.StreamCache,org.apache.camel.Exchange) throws java.io.IOException2019-05-27 06:47:06,050 [main           ] WARN  DefaultTypeConverter           - Overriding type converter from: StaticMethodTypeConverter: public static byte[] org.apache.camel.converter.stream.StreamCacheConverter.convertToByteArray(org.apache.camel.StreamCache,org.apache.camel.Exchange) throws java.io.IOException to: StaticMethodTypeConverter: public static byte[] org.apache.camel.converter.stream.StreamCacheConverter.convertToByteArray(org.apache.camel.StreamCache,org.apache.camel.Exchange) throws java.io.IOException Task camel-blueprint - Many WARNs about overriding type converters Noticed these during testing CiA2 book2019-05-27 06:47:06,045 [main           ] WARN  DefaultTypeConverter           - Overriding type converter from: org.apache.camel.support.SimpleTypeConverter@659f226a to: StaticMethodTypeConverter: public static org.restlet.data.Method org.apache.camel.component.restlet.converter.RestletConverter.toMethod(java.lang.String)2019-05-27 06:47:06,045 [main           ] WARN  DefaultTypeConverter           - Overriding type converter from: org.apache.camel.support.SimpleTypeConverter@2e463f4 to: StaticMethodTypeConverter: public static org.restlet.data.Method[] org.apache.camel.component.restlet.converter.RestletConverter.toMethods(java.lang.String)2019-05-27 06:47:06,045 [main           ] WARN  DefaultTypeConverter           - Overriding type converter from: org.apache.camel.support.SimpleTypeConverter@32ec9c90 to: StaticMethodTypeConverter: public static org.restlet.data.MediaType[] org.apache.camel.component.restlet.converter.RestletConverter.toMediaTypes(java.lang.String)2019-05-27 06:47:06,046 [main           ] WARN  DefaultTypeConverter           - Overriding type converter from: org.apache.camel.support.SimpleTypeConverter@36ab3814 to: StaticMethodTypeConverter: public static org.restlet.data.MediaType org.apache.camel.component.restlet.converter.RestletConverter.toMediaType(java.lang.String)2019-05-27 06:47:06,046 [main           ] WARN  DefaultTypeConverter           - Overriding type converter from: org.apache.camel.support.SimpleTypeConverter@467233e4 to: StaticMethodTypeConverter: public static java.io.InputStream org.apache.camel.http.common.HttpConverter.toInputStream(org.apache.camel.http.common.HttpMessage,org.apache.camel.Exchange) throws java.lang.Exception2019-05-27 06:47:06,046 [main           ] WARN  DefaultTypeConverter           - Overriding type converter from: org.apache.camel.support.SimpleTypeConverter@427a12b6 to: StaticMethodTypeConverter: public static java.io.InputStream org.apache.camel.http.common.HttpConverter.toInputStream(javax.servlet.http.HttpServletRequest,org.apache.camel.Exchange) throws java.io.IOException2019-05-27 06:47:06,046 [main           ] WARN  DefaultTypeConverter           - Overriding type converter from: org.apache.camel.support.SimpleTypeConverter@6025d790 to: StaticMethodTypeConverter: public static java.io.BufferedReader org.apache.camel.http.common.HttpConverter.toReader(org.apache.camel.http.common.HttpMessage) throws java.io.IOException2019-05-27 06:47:06,046 [main           ] WARN  DefaultTypeConverter           - Overriding type converter from: org.apache.camel.support.SimpleTypeConverter@af7e376 to: StaticMethodTypeConverter: public static javax.servlet.http.HttpServletResponse org.apache.camel.http.common.HttpConverter.toServletResponse(org.apache.camel.Message)2019-05-27 06:47:06,046 [main           ] WARN  DefaultTypeConverter           - Overriding type converter from: org.apache.camel.support.SimpleTypeConverter@5dcd0cdf to: StaticMethodTypeConverter: public static javax.servlet.http.HttpServletRequest org.apache.camel.http.common.HttpConverter.toServletRequest(org.apache.camel.Message)2019-05-27 06:47:06,047 [main           ] WARN  DefaultTypeConverter           - Overriding type converter from: org.apache.camel.support.SimpleTypeConverter@4fb04a72 to: StaticMethodTypeConverter: public static javax.servlet.ServletInputStream org.apache.camel.http.common.HttpConverter.toServletInputStream(org.apache.camel.http.common.HttpMessage) throws java.io.IOException2019-05-27 06:47:06,047 [main           ] WARN  DefaultTypeConverter           - Overriding type converter from: org.apache.camel.support.SimpleTypeConverter@1a07bf6 to: StaticMethodTypeConverter: public static java.io.InputStream org.apache.camel.spring.converter.ResourceConverter.convertToInputStream(org.springframework.core.io.Resource) throws java.io.IOException2019-05-27 06:47:06,047 [main           ] WARN  DefaultTypeConverter           - Overriding type converter from: org.apache.camel.support.SimpleTypeConverter@34d713a2 to: StaticMethodTypeConverter: public static java.lang.Object[] org.apache.camel.component.cxf.converter.CxfConverter.toArray(java.lang.Object)2019-05-27 06:47:06,047 [main           ] WARN  DefaultTypeConverter           - Overriding type converter from: org.apache.camel.support.SimpleTypeConverter@36aab105 to: StaticMethodTypeConverter: public static java.io.InputStream org.apache.camel.component.cxf.converter.CxfConverter.toInputStream(javax.ws.rs.core.Response,org.apache.camel.Exchange)2019-05-27 06:47:06,047 [main           ] WARN  DefaultTypeConverter           - Overriding type converter from: org.apache.camel.support.SimpleTypeConverter@889a8a8 to: StaticMethodTypeConverter: public static javax.xml.namespace.QName org.apache.camel.component.cxf.converter.CxfConverter.toQName(java.lang.String)2019-05-27 06:47:06,047 [main           ] WARN  DefaultTypeConverter           - Overriding type converter from: org.apache.camel.support.SimpleTypeConverter@f29353f to: StaticMethodTypeConverter: public static org.apache.cxf.message.MessageContentsList org.apache.camel.component.cxf.converter.CxfConverter.toMessageContentsList(java.lang.Object[])2019-05-27 06:47:06,047 [main           ] WARN  DefaultTypeConverter           - Overriding type converter from: org.apache.camel.support.SimpleTypeConverter@36f7d7b to: StaticMethodTypeConverter: public static org.apache.camel.component.cxf.DataFormat org.apache.camel.component.cxf.converter.CxfConverter.toDataFormat(java.lang.String)2019-05-27 06:47:06,047 [main           ] WARN  DefaultTypeConverter           - Overriding type converter from: org.apache.camel.support.SimpleTypeConverter@60aec68a to: StaticMethodTypeConverter: public static java.lang.String org.apache.camel.component.cxf.converter.CxfConverter.soapMessageToString(javax.xml.soap.SOAPMessage,org.apache.camel.Exchange) throws javax.xml.soap.SOAPException,java.io.IOException2019-05-27 06:47:06,047 [main           ] WARN  DefaultTypeConverter           - Overriding type converter from: org.apache.camel.support.SimpleTypeConverter@25a7fedf to: StaticMethodTypeConverter: public static java.io.InputStream org.apache.camel.component.cxf.converter.CxfConverter.soapMessageToInputStream(javax.xml.soap.SOAPMessage,org.apache.camel.Exchange) throws javax.xml.soap.SOAPException,java.io.IOException2019-05-27 06:47:06,047 [main           ] WARN  DefaultTypeConverter           - Overriding type converter from: org.apache.camel.support.SimpleTypeConverter@6361b799 to: StaticMethodTypeConverter: public static org.w3c.dom.NodeList org.apache.camel.component.cxf.converter.CxfPayloadConverter.cxfPayloadToNodeList(org.apache.camel.component.cxf.CxfPayload,org.apache.camel.Exchange)2019-05-27 06:47:06,047 [main           ] WARN  DefaultTypeConverter           - Overriding type converter from: org.apache.camel.support.SimpleTypeConverter@1b9d9a2b to: StaticMethodTypeConverter: public static org.w3c.dom.Node org.apache.camel.component.cxf.converter.CxfPayloadConverter.cxfPayLoadToNode(org.apache.camel.component.cxf.CxfPayload,org.apache.camel.Exchange)2019-05-27 06:47:06,047 [main           ] WARN  DefaultTypeConverter           - Overriding type converter from: org.apache.camel.support.SimpleTypeConverter@d919544 to: StaticMethodTypeConverter: public static org.apache.camel.component.cxf.CxfPayload org.apache.camel.component.cxf.converter.CxfPayloadConverter.nodeListToCxfPayload(org.w3c.dom.NodeList,org.apache.camel.Exchange)2019-05-27 06:47:06,047 [main           ] WARN  DefaultTypeConverter           - Overriding type converter from: org.apache.camel.support.SimpleTypeConverter@17dad32f to: StaticMethodTypeConverter: public static org.apache.camel.component.cxf.CxfPayload org.apache.camel.component.cxf.converter.CxfPayloadConverter.elementToCxfPayload(org.w3c.dom.Element,org.apache.camel.Exchange)2019-05-27 06:47:06,047 [main           ] WARN  DefaultTypeConverter           - Overriding type converter from: org.apache.camel.support.SimpleTypeConverter@79696332 to: StaticMethodTypeConverter: public static org.apache.camel.component.cxf.CxfPayload org.apache.camel.component.cxf.converter.CxfPayloadConverter.documentToCxfPayload(org.w3c.dom.Document,org.apache.camel.Exchange)2019-05-27 06:47:06,048 [main           ] WARN  DefaultTypeConverter           - Overriding type converter from: org.apache.camel.support.SimpleTypeConverter@ed2f2f6 to: StaticMethodTypeConverter: public static org.apache.camel.component.cxf.CxfPayload org.apache.camel.component.cxf.converter.CxfPayloadConverter.sourceToCxfPayload(javax.xml.transform.Source,org.apache.camel.Exchange)2019-05-27 06:47:06,048 [main           ] WARN  DefaultTypeConverter           - Overriding type converter from: org.apache.camel.support.SimpleTypeConverter@fe87ddd to: StaticMethodTypeConverter: public static org.apache.camel.StreamCache org.apache.camel.component.cxf.converter.CxfPayloadConverter.cxfPayLoadToStreamCache(org.apache.camel.component.cxf.CxfPayload,org.apache.camel.Exchange)2019-05-27 06:47:06,048 [main           ] WARN  DefaultTypeConverter           - Overriding type converter from: org.apache.camel.support.SimpleTypeConverter@4eea94a4 to: StaticMethodTypeConverter: public static javax.xml.transform.Source org.apache.camel.component.cxf.converter.CxfPayloadConverter.cxfPayLoadToSource(org.apache.camel.component.cxf.CxfPayload,org.apache.camel.Exchange)2019-05-27 06:47:06,048 [main           ] WARN  DefaultTypeConverter           - Overriding type converter from: org.apache.camel.support.SimpleTypeConverter@29be997f to: StaticMethodTypeConverter: public static java.io.InputStream org.apache.camel.component.file.GenericFileConverter.genericFileToInputStream(org.apache.camel.component.file.GenericFile,org.apache.camel.Exchange) throws java.io.IOException2019-05-27 06:47:06,048 [main           ] WARN  DefaultTypeConverter           - Overriding type converter from: org.apache.camel.support.SimpleTypeConverter@33eb6758 to: StaticMethodTypeConverter: public static java.lang.String org.apache.camel.component.file.GenericFileConverter.genericFileToString(org.apache.camel.component.file.GenericFile,org.apache.camel.Exchange) throws java.io.IOException,org.apache.camel.NoTypeConversionAvailableException2019-05-27 06:47:06,048 [main           ] WARN  DefaultTypeConverter           - Overriding type converter from: org.apache.camel.support.SimpleTypeConverter@f8a6243 to: StaticMethodTypeConverter: public static java.io.Serializable org.apache.camel.component.file.GenericFileConverter.genericFileToSerializable(org.apache.camel.component.file.GenericFile,org.apache.camel.Exchange) throws java.io.IOException2019-05-27 06:47:06,048 [main           ] WARN  DefaultTypeConverter           - Overriding type converter from: org.apache.camel.support.SimpleTypeConverter@7f9e8421 to: StaticMethodTypeConverter: public static org.apache.camel.StreamCache org.apache.camel.converter.stream.StreamCacheConverter.convertToStreamCache(java.io.ByteArrayInputStream,org.apache.camel.Exchange) throws java.io.IOException2019-05-27 06:47:06,048 [main           ] WARN  DefaultTypeConverter           - Overriding type converter from: org.apache.camel.support.SimpleTypeConverter@23da79eb to: StaticMethodTypeConverter: public static org.apache.camel.StreamCache org.apache.camel.converter.stream.StreamCacheConverter.convertToStreamCache(java.io.InputStream,org.apache.camel.Exchange) throws java.io.IOException2019-05-27 06:47:06,048 [main           ] WARN  DefaultTypeConverter           - Overriding type converter from: org.apache.camel.support.SimpleTypeConverter@168b4cb0 to: StaticMethodTypeConverter: public static org.apache.camel.StreamCache org.apache.camel.converter.stream.StreamCacheConverter.convertToStreamCache(org.apache.camel.converter.stream.CachedOutputStream,org.apache.camel.Exchange) throws java.io.IOException2019-05-27 06:47:06,048 [main           ] WARN  DefaultTypeConverter           - Overriding type converter from: org.apache.camel.support.SimpleTypeConverter@3e05586b to: StaticMethodTypeConverter: public static org.apache.camel.StreamCache org.apache.camel.converter.stream.StreamCacheConverter.convertToStreamCache(java.io.Reader,org.apache.camel.Exchange) throws java.io.IOException2019-05-27 06:47:06,048 [main           ] WARN  DefaultTypeConverter           - Overriding type converter from: org.apache.camel.support.SimpleTypeConverter@35b17c06 to: StaticMethodTypeConverter: public static org.apache.camel.StreamCache org.apache.camel.converter.stream.StreamCacheConverter.convertToStreamCache(javax.xml.transform.stream.StreamSource,org.apache.camel.Exchange) throws java.io.IOException2019-05-27 06:47:06,048 [main           ] WARN  DefaultTypeConverter           - Overriding type converter from: org.apache.camel.support.SimpleTypeConverter@45545e7a to: StaticMethodTypeConverter: public static org.apache.camel.StreamCache org.apache.camel.converter.stream.StreamCacheConverter.convertToStreamCache(org.apache.camel.StringSource)2019-05-27 06:47:06,048 [main           ] WARN  DefaultTypeConverter           - Overriding type converter from: org.apache.camel.support.SimpleTypeConverter@9f674ac to: StaticMethodTypeConverter: public static org.apache.camel.StreamCache org.apache.camel.converter.stream.StreamCacheConverter.convertToStreamCache(org.apache.camel.BytesSource)2019-05-27 06:47:06,048 [main           ] WARN  DefaultTypeConverter           - Overriding type converter from: org.apache.camel.support.SimpleTypeConverter@1da4b3f9 to: StaticMethodTypeConverter: public static org.apache.camel.StreamCache org.apache.camel.converter.stream.StreamCacheConverter.convertToStreamCache(javax.xml.transform.sax.SAXSource,org.apache.camel.Exchange) throws javax.xml.transform.TransformerException2019-05-27 06:47:06,048 [main           ] WARN  DefaultTypeConverter           - Overriding type converter from: org.apache.camel.support.SimpleTypeConverter@23cbbd07 to: StaticMethodTypeConverter: public static java.nio.ByteBuffer org.apache.camel.converter.stream.StreamCacheConverter.convertToByteBuffer(org.apache.camel.StreamCache,org.apache.camel.Exchange) throws java.io.IOException2019-05-27 06:47:06,048 [main           ] WARN  DefaultTypeConverter           - Overriding type converter from: org.apache.camel.support.SimpleTypeConverter@448b808a to: StaticMethodTypeConverter: public static java.io.Serializable org.apache.camel.converter.stream.StreamCacheConverter.convertToSerializable(org.apache.camel.StreamCache,org.apache.camel.Exchange) throws java.io.IOException2019-05-27 06:47:06,048 [main           ] WARN  DefaultTypeConverter           - Overriding type converter from: org.apache.camel.support.SimpleTypeConverter@7e62cfa3 to: StaticMethodTypeConverter: public static byte[] org.apache.camel.converter.stream.StreamCacheConverter.convertToByteArray(org.apache.camel.StreamCache,org.apache.camel.Exchange) throws java.io.IOException2019-05-27 06:47:06,049 [main           ] WARN  DefaultTypeConverter           - Overriding type converter from: StaticMethodTypeConverter: public static org.apache.camel.StreamCache org.apache.camel.converter.stream.StreamCacheConverter.convertToStreamCache(java.io.ByteArrayInputStream,org.apache.camel.Exchange) throws java.io.IOException to: StaticMethodTypeConverter: public static org.apache.camel.StreamCache org.apache.camel.converter.stream.StreamCacheConverter.convertToStreamCache(java.io.ByteArrayInputStream,org.apache.camel.Exchange) throws java.io.IOException2019-05-27 06:47:06,049 [main           ] WARN  DefaultTypeConverter           - Overriding type converter from: StaticMethodTypeConverter: public static org.apache.camel.StreamCache org.apache.camel.converter.stream.StreamCacheConverter.convertToStreamCache(java.io.InputStream,org.apache.camel.Exchange) throws java.io.IOException to: StaticMethodTypeConverter: public static org.apache.camel.StreamCache org.apache.camel.converter.stream.StreamCacheConverter.convertToStreamCache(java.io.InputStream,org.apache.camel.Exchange) throws java.io.IOException2019-05-27 06:47:06,049 [main           ] WARN  DefaultTypeConverter           - Overriding type converter from: StaticMethodTypeConverter: public static org.apache.camel.StreamCache org.apache.camel.converter.stream.StreamCacheConverter.convertToStreamCache(org.apache.camel.converter.stream.CachedOutputStream,org.apache.camel.Exchange) throws java.io.IOException to: StaticMethodTypeConverter: public static org.apache.camel.StreamCache org.apache.camel.converter.stream.StreamCacheConverter.convertToStreamCache(org.apache.camel.converter.stream.CachedOutputStream,org.apache.camel.Exchange) throws java.io.IOException2019-05-27 06:47:06,049 [main           ] WARN  DefaultTypeConverter           - Overriding type converter from: StaticMethodTypeConverter: public static org.apache.camel.StreamCache org.apache.camel.converter.stream.StreamCacheConverter.convertToStreamCache(java.io.Reader,org.apache.camel.Exchange) throws java.io.IOException to: StaticMethodTypeConverter: public static org.apache.camel.StreamCache org.apache.camel.converter.stream.StreamCacheConverter.convertToStreamCache(java.io.Reader,org.apache.camel.Exchange) throws java.io.IOException2019-05-27 06:47:06,049 [main           ] WARN  DefaultTypeConverter           - Overriding type converter from: StaticMethodTypeConverter: public static org.apache.camel.StreamCache org.apache.camel.converter.stream.StreamCacheConverter.convertToStreamCache(javax.xml.transform.stream.StreamSource,org.apache.camel.Exchange) throws java.io.IOException to: StaticMethodTypeConverter: public static org.apache.camel.StreamCache org.apache.camel.converter.stream.StreamCacheConverter.convertToStreamCache(javax.xml.transform.stream.StreamSource,org.apache.camel.Exchange) throws java.io.IOException2019-05-27 06:47:06,049 [main           ] WARN  DefaultTypeConverter           - Overriding type converter from: StaticMethodTypeConverter: public static org.apache.camel.StreamCache org.apache.camel.converter.stream.StreamCacheConverter.convertToStreamCache(org.apache.camel.StringSource) to: StaticMethodTypeConverter: public static org.apache.camel.StreamCache org.apache.camel.converter.stream.StreamCacheConverter.convertToStreamCache(org.apache.camel.StringSource)2019-05-27 06:47:06,049 [main           ] WARN  DefaultTypeConverter           - Overriding type converter from: StaticMethodTypeConverter: public static org.apache.camel.StreamCache org.apache.camel.converter.stream.StreamCacheConverter.convertToStreamCache(org.apache.camel.BytesSource) to: StaticMethodTypeConverter: public static org.apache.camel.StreamCache org.apache.camel.converter.stream.StreamCacheConverter.convertToStreamCache(org.apache.camel.BytesSource)2019-05-27 06:47:06,050 [main           ] WARN  DefaultTypeConverter           - Overriding type converter from: StaticMethodTypeConverter: public static org.apache.camel.StreamCache org.apache.camel.converter.stream.StreamCacheConverter.convertToStreamCache(javax.xml.transform.sax.SAXSource,org.apache.camel.Exchange) throws javax.xml.transform.TransformerException to: StaticMethodTypeConverter: public static org.apache.camel.StreamCache org.apache.camel.converter.stream.StreamCacheConverter.convertToStreamCache(javax.xml.transform.sax.SAXSource,org.apache.camel.Exchange) throws javax.xml.transform.TransformerException2019-05-27 06:47:06,050 [main           ] WARN  DefaultTypeConverter           - Overriding type converter from: StaticMethodTypeConverter: public static java.nio.ByteBuffer org.apache.camel.converter.stream.StreamCacheConverter.convertToByteBuffer(org.apache.camel.StreamCache,org.apache.camel.Exchange) throws java.io.IOException to: StaticMethodTypeConverter: public static java.nio.ByteBuffer org.apache.camel.converter.stream.StreamCacheConverter.convertToByteBuffer(org.apache.camel.StreamCache,org.apache.camel.Exchange) throws java.io.IOException2019-05-27 06:47:06,050 [main           ] WARN  DefaultTypeConverter           - Overriding type converter from: StaticMethodTypeConverter: public static java.io.Serializable org.apache.camel.converter.stream.StreamCacheConverter.convertToSerializable(org.apache.camel.StreamCache,org.apache.camel.Exchange) throws java.io.IOException to: StaticMethodTypeConverter: public static java.io.Serializable org.apache.camel.converter.stream.StreamCacheConverter.convertToSerializable(org.apache.camel.StreamCache,org.apache.camel.Exchange) throws java.io.IOException2019-05-27 06:47:06,050 [main           ] WARN  DefaultTypeConverter           - Overriding type converter from: StaticMethodTypeConverter: public static byte[] org.apache.camel.converter.stream.StreamCacheConverter.convertToByteArray(org.apache.camel.StreamCache,org.apache.camel.Exchange) throws java.io.IOException to: StaticMethodTypeConverter: public static byte[] org.apache.camel.converter.stream.StreamCacheConverter.convertToByteArray(org.apache.camel.StreamCache,org.apache.camel.Exchange) throws java.io.IOException
camel-zookeeper - Deprecate route master/slave policy As the camel-zookeeper-master component is better at handling this. So lets deprecate this in Camel 2.x, and remove in 3.0 Improvement camel-zookeeper - Deprecate route master/slave policy As the camel-zookeeper-master component is better at handling this. So lets deprecate this in Camel 2.x, and remove in 3.0
JndiContext - Remove old bean binding There is some old code that allows to define in jndi.properties beans with .class etc to create these beans via basic class loading that was from Camel 1.x time and nobody uses.This should be removed Improvement JndiContext - Remove old bean binding There is some old code that allows to define in jndi.properties beans with .class etc to create these beans via basic class loading that was from Camel 1.x time and nobody uses.This should be removed
IntrospectionSupport - Remove old legacy JDK PropertyEditor There is some old code using JDKPropertyEditor editor = PropertyEditorManager.findEditor(type);But this is no longer in use as we really use camel's type converter. That above is also slow and not thread safe and was intended for java swing/beans stuff and some cruft from very old times. Lets try to get rid of it. Improvement IntrospectionSupport - Remove old legacy JDK PropertyEditor There is some old code using JDKPropertyEditor editor = PropertyEditorManager.findEditor(type);But this is no longer in use as we really use camel's type converter. That above is also slow and not thread safe and was intended for java swing/beans stuff and some cruft from very old times. Lets try to get rid of it.
Support for nested properties binding As today properties binding does not work for nested objects so assuming I have a class like:{code:java}class MyComponent {        public void setFoo(String foo) {        this.foo = foo;    }    public String getFoo() {        return foo;    }    public void setConfiguration(Configuration conf) {        this.conf = conf;    }    public Configuration getConfiguration() {        return conf;    }    static class Configuration {            public void setBar(String bar) {            this.bar = bar        }        public String getBar() {            return bar        }    }}{code}And a set of properties like:{code}myComponent.foo = "foo"myComponent.conf.bar = "bar"{code}Then only MyComponent.foo will be set but it would be nice if the binding framework could navigate the property using dot notation and set any dependent object. New Feature Support for nested properties binding As today properties binding does not work for nested objects so assuming I have a class like:{code:java}class MyComponent {        public void setFoo(String foo) {        this.foo = foo;    }    public String getFoo() {        return foo;    }    public void setConfiguration(Configuration conf) {        this.conf = conf;    }    public Configuration getConfiguration() {        return conf;    }    static class Configuration {            public void setBar(String bar) {            this.bar = bar        }        public String getBar() {            return bar        }    }}{code}And a set of properties like:{code}myComponent.foo = "foo"myComponent.conf.bar = "bar"{code}Then only MyComponent.foo will be set but it would be nice if the binding framework could navigate the property using dot notation and set any dependent object.
Producer and consumer template/cache should check if camel is started when being used When sending via producer template etc then you can send to endpoints even if camel is stopped / not started etc. We should add a check for this as camel would ideally need to be started first to ensure the sending works correctly. Improvement Producer and consumer template/cache should check if camel is started when being used When sending via producer template etc then you can send to endpoints even if camel is stopped / not started etc. We should add a check for this as camel would ideally need to be started first to ensure the sending works correctly.
camel3 - Some of the SPI can be static services when there can only be one configured A number of configurations for packagescan class resolver and node id factory and whatnot are essentially a single instance that can be configured, so we can leverage this fact and make them StaticService if they are just defined as a Service today. Improvement camel3 - Some of the SPI can be static services when there can only be one configured A number of configurations for packagescan class resolver and node id factory and whatnot are essentially a single instance that can be configured, so we can leverage this fact and make them StaticService if they are just defined as a Service today.
isUseAdviceWith causes test to hang Having this test:{code:java}import org.apache.camel.CamelContext;import org.apache.camel.RoutesBuilder;import org.apache.camel.builder.AdviceWithRouteBuilder;import org.apache.camel.builder.RouteBuilder;import org.apache.camel.component.mock.MockEndpoint;import org.apache.camel.test.junit4.CamelTestSupport;import org.junit.Test;public class MyRouteTest extends CamelTestSupport {  private static final String ROUTE_ID = "mytest";  @Override  public RoutesBuilder createRouteBuilder() throws Exception {    return new RouteBuilder() {      @Override      public void configure() throws Exception {        from("direct:mytest")          .id(ROUTE_ID)          .to("stream:out");      }    };  }  @Override  public void setUp() throws Exception {      super.setUp();      final CamelContext camelContext = context();      camelContext.getRouteDefinition(ROUTE_ID)        .adviceWith(camelContext, new AdviceWithRouteBuilder() {          @Override          public void configure() throws Exception {            weaveAddLast().to("mock:extract");          }        });  }  @Override  public boolean isUseAdviceWith() {      return true; // <- here is the problem  }  @Test  public void shouldFire() throws InterruptedException {    // given    final MockEndpoint myMock = getMockEndpoint("mock:extract");    myMock.expectedMessageCount(1);    myMock.expectedBodiesReceived("test");    // when    template.sendBody("direct:mytest", "test");    // then    myMock.assertIsSatisfied();  }}{code} Causes Camel to hang Improvement isUseAdviceWith causes test to hang Having this test:{code:java}import org.apache.camel.CamelContext;import org.apache.camel.RoutesBuilder;import org.apache.camel.builder.AdviceWithRouteBuilder;import org.apache.camel.builder.RouteBuilder;import org.apache.camel.component.mock.MockEndpoint;import org.apache.camel.test.junit4.CamelTestSupport;import org.junit.Test;public class MyRouteTest extends CamelTestSupport {  private static final String ROUTE_ID = "mytest";  @Override  public RoutesBuilder createRouteBuilder() throws Exception {    return new RouteBuilder() {      @Override      public void configure() throws Exception {        from("direct:mytest")          .id(ROUTE_ID)          .to("stream:out");      }    };  }  @Override  public void setUp() throws Exception {      super.setUp();      final CamelContext camelContext = context();      camelContext.getRouteDefinition(ROUTE_ID)        .adviceWith(camelContext, new AdviceWithRouteBuilder() {          @Override          public void configure() throws Exception {            weaveAddLast().to("mock:extract");          }        });  }  @Override  public boolean isUseAdviceWith() {      return true; // <- here is the problem  }  @Test  public void shouldFire() throws InterruptedException {    // given    final MockEndpoint myMock = getMockEndpoint("mock:extract");    myMock.expectedMessageCount(1);    myMock.expectedBodiesReceived("test");    // when    template.sendBody("direct:mytest", "test");    // then    myMock.assertIsSatisfied();  }}{code} Causes Camel to hang
Camel main - Allow to configure supervising route controller Like you can do in SB to setup advanced route startup where Camel can retry starting routes etc. Improvement Camel main - Allow to configure supervising route controller Like you can do in SB to setup advanced route startup where Camel can retry starting routes etc.
Simple language - Add colon as alternative syntax style The simple syntax can maybe be improved a bit when its a function such as env or sysenv or other functions vs OGNL method calls on body, headers etc that uses dot style.Eg {code}${sysenv.FOO}{code}vs{code}${env:FOO}{code}It may feel a bit more natural to use colon in these situations, and dot when using{code}${body.someGetter}{code}And to refer to a header you can use both{code}${header.foo}{code}{code}${header:foo}{code}https://github.com/apache/camel/blob/master/core/camel-core/src/main/docs/simple-language.adoc Improvement Simple language - Add colon as alternative syntax style The simple syntax can maybe be improved a bit when its a function such as env or sysenv or other functions vs OGNL method calls on body, headers etc that uses dot style.Eg {code}${sysenv.FOO}{code}vs{code}${env:FOO}{code}It may feel a bit more natural to use colon in these situations, and dot when using{code}${body.someGetter}{code}And to refer to a header you can use both{code}${header.foo}{code}{code}${header:foo}{code}https://github.com/apache/camel/blob/master/core/camel-core/src/main/docs/simple-language.adoc
Simple language - Add env as function to lookup system env variable You have to use sysenv to lookup OS env variable. But most people would know it as env, so lets add that as an alias so you can use both of them. Improvement Simple language - Add env as function to lookup system env variable You have to use sysenv to lookup OS env variable. But most people would know it as env, so lets add that as an alias so you can use both of them.
Rename chiper to cipher Fix the typo in the API in camel-core Task Rename chiper to cipher Fix the typo in the API in camel-core
Implement missing optimisation for DelimiterBasedFrameDecoder See pretty nice analysis on SO [https://stackoverflow.com/questions/56110408/memory-leak-in-camel-netty-tcp-client-when-consuming-lines-with-windows-line-bre]*io.netty.handler.codec.DelimiterBasedFrameDecoder* internally delegates decoding to *io.netty.handler.codec.LineBasedFrameDecoder*. This delegation is not working with Camel, because Netty internally checks for condition{code:java}this.getClass() != DelimiterBasedFrameDecoder.class // io.netty.handler.codec.DelimiterBasedFrameDecoder line 174 - !isSubclass(){code}We can recreate similar optimisation inside *org.apache.camel.component.netty4.codec.DelimiterBasedFrameDecoder* and get (according to SO post) significant performance improvement. Improvement Implement missing optimisation for DelimiterBasedFrameDecoder See pretty nice analysis on SO [https://stackoverflow.com/questions/56110408/memory-leak-in-camel-netty-tcp-client-when-consuming-lines-with-windows-line-bre]*io.netty.handler.codec.DelimiterBasedFrameDecoder* internally delegates decoding to *io.netty.handler.codec.LineBasedFrameDecoder*. This delegation is not working with Camel, because Netty internally checks for condition{code:java}this.getClass() != DelimiterBasedFrameDecoder.class // io.netty.handler.codec.DelimiterBasedFrameDecoder line 174 - !isSubclass(){code}We can recreate similar optimisation inside *org.apache.camel.component.netty4.codec.DelimiterBasedFrameDecoder* and get (according to SO post) significant performance improvement.
camel - Only allow setting routeId once per route in Java DSL 1 route = 1 route id, what you did in that unit test / JIRA ticket was wrong and not intended to be supported, eg .routeId will override each other, a route has 1 route id. So do only set .routeId once per route!From gitter chat Improvement camel - Only allow setting routeId once per route in Java DSL 1 route = 1 route id, what you did in that unit test / JIRA ticket was wrong and not intended to be supported, eg .routeId will override each other, a route has 1 route id. So do only set .routeId once per route!From gitter chat
camel3 - The various Camel exceptions should favour extending runtime exception This makes using the APIs in Camel easier, and most of them are runtime based anyway. So lets align to be more non checked exceptions Improvement camel3 - The various Camel exceptions should favour extending runtime exception This makes using the APIs in Camel easier, and most of them are runtime based anyway. So lets align to be more non checked exceptions
camel-webhook - Consumer polish Should extend ServiceSupport and do its startup stop in doStart/doStop etc. Improvement camel-webhook - Consumer polish Should extend ServiceSupport and do its startup stop in doStart/doStop etc.
Allow producer to lazy start until first message We could add option to DefaultProducer so any producer allows to defer its startup (doStart) to when the first message is being processed. The danger is that the startup logic has to be thread-safe and if there are concurrent messages then they would need to hold back until the startup is done. This is a trade-off that the user would need to accept if enabled.But this can make it easier to let Camel startup routes even if some remote server is not available when a producer startup as part of route startup. Improvement Allow producer to lazy start until first message We could add option to DefaultProducer so any producer allows to defer its startup (doStart) to when the first message is being processed. The danger is that the startup logic has to be thread-safe and if there are concurrent messages then they would need to hold back until the startup is done. This is a trade-off that the user would need to accept if enabled.But this can make it easier to let Camel startup routes even if some remote server is not available when a producer startup as part of route startup.
camel3 - Service start/stop should use unchecked exceptions The API for org.apache.camel.Service has throws Exception for its start/stop methods. It would be great to remove those, as they throw runtime exceptions when failing, and this makes using these APIs easier for end users, so they dont have the burden of checked exceptions. Improvement camel3 - Service start/stop should use unchecked exceptions The API for org.apache.camel.Service has throws Exception for its start/stop methods. It would be great to remove those, as they throw runtime exceptions when failing, and this makes using these APIs easier for end users, so they dont have the burden of checked exceptions.
Camel-Tracer: New implementation We deprecated the 2.x one and removed it, hence we need a new implementation in Camel 3. Task Camel-Tracer: New implementation We deprecated the 2.x one and removed it, hence we need a new implementation in Camel 3.
Camel main - Allow to configure global and common options ala camel-spring-boot have So you can set context name, shutdown timeout, and other options etc. Improvement Camel main - Allow to configure global and common options ala camel-spring-boot have So you can set context name, shutdown timeout, and other options etc.
Properties component - Let OS environment variable take precedence by having it in override mode by default See SOhttps://stackoverflow.com/questions/56081583/camel-standalone-configuration-of-propertiescomponent-does-not-work-on-beaninIt makes sense to let OS env variables by default to let them override any existing property values. This is natural in cloud platforms and also how Spring Boot would work etc. Improvement Properties component - Let OS environment variable take precedence by having it in override mode by default See SOhttps://stackoverflow.com/questions/56081583/camel-standalone-configuration-of-propertiescomponent-does-not-work-on-beaninIt makes sense to let OS env variables by default to let them override any existing property values. This is natural in cloud platforms and also how Spring Boot would work etc.
Component configuration - Allow to use dot to refer to nested options For example some Camel components has nested options like camel-netty4 which has a NettyConfiguration class. So when you want to set some of its options you cannot easily do this via component configuration. We have some special support for spring boot that generated these nested options, but its also needed for other use-cases such as the Camel Main and just in general.For example with SB we can docamel.component.netty4-http.configuration.max-header-sizeWe should add support for doing this via Camel Main and in general also Task Component configuration - Allow to use dot to refer to nested options For example some Camel components has nested options like camel-netty4 which has a NettyConfiguration class. So when you want to set some of its options you cannot easily do this via component configuration. We have some special support for spring boot that generated these nested options, but its also needed for other use-cases such as the Camel Main and just in general.For example with SB we can docamel.component.netty4-http.configuration.max-header-sizeWe should add support for doing this via Camel Main and in general also
File Component: Add option to fail startup when not having read permission on folder When starting a file consumer you configure a folder to poll.When the camel context does not have read access on the folder, there is no error (or even warning), that route just starts.But when saving files into the folder, they are not picked up and there is no further message.This issue was raised on stackoverflow: [https://stackoverflow.com/questions/55920217/camel-file-consumer-when-folder-is-not-accessible] Ideally, the file consumer would check at startup if it has access to the folder (we should propably check for write access here, but read access could also be enough?)If the component (/context) does not have the required access to the folder, it should throw the error and exit the context (so it isn't started in a failure state).This option should be disabled by default.Also we should think about a way to configure the behavior:1. For what permission should the consumer check (read / read-write)2. What should happen when the permission is not given? (just an error / error + stop route / error + stop context)As always, we should make this configurable via a custom bean. New Feature File Component: Add option to fail startup when not having read permission on folder When starting a file consumer you configure a folder to poll.When the camel context does not have read access on the folder, there is no error (or even warning), that route just starts.But when saving files into the folder, they are not picked up and there is no further message.This issue was raised on stackoverflow: [https://stackoverflow.com/questions/55920217/camel-file-consumer-when-folder-is-not-accessible] Ideally, the file consumer would check at startup if it has access to the folder (we should propably check for write access here, but read access could also be enough?)If the component (/context) does not have the required access to the folder, it should throw the error and exit the context (so it isn't started in a failure state).This option should be disabled by default.Also we should think about a way to configure the behavior:1. For what permission should the consumer check (read / read-write)2. What should happen when the permission is not given? (just an error / error + stop route / error + stop context)As always, we should make this configurable via a custom bean.
QuartzScheduledPollConsumerScheduler should not remove trigger when quartz is clustered When using ftp component with quartz scheduler, like following sample"ftp:"+sftpUsername+"@"+sftpHost+":"+sftpPort+"/3G?password="+sftpPw+"&binary=true&delay=5s&delete=true&scheduler=quartz2&scheduler.cron=\{{cron.3G.processing}}&scheduler.triggerId=3G_Trigger" During shutdown, camel will remove all triggers without check quartz is running in cluster mode or not. Since we config quartz is cluster means there can be other instances running, so does it make sense we should check quartz cluster state to decide triggers should remove or keep? !QuartzScheduledPollConsumerScheduler.java — camel-quartz2 2019-05-02 15-46-49.jpg!  Improvement QuartzScheduledPollConsumerScheduler should not remove trigger when quartz is clustered When using ftp component with quartz scheduler, like following sample"ftp:"+sftpUsername+"@"+sftpHost+":"+sftpPort+"/3G?password="+sftpPw+"&binary=true&delay=5s&delete=true&scheduler=quartz2&scheduler.cron=\{{cron.3G.processing}}&scheduler.triggerId=3G_Trigger" During shutdown, camel will remove all triggers without check quartz is running in cluster mode or not. Since we config quartz is cluster means there can be other instances running, so does it make sense we should check quartz cluster state to decide triggers should remove or keep? !QuartzScheduledPollConsumerScheduler.java -- camel-quartz2 2019-05-02 15-46-49.jpg! 
Move dataformats out of camel-core We should deprecate string/seriazliation dataformats as they dont bring value, and java object serialization is a bad design and also often a security vulnerability (many issues reported against this functionality in java).And then we can move zip/gzip into camel-deflater.  Task Move dataformats out of camel-core We should deprecate string/seriazliation dataformats as they dont bring value, and java object serialization is a bad design and also often a security vulnerability (many issues reported against this functionality in java).And then we can move zip/gzip into camel-deflater. 
camel3 - build system - dataformats from camel-core no longer generated in readme files Likely because they were moved from camel-core to camel-base etc. Task camel3 - build system - dataformats from camel-core no longer generated in readme files Likely because they were moved from camel-core to camel-base etc.
camel3 - DefaultEndpoint - Should be singleton by default We should{code}    @Override    public boolean isSingleton() {        // lets be singleton by default as otherwise end-users may mistakenly write components        // which are not singleton. Only in very rare situations would you need to be non-singletons.        return true;    }{code}in DefaultEndpoint, and then remove it from all the components that are also singleton. I think its possible only camel-ftp that may not be. Improvement camel3 - DefaultEndpoint - Should be singleton by default We should{code}    @Override    public boolean isSingleton() {        // lets be singleton by default as otherwise end-users may mistakenly write components        // which are not singleton. Only in very rare situations would you need to be non-singletons.        return true;    }{code}in DefaultEndpoint, and then remove it from all the components that are also singleton. I think its possible only camel-ftp that may not be.
camel3 - Move language annotations for bean parameter bindings into their own package We have @Simple @Constant and @SpEL that are in the root package of language. They should be moved to their sub package, and @SpEL moved to camel-spring Improvement camel3 - Move language annotations for bean parameter bindings into their own package We have @Simple @Constant and @SpEL that are in the root package of language. They should be moved to their sub package, and @SpEL moved to camel-spring
ProxyHelper - Remove binding option binding is always default true and setting it to false is no longer supported on Camel 3 Improvement ProxyHelper - Remove binding option binding is always default true and setting it to false is no longer supported on Camel 3
CamelContext - Move API that are not related to end users to an ExtendedCamelContext Lets cleanup a bit more on CamelContext and move APIs that are more useable for component developers and internally to Camel itself to an ExtendedCamelContext, so the API the end user see on CamelContext is more limited and mostly relevant to what he/she needs to use.We already have some for model CamelContext and JMX etc today.  Improvement CamelContext - Move API that are not related to end users to an ExtendedCamelContext Lets cleanup a bit more on CamelContext and move APIs that are more useable for component developers and internally to Camel itself to an ExtendedCamelContext, so the API the end user see on CamelContext is more limited and mostly relevant to what he/she needs to use.We already have some for model CamelContext and JMX etc today. 
camel3 - Move bean component out of camel-core It seems there are only a few tangles left to make it possible to move bean component and language out of camel-core Improvement camel3 - Move bean component out of camel-core It seems there are only a few tangles left to make it possible to move bean component and language out of camel-core
camel-xpath does not build I think due to CAMEL-13442 refactoring, there's a generated sources path that's looking in the wrong place when camel-xpath tries to build.  Here's the stacktrace:{code:java}[INFO] Scanning for projects...[INFO] [INFO] ------------------------------------------------------------------------[INFO] Building Camel :: XPath 3.0.0-SNAPSHOT[INFO] ------------------------------------------------------------------------[INFO] [INFO] --- maven-bundle-plugin:4.1.0:cleanVersions (versions) @ camel-xpath ---[INFO] [INFO] --- maven-resources-plugin:3.1.0:resources (default-resources) @ camel-xpath ---[INFO] Using 'UTF-8' encoding to copy filtered resources.[INFO] skip non existing resourceDirectory /home/tdalbo/Programming/upstream/apache/camel/components/camel-xpath/src/main/resources[INFO] [INFO] --- flatten-maven-plugin:1.1.0:flatten (default-cli) @ camel-xpath ---[INFO] Generating flattened POM of project org.apache.camel:camel-xpath:jar:3.0.0-SNAPSHOT...[INFO] [INFO] --- maven-compiler-plugin:3.8.0:compile (default-compile) @ camel-xpath ---[INFO] Changes detected - recompiling the module![INFO] Compiling 8 source files to /home/tdalbo/Programming/upstream/apache/camel/components/camel-xpath/target/classes[INFO] [INFO] --- camel-package-maven-plugin:3.0.0-SNAPSHOT:prepare-components (generate) @ camel-xpath ---[INFO] ------------------------------------------------------------------------[INFO] BUILD FAILURE[INFO] ------------------------------------------------------------------------[INFO] Total time: 3.298 s[INFO] Finished at: 2019-04-23T07:42:30-06:00[INFO] Final Memory: 24M/78M[INFO] ------------------------------------------------------------------------[ERROR] Failed to execute goal org.apache.camel:camel-package-maven-plugin:3.0.0-SNAPSHOT:prepare-components (generate) on project camel-xpath: Error loading language model from camel-core. Reason: java.io.FileNotFoundException: /home/tdalbo/Programming/upstream/apache/camel/core/camel-core/target/classes/org/apache/camel/model/language/xpath.json (No such file or directory) -> [Help 1][ERROR] [ERROR] To see the full stack trace of the errors, re-run Maven with the -e switch.[ERROR] Re-run Maven using the -X switch to enable full debug logging.[ERROR] [ERROR] For more information about the errors and possible solutions, please read the following articles:[ERROR] [Help 1] http://cwiki.apache.org/confluence/display/MAVEN/MojoExecutionException{code} Task camel-xpath does not build I think due to CAMEL-13442 refactoring, there's a generated sources path that's looking in the wrong place when camel-xpath tries to build.  Here's the stacktrace:{code:java}[INFO] Scanning for projects...[INFO] [INFO] ------------------------------------------------------------------------[INFO] Building Camel :: XPath 3.0.0-SNAPSHOT[INFO] ------------------------------------------------------------------------[INFO] [INFO] --- maven-bundle-plugin:4.1.0:cleanVersions (versions) @ camel-xpath ---[INFO] [INFO] --- maven-resources-plugin:3.1.0:resources (default-resources) @ camel-xpath ---[INFO] Using 'UTF-8' encoding to copy filtered resources.[INFO] skip non existing resourceDirectory /home/tdalbo/Programming/upstream/apache/camel/components/camel-xpath/src/main/resources[INFO] [INFO] --- flatten-maven-plugin:1.1.0:flatten (default-cli) @ camel-xpath ---[INFO] Generating flattened POM of project org.apache.camel:camel-xpath:jar:3.0.0-SNAPSHOT...[INFO] [INFO] --- maven-compiler-plugin:3.8.0:compile (default-compile) @ camel-xpath ---[INFO] Changes detected - recompiling the module![INFO] Compiling 8 source files to /home/tdalbo/Programming/upstream/apache/camel/components/camel-xpath/target/classes[INFO] [INFO] --- camel-package-maven-plugin:3.0.0-SNAPSHOT:prepare-components (generate) @ camel-xpath ---[INFO] ------------------------------------------------------------------------[INFO] BUILD FAILURE[INFO] ------------------------------------------------------------------------[INFO] Total time: 3.298 s[INFO] Finished at: 2019-04-23T07:42:30-06:00[INFO] Final Memory: 24M/78M[INFO] ------------------------------------------------------------------------[ERROR] Failed to execute goal org.apache.camel:camel-package-maven-plugin:3.0.0-SNAPSHOT:prepare-components (generate) on project camel-xpath: Error loading language model from camel-core. Reason: java.io.FileNotFoundException: /home/tdalbo/Programming/upstream/apache/camel/core/camel-core/target/classes/org/apache/camel/model/language/xpath.json (No such file or directory) -> [Help 1][ERROR] [ERROR] To see the full stack trace of the errors, re-run Maven with the -e switch.[ERROR] Re-run Maven using the -X switch to enable full debug logging.[ERROR] [ERROR] For more information about the errors and possible solutions, please read the following articles:[ERROR] [Help 1] http://cwiki.apache.org/confluence/display/MAVEN/MojoExecutionException{code}
camel3 - Move xpath out of camel-core We can move more xml stuff out of camel-core such as the xpath language Improvement camel3 - Move xpath out of camel-core We can move more xml stuff out of camel-core such as the xpath language
camel3 - DataFormatResolver should be able to lookup from model When you have data formats defined via ids, such as{code}    <dataFormats>        <json library="Jackson" id="myjson"/>        <jaxb contextPath="org.apache.camel.component.dozer.example.abc" id="myjaxb"/>    </dataFormats>{code} Improvement camel3 - DataFormatResolver should be able to lookup from model When you have data formats defined via ids, such as{code}    <dataFormats>        <json library="Jackson" id="myjson"/>        <jaxb contextPath="org.apache.camel.component.dozer.example.abc" id="myjaxb"/>    </dataFormats>{code}
Simple language - Deprecate and remove change its start/end token We should rely on simple tokens being ${ } or $simple{ } for its functions. There is some code that would allow to change those but its not really in use and may not actually work in 100% situations. So lets cleanup this for camel 3. So deprecate in camel 2.x and remove in 3. Improvement Simple language - Deprecate and remove change its start/end token We should rely on simple tokens being ${ } or $simple{ } for its functions. There is some code that would allow to change those but its not really in use and may not actually work in 100% situations. So lets cleanup this for camel 3. So deprecate in camel 2.x and remove in 3.
Simple language - Functions with space should use camelCase style Lets avoid having functions such asstarts withnot containswhere there are space as that makes it a bit less obvious its a function name, and can also lead to: https://stackoverflow.com/questions/55705150/camel-simple-expression-inside-jsonpath-languageSo instead if we usestartsWithnotContains Improvement Simple language - Functions with space should use camelCase style Lets avoid having functions such asstarts withnot containswhere there are space as that makes it a bit less obvious its a function name, and can also lead to: https://stackoverflow.com/questions/55705150/camel-simple-expression-inside-jsonpath-languageSo instead if we usestartsWithnotContains
Add possibility to invalidate cache for PropertiesComponent Currently I can only enable/disable cache for PropertiesComponent.I'd like to be able to enable caching, but programmatically invalidate cache on demand.This should be rather simeple to implemet, something like:{code:java}public void invalidateCache() {  this.cacheMap.clear();}{code} Improvement Add possibility to invalidate cache for PropertiesComponent Currently I can only enable/disable cache for PropertiesComponent.I'd like to be able to enable caching, but programmatically invalidate cache on demand.This should be rather simeple to implemet, something like:{code:java}public void invalidateCache() {  this.cacheMap.clear();}{code}
Remove camel-rmi Its bad design to use Java RMI and the work on CAMEL-13421 makes it better to remove this component as well, and deprecate it in 2.x Improvement Remove camel-rmi Its bad design to use Java RMI and the work on CAMEL-13421 makes it better to remove this component as well, and deprecate it in 2.x
Remove BeanInvocation from camel-bean Doing remote RPC calls via java bean serialization is a bad design and its not really much in use. Lets use the chance to get this removed for 3.x and deprecated in 2.x. Improvement Remove BeanInvocation from camel-bean Doing remote RPC calls via java bean serialization is a bad design and its not really much in use. Lets use the chance to get this removed for 3.x and deprecated in 2.x.
Move mock component out of camel-core Now that we got a bit more moved out, its maybe a bit easier to move out the mock. Improvement Move mock component out of camel-core Now that we got a bit more moved out, its maybe a bit easier to move out the mock.
Please add camel-core-osgi to Camel Karaf feature repo I was following this documentation [http://camel.apache.org/karaf.html] in order to make Camel work in Karaf.Many tutorials point to this configuration:{code:java}@Overridepublic void start(final BundleContext bundleContext) throws Exception {  camelContext = new OsgiDefaultCamelContext(bundleContext);  registrationCamelContext = bundleContext.registerService(CamelContext.class, camelContext, null);  camelContext.start();}{code}Unfortunately, when I install Camel in karaf:{code:java}karaf@root> feature:repo-add camel 2.23.1{code}only camel-core can be installed, while camel-core-osgi is missing.Unfortunately camel-core contains only {code:java}DefaultCamelContext{code}which causes classpath problems in Karaf. For example I import camel-http4, but I get:{code:java}Caused by: org.apache.camel.ResolveEndpointFailedException: Failed to resolve endpoint: http4://my.site due to: No component found with scheme: http4{code}or I import camel-jackson, but I get:{code:java}Caused by: java.lang.IllegalArgumentException: Data format 'json-jackson' could not be created. Ensure that the data format is valid and the associated Camel component is present on the classpath{code}The solution is to use:{code:java}OsgiDefaultCamelContext{code}which is located in camel-core-osgi, which is unavailable in Camel Karaf repo.  Improvement Please add camel-core-osgi to Camel Karaf feature repo I was following this documentation [http://camel.apache.org/karaf.html] in order to make Camel work in Karaf.Many tutorials point to this configuration:{code:java}@Overridepublic void start(final BundleContext bundleContext) throws Exception {  camelContext = new OsgiDefaultCamelContext(bundleContext);  registrationCamelContext = bundleContext.registerService(CamelContext.class, camelContext, null);  camelContext.start();}{code}Unfortunately, when I install Camel in karaf:{code:java}karaf@root> feature:repo-add camel 2.23.1{code}only camel-core can be installed, while camel-core-osgi is missing.Unfortunately camel-core contains only {code:java}DefaultCamelContext{code}which causes classpath problems in Karaf. For example I import camel-http4, but I get:{code:java}Caused by: org.apache.camel.ResolveEndpointFailedException: Failed to resolve endpoint: http4://my.site due to: No component found with scheme: http4{code}or I import camel-jackson, but I get:{code:java}Caused by: java.lang.IllegalArgumentException: Data format 'json-jackson' could not be created. Ensure that the data format is valid and the associated Camel component is present on the classpath{code}The solution is to use:{code:java}OsgiDefaultCamelContext{code}which is located in camel-core-osgi, which is unavailable in Camel Karaf repo. 
Date.getTime() can be changed to System.currentTimeMillis() Hello,I found that System.currentTimeMillis() can be used here instead of new Date.getTime().Since new Date() is a thin wrapper of light method System.currentTimeMillis(). The performance will be greatly damaged if it is invoked too much times.According to my local testing at the same environment, System.currentTimeMillis() can achieve a speedup to 5 times (435 ms vs 2073 ms), when these two methods are invoked 5,000,000 times. Improvement Date.getTime() can be changed to System.currentTimeMillis() Hello,I found that System.currentTimeMillis() can be used here instead of new Date.getTime().Since new Date() is a thin wrapper of light method System.currentTimeMillis(). The performance will be greatly damaged if it is invoked too much times.According to my local testing at the same environment, System.currentTimeMillis() can achieve a speedup to 5 times (435 ms vs 2073 ms), when these two methods are invoked 5,000,000 times.
camel-core - Move cloud out into camel-cloud component Lets see if we can move the cloud parts out of camel-core into a new camel-cloud that some components uses, like camel-service, camel-ribbon etc. Task camel-core - Move cloud out into camel-cloud component Lets see if we can move the cloud parts out of camel-core into a new camel-cloud that some components uses, like camel-service, camel-ribbon etc.
Remove the JMX explain APis and related We have a set of explain APIs on JMX that can output "catalog" like information. However we dont really use it, and this can help remove functionality and complexity of camel-core.You can get details via the camel-catalog and at runtime the runtime camel-catalog. Task Remove the JMX explain APis and related We have a set of explain APIs on JMX that can output "catalog" like information. However we dont really use it, and this can help remove functionality and complexity of camel-core.You can get details via the camel-catalog and at runtime the runtime camel-catalog.
resolve delegating endpoint when routes are dumped As today the ModelHelper.dumpModelAsXml(..., ...) does not resolve delegating endpoint so in case an endpoint delegates to an additional endpoint, this delegated endpoint is not shown in the routes dump.It would be nice to have an option to configure if the delegating endpoint should be replaced by the delegated one on dumpModelAsXml Improvement resolve delegating endpoint when routes are dumped As today the ModelHelper.dumpModelAsXml(..., ...) does not resolve delegating endpoint so in case an endpoint delegates to an additional endpoint, this delegated endpoint is not shown in the routes dump.It would be nice to have an option to configure if the delegating endpoint should be replaced by the delegated one on dumpModelAsXml
enhance message history eip  The current message history eip is somehow limited as we cannot choose which nodes we want to take into account, as example if one creates routes using the new Step EIP, he may want to get the history to track step related activities only.Another additional feature would be to have the message history pattern to keep a copy of the message being produced by the processor under monitor. New Feature enhance message history eip  The current message history eip is somehow limited as we cannot choose which nodes we want to take into account, as example if one creates routes using the new Step EIP, he may want to get the history to track step related activities only.Another additional feature would be to have the message history pattern to keep a copy of the message being produced by the processor under monitor.
Camel main - Allow to configure hystrix via application.properties So you can easily configure hystrix from property placeholders in application.properties etc, which you can do with spring boot etc. Improvement Camel main - Allow to configure hystrix via application.properties So you can easily configure hystrix from property placeholders in application.properties etc, which you can do with spring boot etc.
Re-enable the camel-lra integration tests These camel-lra integration tests were ignored due to the JBTM issues which have been fixed in the Narayana 5.9.0.Final release. So I think it could be useful to re-enable to verify if it works. Test Re-enable the camel-lra integration tests These camel-lra integration tests were ignored due to the JBTM issues which have been fixed in the Narayana 5.9.0.Final release. So I think it could be useful to re-enable to verify if it works.
Update document of HostAddresses  As the Host and Port options are removed, we need to update the HostAddresses document for it. Improvement Update document of HostAddresses  As the Host and Port options are removed, we need to update the HostAddresses document for it.
Camel elasticsearch support search without specifying the indexName and indexType ElasticSearch support not to specify the indexName and indexType for search, so camel-elasticsearch search option don't need to specify the indexName and indexType Task Camel elasticsearch support search without specifying the indexName and indexType ElasticSearch support not to specify the indexName and indexType for search, so camel-elasticsearch search option don't need to specify the indexName and indexType
Camel main - Allow to add extra properties to property component To make it easier to add custom properties from java api. Currently you can only configure properties locations (eg file locations) Improvement Camel main - Allow to add extra properties to property component To make it easier to add custom properties from java api. Currently you can only configure properties locations (eg file locations)
route-coverage : Add option to generate a jacoco XML report Would be good to have the route-coverage maven plugin to be able to generate a XML report using the jacoco XML report format, described in the jacoco documentation [https://www.jacoco.org/jacoco/trunk/doc/] The benefit is that tools like SonarQube has support for handling these XML reports and they can then add this into the report.   New Feature route-coverage : Add option to generate a jacoco XML report Would be good to have the route-coverage maven plugin to be able to generate a XML report using the jacoco XML report format, described in the jacoco documentation [https://www.jacoco.org/jacoco/trunk/doc/] The benefit is that tools like SonarQube has support for handling these XML reports and they can then add this into the report.  
camel-sql - stored procedure loaded from file/classpath should skip comment lines The template is loaded from a resource such a file on the classpath, then lines with comments (start with --) should be skipped. Improvement camel-sql - stored procedure loaded from file/classpath should skip comment lines The template is loaded from a resource such a file on the classpath, then lines with comments (start with --) should be skipped.
create camel-cloudevents data type We should create a camel-cloudevents data type based on https://github.com/cloudevents/sdk-java New Feature create camel-cloudevents data type We should create a camel-cloudevents data type based on https://github.com/cloudevents/sdk-java
Message parameter for log component There does not seem to be a good way to log a message describing what is logged.Imagine I have a route, where I want to be able to trace all the content. I could use .log() processor but log component is better for tracing all the exchange details and also provides showStreams option. {code:java}from(direct:in).to(log:MyTestClass?level=TRACE).to(direct:step1).to(log:MyTestClass?level=TRACE).to(direct:step2).to(log:MyTestClass?level=TRACE).to(direct:step3).to(log:MyTestClass?level=TRACE).to(mock:result){code} In the resulting log, it will be hard to see which line is produced by which log producer.Something like {code:java}.to(log:MyTestClass?level=TRACE&message=user before step1){code}would be quite helpful. Wondering why it has not been implemented yet. I found only early requests from 2008. Beeing able to use simple language would be even better:  {code:java}.to(log:MyTestClass?level=TRACE&message=user before step1 - ${header.user.name}){code}  Improvement Message parameter for log component There does not seem to be a good way to log a message describing what is logged.Imagine I have a route, where I want to be able to trace all the content. I could use .log() processor but log component is better for tracing all the exchange details and also provides showStreams option. {code:java}from(direct:in).to(log:MyTestClass?level=TRACE).to(direct:step1).to(log:MyTestClass?level=TRACE).to(direct:step2).to(log:MyTestClass?level=TRACE).to(direct:step3).to(log:MyTestClass?level=TRACE).to(mock:result){code} In the resulting log, it will be hard to see which line is produced by which log producer.Something like {code:java}.to(log:MyTestClass?level=TRACE&message=user before step1){code}would be quite helpful. Wondering why it has not been implemented yet. I found only early requests from 2008. Beeing able to use simple language would be even better:  {code:java}.to(log:MyTestClass?level=TRACE&message=user before step1 - ${header.user.name}){code} 
camel-core - BeanConverter should be in core static converters This component is still in camel-core and its not part of the core static converters. We should include it - until (if possible) we move the bean component out of camel-core. Improvement camel-core - BeanConverter should be in core static converters This component is still in camel-core and its not part of the core static converters. We should include it - until (if possible) we move the bean component out of camel-core.
apt compiler - Separate core vs component processors We should make camel-core / camel-spring / camel-blueprint have their own set of apt compiler plugins. And then another set for the general components etc.This avoids running some of these on modules they dont need to do. New Feature apt compiler - Separate core vs component processors We should make camel-core / camel-spring / camel-blueprint have their own set of apt compiler plugins. And then another set for the general components etc.This avoids running some of these on modules they dont need to do.
camel-core - Add alternative way of loading type converters without classpath scanning We should make it possible to load and install all type converters without having to do- classpath scanning- loading TypeConverter file from META-INFFor example we do some apt compiler source code generation for the core type converter.It would be good to have something similar or other means of loading and installing type converters that can be done fast and quick, which is needed for Camel K and graal like runtimes. New Feature camel-core - Add alternative way of loading type converters without classpath scanning We should make it possible to load and install all type converters without having to do- classpath scanning- loading TypeConverter file from META-INFFor example we do some apt compiler source code generation for the core type converter.It would be good to have something similar or other means of loading and installing type converters that can be done fast and quick, which is needed for Camel K and graal like runtimes.
ModelCamelContext loadRoutesDefinition/loadRestsDefinition are misleading We do have method like loadRoutesDefinition and loadRestsDefinition in the ModelCamelContext interface but they are a little bit misleading as they do not load a definition in the camel context but they are an helper that invoke{code}ModelHelper.loadRoutesDefinition(this, is){code}The only advantage is that you do not need to pass the camel context but other that that they appear as pure utility.Toproperly load a route one need to do something something like{code}context.addRouteDefinitions(context.loadRoutesDefinition(is).getRoutes()){code}which is a little ugly Improvement ModelCamelContext loadRoutesDefinition/loadRestsDefinition are misleading We do have method like loadRoutesDefinition and loadRestsDefinition in the ModelCamelContext interface but they are a little bit misleading as they do not load a definition in the camel context but they are an helper that invoke{code}ModelHelper.loadRoutesDefinition(this, is){code}The only advantage is that you do not need to pass the camel context but other that that they appear as pure utility.Toproperly load a route one need to do something something like{code}context.addRouteDefinitions(context.loadRoutesDefinition(is).getRoutes()){code}which is a little ugly
camel-cdi and camel-blueprint - Cleanup bean post processor Looks like they do some custom code that likely is not longer needed and can rely on the default out of the box. Task camel-cdi and camel-blueprint - Cleanup bean post processor Looks like they do some custom code that likely is not longer needed and can rely on the default out of the box.
@EndpointInject - Use value as uri We should favour using value as attribute name so you can use shorthand syntax with @EndpointInject("jms:cheese") instead of having to use uri = "xxx"The same for @Produce and @Consume etc Improvement @EndpointInject - Use value as uri We should favour using value as attribute name so you can use shorthand syntax with @EndpointInject("jms:cheese") instead of having to use uri = "xxx"The same for @Produce and @Consume etc
Remove ref on @Consume as you should use ref in the uri instead We removed this on <to ref="xxx"> already in the DSL. We should remove this in other places like @Consume annotation Improvement Remove ref on @Consume as you should use ref in the uri instead We removed this on <to ref="xxx"> already in the DSL. We should remove this in other places like @Consume annotation
Camel registry - Allow to bind anonymously by type With the new bind api on registry we should also allow to bind with null id and by the type only, so you can bind anonymously.For example for single resources in microservices / serverless, which Camel K uses. New Feature Camel registry - Allow to bind anonymously by type With the new bind api on registry we should also allow to bind with null id and by the type only, so you can bind anonymously.For example for single resources in microservices / serverless, which Camel K uses.
Move catalog apis from CamelContext into CatalogCamelContext Lets move these catalog apis into a dedicated catalog camel context which you can then use the adapt api from camel context if you want to use it, like with model camel context Improvement Move catalog apis from CamelContext into CatalogCamelContext Lets move these catalog apis into a dedicated catalog camel context which you can then use the adapt api from camel context if you want to use it, like with model camel context
Allow bean component to invoke methods with package modifier in the same class To make it easier to use methods from the same route builder class where you define the routes, then you may have helper methods, that are invoked via bean / method call language. And they can only see public methods as its via camel-core they are called. So we should look at opening up the visibility, like we do with field injection and other things. Improvement Allow bean component to invoke methods with package modifier in the same class To make it easier to use methods from the same route builder class where you define the routes, then you may have helper methods, that are invoked via bean / method call language. And they can only see public methods as its via camel-core they are called. So we should look at opening up the visibility, like we do with field injection and other things.
camel-core tests fail if JAVA_HOME is not set Test assumes that JAVA_HOME exists which is standard but not mandatory.{noformat}[ERROR] org.apache.camel.component.properties.PropertiesComponentDefaultFunctionsTest.testFunction(org.apache.camel.component.properties.PropertiesComponentDefaultFunctionsTest){noformat} Test camel-core tests fail if JAVA_HOME is not set Test assumes that JAVA_HOME exists which is standard but not mandatory.{noformat}[ERROR] org.apache.camel.component.properties.PropertiesComponentDefaultFunctionsTest.testFunction(org.apache.camel.component.properties.PropertiesComponentDefaultFunctionsTest){noformat}
Properties component - Add easy method to lookup via key Lets make this code a bit easier, and have a nicer API on the PropertiesComponent we have in camel-api now for Camel 3{code}                        // build key with default value included as this is supported during resolving                        String key = pi.value();                        if (!isEmpty(pi.defaultValue())) {                            key = key + ":" + pi.defaultValue();                        }                        // need to force property lookup by having key enclosed in tokens                        key = camelContext.getPropertiesComponent().getPrefixToken() + key + camelContext.getPropertiesComponent().getSuffixToken();                        try {                            Object value = camelContext.resolvePropertyPlaceholders(key);                            parameters[i] = camelContext.getTypeConverter().convertTo(type, value);                        } catch (Exception e) {                            throw RuntimeCamelException.wrapRuntimeCamelException(e);                        }{code} Improvement Properties component - Add easy method to lookup via key Lets make this code a bit easier, and have a nicer API on the PropertiesComponent we have in camel-api now for Camel 3{code}                        // build key with default value included as this is supported during resolving                        String key = pi.value();                        if (!isEmpty(pi.defaultValue())) {                            key = key + ":" + pi.defaultValue();                        }                        // need to force property lookup by having key enclosed in tokens                        key = camelContext.getPropertiesComponent().getPrefixToken() + key + camelContext.getPropertiesComponent().getSuffixToken();                        try {                            Object value = camelContext.resolvePropertyPlaceholders(key);                            parameters[i] = camelContext.getTypeConverter().convertTo(type, value);                        } catch (Exception e) {                            throw RuntimeCamelException.wrapRuntimeCamelException(e);                        }{code}
Camel-linkedin, switch HtmlUnit to JSoup to not rely on Jetty (and allow update to servlet api 4) Component camel-linkedin depends on Jetty (see https://github.com/apache/camel/blob/master/platforms/karaf/features/src/main/resources/features.xml#L1578)This dependency doesn't allow update servlet-api to 4.0Solution is to refactor component to use JSoup instead. Improvement Camel-linkedin, switch HtmlUnit to JSoup to not rely on Jetty (and allow update to servlet api 4) Component camel-linkedin depends on Jetty (see https://github.com/apache/camel/blob/master/platforms/karaf/features/src/main/resources/features.xml#L1578)This dependency doesn't allow update servlet-api to 4.0Solution is to refactor component to use JSoup instead.
camel-quartz - Allow to configure cron parameter with spaces In the past we had to use + sign as separator in the cron{code}0/2+*+*+*+*+?{code}We should support also using spaces, so its like text-book cron{code}0/2 * * * * ?{code} Improvement camel-quartz - Allow to configure cron parameter with spaces In the past we had to use + sign as separator in the cron{code}0/2+*+*+*+*+?{code}We should support also using spaces, so its like text-book cron{code}0/2 * * * * ?{code}
Properties component - Keys with dashes should lookup with underscores as well On linux OS environment variables using dashes is not allowed, eg FOO-BAR, should be FOO_BAR. So we should automatic add support for looking up with underscores as fallback. Improvement Properties component - Keys with dashes should lookup with underscores as well On linux OS environment variables using dashes is not allowed, eg FOO-BAR, should be FOO_BAR. So we should automatic add support for looking up with underscores as fallback.
Properties component - Add support for lookup exact by key, and mixed dashed vs camel case So you can define property placeholders using a dashed stylehttps://github.com/apache/camel/blob/master/components/camel-jms/src/main/docs/jms-component.adocFor example to set the JMS component option you can do:camel.component.jms.acceptMessagesWhileStopping=trueBut would be nice to support dashed style too (ala spring boot)camel.component.jms.accept-messages-while-stopping=trueThis is needed for Camel standalone to make this easier / similar to spring-boot New Feature Properties component - Add support for lookup exact by key, and mixed dashed vs camel case So you can define property placeholders using a dashed stylehttps://github.com/apache/camel/blob/master/components/camel-jms/src/main/docs/jms-component.adocFor example to set the JMS component option you can do:camel.component.jms.acceptMessagesWhileStopping=trueBut would be nice to support dashed style too (ala spring boot)camel.component.jms.accept-messages-while-stopping=trueThis is needed for Camel standalone to make this easier / similar to spring-boot
 AggregationStrategy - Access original exchange in aggregate method For aggregation after multicast/splitter the original exchange should optionally be available in the aggregate method. There are several use cases when we would like to go-on processing the original exchange after multicast, but we'd like to enrich it with the outcome of the called routes. For example:{code:java}rest().get("orders/{orderId}").route()  .to("direct:getOrderDetails") //get UserId, ItemId  .setBody(method(this,"createResponsePojo"))  .multicast(new MyAggregationStrategy())    .to("direct:getUserDetails")    .to("direct:getDeliveryAddress")    .to("direct:getItemDetails")  .end();{code}If any of the called routes fail, we still would like return a partial response in our service (this is a common requirement in case of microservices). The MyAggregationStrategy should simply enrich the ResponePojo object from the original exchange somehow with the new exchanges coming from the sub-routes. See this example:{code:java}public class MyAggregationStrategy implements AggregationStrategy {public Exchange aggregateWithOriginal(Exchange oldExchange, Exchange newExchange, Exchange originalExchange) {  Exchange exchange = oldExchange != null ? oldExchange : originalExchange;  ResponsePojo response = exchange.getMessage().getBody(ResponsePojo.class);  if (! newExchange.isFailed()) {    // ... Add newExchange body somehow to ResponsePojo object...  }  return exchange;}...}{code}Currently only the exchanges from the "sub-routes" are available during aggregation, so the exchange after the aggregate will be one (the first) of those. This comes with multiple problems: * Though the exchanges in the sub-routes are copies of the original exchange, sub routes make modifications: modify headers, modify properties, etc. Usually we don't want to see all these set by a sub-route on the final aggregated exchange. It's only noise. "Whatever happens in the sub-route, should stay in the sub-route." - We only want to see on the aggregated exchange what we "took" intentionally from the sub-route exchanges. * If we use stopOnException(true) our life is simple because we usually don't have to worry about exceptions in aggregate, we will stop anyway. The aggregation logic can become complicated if we want to go on with processing in case of errors. The first time aggregate() is called the oldExchange is null, so we usually take the newExchange as the return value. If this exchange has an Exception, we need to "clean" it first, otherwise the error handler will kick in after aggregation. This is non-trivial.h3. Suggested approachLet's extend the AggregationStrategy interface with a new method that takes three exchanges. This should be called after Multicast EIP (Enrich EIP is simple, it only has two exchanges).With a default implementations we can keep the interface compatible:{code:java}public interface AggregationStrategy {/*** Aggregates an old, a new and the original exchange together to create a single combined exchange.** @param oldExchange the oldest exchange, which is the returned value of the previous aggregation on null.* @param newExchange the newest exchange* @param originalExchange the original exchange before Multicast or Splitter EIP. Null in case of Enrich EIP.* @return a combined exchange, favor returning the oldExchange*/default Exchange aggregateWithOriginal(Exchange oldExchange, Exchange newExchange, Exchange originalExchange) {  return aggregate(oldExchange, newExchange);};//Maybe we should have a default implementation here too so one can only implement aggregateWithOriginal()Exchange aggregate(Exchange oldExchange, Exchange newExchange); ... }{code}{code:java} {code} New Feature  AggregationStrategy - Access original exchange in aggregate method For aggregation after multicast/splitter the original exchange should optionally be available in the aggregate method. There are several use cases when we would like to go-on processing the original exchange after multicast, but we'd like to enrich it with the outcome of the called routes. For example:{code:java}rest().get("orders/{orderId}").route()  .to("direct:getOrderDetails") //get UserId, ItemId  .setBody(method(this,"createResponsePojo"))  .multicast(new MyAggregationStrategy())    .to("direct:getUserDetails")    .to("direct:getDeliveryAddress")    .to("direct:getItemDetails")  .end();{code}If any of the called routes fail, we still would like return a partial response in our service (this is a common requirement in case of microservices). The MyAggregationStrategy should simply enrich the ResponePojo object from the original exchange somehow with the new exchanges coming from the sub-routes. See this example:{code:java}public class MyAggregationStrategy implements AggregationStrategy {public Exchange aggregateWithOriginal(Exchange oldExchange, Exchange newExchange, Exchange originalExchange) {  Exchange exchange = oldExchange != null ? oldExchange : originalExchange;  ResponsePojo response = exchange.getMessage().getBody(ResponsePojo.class);  if (! newExchange.isFailed()) {    // ... Add newExchange body somehow to ResponsePojo object...  }  return exchange;}...}{code}Currently only the exchanges from the "sub-routes" are available during aggregation, so the exchange after the aggregate will be one (the first) of those. This comes with multiple problems: * Though the exchanges in the sub-routes are copies of the original exchange, sub routes make modifications: modify headers, modify properties, etc. Usually we don't want to see all these set by a sub-route on the final aggregated exchange. It's only noise. "Whatever happens in the sub-route, should stay in the sub-route." - We only want to see on the aggregated exchange what we "took" intentionally from the sub-route exchanges. * If we use stopOnException(true) our life is simple because we usually don't have to worry about exceptions in aggregate, we will stop anyway. The aggregation logic can become complicated if we want to go on with processing in case of errors. The first time aggregate() is called the oldExchange is null, so we usually take the newExchange as the return value. If this exchange has an Exception, we need to "clean" it first, otherwise the error handler will kick in after aggregation. This is non-trivial.h3. Suggested approachLet's extend the AggregationStrategy interface with a new method that takes three exchanges. This should be called after Multicast EIP (Enrich EIP is simple, it only has two exchanges).With a default implementations we can keep the interface compatible:{code:java}public interface AggregationStrategy {/*** Aggregates an old, a new and the original exchange together to create a single combined exchange.** @param oldExchange the oldest exchange, which is the returned value of the previous aggregation on null.* @param newExchange the newest exchange* @param originalExchange the original exchange before Multicast or Splitter EIP. Null in case of Enrich EIP.* @return a combined exchange, favor returning the oldExchange*/default Exchange aggregateWithOriginal(Exchange oldExchange, Exchange newExchange, Exchange originalExchange) {  return aggregate(oldExchange, newExchange);};//Maybe we should have a default implementation here too so one can only implement aggregateWithOriginal()Exchange aggregate(Exchange oldExchange, Exchange newExchange); ... }{code}{code:java} {code}
Add @BindRegistry annotation to allow binding a field/class/bean to the Camel registry Now that we can bind to registry, lets add an annotation so users can define those as well, for example with Camel standalone. New Feature Add @BindRegistry annotation to allow binding a field/class/bean to the Camel registry Now that we can bind to registry, lets add an annotation so users can define those as well, for example with Camel standalone.
spring boot starter - Generated auto configuration should support exclude properties on component level A few component inherit each other, and they may exclude some of the parent options, for example ftp/netty4-http etc. Currently they only do that on endpoint level. We need something similar on component level so the SB auto generation dont include them.{code}        excludeProperties = "textline,delimiter,autoAppendDelimiter,decoderMaxLineLength,encoding,allowDefaultCodec,udpConnectionlessSending,networkInterface"                + ",clientMode,reconnect,reconnectInterval,useByteBuf,udpByteArrayCodec,broadcast,correlationManager"){code} Improvement spring boot starter - Generated auto configuration should support exclude properties on component level A few component inherit each other, and they may exclude some of the parent options, for example ftp/netty4-http etc. Currently they only do that on endpoint level. We need something similar on component level so the SB auto generation dont include them.{code}        excludeProperties = "textline,delimiter,autoAppendDelimiter,decoderMaxLineLength,encoding,allowDefaultCodec,udpConnectionlessSending,networkInterface"                + ",clientMode,reconnect,reconnectInterval,useByteBuf,udpByteArrayCodec,broadcast,correlationManager"){code}
Properties component - Allow to access loaded properties We should expose API on properties component so users and tooling can access the loaded properties. This can help with detecting which properties are available in the project. New Feature Properties component - Allow to access loaded properties We should expose API on properties component so users and tooling can access the loaded properties. This can help with detecting which properties are available in the project.
Link missing in JMX Documentation Reference: [https://github.com/apache/camel/blob/master/components/camel-jmx/src/main/docs/jmx-component.adoc#which-processors-are-registered]{{It mentions "See this FAQ". But there is no link for it.}} Task Link missing in JMX Documentation Reference: [https://github.com/apache/camel/blob/master/components/camel-jmx/src/main/docs/jmx-component.adoc#which-processors-are-registered]{{It mentions "See this FAQ". But there is no link for it.}}
camel-core-xml - Make JMX optional This module requires camel-management-impl. We should try to make this optional, so the JMX agent is not needed via compile time, but loaded via some factory way. Then end users can run camel XML with and without JMX more easily. Improvement camel-core-xml - Make JMX optional This module requires camel-management-impl. We should try to make this optional, so the JMX agent is not needed via compile time, but loaded via some factory way. Then end users can run camel XML with and without JMX more easily.
camel-core - Use camel-test for unit testing We can now build camel-test before camel-core, and then use camel-test for testing camel-core instead of having its own ContextTestSupport and other base classes. Improvement camel-core - Use camel-test for unit testing We can now build camel-test before camel-core, and then use camel-test for testing camel-core instead of having its own ContextTestSupport and other base classes.
Add release artifacts of camel-k-runtime project We need to create the source release artifact for the camel-k-runtime project. Task Add release artifacts of camel-k-runtime project We need to create the source release artifact for the camel-k-runtime project.
SimpleRegistry - Favour DefaultRegistry The DefaultRegistry should be favoured to be used. The simple registry is now more of an implementation detail as part of default registry.And you can now do bind on default registry so you dont need to add custom registry to camel context to bind a bean etc. Improvement SimpleRegistry - Favour DefaultRegistry The DefaultRegistry should be favoured to be used. The simple registry is now more of an implementation detail as part of default registry.And you can now do bind on default registry so you dont need to add custom registry to camel context to bind a bean etc.
camel-cdi - Remove OSGi support OSGi with camel-cdi was hard to make stable and also not recommended to use. We only support OSGi blueprint on OSGi and for CDI then use plain CDI containers. Task camel-cdi - Remove OSGi support OSGi with camel-cdi was hard to make stable and also not recommended to use. We only support OSGi blueprint on OSGi and for CDI then use plain CDI containers.
Camel Main - Make it have more functionality and convention out of the box For users that just want a plain Camel standalone, and also for Camel K where running low-footprint is important.For example to make properties component automatic load from application.properties from root classpath. And also allow to have those properties fallback to lookup via ENV variables, so containers can customize them that way too.And add other ideas here to this ticket Improvement Camel Main - Make it have more functionality and convention out of the box For users that just want a plain Camel standalone, and also for Camel K where running low-footprint is important.For example to make properties component automatic load from application.properties from root classpath. And also allow to have those properties fallback to lookup via ENV variables, so containers can customize them that way too.And add other ideas here to this ticket
Don't ship the jars in the source artifacts In Camel 3.0.0 M1 source release kit, there are some jars for testing, we need to clean them out.{code}.//tests/camel-itest/lib/org/apache/camel/camel-validator-test-resources/1.0.0/camel-validator-test-resources-1.0.0.jar.//components/camel-spring/src/test/resources/package_scan_test.jar.//components/camel-spring/src/test/resources/package+scan+test.jar{code} Task Don't ship the jars in the source artifacts In Camel 3.0.0 M1 source release kit, there are some jars for testing, we need to clean them out.{code}.//tests/camel-itest/lib/org/apache/camel/camel-validator-test-resources/1.0.0/camel-validator-test-resources-1.0.0.jar.//components/camel-spring/src/test/resources/package_scan_test.jar.//components/camel-spring/src/test/resources/package+scan+test.jar{code}
Simple language - Backwards compatible parser on 2.x should WARN We can make the old deprecated syntax of the simple language log a WARN when it has detected this style in Camel 2.24, so users can get more prepared for Camel 3.0 upgrade. Task Simple language - Backwards compatible parser on 2.x should WARN We can make the old deprecated syntax of the simple language log a WARN when it has detected this style in Camel 2.24, so users can get more prepared for Camel 3.0 upgrade.
Upgrade jetty to latest 9.4.x There is a newer release, but it may affect camel-cxf and others which tests with jetty. Jetty is always a bit problematic in their upgrades :( Task Upgrade jetty to latest 9.4.x There is a newer release, but it may affect camel-cxf and others which tests with jetty. Jetty is always a bit problematic in their upgrades :(
camel-jetty - Remove deprecated producer The producer of camel-jetty has been deprecated in Camel 2.x, and should be removed in 3.0. Task camel-jetty - Remove deprecated producer The producer of camel-jetty has been deprecated in Camel 2.x, and should be removed in 3.0.
Merge camel-jetty9 back into camel-jetty In the old days we had jetty 8 vs 9 problem, so we had to splitup it.Now we camel 3 we can move back camel-jetty9 into camel-jetty and have this single JAR. Task Merge camel-jetty9 back into camel-jetty In the old days we had jetty 8 vs 9 problem, so we had to splitup it.Now we camel 3 we can move back camel-jetty9 into camel-jetty and have this single JAR.
camel-mail: Add headerFilterStrategy option to component level Currently it's not possible to change/customize the headerFilterStrategy for all camel-mail endpoints because it has to be configured on endpoint level.In the cxf component it's possible to configure it on component level too, so it's possible to provide a global headerFilterStrategy:Example:{noformat}		CxfComponent comp = camelContext.getComponent("cxf",				CxfComponent.class);		CxfHeaderFilterStrategy strategy = new CxfHeaderFilterStrategy();		strategy.setOutFilterPattern(				"<customized>");		comp.setHeaderFilterStrategy(strategy);{noformat}It would be an improvement to add the headerFilterStrategy option also to component level. Improvement camel-mail: Add headerFilterStrategy option to component level Currently it's not possible to change/customize the headerFilterStrategy for all camel-mail endpoints because it has to be configured on endpoint level.In the cxf component it's possible to configure it on component level too, so it's possible to provide a global headerFilterStrategy:Example:{noformat}		CxfComponent comp = camelContext.getComponent("cxf",				CxfComponent.class);		CxfHeaderFilterStrategy strategy = new CxfHeaderFilterStrategy();		strategy.setOutFilterPattern(				"<customized>");		comp.setHeaderFilterStrategy(strategy);{noformat}It would be an improvement to add the headerFilterStrategy option also to component level.
camel-test-spring - Add support for @ExcludeRoutes annotation when testing spring boot Reported on user forumhttp://camel.465427.n5.nabble.com/ExcludeRoutes-not-working-tp5830132.html Improvement camel-test-spring - Add support for @ExcludeRoutes annotation when testing spring boot Reported on user forumhttp://camel.465427.n5.nabble.com/ExcludeRoutes-not-working-tp5830132.html
camel3 - camel-core - Should have management-impl out of the box So its like in 2.x, where you have JMX out of the box.We will for M2 work on a camel-core-tiny where you dont have that OOTB and other core components etc to have a minimal Camel. Task camel3 - camel-core - Should have management-impl out of the box So its like in 2.x, where you have JMX out of the box.We will for M2 work on a camel-core-tiny where you dont have that OOTB and other core components etc to have a minimal Camel.
camel3 - spring-boot-start - Auto configuration too many we have still the ones that was in camel-core, but many has been moved out to its own component such as file, log, timer etc. Task camel3 - spring-boot-start - Auto configuration too many we have still the ones that was in camel-core, but many has been moved out to its own component such as file, log, timer etc.
camel3 - camel-core-minimal - To have core with as few dependencies as possible The camel-core includes all the core components from 2.x. However you may want to choose precisely only the core components you need.So with a camel-core-minimal you can then add the ones afterwards, such as log,timer and file etc. Task camel3 - camel-core-minimal - To have core with as few dependencies as possible The camel-core includes all the core components from 2.x. However you may want to choose precisely only the core components you need.So with a camel-core-minimal you can then add the ones afterwards, such as log,timer and file etc.
camel3 - Caffeine jar is not shaded It should be shaded into camel-core which I dont think happens Task camel3 - Caffeine jar is not shaded It should be shaded into camel-core which I dont think happens
Using @Produce as proxy for sending to endpoint does not emit sending/sent events Reported on user forumhttp://camel.465427.n5.nabble.com/No-ExchangeSentEvent-in-Produce-but-is-in-ProducerTemplate-tp5830067.html Improvement Using @Produce as proxy for sending to endpoint does not emit sending/sent events Reported on user forumhttp://camel.465427.n5.nabble.com/No-ExchangeSentEvent-in-Produce-but-is-in-ProducerTemplate-tp5830067.html
camel3 - Karaf commands should use org.apache.camel as group id So everything we do in Apache Camel is always org.apache.camel    <dependency>      <groupId>org.apache.camel.karaf</groupId>      <artifactId>camel-karaf-commands</artifactId>    </dependency>Should be    <dependency>      <groupId>org.apache.camel</groupId>      <artifactId>camel-karaf-commands</artifactId>    </dependency> Task camel3 - Karaf commands should use org.apache.camel as group id So everything we do in Apache Camel is always org.apache.camel    <dependency>      <groupId>org.apache.camel.karaf</groupId>      <artifactId>camel-karaf-commands</artifactId>    </dependency>Should be    <dependency>      <groupId>org.apache.camel</groupId>      <artifactId>camel-karaf-commands</artifactId>    </dependency>
camel3 - Remove deprecate jolokia commands Just noticed it was there when I built locally. Task camel3 - Remove deprecate jolokia commands Just noticed it was there when I built locally.
camel-catalog - Should be built after all Camel components It should be built after all the camel components so it includes all the metadata of all components. Currently Maven builds it too early. Task camel-catalog - Should be built after all Camel components It should be built after all the camel components so it includes all the metadata of all components. Currently Maven builds it too early.
Rename terser language to hl7terser The language terser is not well know, and its confusing what it does. I think we should rename it to hl7terser to indicate its about hl7. Improvement Rename terser language to hl7terser The language terser is not well know, and its confusing what it does. I think we should rename it to hl7terser to indicate its about hl7.
Consider removing useOriginalMessage functionality This feature is a bit more complex and its intention/design was to in case of an error during routing, you could say, that the original incoming message should be restored as-is and used as "result", for example in case you want to move that message to some dead letter queue or log it etc.However people may mis-understand this, and think you can mix the original message BODY only and enrich it with any existing headers at the time of error - but that was not how it was designed/intended.However a few EIPs and if you turned on shared unit of work, you could end up with situations where it would mix the original message with the message of error.If the user wants to mix both the original message with the message at the error, then they should use a bean/processor/aggregation strategy etc to "merge" the data together as they want. NOT rely on just saying useOriginalMessage and "hope for the best". Also the original message body, can when you transfer messages over Camel endpoints be stored at new endpoints such as JMS, direct-vm etc whom creates a new exchange. And if you use direct, and other internals it would not. So it can be a bit unclear where such original message would origin from.Instead we should let the user use the Claim Check EIP pattern where you can explict set safe points with the original message, and easily merge data back agains, such as the message body only etc.See for examplehttps://github.com/apache/camel/blob/camel-2.x/camel-core/src/test/java/org/apache/camel/issues/MulticastMixOriginalMessageBodyAndEnrichedHeadersTest.javaVShttps://github.com/apache/camel/blob/camel-2.x/camel-core/src/test/java/org/apache/camel/issues/MulticastMixOriginalMessageBodyAndEnrichedHeadersClaimCheckTest.java Improvement Consider removing useOriginalMessage functionality This feature is a bit more complex and its intention/design was to in case of an error during routing, you could say, that the original incoming message should be restored as-is and used as "result", for example in case you want to move that message to some dead letter queue or log it etc.However people may mis-understand this, and think you can mix the original message BODY only and enrich it with any existing headers at the time of error - but that was not how it was designed/intended.However a few EIPs and if you turned on shared unit of work, you could end up with situations where it would mix the original message with the message of error.If the user wants to mix both the original message with the message at the error, then they should use a bean/processor/aggregation strategy etc to "merge" the data together as they want. NOT rely on just saying useOriginalMessage and "hope for the best". Also the original message body, can when you transfer messages over Camel endpoints be stored at new endpoints such as JMS, direct-vm etc whom creates a new exchange. And if you use direct, and other internals it would not. So it can be a bit unclear where such original message would origin from.Instead we should let the user use the Claim Check EIP pattern where you can explict set safe points with the original message, and easily merge data back agains, such as the message body only etc.See for examplehttps://github.com/apache/camel/blob/camel-2.x/camel-core/src/test/java/org/apache/camel/issues/MulticastMixOriginalMessageBodyAndEnrichedHeadersTest.javaVShttps://github.com/apache/camel/blob/camel-2.x/camel-core/src/test/java/org/apache/camel/issues/MulticastMixOriginalMessageBodyAndEnrichedHeadersClaimCheckTest.java
[consumer.]bridgeErrorHandler doesn't handle exception thrown by startingDirectoryMustExist Following [StackOverflow: _File component's \[consumer.\]bridgeErrorHandler in conjunction with startingDirectoryMustExist_ |https://stackoverflow.com/questions/54513101/file-components-consumer-bridgeerrorhandler-in-conjunction-with-startingdirec] I created the following test class:{code:java}package test;import org.apache.camel.LoggingLevel;import org.apache.camel.builder.RouteBuilder;import org.apache.camel.main.Main;import org.junit.After;import org.junit.Before;import org.junit.Test;public class CamelBridgeErrorHandlerTest {  private Main main;  @Before  public void before() {    main = new Main();  }  @Test  public void bridgeErrorHandler() {    main.addRouteBuilder(new RouteBuilder() {      @Override      public void configure() throws Exception {        route(this, "file:not.existing.dir?autoCreate=false&startingDirectoryMustExist=true&bridgeErrorHandler=true");      }    });  }  @Test  public void consumerBridgeErrorHandler() {    main.addRouteBuilder(new RouteBuilder() {      @Override      public void configure() throws Exception {        route(this, "file:not.existing.dir?autoCreate=false&startingDirectoryMustExist=true&consumer.bridgeErrorHandler=true");      }    });  }  private void route(final RouteBuilder builder, final String consumerURI) {    builder        .from(consumerURI)        // this is never reached        .onException(Exception.class)        .handled(true)        .log(LoggingLevel.ERROR, "${exception}")        .end()        .log(" ... processing ...");  }  @After  public void after() throws Exception {    main.start();  }}{code}Both test methods throw:{noformat}org.apache.camel.FailedToCreateRouteException: Failed to create route routeN:  Route(routeN)[[From[file:not.existing.dir?autoCreate=false&s...    because of Starting directory does not exist: not.existing.dir{noformat}rather than the exception(s) being handled by the route(s)' {{onException()}}.----P.S.: When TRACEing through the log output both test methods show:{quote}2019-02-08 11:29:36.209 TRACE camel.model.ProcessorDefinitionHelper – There are 6 properties on: From\[file:not.existing.dir?autoCreate=false&startingDirectoryMustExist=true&\{consumer.}bridgeErrorHandler=true\]{quote}while there are just 3 of them ({{autoCreate}}, {{startingDirectoryMustExist}}, {{[consumer.]bridgeErrorHandler}}), aren't there? Is this worth another issue? Improvement [consumer.]bridgeErrorHandler doesn't handle exception thrown by startingDirectoryMustExist Following [StackOverflow: _File component's \[consumer.\]bridgeErrorHandler in conjunction with startingDirectoryMustExist_ |https://stackoverflow.com/questions/54513101/file-components-consumer-bridgeerrorhandler-in-conjunction-with-startingdirec] I created the following test class:{code:java}package test;import org.apache.camel.LoggingLevel;import org.apache.camel.builder.RouteBuilder;import org.apache.camel.main.Main;import org.junit.After;import org.junit.Before;import org.junit.Test;public class CamelBridgeErrorHandlerTest {  private Main main;  @Before  public void before() {    main = new Main();  }  @Test  public void bridgeErrorHandler() {    main.addRouteBuilder(new RouteBuilder() {      @Override      public void configure() throws Exception {        route(this, "file:not.existing.dir?autoCreate=false&startingDirectoryMustExist=true&bridgeErrorHandler=true");      }    });  }  @Test  public void consumerBridgeErrorHandler() {    main.addRouteBuilder(new RouteBuilder() {      @Override      public void configure() throws Exception {        route(this, "file:not.existing.dir?autoCreate=false&startingDirectoryMustExist=true&consumer.bridgeErrorHandler=true");      }    });  }  private void route(final RouteBuilder builder, final String consumerURI) {    builder        .from(consumerURI)        // this is never reached        .onException(Exception.class)        .handled(true)        .log(LoggingLevel.ERROR, "${exception}")        .end()        .log(" ... processing ...");  }  @After  public void after() throws Exception {    main.start();  }}{code}Both test methods throw:{noformat}org.apache.camel.FailedToCreateRouteException: Failed to create route routeN:  Route(routeN)[[From[file:not.existing.dir?autoCreate=false&s...    because of Starting directory does not exist: not.existing.dir{noformat}rather than the exception(s) being handled by the route(s)' {{onException()}}.----P.S.: When TRACEing through the log output both test methods show:{quote}2019-02-08 11:29:36.209 TRACE camel.model.ProcessorDefinitionHelper - There are 6 properties on: From\[file:not.existing.dir?autoCreate=false&startingDirectoryMustExist=true&\{consumer.}bridgeErrorHandler=true\]{quote}while there are just 3 of them ({{autoCreate}}, {{startingDirectoryMustExist}}, {{[consumer.]bridgeErrorHandler}}), aren't there? Is this worth another issue?
camel3 - Remove includeRoutes on RouteBuilder This functionality was not really in use, and was not fully implemented. And there was no similar feature for using other DSLs such as XML.Its deprecated in 2.x and removed in 3 Improvement camel3 - Remove includeRoutes on RouteBuilder This functionality was not really in use, and was not fully implemented. And there was no similar feature for using other DSLs such as XML.Its deprecated in 2.x and removed in 3
Remove headers should be case in-sensitive by default The PatternHelper.matchPattern is case sensitive when matching with wildcard and regexp. For exact match then header keys are by default case insensitive so remove foo will remove FOO Foo and foo headers. But remove pattern=foo* will only remove lower-case foo headers. So we should make this case insensitive for all kinds of patterns (exact, wildcard and regexp). Improvement Remove headers should be case in-sensitive by default The PatternHelper.matchPattern is case sensitive when matching with wildcard and regexp. For exact match then header keys are by default case insensitive so remove foo will remove FOO Foo and foo headers. But remove pattern=foo* will only remove lower-case foo headers. So we should make this case insensitive for all kinds of patterns (exact, wildcard and regexp).
Unable to invoke beans starting with the string "header" using toD  I found one strange behavior when I added below to my route: {code:java}from(...)    .toD("headerEnricher"){code} After some debugging with below unit test, I was able to find the culprit as this line which is interpreting "headerEnricher" as if it is equivalent to "header.Enricher" or "header[Enricher]"[https://github.com/apache/camel/blob/camel-2.23.x/camel-core/src/main/java/org/apache/camel/language/simple/ast/SimpleFunctionExpression.java#L352]  {code:java}@Testpublic void testSimpleHeaderString() {final Language lan = new DefaultCamelContext().resolveLanguage("simple");final Expression exp = lan.createExpression("hederEnricher");//PassAssert.assertEquals(exp.toString(), "hederEnricher");final Expression exp2 = lan.createExpression("headerEnricher");//FailAssert.assertEquals(exp2.toString(), "headerEnricher");}{code} My thought is that the legacy syntax should not try to parse the header expression unless it is followed by some kind of valid operator character like . or ? or [   Improvement Unable to invoke beans starting with the string "header" using toD  I found one strange behavior when I added below to my route: {code:java}from(...)    .toD("headerEnricher"){code} After some debugging with below unit test, I was able to find the culprit as this line which is interpreting "headerEnricher" as if it is equivalent to "header.Enricher" or "header[Enricher]"[https://github.com/apache/camel/blob/camel-2.23.x/camel-core/src/main/java/org/apache/camel/language/simple/ast/SimpleFunctionExpression.java#L352]  {code:java}@Testpublic void testSimpleHeaderString() {final Language lan = new DefaultCamelContext().resolveLanguage("simple");final Expression exp = lan.createExpression("hederEnricher");//PassAssert.assertEquals(exp.toString(), "hederEnricher");final Expression exp2 = lan.createExpression("headerEnricher");//FailAssert.assertEquals(exp2.toString(), "headerEnricher");}{code} My thought is that the legacy syntax should not try to parse the header expression unless it is followed by some kind of valid operator character like . or ? or [  
Removed deprecated stuff from simple language Related to CAMEL-13150. Where property on the date command is deprecated. We should remove that, and also look at other things that has been deprecated in the simple language in 2.x. Task Removed deprecated stuff from simple language Related to CAMEL-13150. Where property on the date command is deprecated. We should remove that, and also look at other things that has been deprecated in the simple language in 2.x.
Add command "exchangeProperty" for dateExpression in ExpressionBuilder Method "_dateExpression_" in _ExpressionBuilder.java_ is not taking care about new accessor of "_exchangeProperty_". Command "_property_" is *deprecated* since 2.15+working+ : simple("_${date:property.CamelCreatedTimestamp:yyyy-MM-dd}_") +not-working+ : simple("_${date:exchangeProperty.CamelCreatedTimestamp:yyyy-MM-dd}_")  Improvement Add command "exchangeProperty" for dateExpression in ExpressionBuilder Method "_dateExpression_" in _ExpressionBuilder.java_ is not taking care about new accessor of "_exchangeProperty_". Command "_property_" is *deprecated* since 2.15+working+ : simple("_${date:property.CamelCreatedTimestamp:yyyy-MM-dd}_") +not-working+ : simple("_${date:exchangeProperty.CamelCreatedTimestamp:yyyy-MM-dd}_") 
Move bean component out of camel-core This component is a bit more challenging as bean component is also used for method call language and has support for using language annotations. For example also for @XPath etc. Task Move bean component out of camel-core This component is a bit more challenging as bean component is also used for method call language and has support for using language annotations. For example also for @XPath etc.
Camel may package artifacts from different version When switching from one branch to another there is a (likely) possibility that component directories that existed in a previous checkout branch are no longer available in the current checkout branch. However, `camel-foo/target` with all the previously generated artifacts is still on the file system and cannot be detected by `git status` either. Neither will these stale target directories be removed by `mvn clean`.The camel packager plugin seems to be walking the camel directory structure and will package everything it finds. As a result the camel-2.23.2-SNAPSHOT catalog may contain a catalog entry that points to camel-browse-3.0.0-SNAPSHOT.As a workaround, I suggest to do something like this {code}find . -type d -name target | xargs rm -rf{code}before doing a clean mvn build.As a possible solution, it may be necessary for the thing that walks the directory structure to require at least one file that is maintained in SCM (e.g. pom.xml) Task Camel may package artifacts from different version When switching from one branch to another there is a (likely) possibility that component directories that existed in a previous checkout branch are no longer available in the current checkout branch. However, `camel-foo/target` with all the previously generated artifacts is still on the file system and cannot be detected by `git status` either. Neither will these stale target directories be removed by `mvn clean`.The camel packager plugin seems to be walking the camel directory structure and will package everything it finds. As a result the camel-2.23.2-SNAPSHOT catalog may contain a catalog entry that points to camel-browse-3.0.0-SNAPSHOT.As a workaround, I suggest to do something like this {code}find . -type d -name target | xargs rm -rf{code}before doing a clean mvn build.As a possible solution, it may be necessary for the thing that walks the directory structure to require at least one file that is maintained in SCM (e.g. pom.xml)
camel-api - Add API for advising routes We should likely add a nicer API for testing camel routes with the adviceWith functionality. Today you have to use a RouteReifier from camel-core. We should make a new API in camel-api and make it with a nicer name so its easier to understand and use.{code}        RouteReifier.adviceWith(context.getRouteDefinitions().get(0), context, new RouteBuilder() {            @Override            public void configure() throws Exception {                // intercept sending to mock:foo and do something else                interceptSendToEndpoint("mock:foo")                        .skipSendToOriginalEndpoint()                        .to("log:foo")                        .to("mock:advised");            }        });{code} New Feature camel-api - Add API for advising routes We should likely add a nicer API for testing camel routes with the adviceWith functionality. Today you have to use a RouteReifier from camel-core. We should make a new API in camel-api and make it with a nicer name so its easier to understand and use.{code}        RouteReifier.adviceWith(context.getRouteDefinitions().get(0), context, new RouteBuilder() {            @Override            public void configure() throws Exception {                // intercept sending to mock:foo and do something else                interceptSendToEndpoint("mock:foo")                        .skipSendToOriginalEndpoint()                        .to("log:foo")                        .to("mock:advised");            }        });{code}
Move rest component out of camel-core Create a new camel-rest component which has the rest component (needed when using rest-dsl, or using rest component directly etc). Task Move rest component out of camel-core Create a new camel-rest component which has the rest component (needed when using rest-dsl, or using rest component directly etc).
camel3 - build system - Packaging dataformat and language needs to include json metadata When we just depend on camel-support for custom dataformats and languages then they cant locate camel-core JAR which has model json metadata they need for enriching their json metadata.The camel-package-maven-plugin needs to find the camel-core JAR in another way now as its not on the classpath in the maven project. Task camel3 - build system - Packaging dataformat and language needs to include json metadata When we just depend on camel-support for custom dataformats and languages then they cant locate camel-core JAR which has model json metadata they need for enriching their json metadata.The camel-package-maven-plugin needs to find the camel-core JAR in another way now as its not on the classpath in the maven project.
Duplicate declaration of maven dependency in examples [WARNING][WARNING] Some problems were encountered while building the effective model for org.apache.camel.example:camel-example-cdi:jar:3.0.0-SNAPSHOT[WARNING] 'dependencies.dependency.(groupId:artifactId:type:classifier)' must be unique: org.apache.camel:camel-core:jar -> duplicate declaration of version (?) @ org.apache.camel.example:camel-example-cdi:[unknown-version], /Users/davsclaus/workspace/camel/examples/camel-example-cdi/pom.xml, line 61, column 17[WARNING][WARNING] Some problems were encountered while building the effective model for org.apache.camel.example:camel-example-cdi-cassandraql:jar:3.0.0-SNAPSHOT[WARNING] 'dependencies.dependency.(groupId:artifactId:type:classifier)' must be unique: org.apache.camel:camel-core:jar -> duplicate declaration of version (?) @ org.apache.camel.example:camel-example-cdi-cassandraql:[unknown-version], /Users/davsclaus/workspace/camel/examples/camel-example-cdi-cassandraql/pom.xml, line 64, column 17[WARNING][WARNING] It is highly recommended to fix these problems because they threaten the stability of your build.[WARNING][WARNING] For this reason, future Maven versions might no longer support building such malformed projects.[WARNING][INFO] -------------------------------------- Task Duplicate declaration of maven dependency in examples [WARNING][WARNING] Some problems were encountered while building the effective model for org.apache.camel.example:camel-example-cdi:jar:3.0.0-SNAPSHOT[WARNING] 'dependencies.dependency.(groupId:artifactId:type:classifier)' must be unique: org.apache.camel:camel-core:jar -> duplicate declaration of version (?) @ org.apache.camel.example:camel-example-cdi:[unknown-version], /Users/davsclaus/workspace/camel/examples/camel-example-cdi/pom.xml, line 61, column 17[WARNING][WARNING] Some problems were encountered while building the effective model for org.apache.camel.example:camel-example-cdi-cassandraql:jar:3.0.0-SNAPSHOT[WARNING] 'dependencies.dependency.(groupId:artifactId:type:classifier)' must be unique: org.apache.camel:camel-core:jar -> duplicate declaration of version (?) @ org.apache.camel.example:camel-example-cdi-cassandraql:[unknown-version], /Users/davsclaus/workspace/camel/examples/camel-example-cdi-cassandraql/pom.xml, line 64, column 17[WARNING][WARNING] It is highly recommended to fix these problems because they threaten the stability of your build.[WARNING][WARNING] For this reason, future Maven versions might no longer support building such malformed projects.[WARNING][INFO] --------------------------------------
camel3 - Components should not use XmlConverter directly There are a few components that uses XmlConverter directly like camel-cxf and camel-spring-ws. We should use XmlConverterHelper from camel-support if possible, or better yet the neutral TypeConverter API from camel-api. Task camel3 - Components should not use XmlConverter directly There are a few components that uses XmlConverter directly like camel-cxf and camel-spring-ws. We should use XmlConverterHelper from camel-support if possible, or better yet the neutral TypeConverter API from camel-api.
For Swagger, add an option whether to use X-Forward headers An earlier JIRA: CAMEL-12855 created an issue where the forwarded header could be used to set the "host" for Swagger. This overwrote the old behavior where one could specify a "hard-code" host in the RestConfiguration.Add an option to control whether these x-forward headers should be applied or not, to have the old behavior vs the new. (e.g. *useXForwardHeaders* = true/false)[~cibsen@e-ma.net], a couple of questions: # would the default be the new behavior (using the headers), or the old behavior (do not use the headers) ? # should the parameter turn on/off the entire X-FORWARD section... that is in [the setupXForwardedHeaders() here|https://github.com/apache/camel/blob/release/2.23.0/components/camel-swagger-java/src/main/java/org/apache/camel/swagger/RestSwaggerSupport.java#L358-L385] ? Improvement For Swagger, add an option whether to use X-Forward headers An earlier JIRA: CAMEL-12855 created an issue where the forwarded header could be used to set the "host" for Swagger. This overwrote the old behavior where one could specify a "hard-code" host in the RestConfiguration.Add an option to control whether these x-forward headers should be applied or not, to have the old behavior vs the new. (e.g. *useXForwardHeaders* = true/false)[~cibsen@e-ma.net], a couple of questions: # would the default be the new behavior (using the headers), or the old behavior (do not use the headers) ? # should the parameter turn on/off the entire X-FORWARD section... that is in [the setupXForwardedHeaders() here|https://github.com/apache/camel/blob/release/2.23.0/components/camel-swagger-java/src/main/java/org/apache/camel/swagger/RestSwaggerSupport.java#L358-L385] ?
camel3 - move xslt componet out of camel-core This requires a bit of shared xml code to be moved to camel-support. Task camel3 - move xslt componet out of camel-core This requires a bit of shared xml code to be moved to camel-support.
Create Cache Policy for routes Let's write a Policy for camel routes that can cache the "result" of a route and execute the route next time only if nothing is found in the cache. Related to cache DSL idea, but without DSL change: https://issues.apache.org/jira/browse/CAMEL-11114 In the first draft the CachePolicy would cache the Message Body by a key calculated via an Expression.Interface: * cachePolicy.setCacheManager( cacheManager ) - set the CacheManager. If not set, try lookup automatically. * cachePolicy.setCacheName ( name ) - Will use this cache from the CacheManager. If not set, we can use the route id by default. * cachePolicy.setKeyExpression( expression ) - Camel expression that is evaluated on the Exchange to determine the cache key. If it's found in the cache, the route is not executed and the cached value is set as Body. Otherwise the Message Body is added to the cache after the route with this key. An earlier related implementation: [https://gist.github.com/bszeti/552bf7a1f05a75fc2964a4ce7ce889b5] and how it can be used in a route: [https://gist.github.com/bszeti/4f855cd80cd69e3953ff990b0ae056a2]   New Feature Create Cache Policy for routes Let's write a Policy for camel routes that can cache the "result" of a route and execute the route next time only if nothing is found in the cache. Related to cache DSL idea, but without DSL change: https://issues.apache.org/jira/browse/CAMEL-11114 In the first draft the CachePolicy would cache the Message Body by a key calculated via an Expression.Interface: * cachePolicy.setCacheManager( cacheManager ) - set the CacheManager. If not set, try lookup automatically. * cachePolicy.setCacheName ( name ) - Will use this cache from the CacheManager. If not set, we can use the route id by default. * cachePolicy.setKeyExpression( expression ) - Camel expression that is evaluated on the Exchange to determine the cache key. If it's found in the cache, the route is not executed and the cached value is set as Body. Otherwise the Message Body is added to the cache after the route with this key. An earlier related implementation: [https://gist.github.com/bszeti/552bf7a1f05a75fc2964a4ce7ce889b5] and how it can be used in a route: [https://gist.github.com/bszeti/4f855cd80cd69e3953ff990b0ae056a2]  
camel3 - build system - camel-catalog should not warn for missing doc for inactive modules When we have removed deprecated modules in 3.x, then the folders stay in git when you switch branches.So we get this WARNs when building camel-catalog{code}[WARNING] 	Missing document detected: 40[WARNING] 		camel-bam[WARNING] 		camel-cache[WARNING] 		camel-castor[WARNING] 		camel-context[WARNING] 		camel-eclipse[WARNING] 		camel-elasticsearch[WARNING] 		camel-elasticsearch5[WARNING] 		camel-groovy-dsl[WARNING] 		camel-guice[WARNING] 		camel-hawtdb[WARNING] 		camel-hdfs[WARNING] 		camel-hessian[WARNING] 		camel-http[WARNING] 		camel-ibatis[WARNING] 		camel-javaspace[WARNING] 		camel-jira[WARNING] 		camel-josql[WARNING] 		camel-juel[WARNING] 		camel-jxpath[WARNING] 		camel-kestrel[WARNING] 		camel-krati[WARNING] 		camel-mina[WARNING] 		camel-mongodb[WARNING] 		camel-netty[WARNING] 		camel-netty-http[WARNING] 		camel-openshift[WARNING] 		camel-quartz[WARNING] 		camel-routebox[WARNING] 		camel-ruby[WARNING] 		camel-rx[WARNING] 		camel-scala[WARNING] 		camel-scr[WARNING] 		camel-servletlistener[WARNING] 		camel-swagger[WARNING] 		camel-testng[WARNING] 		camel-urlrewrite[WARNING] 		camel-xmlbeans[WARNING] 		camel-xmljson[WARNING] 		camel-xmlrpc[WARNING] 		camel-yql{code}We should make it detect that these are empty folders (has no pom.xml) and skip them. Task camel3 - build system - camel-catalog should not warn for missing doc for inactive modules When we have removed deprecated modules in 3.x, then the folders stay in git when you switch branches.So we get this WARNs when building camel-catalog{code}[WARNING] 	Missing document detected: 40[WARNING] 		camel-bam[WARNING] 		camel-cache[WARNING] 		camel-castor[WARNING] 		camel-context[WARNING] 		camel-eclipse[WARNING] 		camel-elasticsearch[WARNING] 		camel-elasticsearch5[WARNING] 		camel-groovy-dsl[WARNING] 		camel-guice[WARNING] 		camel-hawtdb[WARNING] 		camel-hdfs[WARNING] 		camel-hessian[WARNING] 		camel-http[WARNING] 		camel-ibatis[WARNING] 		camel-javaspace[WARNING] 		camel-jira[WARNING] 		camel-josql[WARNING] 		camel-juel[WARNING] 		camel-jxpath[WARNING] 		camel-kestrel[WARNING] 		camel-krati[WARNING] 		camel-mina[WARNING] 		camel-mongodb[WARNING] 		camel-netty[WARNING] 		camel-netty-http[WARNING] 		camel-openshift[WARNING] 		camel-quartz[WARNING] 		camel-routebox[WARNING] 		camel-ruby[WARNING] 		camel-rx[WARNING] 		camel-scala[WARNING] 		camel-scr[WARNING] 		camel-servletlistener[WARNING] 		camel-swagger[WARNING] 		camel-testng[WARNING] 		camel-urlrewrite[WARNING] 		camel-xmlbeans[WARNING] 		camel-xmljson[WARNING] 		camel-xmlrpc[WARNING] 		camel-yql{code}We should make it detect that these are empty folders (has no pom.xml) and skip them.
Remove camel-script and make camel-javascript scripting api/jsr is also deprecated in the jdk and to be removed in the futurewe will remove it for camel 3and deprecate it in 2.xfor camel k and using javascript i think they are doing something custom, and will can make a new camel-javascript language for that purpose solelyall the other scripting languages was also a security vulnerability as well Task Remove camel-script and make camel-javascript scripting api/jsr is also deprecated in the jdk and to be removed in the futurewe will remove it for camel 3and deprecate it in 2.xfor camel k and using javascript i think they are doing something custom, and will can make a new camel-javascript language for that purpose solelyall the other scripting languages was also a security vulnerability as well
Move file component out of camel core There is some file cluster that uses some abstract cluster stuff which we need to move to camel-support Task Move file component out of camel core There is some file cluster that uses some abstract cluster stuff which we need to move to camel-support
Move dataset component out of camel-core We should likely put mock, dataset and test components in the same JAR as dataset and test extends mock component. So its easier they are in the same JAR.Also we already have camel-test for junit testing, so the test component would conflict with camel-test.So if we call it camel-mock JAR then we have a free name to use. Task Move dataset component out of camel-core We should likely put mock, dataset and test components in the same JAR as dataset and test extends mock component. So its easier they are in the same JAR.Also we already have camel-test for junit testing, so the test component would conflict with camel-test.So if we call it camel-mock JAR then we have a free name to use.
Move camel-dataformat out of camel-core for dataformat component we need to move MarshalProcessor / UnmarshalProcessor to camel-support first to have it in a public api Task Move camel-dataformat out of camel-core for dataformat component we need to move MarshalProcessor / UnmarshalProcessor to camel-support first to have it in a public api
build system - Automate list of components in parent and apache-camel poms We need to add manually all the camel JARs in the parent/pom and apache-camel poms and the include file as well. As we get more and more components and also -starter JARs we should automate this. Task build system - Automate list of components in parent and apache-camel poms We need to add manually all the camel JARs in the parent/pom and apache-camel poms and the include file as well. As we get more and more components and also -starter JARs we should automate this.
Upgrade to latest Guava version for Swagger dependency Guava up to ver 24.1 has a denial of service vulnerability.Upgrade the camel-swagger dependency on Guava to a newer version.Would be nice if this could go in the 2.23.x version and above  Improvement Upgrade to latest Guava version for Swagger dependency Guava up to ver 24.1 has a denial of service vulnerability.Upgrade the camel-swagger dependency on Guava to a newer version.Would be nice if this could go in the 2.23.x version and above 
doc - pipes and filters should be pipeline-eip The tooling report this as a missing EIP doc page.It should just be renamed to pipeline-eip Task doc - pipes and filters should be pipeline-eip The tooling report this as a missing EIP doc page.It should just be renamed to pipeline-eip
component docs - Generated description with simple language should include curly brackets For example the idempotentKey athttps://github.com/apache/camel/blob/master/camel-core/src/main/docs/file-component.adocShould include{code}${file:name}-...{code}Where the curly brackets are missing. Task component docs - Generated description with simple language should include curly brackets For example the idempotentKey athttps://github.com/apache/camel/blob/master/camel-core/src/main/docs/file-component.adocShould include{code}${file:name}-...{code}Where the curly brackets are missing.
FileWatcherReloadStrategy - Use file component instead of JDK FileWatcher The FileWatcherReloadStrategy keeps failing on various platforms and CI server.Lets use Camel's file component instead (to eat our own dog food) Improvement FileWatcherReloadStrategy - Use file component instead of JDK FileWatcher The FileWatcherReloadStrategy keeps failing on various platforms and CI server.Lets use Camel's file component instead (to eat our own dog food)
camel3 - build system - Component level metadata is missing In 2.x we used to have component level metadata but in 3.x they are not thereFor example testManagedCamelContextExplainComponentModel fails this test. Task camel3 - build system - Component level metadata is missing In 2.x we used to have component level metadata but in 3.x they are not thereFor example testManagedCamelContextExplainComponentModel fails this test.
camel-hystrix - Do not fallback on HystrixBadRequestException See SOhttps://stackoverflow.com/questions/54151657/camel-hystrix-eip-ignoreexceptions-to-prevent-call-to-fallbackAnd the javadoc athttps://netflix.github.io/Hystrix/javadoc/com/netflix/hystrix/exception/HystrixBadRequestException.html Improvement camel-hystrix - Do not fallback on HystrixBadRequestException See SOhttps://stackoverflow.com/questions/54151657/camel-hystrix-eip-ignoreexceptions-to-prevent-call-to-fallbackAnd the javadoc athttps://netflix.github.io/Hystrix/javadoc/com/netflix/hystrix/exception/HystrixBadRequestException.html
camel-zipfile and camel-tarfile - ZipIterator and TarIterator issue There is a little problem with hasNext vs next contract so they dont behave correctly with the EIPs such as splitter with the 3.0 refactored code. Task camel-zipfile and camel-tarfile - ZipIterator and TarIterator issue There is a little problem with hasNext vs next contract so they dont behave correctly with the EIPs such as splitter with the 3.0 refactored code.
camel3 - build system - Reduce maven plugins not needed to run We can look at reducing some of the maven goals that runs during building components to reduce the burden on maven and speedup the build a bit.- dont run enforcer plugin- dont run maven site plugin- only run osgi plugin on core and components- skip running integration tests if fastinstall profile enabled on some modules- ... Task camel3 - build system - Reduce maven plugins not needed to run We can look at reducing some of the maven goals that runs during building components to reduce the burden on maven and speedup the build a bit.- dont run enforcer plugin- dont run maven site plugin- only run osgi plugin on core and components- skip running integration tests if fastinstall profile enabled on some modules- ...
camel-restdsl-swagger-plugin - Skip running integration tests with -P fastinstall When runningmvn clean install -P fastinstallThen the integration tests are run in this module and they take 40+ sec to run. It would be nice to skip this so the build is quicker in fast install mode{code}[INFO] --- maven-invoker-plugin:3.1.0:integration-test (integration-test) @ camel-restdsl-swagger-plugin ---[INFO] Building: simple-dto/pom.xml[INFO] run post-build script verify.groovy[INFO]           simple-dto/pom.xml ............................... SUCCESS (22.3 s)[INFO] Building: simple-xml-dto/pom.xml[INFO] run post-build script verify.groovy[INFO]           simple-xml-dto/pom.xml ........................... SUCCESS (8.5 s)[INFO] Building: simple-xml/pom.xml[INFO] run post-build script verify.groovy[INFO]           simple-xml/pom.xml ............................... SUCCESS (4.8 s)[INFO] Building: simple/pom.xml[INFO] run post-build script verify.groovy[INFO]           simple/pom.xml ................................... SUCCESS (2.9 s)[INFO] Building: customized/pom.xml[INFO] run post-build script verify.groovy[INFO]           customized/pom.xml ............................... SUCCESS (3.3 s)[INFO][INFO] --- maven-invoker-plugin:3.1.0:verify (integration-test) @ camel-restdsl-swagger-plugin ---[INFO] -------------------------------------------------[INFO] Build Summary:[INFO]   Passed: 5, Failed: 0, Errors: 0, Skipped: 0[INFO] -------------------------------------------------{code} Task camel-restdsl-swagger-plugin - Skip running integration tests with -P fastinstall When runningmvn clean install -P fastinstallThen the integration tests are run in this module and they take 40+ sec to run. It would be nice to skip this so the build is quicker in fast install mode{code}[INFO] --- maven-invoker-plugin:3.1.0:integration-test (integration-test) @ camel-restdsl-swagger-plugin ---[INFO] Building: simple-dto/pom.xml[INFO] run post-build script verify.groovy[INFO]           simple-dto/pom.xml ............................... SUCCESS (22.3 s)[INFO] Building: simple-xml-dto/pom.xml[INFO] run post-build script verify.groovy[INFO]           simple-xml-dto/pom.xml ........................... SUCCESS (8.5 s)[INFO] Building: simple-xml/pom.xml[INFO] run post-build script verify.groovy[INFO]           simple-xml/pom.xml ............................... SUCCESS (4.8 s)[INFO] Building: simple/pom.xml[INFO] run post-build script verify.groovy[INFO]           simple/pom.xml ................................... SUCCESS (2.9 s)[INFO] Building: customized/pom.xml[INFO] run post-build script verify.groovy[INFO]           customized/pom.xml ............................... SUCCESS (3.3 s)[INFO][INFO] --- maven-invoker-plugin:3.1.0:verify (integration-test) @ camel-restdsl-swagger-plugin ---[INFO] -------------------------------------------------[INFO] Build Summary:[INFO]   Passed: 5, Failed: 0, Errors: 0, Skipped: 0[INFO] -------------------------------------------------{code}
camel3 - build system needs to generate component.properties We now generate more of the meta files in the META-INF/services folder. But the JARs from 2.x vs 3.0 is not exactly the same.The component.properties dataformat.properties language.properties files is currently not being generated.Some of our tooling depends on that these files are there.For example the camel-catalog is not correct, try to compare its 2.x JAR vs 3.0 JAR, and you can then find out much more what is wrong currently with the 3.0 branch. Task camel3 - build system needs to generate component.properties We now generate more of the meta files in the META-INF/services folder. But the JARs from 2.x vs 3.0 is not exactly the same.The component.properties dataformat.properties language.properties files is currently not being generated.Some of our tooling depends on that these files are there.For example the camel-catalog is not correct, try to compare its 2.x JAR vs 3.0 JAR, and you can then find out much more what is wrong currently with the 3.0 branch.
camel-core - File producer should by default not allow writing files to directories outside its starting directory For example{code:xml}<from uri="file:src/test/resources/data?noop=true"/><setHeader headerName="CamelFileName">    <simple>../../${file:name}</simple></setHeader><to uri="file:target/results"/>{code}Can write the file outside the target/results folder. We should not allow this by default to be more security friendly. We should add a new option (maybe name it jailStartingDirectory or allowWriteOutsideStartingDirectory) or some better name Improvement camel-core - File producer should by default not allow writing files to directories outside its starting directory For example{code:xml}<from uri="file:src/test/resources/data?noop=true"/><setHeader headerName="CamelFileName">    <simple>../../${file:name}</simple></setHeader><to uri="file:target/results"/>{code}Can write the file outside the target/results folder. We should not allow this by default to be more security friendly. We should add a new option (maybe name it jailStartingDirectory or allowWriteOutsideStartingDirectory) or some better name
Add the possibility to disable the invocation of ModelHelper.dumpModelAsXml() during testing Add the possibility to disable the invocation of {{ModelHelper.dumpModelAsXml()}}. This is particularly disturbing for Camel contexts with a lot of route definitions as this uses a lot of processing time and the information is only used for log output.Actual use in 2.x in {{RouteDefinition.java}}:{code:java|title=RouteDefinition.java}String beforeAsXml = ModelHelper.dumpModelAsXml(camelContext, this);...String afterAsXml = ModelHelper.dumpModelAsXml(camelContext, merged);log.info("Adviced route before/after as XML:\n{}\n{}", beforeAsXml, afterAsXml);{code}In 2.X this should be optimized in {{RouteDefinition.java}}, in 3.X in {{RouteReifier.java}}.Possible solution: Add {{log.isInfoEnabled{}}} guard.  Improvement Add the possibility to disable the invocation of ModelHelper.dumpModelAsXml() during testing Add the possibility to disable the invocation of {{ModelHelper.dumpModelAsXml()}}. This is particularly disturbing for Camel contexts with a lot of route definitions as this uses a lot of processing time and the information is only used for log output.Actual use in 2.x in {{RouteDefinition.java}}:{code:java|title=RouteDefinition.java}String beforeAsXml = ModelHelper.dumpModelAsXml(camelContext, this);...String afterAsXml = ModelHelper.dumpModelAsXml(camelContext, merged);log.info("Adviced route before/after as XML:\n{}\n{}", beforeAsXml, afterAsXml);{code}In 2.X this should be optimized in {{RouteDefinition.java}}, in 3.X in {{RouteReifier.java}}.Possible solution: Add {{log.isInfoEnabled{}}} guard. 
camel-core - test failure: org.apache.camel.impl.FileWatcherReloadStrategyTest. [INFO] Running org.apache.camel.impl.FileWatcherReloadStrategyTest[ERROR] Tests run: 7, Failures: 0, Errors: 6, Skipped: 0, Time elapsed: 123.022 s <<< FAILURE! - in org.apache.camel.impl.FileWatcherReloadStrategyTest[ERROR] testUpdateXmlRoute(org.apache.camel.impl.FileWatcherReloadStrategyTest) Time elapsed: 20.529 s <<< ERROR!org.awaitility.core.ConditionTimeoutException: Assertion condition defined as a lambda expression in org.apache.camel.impl.FileWatcherReloadStrategyTest expected:<1> but was:<0> within 20 seconds. at org.apache.camel.impl.FileWatcherReloadStrategyTest.testUpdateXmlRoute(FileWatcherReloadStrategyTest.java:166)Caused by: java.lang.AssertionError: expected:<1> but was:<0> at org.apache.camel.impl.FileWatcherReloadStrategyTest.lambda$testUpdateXmlRoute$1(FileWatcherReloadStrategyTest.java:166)[ERROR] testAddNewRoute(org.apache.camel.impl.FileWatcherReloadStrategyTest) Time elapsed: 20.058 s <<< ERROR!org.awaitility.core.ConditionTimeoutException: Assertion condition defined as a lambda expression in org.apache.camel.impl.FileWatcherReloadStrategyTest expected:<1> but was:<0> within 20 seconds. at org.apache.camel.impl.FileWatcherReloadStrategyTest.testAddNewRoute(FileWatcherReloadStrategyTest.java:71)Caused by: java.lang.AssertionError: expected:<1> but was:<0> at org.apache.camel.impl.FileWatcherReloadStrategyTest.lambda$testAddNewRoute$0(FileWatcherReloadStrategyTest.java:71)[ERROR] testUpdateXmlRoute(org.apache.camel.impl.FileWatcherReloadStrategyTest) Time elapsed: 20.078 s <<< ERROR!org.awaitility.core.ConditionTimeoutException: Assertion condition defined as a lambda expression in org.apache.camel.impl.FileWatcherReloadStrategyTest expected:<1> but was:<0> within 20 seconds. at org.apache.camel.impl.FileWatcherReloadStrategyTest.testUpdateXmlRoute(FileWatcherReloadStrategyTest.java:166)Caused by: java.lang.AssertionError: expected:<1> but was:<0> at org.apache.camel.impl.FileWatcherReloadStrategyTest.lambda$testUpdateXmlRoute$1(FileWatcherReloadStrategyTest.java:166)[ERROR] testAddNewRoute(org.apache.camel.impl.FileWatcherReloadStrategyTest) Time elapsed: 20.067 s <<< ERROR!org.awaitility.core.ConditionTimeoutException: Assertion condition defined as a lambda expression in org.apache.camel.impl.FileWatcherReloadStrategyTest expected:<1> but was:<0> within 20 seconds. at org.apache.camel.impl.FileWatcherReloadStrategyTest.testAddNewRoute(FileWatcherReloadStrategyTest.java:71)Caused by: java.lang.AssertionError: expected:<1> but was:<0> at org.apache.camel.impl.FileWatcherReloadStrategyTest.lambda$testAddNewRoute$0(FileWatcherReloadStrategyTest.java:71)[ERROR] testUpdateXmlRoute(org.apache.camel.impl.FileWatcherReloadStrategyTest) Time elapsed: 20.095 s <<< ERROR!org.awaitility.core.ConditionTimeoutException: Assertion condition defined as a lambda expression in org.apache.camel.impl.FileWatcherReloadStrategyTest expected:<1> but was:<0> within 20 seconds. at org.apache.camel.impl.FileWatcherReloadStrategyTest.testUpdateXmlRoute(FileWatcherReloadStrategyTest.java:166)Caused by: java.lang.AssertionError: expected:<1> but was:<0> at org.apache.camel.impl.FileWatcherReloadStrategyTest.lambda$testUpdateXmlRoute$1(FileWatcherReloadStrategyTest.java:166)[ERROR] testAddNewRoute(org.apache.camel.impl.FileWatcherReloadStrategyTest) Time elapsed: 20.026 s <<< ERROR!org.awaitility.core.ConditionTimeoutException: Assertion condition defined as a lambda expression in org.apache.camel.impl.FileWatcherReloadStrategyTest expected:<1> but was:<0> within 20 seconds. at org.apache.camel.impl.FileWatcherReloadStrategyTest.testAddNewRoute(FileWatcherReloadStrategyTest.java:71)Caused by: java.lang.AssertionError: expected:<1> but was:<0> at org.apache.camel.impl.FileWatcherReloadStrategyTest.lambda$testAddNewRoute$0(FileWatcherReloadStrategyTest.java:71)[INFO][INFO] Results:[INFO][ERROR] Errors:[ERROR] org.apache.camel.impl.FileWatcherReloadStrategyTest.testAddNewRoute(org.apache.camel.impl.FileWatcherReloadStrategyTest)[ERROR] Run 1: FileWatcherReloadStrategyTest.testAddNewRoute:71 » ConditionTimeout Assertion ...[ERROR] Run 2: FileWatcherReloadStrategyTest.testAddNewRoute:71 » ConditionTimeout Assertion ...[ERROR] Run 3: FileWatcherReloadStrategyTest.testAddNewRoute:71 » ConditionTimeout Assertion ...[INFO][ERROR] org.apache.camel.impl.FileWatcherReloadStrategyTest.testUpdateXmlRoute(org.apache.camel.impl.FileWatcherReloadStrategyTest)[ERROR] Run 1: FileWatcherReloadStrategyTest.testUpdateXmlRoute:166 » ConditionTimeout Assert...[ERROR] Run 2: FileWatcherReloadStrategyTest.testUpdateXmlRoute:166 » ConditionTimeout Assert...[ERROR] Run 3: FileWatcherReloadStrategyTest.testUpdateXmlRoute:166 » ConditionTimeout Assert...[INFO][INFO][ERROR] Tests run: 3, Failures: 0, Errors: 2, Skipped: 0 Test camel-core - test failure: org.apache.camel.impl.FileWatcherReloadStrategyTest. [INFO] Running org.apache.camel.impl.FileWatcherReloadStrategyTest[ERROR] Tests run: 7, Failures: 0, Errors: 6, Skipped: 0, Time elapsed: 123.022 s <<< FAILURE! - in org.apache.camel.impl.FileWatcherReloadStrategyTest[ERROR] testUpdateXmlRoute(org.apache.camel.impl.FileWatcherReloadStrategyTest) Time elapsed: 20.529 s <<< ERROR!org.awaitility.core.ConditionTimeoutException: Assertion condition defined as a lambda expression in org.apache.camel.impl.FileWatcherReloadStrategyTest expected:<1> but was:<0> within 20 seconds. at org.apache.camel.impl.FileWatcherReloadStrategyTest.testUpdateXmlRoute(FileWatcherReloadStrategyTest.java:166)Caused by: java.lang.AssertionError: expected:<1> but was:<0> at org.apache.camel.impl.FileWatcherReloadStrategyTest.lambda$testUpdateXmlRoute$1(FileWatcherReloadStrategyTest.java:166)[ERROR] testAddNewRoute(org.apache.camel.impl.FileWatcherReloadStrategyTest) Time elapsed: 20.058 s <<< ERROR!org.awaitility.core.ConditionTimeoutException: Assertion condition defined as a lambda expression in org.apache.camel.impl.FileWatcherReloadStrategyTest expected:<1> but was:<0> within 20 seconds. at org.apache.camel.impl.FileWatcherReloadStrategyTest.testAddNewRoute(FileWatcherReloadStrategyTest.java:71)Caused by: java.lang.AssertionError: expected:<1> but was:<0> at org.apache.camel.impl.FileWatcherReloadStrategyTest.lambda$testAddNewRoute$0(FileWatcherReloadStrategyTest.java:71)[ERROR] testUpdateXmlRoute(org.apache.camel.impl.FileWatcherReloadStrategyTest) Time elapsed: 20.078 s <<< ERROR!org.awaitility.core.ConditionTimeoutException: Assertion condition defined as a lambda expression in org.apache.camel.impl.FileWatcherReloadStrategyTest expected:<1> but was:<0> within 20 seconds. at org.apache.camel.impl.FileWatcherReloadStrategyTest.testUpdateXmlRoute(FileWatcherReloadStrategyTest.java:166)Caused by: java.lang.AssertionError: expected:<1> but was:<0> at org.apache.camel.impl.FileWatcherReloadStrategyTest.lambda$testUpdateXmlRoute$1(FileWatcherReloadStrategyTest.java:166)[ERROR] testAddNewRoute(org.apache.camel.impl.FileWatcherReloadStrategyTest) Time elapsed: 20.067 s <<< ERROR!org.awaitility.core.ConditionTimeoutException: Assertion condition defined as a lambda expression in org.apache.camel.impl.FileWatcherReloadStrategyTest expected:<1> but was:<0> within 20 seconds. at org.apache.camel.impl.FileWatcherReloadStrategyTest.testAddNewRoute(FileWatcherReloadStrategyTest.java:71)Caused by: java.lang.AssertionError: expected:<1> but was:<0> at org.apache.camel.impl.FileWatcherReloadStrategyTest.lambda$testAddNewRoute$0(FileWatcherReloadStrategyTest.java:71)[ERROR] testUpdateXmlRoute(org.apache.camel.impl.FileWatcherReloadStrategyTest) Time elapsed: 20.095 s <<< ERROR!org.awaitility.core.ConditionTimeoutException: Assertion condition defined as a lambda expression in org.apache.camel.impl.FileWatcherReloadStrategyTest expected:<1> but was:<0> within 20 seconds. at org.apache.camel.impl.FileWatcherReloadStrategyTest.testUpdateXmlRoute(FileWatcherReloadStrategyTest.java:166)Caused by: java.lang.AssertionError: expected:<1> but was:<0> at org.apache.camel.impl.FileWatcherReloadStrategyTest.lambda$testUpdateXmlRoute$1(FileWatcherReloadStrategyTest.java:166)[ERROR] testAddNewRoute(org.apache.camel.impl.FileWatcherReloadStrategyTest) Time elapsed: 20.026 s <<< ERROR!org.awaitility.core.ConditionTimeoutException: Assertion condition defined as a lambda expression in org.apache.camel.impl.FileWatcherReloadStrategyTest expected:<1> but was:<0> within 20 seconds. at org.apache.camel.impl.FileWatcherReloadStrategyTest.testAddNewRoute(FileWatcherReloadStrategyTest.java:71)Caused by: java.lang.AssertionError: expected:<1> but was:<0> at org.apache.camel.impl.FileWatcherReloadStrategyTest.lambda$testAddNewRoute$0(FileWatcherReloadStrategyTest.java:71)[INFO][INFO] Results:[INFO][ERROR] Errors:[ERROR] org.apache.camel.impl.FileWatcherReloadStrategyTest.testAddNewRoute(org.apache.camel.impl.FileWatcherReloadStrategyTest)[ERROR] Run 1: FileWatcherReloadStrategyTest.testAddNewRoute:71 >> ConditionTimeout Assertion ...[ERROR] Run 2: FileWatcherReloadStrategyTest.testAddNewRoute:71 >> ConditionTimeout Assertion ...[ERROR] Run 3: FileWatcherReloadStrategyTest.testAddNewRoute:71 >> ConditionTimeout Assertion ...[INFO][ERROR] org.apache.camel.impl.FileWatcherReloadStrategyTest.testUpdateXmlRoute(org.apache.camel.impl.FileWatcherReloadStrategyTest)[ERROR] Run 1: FileWatcherReloadStrategyTest.testUpdateXmlRoute:166 >> ConditionTimeout Assert...[ERROR] Run 2: FileWatcherReloadStrategyTest.testUpdateXmlRoute:166 >> ConditionTimeout Assert...[ERROR] Run 3: FileWatcherReloadStrategyTest.testUpdateXmlRoute:166 >> ConditionTimeout Assert...[INFO][INFO][ERROR] Tests run: 3, Failures: 0, Errors: 2, Skipped: 0
camel-swagger-java - Should default use scheme from rest-dsl configuration in swagger doc Because http is default then we have not noticed before. But if you use https as the scheme in the rest-dsl for the rest service then the swagger doc generated is outputting http by default. We should use the scheme setting from the rest-dsl out of the box.You can configure it explicit via				.apiProperty("schemes", "https") Improvement camel-swagger-java - Should default use scheme from rest-dsl configuration in swagger doc Because http is default then we have not noticed before. But if you use https as the scheme in the rest-dsl for the rest service then the swagger doc generated is outputting http by default. We should use the scheme setting from the rest-dsl out of the box.You can configure it explicit via				.apiProperty("schemes", "https")
camel-core - File read lock changed - If file gets deleted then break out loop See SOhttps://stackoverflow.com/questions/53865940/apache-camel-route-hangs-when-file-is-deleted-during-processing?noredirect=1#comment94587192_53865940So if the target file gets deleted during the check interval and you have timeout = 0, then it will keep looping. So we should add a check if the file still exists in the looping. Improvement camel-core - File read lock changed - If file gets deleted then break out loop See SOhttps://stackoverflow.com/questions/53865940/apache-camel-route-hangs-when-file-is-deleted-during-processing?noredirect=1#comment94587192_53865940So if the target file gets deleted during the check interval and you have timeout = 0, then it will keep looping. So we should add a check if the file still exists in the looping.
Remove camel-example-swagger-xml This example downloads from 3rd party repo - lets avoid this and we have 100 other examples already. Task Remove camel-example-swagger-xml This example downloads from 3rd party repo - lets avoid this and we have 100 other examples already.
Swagger does not work if JMX is disabled Swagger returns 402 No Content if jmx is disabled.How to reproduce:Add following code to main method of [Application|https://github.com/apache/camel/blob/master/examples/camel-example-spring-boot-rest-swagger/src/main/java/org/apache/camel/example/springboot/Application.java] class{{System.setProperty("org.apache.camel.jmx.disabled", "true");}}  Improvement Swagger does not work if JMX is disabled Swagger returns 402 No Content if jmx is disabled.How to reproduce:Add following code to main method of [Application|https://github.com/apache/camel/blob/master/examples/camel-example-spring-boot-rest-swagger/src/main/java/org/apache/camel/example/springboot/Application.java] class{{System.setProperty("org.apache.camel.jmx.disabled", "true");}} 
camel-spring-boot - load multiple route xml files  When  I use SpringDSL , i want to load two route files For Example route1.xml and route2.xmlIf I put two files in same directory like below , it is workingcamel.springboot.xmlRoutes: file :directory/*.xml  If I put two files into different directories , it does not workcamel.springboot.xmlRoutes: [file:directory1/route1.xml|file:///directory1/route1.xml] , directory2/route2.xmlCould you please implement this feature?Thanks New Feature camel-spring-boot - load multiple route xml files  When  I use SpringDSL , i want to load two route files For Example route1.xml and route2.xmlIf I put two files in same directory like below , it is workingcamel.springboot.xmlRoutes: file :directory/*.xml  If I put two files into different directories , it does not workcamel.springboot.xmlRoutes: [file:directory1/route1.xml|file:///directory1/route1.xml] , directory2/route2.xmlCould you please implement this feature?Thanks
Deprecate camel-script With the release of Java 11, Nashorn is deprecated, and will likely be removed from the JDK at a later time.[9] The GraalVM was suggested as a workaround.-> https://en.wikipedia.org/wiki/Nashorn_(JavaScript_engine)We have already deprecated these other scripting languages like python, php etc (https://github.com/apache/camel/blob/master/components/readme.adoc#expression-languages).And groovy also dont recommend using camel-script by groovy directly, which you can do via camel-groovyhttp://docs.groovy-lang.org/latest/html/documentation/guide-integrating.html#jsr223 Task Deprecate camel-script With the release of Java 11, Nashorn is deprecated, and will likely be removed from the JDK at a later time.[9] The GraalVM was suggested as a workaround.-> https://en.wikipedia.org/wiki/Nashorn_(JavaScript_engine)We have already deprecated these other scripting languages like python, php etc (https://github.com/apache/camel/blob/master/components/readme.adoc#expression-languages).And groovy also dont recommend using camel-script by groovy directly, which you can do via camel-groovyhttp://docs.groovy-lang.org/latest/html/documentation/guide-integrating.html#jsr223
camel-properties : fall-back to env vars The camel properties component at the moment fall-back to system properties but to improve cloud integration, it should also fall-back to environment variables Improvement camel-properties : fall-back to env vars The camel properties component at the moment fall-back to system properties but to improve cloud integration, it should also fall-back to environment variables
Route coverage: specify coverage to fail on currently, there is an option to fail the build if the coverage does not reach 100%.it would be nice to be able to specify the level of coverage wanted as a parameter of the maven plugin Improvement Route coverage: specify coverage to fail on currently, there is an option to fail the build if the coverage does not reach 100%.it would be nice to be able to specify the level of coverage wanted as a parameter of the maven plugin
FTP endpoint with 'localWorkDirectory' considers File Consumer's 'noop' option [https://camel.apache.org/ftp2.html] reads:{quote}See [File|https://camel.apache.org/file2.html] for more options as all the options from [File|https://camel.apache.org/file2.html] is inherited.{quote} and in *Using Local Work Directory*:{quote}And finally, when the Exchange is complete the local file is deleted.{quote} [https://camel.apache.org/file2.html] reads:{quote}|{{noop}}|{{false}}|If *{{true}}*, the file is not moved or deleted in any way.|{quote}I have a use case where I'd need the file transferred to \{{localWorkDirectory}} to stay there. Otherwise I have to change \{{localWorkDirectory}} to something else and add a Producer endpoint to my route which copies the file to the intended directory (i.e. the former \{{localWorkDirectory}}), which is inconvenient with GiB-size files. New Feature FTP endpoint with 'localWorkDirectory' considers File Consumer's 'noop' option [https://camel.apache.org/ftp2.html] reads:{quote}See [File|https://camel.apache.org/file2.html] for more options as all the options from [File|https://camel.apache.org/file2.html] is inherited.{quote} and in *Using Local Work Directory*:{quote}And finally, when the Exchange is complete the local file is deleted.{quote} [https://camel.apache.org/file2.html] reads:{quote}|{{noop}}|{{false}}|If *{{true}}*, the file is not moved or deleted in any way.|{quote}I have a use case where I'd need the file transferred to \{{localWorkDirectory}} to stay there. Otherwise I have to change \{{localWorkDirectory}} to something else and add a Producer endpoint to my route which copies the file to the intended directory (i.e. the former \{{localWorkDirectory}}), which is inconvenient with GiB-size files.
Allow Endpoint to set the key that ProducerCache uses ProducerCache is heavily tied to Endpoint URIs. Using the Endpoint URI as the key to the cache does not allow for the creation of Endpoints with the same URI but different configurations. For example, using a RecipientList to call the same SOAP endpoint but with different SSL certificates isn't currently possible. As the URI is always the same.the ProducerCache will always use the first Endpoint it added to the map even if multiple Endpoints are added to the CamelContext with different keys.Adding getProducerCacheKey & setProducerCacheKey methods to the Endpoint interface would allow for setting the key programmatically. ProducerCache.doGetProducer would use the getProducerCacheKey method instead of getEndpointUri.DefaultEndpoint would have a new member variable producerCacheKey and could implement the getter such that if the producerCacheKey member was not set it would return getEndpointUri() Improvement Allow Endpoint to set the key that ProducerCache uses ProducerCache is heavily tied to Endpoint URIs. Using the Endpoint URI as the key to the cache does not allow for the creation of Endpoints with the same URI but different configurations. For example, using a RecipientList to call the same SOAP endpoint but with different SSL certificates isn't currently possible. As the URI is always the same.the ProducerCache will always use the first Endpoint it added to the map even if multiple Endpoints are added to the CamelContext with different keys.Adding getProducerCacheKey & setProducerCacheKey methods to the Endpoint interface would allow for setting the key programmatically. ProducerCache.doGetProducer would use the getProducerCacheKey method instead of getEndpointUri.DefaultEndpoint would have a new member variable producerCacheKey and could implement the getter such that if the producerCacheKey member was not set it would return getEndpointUri()
camel-catalog: provide information about active/passive endpoints In Camel K we need to distinguish active from passive endpoints in order to determine when a integration can be scaled down to 0. E.g. * a "timer" (start) endpoint is *active*, because it needs to have a JVM always running and do something at each interval * a "jms" (start) endpoint is *active* because it needs to establish a connection to the broker and keep it alive * a "direct" or "seda" endpoint is *passive*, because they do something when they receive an exchange from another route * a "undertow" (start) endpoint is *passive*, because it does nothing until somebody calls it from an +external+ service (http based endpoints can all be considered passive in Knative+CamelK) We should add this information to the catalog. Now I've embedded it in Camel K. Task camel-catalog: provide information about active/passive endpoints In Camel K we need to distinguish active from passive endpoints in order to determine when a integration can be scaled down to 0. E.g. * a "timer" (start) endpoint is *active*, because it needs to have a JVM always running and do something at each interval * a "jms" (start) endpoint is *active* because it needs to establish a connection to the broker and keep it alive * a "direct" or "seda" endpoint is *passive*, because they do something when they receive an exchange from another route * a "undertow" (start) endpoint is *passive*, because it does nothing until somebody calls it from an +external+ service (http based endpoints can all be considered passive in Knative+CamelK) We should add this information to the catalog. Now I've embedded it in Camel K.
deprecate the Camel maven archetypes ts these maven archetypes, we are considering to deprecate for 2.x and remove in 3.xhttps://github.com/apache/camel/tree/master/archetypes Task deprecate the Camel maven archetypes ts these maven archetypes, we are considering to deprecate for 2.x and remove in 3.xhttps://github.com/apache/camel/tree/master/archetypes
Stream Caching Cipher is misspelled as chiper The typo is in the docs here:https://camel.apache.org/stream-caching.htmlAs well as {{org.apache.camel.spring.boot.CamelConfigurationProperties}}I'm guessing it is in other places as well. Task Stream Caching Cipher is misspelled as chiper The typo is in the docs here:https://camel.apache.org/stream-caching.htmlAs well as {{org.apache.camel.spring.boot.CamelConfigurationProperties}}I'm guessing it is in other places as well.
Error handler - Counter and option to log when a retry became success Asked on twitterhttps://twitter.com/luistrigueiros/status/1053039644093366272It may be good to have a way to know if a message that has first failed and then with retries from the error handler then became succesful. We should be able to see this with- counter in the mbean- log message in the logs, option to configure the logging level. Improvement Error handler - Counter and option to log when a retry became success Asked on twitterhttps://twitter.com/luistrigueiros/status/1053039644093366272It may be good to have a way to know if a message that has first failed and then with retries from the error handler then became succesful. We should be able to see this with- counter in the mbean- log message in the logs, option to configure the logging level.
When no route is defined, mention in log that it is the reason why it shutdowns the Camel Context automatically When starting a project and that no Camel route are found, the camel context is shutdown immediately.it would be nice to have a trace  in log mentioning the reason.maybe also refer to some documentation on how to configure routes? Improvement When no route is defined, mention in log that it is the reason why it shutdowns the Camel Context automatically When starting a project and that no Camel route are found, the camel context is shutdown immediately.it would be nice to have a trace  in log mentioning the reason.maybe also refer to some documentation on how to configure routes?
Camel project generated from spring initalzr is shutdowning immediately after start - go to https://start.spring.io/- let default values for "generate a Maven project with Java and Spring Boot 2.0.5"- add Camel dependencies- expand zipped project- launch mvn spring-boot:run- Camel is started and then shutdowned immediately instead of letting the application running{noformat}C:\ws\workingDirectoryForTest\test-project-generated-from-start-spring-io\demo>mvn spring-boot:run[INFO] Scanning for projects...[INFO][INFO] ------------------------------------------------------------------------[INFO] Building demo 0.0.1-SNAPSHOT[INFO] ------------------------------------------------------------------------[INFO][INFO] >>> spring-boot-maven-plugin:2.0.5.RELEASE:run (default-cli) > test-compile @ demo >>>[INFO][INFO] --- maven-resources-plugin:3.0.2:resources (default-resources) @ demo ---[INFO] Using 'UTF-8' encoding to copy filtered resources.[INFO] Copying 1 resource[INFO] Copying 0 resource[INFO][INFO] --- maven-compiler-plugin:3.7.0:compile (default-compile) @ demo ---[INFO] Changes detected - recompiling the module![INFO] Compiling 1 source file to C:\ws\workingDirectoryForTest\test-project-generated-from-start-spring-io\demo\target\classes[INFO][INFO] --- maven-resources-plugin:3.0.2:testResources (default-testResources) @ demo ---[INFO] Using 'UTF-8' encoding to copy filtered resources.[INFO] skip non existing resourceDirectory C:\ws\workingDirectoryForTest\test-project-generated-from-start-spring-io\demo\src\test\resources[INFO][INFO] --- maven-compiler-plugin:3.7.0:testCompile (default-testCompile) @ demo ---[INFO] Changes detected - recompiling the module![INFO] Compiling 1 source file to C:\ws\workingDirectoryForTest\test-project-generated-from-start-spring-io\demo\target\test-classes[INFO][INFO] <<< spring-boot-maven-plugin:2.0.5.RELEASE:run (default-cli) < test-compile @ demo <<<[INFO][INFO] --- spring-boot-maven-plugin:2.0.5.RELEASE:run (default-cli) @ demo ---  .   ____          _            __ _ _ /\\ / ___'_ __ _ _(_)_ __  __ _ \ \ \ \( ( )\___ | '_ | '_| | '_ \/ _` | \ \ \ \ \\/  ___)| |_)| | | | | || (_| |  ) ) ) )  '  |____| .__|_| |_|_| |_\__, | / / / / =========|_|==============|___/=/_/_/_/ :: Spring Boot ::        (v2.0.5.RELEASE)2018-10-08 16:25:13.240  INFO 18328 --- [           main] com.example.demo.DemoApplication         : Starting DemoApplication on DESKTOP-9NT300B with PID 18328 (C:\ws\workingDirectoryForTest\test-project-generated-from-start-spring-io\demo\target\classes started by Aurelien Pupier in C:\ws\workingDirectoryForTest\test-project-generated-from-start-spring-io\demo)2018-10-08 16:25:13.243  INFO 18328 --- [           main] com.example.demo.DemoApplication         : No active profile set, falling backto default profiles: default2018-10-08 16:25:13.283  INFO 18328 --- [           main] s.c.a.AnnotationConfigApplicationContext : Refreshing org.springframework.context.annotation.AnnotationConfigApplicationContext@5fc55560: startup date [Mon Oct 08 16:25:13 CEST 2018]; root of context hierarchy2018-10-08 16:25:14.102  INFO 18328 --- [           main] trationDelegate$BeanPostProcessorChecker : Bean 'org.apache.camel.spring.boot.CamelAutoConfiguration' of type [org.apache.camel.spring.boot.CamelAutoConfiguration$$EnhancerBySpringCGLIB$$cae74b74] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)2018-10-08 16:25:14.283  INFO 18328 --- [           main] o.a.c.i.converter.DefaultTypeConverter   : Type converters loaded (core: 195, classpath: 1)2018-10-08 16:25:14.788  INFO 18328 --- [           main] o.s.j.e.a.AnnotationMBeanExporter        : Registering beans for JMX exposure on startup2018-10-08 16:25:14.804  INFO 18328 --- [           main] o.a.camel.spring.boot.RoutesCollector    : Loading additional Camel XML routesfrom: classpath:camel/*.xml2018-10-08 16:25:14.805  INFO 18328 --- [           main] o.a.camel.spring.boot.RoutesCollector    : Loading additional Camel XML rests from: classpath:camel-rest/*.xml2018-10-08 16:25:14.814  INFO 18328 --- [           main] o.a.camel.spring.SpringCamelContext      : Apache Camel 2.22.1 (CamelContext: camel-1) is starting2018-10-08 16:25:14.817  INFO 18328 --- [           main] o.a.c.m.ManagedManagementStrategy        : JMX is enabled2018-10-08 16:25:14.981  INFO 18328 --- [           main] o.a.camel.spring.SpringCamelContext      : StreamCaching is not in use. If using streams then its recommended to enable stream caching. See more details at http://camel.apache.org/stream-caching.html2018-10-08 16:25:14.983  INFO 18328 --- [           main] o.a.camel.spring.SpringCamelContext      : Total 0 routes, of which 0 are started2018-10-08 16:25:14.984  INFO 18328 --- [           main] o.a.camel.spring.SpringCamelContext      : Apache Camel 2.22.1 (CamelContext: camel-1) started in 0.169 seconds2018-10-08 16:25:14.988  INFO 18328 --- [           main] com.example.demo.DemoApplication         : Started DemoApplication in 2.083 seconds (JVM running for 8.856)[INFO] ------------------------------------------------------------------------[INFO] BUILD SUCCESS[INFO] ------------------------------------------------------------------------[INFO] Total time: 6.266 s[INFO] Finished at: 2018-10-08T16:25:14+02:00[INFO] Final Memory: 48M/575M[INFO] ------------------------------------------------------------------------2018-10-08 16:25:15.274  INFO 18328 --- [       Thread-2] s.c.a.AnnotationConfigApplicationContext : Closing org.springframework.context.annotation.AnnotationConfigApplicationContext@5fc55560: startup date [Mon Oct 08 16:25:13 CEST 2018]; root of context hierarchy2018-10-08 16:25:15.277  INFO 18328 --- [       Thread-2] o.s.c.support.DefaultLifecycleProcessor  : Stopping beans in phase 21474836472018-10-08 16:25:15.278  INFO 18328 --- [       Thread-2] o.a.camel.spring.SpringCamelContext      : Apache Camel 2.22.1 (CamelContext: camel-1) is shutting down2018-10-08 16:25:15.300  INFO 18328 --- [       Thread-2] o.a.camel.spring.SpringCamelContext      : Apache Camel 2.22.1 (CamelContext: camel-1) uptime 0.486 seconds2018-10-08 16:25:15.301  INFO 18328 --- [       Thread-2] o.a.camel.spring.SpringCamelContext      : Apache Camel 2.22.1 (CamelContext: camel-1) is shutdown in 0.022 seconds2018-10-08 16:25:15.301  INFO 18328 --- [       Thread-2] o.s.j.e.a.AnnotationMBeanExporter        : Unregistering JMX-exposed beans on shutdown{noformat} Improvement Camel project generated from spring initalzr is shutdowning immediately after start - go to https://start.spring.io/- let default values for "generate a Maven project with Java and Spring Boot 2.0.5"- add Camel dependencies- expand zipped project- launch mvn spring-boot:run- Camel is started and then shutdowned immediately instead of letting the application running{noformat}C:\ws\workingDirectoryForTest\test-project-generated-from-start-spring-io\demo>mvn spring-boot:run[INFO] Scanning for projects...[INFO][INFO] ------------------------------------------------------------------------[INFO] Building demo 0.0.1-SNAPSHOT[INFO] ------------------------------------------------------------------------[INFO][INFO] >>> spring-boot-maven-plugin:2.0.5.RELEASE:run (default-cli) > test-compile @ demo >>>[INFO][INFO] --- maven-resources-plugin:3.0.2:resources (default-resources) @ demo ---[INFO] Using 'UTF-8' encoding to copy filtered resources.[INFO] Copying 1 resource[INFO] Copying 0 resource[INFO][INFO] --- maven-compiler-plugin:3.7.0:compile (default-compile) @ demo ---[INFO] Changes detected - recompiling the module![INFO] Compiling 1 source file to C:\ws\workingDirectoryForTest\test-project-generated-from-start-spring-io\demo\target\classes[INFO][INFO] --- maven-resources-plugin:3.0.2:testResources (default-testResources) @ demo ---[INFO] Using 'UTF-8' encoding to copy filtered resources.[INFO] skip non existing resourceDirectory C:\ws\workingDirectoryForTest\test-project-generated-from-start-spring-io\demo\src\test\resources[INFO][INFO] --- maven-compiler-plugin:3.7.0:testCompile (default-testCompile) @ demo ---[INFO] Changes detected - recompiling the module![INFO] Compiling 1 source file to C:\ws\workingDirectoryForTest\test-project-generated-from-start-spring-io\demo\target\test-classes[INFO][INFO] <<< spring-boot-maven-plugin:2.0.5.RELEASE:run (default-cli) < test-compile @ demo <<<[INFO][INFO] --- spring-boot-maven-plugin:2.0.5.RELEASE:run (default-cli) @ demo ---  .   ____          _            __ _ _ /\\ / ___'_ __ _ _(_)_ __  __ _ \ \ \ \( ( )\___ | '_ | '_| | '_ \/ _` | \ \ \ \ \\/  ___)| |_)| | | | | || (_| |  ) ) ) )  '  |____| .__|_| |_|_| |_\__, | / / / / =========|_|==============|___/=/_/_/_/ :: Spring Boot ::        (v2.0.5.RELEASE)2018-10-08 16:25:13.240  INFO 18328 --- [           main] com.example.demo.DemoApplication         : Starting DemoApplication on DESKTOP-9NT300B with PID 18328 (C:\ws\workingDirectoryForTest\test-project-generated-from-start-spring-io\demo\target\classes started by Aurelien Pupier in C:\ws\workingDirectoryForTest\test-project-generated-from-start-spring-io\demo)2018-10-08 16:25:13.243  INFO 18328 --- [           main] com.example.demo.DemoApplication         : No active profile set, falling backto default profiles: default2018-10-08 16:25:13.283  INFO 18328 --- [           main] s.c.a.AnnotationConfigApplicationContext : Refreshing org.springframework.context.annotation.AnnotationConfigApplicationContext@5fc55560: startup date [Mon Oct 08 16:25:13 CEST 2018]; root of context hierarchy2018-10-08 16:25:14.102  INFO 18328 --- [           main] trationDelegate$BeanPostProcessorChecker : Bean 'org.apache.camel.spring.boot.CamelAutoConfiguration' of type [org.apache.camel.spring.boot.CamelAutoConfiguration$$EnhancerBySpringCGLIB$$cae74b74] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)2018-10-08 16:25:14.283  INFO 18328 --- [           main] o.a.c.i.converter.DefaultTypeConverter   : Type converters loaded (core: 195, classpath: 1)2018-10-08 16:25:14.788  INFO 18328 --- [           main] o.s.j.e.a.AnnotationMBeanExporter        : Registering beans for JMX exposure on startup2018-10-08 16:25:14.804  INFO 18328 --- [           main] o.a.camel.spring.boot.RoutesCollector    : Loading additional Camel XML routesfrom: classpath:camel/*.xml2018-10-08 16:25:14.805  INFO 18328 --- [           main] o.a.camel.spring.boot.RoutesCollector    : Loading additional Camel XML rests from: classpath:camel-rest/*.xml2018-10-08 16:25:14.814  INFO 18328 --- [           main] o.a.camel.spring.SpringCamelContext      : Apache Camel 2.22.1 (CamelContext: camel-1) is starting2018-10-08 16:25:14.817  INFO 18328 --- [           main] o.a.c.m.ManagedManagementStrategy        : JMX is enabled2018-10-08 16:25:14.981  INFO 18328 --- [           main] o.a.camel.spring.SpringCamelContext      : StreamCaching is not in use. If using streams then its recommended to enable stream caching. See more details at http://camel.apache.org/stream-caching.html2018-10-08 16:25:14.983  INFO 18328 --- [           main] o.a.camel.spring.SpringCamelContext      : Total 0 routes, of which 0 are started2018-10-08 16:25:14.984  INFO 18328 --- [           main] o.a.camel.spring.SpringCamelContext      : Apache Camel 2.22.1 (CamelContext: camel-1) started in 0.169 seconds2018-10-08 16:25:14.988  INFO 18328 --- [           main] com.example.demo.DemoApplication         : Started DemoApplication in 2.083 seconds (JVM running for 8.856)[INFO] ------------------------------------------------------------------------[INFO] BUILD SUCCESS[INFO] ------------------------------------------------------------------------[INFO] Total time: 6.266 s[INFO] Finished at: 2018-10-08T16:25:14+02:00[INFO] Final Memory: 48M/575M[INFO] ------------------------------------------------------------------------2018-10-08 16:25:15.274  INFO 18328 --- [       Thread-2] s.c.a.AnnotationConfigApplicationContext : Closing org.springframework.context.annotation.AnnotationConfigApplicationContext@5fc55560: startup date [Mon Oct 08 16:25:13 CEST 2018]; root of context hierarchy2018-10-08 16:25:15.277  INFO 18328 --- [       Thread-2] o.s.c.support.DefaultLifecycleProcessor  : Stopping beans in phase 21474836472018-10-08 16:25:15.278  INFO 18328 --- [       Thread-2] o.a.camel.spring.SpringCamelContext      : Apache Camel 2.22.1 (CamelContext: camel-1) is shutting down2018-10-08 16:25:15.300  INFO 18328 --- [       Thread-2] o.a.camel.spring.SpringCamelContext      : Apache Camel 2.22.1 (CamelContext: camel-1) uptime 0.486 seconds2018-10-08 16:25:15.301  INFO 18328 --- [       Thread-2] o.a.camel.spring.SpringCamelContext      : Apache Camel 2.22.1 (CamelContext: camel-1) is shutdown in 0.022 seconds2018-10-08 16:25:15.301  INFO 18328 --- [       Thread-2] o.s.j.e.a.AnnotationMBeanExporter        : Unregistering JMX-exposed beans on shutdown{noformat}
rest: Host header should not overwrite host attribute on rest-swagger component When defining a rest-swagger component{code}@Bean public Component mobile(CamelContext camelContext) throws URISyntaxException{ RestSwaggerComponent mobile = new RestSwaggerComponent(camelContext); mobile.setHost(mobileHost); mobile.setBasePath(mobileBasePath); mobile.setSpecificationUri( new URI(mobileSpecificationPath)); mobile.setComponentName("http4"); return mobile; }{code}in the following route (rest-endpoint missing, this is calling direct:getMobileAccountById) the host attribute is overwritten by the previous host header (therefore removeHeader needs to be called prior to invocation of the rest-swagger endpoint):({code}from("direct:getMobileAccountById").routeId("getMobileAccountById") .setHeader("customerId", simple("headers.mobileAndFixedlineCustomerId.split(',')[1]")) .removeHeader("Host") .to("mobile:getAccountById") .unmarshal(gsonDataFormatMobile) .log("Just got called for Mobile");{code}The attribute host should not be overwritten by the host-header, if it is set explicitly on the component.  Improvement rest: Host header should not overwrite host attribute on rest-swagger component When defining a rest-swagger component{code}@Bean public Component mobile(CamelContext camelContext) throws URISyntaxException{ RestSwaggerComponent mobile = new RestSwaggerComponent(camelContext); mobile.setHost(mobileHost); mobile.setBasePath(mobileBasePath); mobile.setSpecificationUri( new URI(mobileSpecificationPath)); mobile.setComponentName("http4"); return mobile; }{code}in the following route (rest-endpoint missing, this is calling direct:getMobileAccountById) the host attribute is overwritten by the previous host header (therefore removeHeader needs to be called prior to invocation of the rest-swagger endpoint):({code}from("direct:getMobileAccountById").routeId("getMobileAccountById") .setHeader("customerId", simple("headers.mobileAndFixedlineCustomerId.split(',')[1]")) .removeHeader("Host") .to("mobile:getAccountById") .unmarshal(gsonDataFormatMobile) .log("Just got called for Mobile");{code}The attribute host should not be overwritten by the host-header, if it is set explicitly on the component. 
IntrospectionSupport - Allow to use dash style naming See tickethttps://github.com/apache/camel-k/issues/142 New Feature IntrospectionSupport - Allow to use dash style naming See tickethttps://github.com/apache/camel-k/issues/142
camel-restdsl-swagger:generate - Add restConfiguration with common defaults We should add restConfiguration in the generated DSL source code so the Camel developer can see the configuration bits there, and more easily be able to configure rest-dsl options.We should detect which component is on the classpath and choose, eg jetty / servlet etc. New Feature camel-restdsl-swagger:generate - Add restConfiguration with common defaults We should add restConfiguration in the generated DSL source code so the Camel developer can see the configuration bits there, and more easily be able to configure rest-dsl options.We should detect which component is on the classpath and choose, eg jetty / servlet etc.
camel-restdsl-swagger:generate - Add option to generate dto objects We should add an option to generete DTO objects defined in the swagger json file. But we should not create our own logic that does that, but execute the existing swagger-codegen maven plugin and then have some default convention. And make this useable for 90% of the use-cases, and if people need more advanced dto generation then they can use the swagger-codegen maven plugin as-is.We should add some documentation on both situations and maybe a little example as well. New Feature camel-restdsl-swagger:generate - Add option to generate dto objects We should add an option to generete DTO objects defined in the swagger json file. But we should not create our own logic that does that, but execute the existing swagger-codegen maven plugin and then have some default convention. And make this useable for 90% of the use-cases, and if people need more advanced dto generation then they can use the swagger-codegen maven plugin as-is.We should add some documentation on both situations and maybe a little example as well.
camel-route-parser - Add parser for rest-dsl So we can have better tooling for rest-dsl New Feature camel-route-parser - Add parser for rest-dsl So we can have better tooling for rest-dsl
camel-http4 - Expose connection pool stats in JMX So end users can track the stats of the client connection pool, for example to see when all connections are in use, or the number of idle connections and so on. New Feature camel-http4 - Expose connection pool stats in JMX So end users can track the stats of the client connection pool, for example to see when all connections are in use, or the number of idle connections and so on.
deprecate camel-xmlrpc This project is no longer active maintained and last release was from 2010 Task deprecate camel-xmlrpc This project is no longer active maintained and last release was from 2010
add camel-jclouds-starter With SB 1 it was a conflict with a gson library. But now with SB2 we can add a jclouds starter. Task add camel-jclouds-starter With SB 1 it was a conflict with a gson library. But now with SB2 we can add a jclouds starter.
`@ConditionalOnProperty` target property with no metadata  Several auto-configurations use a condition on a property that has no metadata. As a result, trying to use it to customize the auto-configuration lead to a warning in an IDE.The report detected the following: {noformat}org.apache.camel.model.rest.springboot.RestConfigurationDefinitionAutoConfiguration [camel.rest.enabled]org.apache.camel.spring.boot.TypeConversionConfiguration [camel.springboot.typeConversion]{noformat}For the latter, the property in {{@ConditionalOnProperty}} must use the canonical format (i.e. must be {{camel.springboot.type-conversion}}) Improvement `@ConditionalOnProperty` target property with no metadata  Several auto-configurations use a condition on a property that has no metadata. As a result, trying to use it to customize the auto-configuration lead to a warning in an IDE.The report detected the following: {noformat}org.apache.camel.model.rest.springboot.RestConfigurationDefinitionAutoConfiguration [camel.rest.enabled]org.apache.camel.spring.boot.TypeConversionConfiguration [camel.springboot.typeConversion]{noformat}For the latter, the property in {{@ConditionalOnProperty}} must use the canonical format (i.e. must be {{camel.springboot.type-conversion}})
Upgrade Infinispan We should upgrade to a newer version, 9.3.1 Task Upgrade Infinispan We should upgrade to a newer version, 9.3.1
Upgrade Apache Ignite We should upgrade ignite as it has some good fixes needed Task Upgrade Apache Ignite We should upgrade ignite as it has some good fixes needed
Upgrade jetty to 9.4.11 We are using 9.4.6 but there is a 9.4.11 version Task Upgrade jetty to 9.4.11 We are using 9.4.6 but there is a 9.4.11 version
Some @link javadoc notations not handled well in auto-generated adocs For example, this javadoc:https://github.com/apache/camel/blob/master/camel-core/src/main/java/org/apache/camel/model/SplitDefinition.java#L257-L271{code:java}    /**     * When in streaming mode, then the splitter splits the original message on-demand, and each splitted     * message is processed one by one. This reduces memory usage as the splitter do not split all the messages first,     * but then we do not know the total size, and therefore the {@link org.apache.camel.Exchange#SPLIT_SIZE} is empty.     * <p/>     * In non-streaming mode (default) the splitter will split each message first, to know the total size, and then     * process each message one by one. This requires to keep all the splitted messages in memory and therefore requires     * more memory. The total size is provided in the {@link org.apache.camel.Exchange#SPLIT_SIZE} header.     * <p/>     * The streaming mode also affects the aggregation behavior.     * If enabled then Camel will process replies out-of-order, eg in the order they come back.     * If disabled, Camel will process replies in the same order as the messages was splitted.     *     * @return the builder     */{code}is generated to:https://github.com/apache/camel/blob/master/camel-core/src/main/docs/eips/split-eip.adoc{code}When in streaming mode, then the splitter splits the original message on-demand, and each splitted message is processed one by one. This reduces memory usage as the splitter do not split all the messages first, but then we do not know the total size, and therefore the *link* org.apache.camel.ExchangeSPLIT_SIZE is empty. In non-streaming mode (default) the splitter will split each message first, to know the total size, and then process each message one by one. This requires to keep all the splitted messages in memory and therefore requires more memory. The total size is provided in the *link* org.apache.camel.ExchangeSPLIT_SIZE header. The streaming mode also affects the aggregation behavior. If enabled then Camel will process replies out-of-order, eg in the order they come back. If disabled, Camel will process replies in the same order as the messages was splitted.{code}It is my impression that the current doc generator handles only FQCN well but fails to handle all other forms of Java source references. Task Some @link javadoc notations not handled well in auto-generated adocs For example, this javadoc:https://github.com/apache/camel/blob/master/camel-core/src/main/java/org/apache/camel/model/SplitDefinition.java#L257-L271{code:java}    /**     * When in streaming mode, then the splitter splits the original message on-demand, and each splitted     * message is processed one by one. This reduces memory usage as the splitter do not split all the messages first,     * but then we do not know the total size, and therefore the {@link org.apache.camel.Exchange#SPLIT_SIZE} is empty.     * <p/>     * In non-streaming mode (default) the splitter will split each message first, to know the total size, and then     * process each message one by one. This requires to keep all the splitted messages in memory and therefore requires     * more memory. The total size is provided in the {@link org.apache.camel.Exchange#SPLIT_SIZE} header.     * <p/>     * The streaming mode also affects the aggregation behavior.     * If enabled then Camel will process replies out-of-order, eg in the order they come back.     * If disabled, Camel will process replies in the same order as the messages was splitted.     *     * @return the builder     */{code}is generated to:https://github.com/apache/camel/blob/master/camel-core/src/main/docs/eips/split-eip.adoc{code}When in streaming mode, then the splitter splits the original message on-demand, and each splitted message is processed one by one. This reduces memory usage as the splitter do not split all the messages first, but then we do not know the total size, and therefore the *link* org.apache.camel.ExchangeSPLIT_SIZE is empty. In non-streaming mode (default) the splitter will split each message first, to know the total size, and then process each message one by one. This requires to keep all the splitted messages in memory and therefore requires more memory. The total size is provided in the *link* org.apache.camel.ExchangeSPLIT_SIZE header. The streaming mode also affects the aggregation behavior. If enabled then Camel will process replies out-of-order, eg in the order they come back. If disabled, Camel will process replies in the same order as the messages was splitted.{code}It is my impression that the current doc generator handles only FQCN well but fails to handle all other forms of Java source references.
Create FHIR authorization and transaction quickstart Showcase the following features of the underlying HAPI library:[http://hapifhir.io/doc_rest_client_interceptor.html][http://hapifhir.io/doc_rest_client_examples.html#Transaction_With_Placeholder_IDs]   Task Create FHIR authorization and transaction quickstart Showcase the following features of the underlying HAPI library:[http://hapifhir.io/doc_rest_client_interceptor.html][http://hapifhir.io/doc_rest_client_examples.html#Transaction_With_Placeholder_IDs]  
XmlRouteParser does not handle usage of xml namespace prefix for camel for instance with this file content, using the org.apache.camel.parser.XmlRouteParser.parseXmlRouteEndpoints(InputStream, String, String, List<CamelEndpointDetails>) method will not find the endpoint{quote}<?xml version="1.0" encoding="UTF-8"?><beans xmlns="http://www.springframework.org/schema/beans"    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="        http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd        http://camel.apache.org/schema/spring http://camel.apache.org/schema/spring/camel-spring.xsd">    <camel:camelContext id="camel" xmlns:camel="http://camel.apache.org/schema/spring">        <camel:endpoint uri="timer:timerName?delay=p"/>        <camel:route id="a route">            <camel:from id="_from1" uri="timer:timerName?delay=1000"/>            <camel:to id="_to1" uri="direct:drink"/>        </camel:route>    </camel:camelContext></beans>{quote} Improvement XmlRouteParser does not handle usage of xml namespace prefix for camel for instance with this file content, using the org.apache.camel.parser.XmlRouteParser.parseXmlRouteEndpoints(InputStream, String, String, List<CamelEndpointDetails>) method will not find the endpoint{quote}<?xml version="1.0" encoding="UTF-8"?><beans xmlns="http://www.springframework.org/schema/beans"    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="        http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd        http://camel.apache.org/schema/spring http://camel.apache.org/schema/spring/camel-spring.xsd">    <camel:camelContext id="camel" xmlns:camel="http://camel.apache.org/schema/spring">        <camel:endpoint uri="timer:timerName?delay=p"/>        <camel:route id="a route">            <camel:from id="_from1" uri="timer:timerName?delay=1000"/>            <camel:to id="_to1" uri="direct:drink"/>        </camel:route>    </camel:camelContext></beans>{quote}
camel-sql - Add support for basic dynamic query parameters in consumer See SOhttps://stackoverflow.com/questions/51855665/how-to-implement-stateful-polling-sql-consumer-in-camelIt would be nice if we add support for calling simple expressions like beans and the likes, so end users can have dynamic consumer queries in the SQL from routes  New Feature camel-sql - Add support for basic dynamic query parameters in consumer See SOhttps://stackoverflow.com/questions/51855665/how-to-implement-stateful-polling-sql-consumer-in-camelIt would be nice if we add support for calling simple expressions like beans and the likes, so end users can have dynamic consumer queries in the SQL from routes 
Some spring-boot-starters generated have wrong component name in their javadoc documentation See talk on @devhttp://camel.465427.n5.nabble.com/Re-generating-source-code-Modified-source-files-afterwards-tp5822115.html Task Some spring-boot-starters generated have wrong component name in their javadoc documentation See talk on @devhttp://camel.465427.n5.nabble.com/Re-generating-source-code-Modified-source-files-afterwards-tp5822115.html
support handlers in cxf payload data format without SEI When using a cxf endpoint in payload mode, specifying a WSDL and no service class, the JAX-WS protocol handlers are ignored.Documentation however indicates that payload mode supports protocol JAX-WS handlers.I made a pull request that activates the JAX-WS handlers in this scenario as well, by using a JaxWsEndpointImpl instead of EndpointImpl and removing some checks that avoid the handlers being set.  Improvement support handlers in cxf payload data format without SEI When using a cxf endpoint in payload mode, specifying a WSDL and no service class, the JAX-WS protocol handlers are ignored.Documentation however indicates that payload mode supports protocol JAX-WS handlers.I made a pull request that activates the JAX-WS handlers in this scenario as well, by using a JaxWsEndpointImpl instead of EndpointImpl and removing some checks that avoid the handlers being set. 
SFTP: Cannot specify bind address of local network interface In an environment with multiple network interfaces, it might be necessary to specify the address of the local interface, to which the SFTP connection should bind. Unfortunately, this is not possible with the latest version of camel-ftp. A new URI parameter 'bindAddress' should be introduces which can then be set to the IP-Address of the local network interface against which the SFTP connection should bind. Improvement SFTP: Cannot specify bind address of local network interface In an environment with multiple network interfaces, it might be necessary to specify the address of the local interface, to which the SFTP connection should bind. Unfortunately, this is not possible with the latest version of camel-ftp. A new URI parameter 'bindAddress' should be introduces which can then be set to the IP-Address of the local network interface against which the SFTP connection should bind.
camel-spring-boot - Improve its auto configuration docs Some of these options has no docs, or its sparse, or has some javadoc link reference etchttps://github.com/apache/camel/blob/master/components/camel-spring-boot/src/main/docs/spring-boot.adoc#spring-boot-auto-configuration Improvement camel-spring-boot - Improve its auto configuration docs Some of these options has no docs, or its sparse, or has some javadoc link reference etchttps://github.com/apache/camel/blob/master/components/camel-spring-boot/src/main/docs/spring-boot.adoc#spring-boot-auto-configuration
Unable to combine retry with Hystrix circuit breaker There as been more comment activity and no real resolution for the following ticket -> https://issues.apache.org/jira/browse/CAMEL-12195. This is blocking our ability to create resilient clients combining retry/exponential back-off/circuit-breaker without pulling in other frameworks or hacking in our own retry logic. Improvement Unable to combine retry with Hystrix circuit breaker There as been more comment activity and no real resolution for the following ticket -> https://issues.apache.org/jira/browse/CAMEL-12195. This is blocking our ability to create resilient clients combining retry/exponential back-off/circuit-breaker without pulling in other frameworks or hacking in our own retry logic.
Allow configuration of org.xml.sax.ErrorHandler on DocumentBuilders used in Camel I have trivial route that processes XMLs. When the XML is route and has no content (like empty file processed by {{<from uri="file:xxx">}}) I'm getting:{noformat}[Fatal Error] :-1:-1: Premature end of file.{noformat}printed directly on STDOUT.If there was a way to make {{org.apache.camel.converter.jaxp.XmlConverter}} call {{javax.xml.parsers.DocumentBuilder#setErrorHandler}} (for example delegating to logger), it'd be great. Improvement Allow configuration of org.xml.sax.ErrorHandler on DocumentBuilders used in Camel I have trivial route that processes XMLs. When the XML is route and has no content (like empty file processed by {{<from uri="file:xxx">}}) I'm getting:{noformat}[Fatal Error] :-1:-1: Premature end of file.{noformat}printed directly on STDOUT.If there was a way to make {{org.apache.camel.converter.jaxp.XmlConverter}} call {{javax.xml.parsers.DocumentBuilder#setErrorHandler}} (for example delegating to logger), it'd be great.
camel-spring-boot - Turn of options with @NestedConfigurationProperty in generated auto configuration source See my last comment on CAMEL-10197 Improvement camel-spring-boot - Turn of options with @NestedConfigurationProperty in generated auto configuration source See my last comment on CAMEL-10197
Spring Boot auto configuration - NestedConfigurationProperty should only be for known Camel types Currently we generte this for a range of complex objects that may appear as POJOs but they are likely not, so you cannot configure them, eg they dont have setters and a default no-arg constructor etc.We have a blacklist today, but instead we should flip it to be a whitelist for known Camel types that can be configured like the SSLContextParameters and others. Improvement Spring Boot auto configuration - NestedConfigurationProperty should only be for known Camel types Currently we generte this for a range of complex objects that may appear as POJOs but they are likely not, so you cannot configure them, eg they dont have setters and a default no-arg constructor etc.We have a blacklist today, but instead we should flip it to be a whitelist for known Camel types that can be configured like the SSLContextParameters and others.
Spring Boot configuration documentation should be polished Some of the options have descriptions with html tags for advanced javadoc. We should remove those to make it plain then the spring tooling that generates the metadata json file will be improved for tooling, and also our own online ascii docsFor examplehttps://github.com/apache/camel/blob/camel-12644/components/camel-spring-boot/src/main/docs/spring-boot.adoc#spring-boot-auto-configuration Improvement Spring Boot configuration documentation should be polished Some of the options have descriptions with html tags for advanced javadoc. We should remove those to make it plain then the spring tooling that generates the metadata json file will be improved for tooling, and also our own online ascii docsFor examplehttps://github.com/apache/camel/blob/camel-12644/components/camel-spring-boot/src/main/docs/spring-boot.adoc#spring-boot-auto-configuration
Log messages that do not match with their method function There are some possible copy and paste errors in the log messages (The logging statement was copied from an old place to a new place, but the message wasn't changed to adapt to the function of the new place) which may cause confusion when operators are reading the log messages.  Here is a list of the related logging statements:  *1. log.debug("Created FTPClient [connectTimeout: {}, soTimeout: {}, dataTimeout: {}, bufferSize: {}" + ", receiveDataSocketBufferSize: {}, sendDataSocketBufferSize: {}]: {}";*      *Callsites:* * org.apache.camel.component.file.remote.*{color:#205081}FTPEndpoint{color}*.createRemoteFileOperations, * org.apache.camel.component.file.remote.*{color:#205081}FtpsEndpoint{color}*.createRemoteFileOperations, *2. LOG.debug("Adding to producer service pool with key: {} for producer: {}", endpoint, answer);*      *Callsites:* * org.apache.camel.impl.*{color:#205081}ProducerCache{color}*.doGetProducer, * org.apache.camel.impl.*{color:#205081}ConsumerCache{color}*.doGetPollingConsumer *3. LOG.debug("Trying to update the post {} with id {}", exchange.getIn().getBody(), this.getConfiguration().getId());*      *Callsites:* * org.apache.camel.component.wordpress.producer.{color:#205081}*WordpressPostProducer*.{color}processUpdate, * org.apache.camel.component.wordpress.producer.{color:#205081}*WordpressUserProducer*.{color}processUpdate *4. LOG.error("Create a specific pod require specify a namespace name");*      *Callsites:* * org.apache.camel.component.kubernetes.pods.KubernetesPodsProducer.*{color:#205081}doCreatePod{color},* * org.apache.camel.component.kubernetes.deployments.KubernetesDeploymentsProducer.*{color:#205081}doCreateDeployment{color}* *5. LOG.debug("Channel closed but no message received from address: {}", producer.getConfiguration().getAddress());*      *Callsites:* * org.apache.camel.component.netty.handlers.ClientChannelHandler.*{color:#205081}channelClosed{color},* * org.apache.camel.component.netty4.handlers.ClientChannelHandler.*{color:#205081}channelInactive{color}*  *6. LOG.trace("Delete Broker command returned the error code {}", ase.getErrorCode());*      *Callsites:* * org.apache.camel.component.aws.mq.MQProducer.*{color:#205081}rebootBroker{color}*, * org.apache.camel.component.aws.mq.MQProducer.*{color:#205081}deleteBroker{color}* *7. LOG.debug("Stopping JmsReplyManager: {} from processing replies from: {}", replyManager, endpoint.getReplyTo() != null ? endpoint.getReplyTo() : "temporary queue");*      *Callsites:* * org.apache.camel.component.rabbitmq.*{color:#205081}RabbitMQProducer{color}*.unInitReplyManager, * org.apache.camel.component.jms.*{color:#205081}JmsProducer{color}*.unInitReplyManager *8. logger.warn("Error scanning JAR for custom Camel components", e);*      *Callsites:* * org.apache.camel.catalog.nexus.*{color:#205081}ComponentCatalogNexusRepository{color}*.addCustomCamelComponentsFromArtifact, * org.apache.camel.catalog.nexus.*{color:#205081}ConnectorCatalogNexusRepository.{color}*addCustomCamelConnectorFromArtifact *9. LOGGER.debug("Subscribe to events for queue: {}", resourceName);*      *Callsites:* * org.apache.camel.component.atomix.client.value.{color:#205081}*AtomixValueConsumer*{color}.doStart, * org.apache.camel.component.atomix.client.queue.*{color:#205081}AtomixQueueConsumer{color}*.doStart *10. LOG.warn("TimeoutEvent received at Sip Subscription Listener");*      *Callsites:* * org.apache.camel.component.sip.listener.{color:#205081}*SipSubscriptionListener*{color}.processTimeout, * org.apache.camel.component.sip.listener.{color:#205081}*SipPresenceAgentListener*{color}.processTimeout *11. LOGGER.debug("Executing Docker Kill Container Request");*      *Callsites:* * org.apache.camel.component.docker.producer.DockerProducer.execute{color:#205081}*StopContainer*{color}Request, * org.apache.camel.component.docker.producer.DockerProducer.execute{color:#205081}*KillContainer*{color}Request *12. LOG.trace("Rename Droplet {} : [{}] ", dropletId, action);*      *Callsites:* * org.apache.camel.component.digitalocean.producer.DigitalOceanDropletsProducer.change.*{color:#205081}DropletKernel{color}*, * org.apache.camel.component.digitalocean.producer.DigitalOceanDropletsProducer.{color:#205081}*renameDroplet*{color}   Improvement Log messages that do not match with their method function There are some possible copy and paste errors in the log messages (The logging statement was copied from an old place to a new place, but the message wasn't changed to adapt to the function of the new place) which may cause confusion when operators are reading the log messages.  Here is a list of the related logging statements:  *1. log.debug("Created FTPClient [connectTimeout: {}, soTimeout: {}, dataTimeout: {}, bufferSize: {}" + ", receiveDataSocketBufferSize: {}, sendDataSocketBufferSize: {}]: {}";*      *Callsites:* * org.apache.camel.component.file.remote.*{color:#205081}FTPEndpoint{color}*.createRemoteFileOperations, * org.apache.camel.component.file.remote.*{color:#205081}FtpsEndpoint{color}*.createRemoteFileOperations, *2. LOG.debug("Adding to producer service pool with key: {} for producer: {}", endpoint, answer);*      *Callsites:* * org.apache.camel.impl.*{color:#205081}ProducerCache{color}*.doGetProducer, * org.apache.camel.impl.*{color:#205081}ConsumerCache{color}*.doGetPollingConsumer *3. LOG.debug("Trying to update the post {} with id {}", exchange.getIn().getBody(), this.getConfiguration().getId());*      *Callsites:* * org.apache.camel.component.wordpress.producer.{color:#205081}*WordpressPostProducer*.{color}processUpdate, * org.apache.camel.component.wordpress.producer.{color:#205081}*WordpressUserProducer*.{color}processUpdate *4. LOG.error("Create a specific pod require specify a namespace name");*      *Callsites:* * org.apache.camel.component.kubernetes.pods.KubernetesPodsProducer.*{color:#205081}doCreatePod{color},* * org.apache.camel.component.kubernetes.deployments.KubernetesDeploymentsProducer.*{color:#205081}doCreateDeployment{color}* *5. LOG.debug("Channel closed but no message received from address: {}", producer.getConfiguration().getAddress());*      *Callsites:* * org.apache.camel.component.netty.handlers.ClientChannelHandler.*{color:#205081}channelClosed{color},* * org.apache.camel.component.netty4.handlers.ClientChannelHandler.*{color:#205081}channelInactive{color}*  *6. LOG.trace("Delete Broker command returned the error code {}", ase.getErrorCode());*      *Callsites:* * org.apache.camel.component.aws.mq.MQProducer.*{color:#205081}rebootBroker{color}*, * org.apache.camel.component.aws.mq.MQProducer.*{color:#205081}deleteBroker{color}* *7. LOG.debug("Stopping JmsReplyManager: {} from processing replies from: {}", replyManager, endpoint.getReplyTo() != null ? endpoint.getReplyTo() : "temporary queue");*      *Callsites:* * org.apache.camel.component.rabbitmq.*{color:#205081}RabbitMQProducer{color}*.unInitReplyManager, * org.apache.camel.component.jms.*{color:#205081}JmsProducer{color}*.unInitReplyManager *8. logger.warn("Error scanning JAR for custom Camel components", e);*      *Callsites:* * org.apache.camel.catalog.nexus.*{color:#205081}ComponentCatalogNexusRepository{color}*.addCustomCamelComponentsFromArtifact, * org.apache.camel.catalog.nexus.*{color:#205081}ConnectorCatalogNexusRepository.{color}*addCustomCamelConnectorFromArtifact *9. LOGGER.debug("Subscribe to events for queue: {}", resourceName);*      *Callsites:* * org.apache.camel.component.atomix.client.value.{color:#205081}*AtomixValueConsumer*{color}.doStart, * org.apache.camel.component.atomix.client.queue.*{color:#205081}AtomixQueueConsumer{color}*.doStart *10. LOG.warn("TimeoutEvent received at Sip Subscription Listener");*      *Callsites:* * org.apache.camel.component.sip.listener.{color:#205081}*SipSubscriptionListener*{color}.processTimeout, * org.apache.camel.component.sip.listener.{color:#205081}*SipPresenceAgentListener*{color}.processTimeout *11. LOGGER.debug("Executing Docker Kill Container Request");*      *Callsites:* * org.apache.camel.component.docker.producer.DockerProducer.execute{color:#205081}*StopContainer*{color}Request, * org.apache.camel.component.docker.producer.DockerProducer.execute{color:#205081}*KillContainer*{color}Request *12. LOG.trace("Rename Droplet {} : [{}] ", dropletId, action);*      *Callsites:* * org.apache.camel.component.digitalocean.producer.DigitalOceanDropletsProducer.change.*{color:#205081}DropletKernel{color}*, * org.apache.camel.component.digitalocean.producer.DigitalOceanDropletsProducer.{color:#205081}*renameDroplet*{color}  
camel-spring-boot - Auto configuration of complex types should be more tooling friendly If you have complex types like javax.sql.DataSource and wants to allow to configure this via spring boot autoconfiguration in application.properties - then the generated spring boot classes with all the options will use getter/setter of types javax.sql.DataSource. That seems correct, but the spring-boot tooling itself (that generates additional json file) will skip those as it only support primitives and string types.So we may need to fool, and generate the getter/setter as String type as you use it for configuring it as a bean reference by id anyway, egcamel.component.jdbc.data-source = #myDataSourceWe can add in the javadoc that the type is javax.sql.DataSource. Improvement camel-spring-boot - Auto configuration of complex types should be more tooling friendly If you have complex types like javax.sql.DataSource and wants to allow to configure this via spring boot autoconfiguration in application.properties - then the generated spring boot classes with all the options will use getter/setter of types javax.sql.DataSource. That seems correct, but the spring-boot tooling itself (that generates additional json file) will skip those as it only support primitives and string types.So we may need to fool, and generate the getter/setter as String type as you use it for configuring it as a bean reference by id anyway, egcamel.component.jdbc.data-source = #myDataSourceWe can add in the javadoc that the type is javax.sql.DataSource.
camel-jdbc - Allow to use default datasource from spring-boot Like we do in camel-sql where we lookup and use default data source if there is none configured and there is only 1. Then camel-sql and camel-jdbc is a bit similar and easier to use, such as when using spring boot. Improvement camel-jdbc - Allow to use default datasource from spring-boot Like we do in camel-sql where we lookup and use default data source if there is none configured and there is only 1. Then camel-sql and camel-jdbc is a bit similar and easier to use, such as when using spring boot.
Generate documentation for Spring Boot starters We could add auto-configuration properties section to the component documentation something like that can be seen in the [spring-boot documentation|https://docs.spring.io/spring-boot/docs/1.5.14.RELEASE/reference/htmlsingle/#common-application-properties] to help the users know which properties are available in application.[properties|yaml] under what keys. New Feature Generate documentation for Spring Boot starters We could add auto-configuration properties section to the component documentation something like that can be seen in the [spring-boot documentation|https://docs.spring.io/spring-boot/docs/1.5.14.RELEASE/reference/htmlsingle/#common-application-properties] to help the users know which properties are available in application.[properties|yaml] under what keys.
camel-rabbitmq - Inadequate information for handling catch clauses There are some situations that different exception types are caught, but the handling of those exceptions cannot show the differences between those types. Here are the code snippets which have this problem:{code}org.apache.camel.component.rabbitmq.*RabbitConsumer*.handleShutdownSignal, *Line 271*catch (IOException | TimeoutException e){   log.warn("Unable to obtain a RabbitMQ channel. Will try again");     ...      }{code}It may cause confusions to the person who is reading the log, the person can not know what exception happened here and cannot distinguish if the exception type is IOException or TimeoutException. Simply adding a full stack trace is able to improve it.  Improvement camel-rabbitmq - Inadequate information for handling catch clauses There are some situations that different exception types are caught, but the handling of those exceptions cannot show the differences between those types. Here are the code snippets which have this problem:{code}org.apache.camel.component.rabbitmq.*RabbitConsumer*.handleShutdownSignal, *Line 271*catch (IOException | TimeoutException e){   log.warn("Unable to obtain a RabbitMQ channel. Will try again");     ...      }{code}It may cause confusions to the person who is reading the log, the person can not know what exception happened here and cannot distinguish if the exception type is IOException or TimeoutException. Simply adding a full stack trace is able to improve it. 
tooling - Provide character position in validation result currently the line start and line end are provided but not the character position Improvement tooling - Provide character position in validation result currently the line start and line end are provided but not the character position
tooling - Provide line numbers for CamelEndpointDetails for java dsl currently it is provided for xml dsl but not for java dsl Improvement tooling - Provide line numbers for CamelEndpointDetails for java dsl currently it is provided for xml dsl but not for java dsl
camel-jmx - Should use a thread pool for routing notifications The handleNotification event should be a simple noop operation. But if we route in Camel then it may do many things and call external systems etc. So ideally we should have a little thread pool to process these events - eg a like a wire tap. Improvement camel-jmx - Should use a thread pool for routing notifications The handleNotification event should be a simple noop operation. But if we route in Camel then it may do many things and call external systems etc. So ideally we should have a little thread pool to process these events - eg a like a wire tap.
camel-jmx - Add support for monitoring boolean attribute changes We can monitor counters, gauges and string values. But its not possible to monitor when a boolean value changes.You cannot use the string monitor as JMX does not support that :(So we need to add out own code to handle booleans Improvement camel-jmx - Add support for monitoring boolean attribute changes We can monitor counters, gauges and string values. But its not possible to monitor when a boolean value changes.You cannot use the string monitor as JMX does not support that :(So we need to add out own code to handle booleans
[doc] camel-hawtdb documentation should be updated The documentation for [camel-hawtdb |http://camel.apache.org/hawtdb.html]says:{quote}The [HawtDB|http://hawtdb.fusesource.org/] project is being deprecated and replaced by [leveldb|https://code.google.com/p/leveldb/] as the lightweight and embedable key value database. To make using leveldb easy there is a [leveldbjni|https://github.com/fusesource/leveldbjni] project for that. The Apache ActiveMQ project is planning on using leveldb as their primary file based message store in the future, to replace kahadb.{quote}The last part about ActiveMQ replacing KahaDB with LevelDB is out of date. LevelDB has been deprecated on ActiveMQ and KahaDB remains the standard persistence adapter. The top level warning on http://activemq.apache.org/leveldb-store.html. So I suggest to remove that sentence at minimum.Also, I am not sure do we still recommend LevelDB as an alternative to hawtdb or would there be even better options these days?    Improvement [doc] camel-hawtdb documentation should be updated The documentation for [camel-hawtdb |http://camel.apache.org/hawtdb.html]says:{quote}The [HawtDB|http://hawtdb.fusesource.org/] project is being deprecated and replaced by [leveldb|https://code.google.com/p/leveldb/] as the lightweight and embedable key value database. To make using leveldb easy there is a [leveldbjni|https://github.com/fusesource/leveldbjni] project for that. The Apache ActiveMQ project is planning on using leveldb as their primary file based message store in the future, to replace kahadb.{quote}The last part about ActiveMQ replacing KahaDB with LevelDB is out of date. LevelDB has been deprecated on ActiveMQ and KahaDB remains the standard persistence adapter. The top level warning on http://activemq.apache.org/leveldb-store.html. So I suggest to remove that sentence at minimum.Also, I am not sure do we still recommend LevelDB as an alternative to hawtdb or would there be even better options these days?   
Use Spring Boot autoconfigure-processor to optimize auto-configurations As explained in [the its reference documentation|https://github.com/spring-projects/spring-boot/blob/master/spring-boot-project/spring-boot-docs/src/main/asciidoc/spring-boot-features.adoc#autoconfigure-module], Spring Boot provides a {{spring-boot-autoconfigure-processor}}.This should be added as an optional dependency to each module that contains AutoConfiguration classes (and the `spring.factories` file declaring them).Once configured, this annotation processor will generate metadata at compile time and will help Spring Boot process those auto-configurations without loading the actual classes in some cases.In this project, the several modules are declaring auto-configurations but are not using this annotation processor. Could you add it to the build files?{code:xml}<dependency> <groupId>org.springframework.boot</groupId> <artifactId>spring-boot-autoconfigure-processor</artifactId> <optional>true</optional></dependency>{code}Once added, this should generate a {{spring-autoconfigure-metadata.properties}} file in the {{target/classes/META-INF}} folder of earch module. Improvement Use Spring Boot autoconfigure-processor to optimize auto-configurations As explained in [the its reference documentation|https://github.com/spring-projects/spring-boot/blob/master/spring-boot-project/spring-boot-docs/src/main/asciidoc/spring-boot-features.adoc#autoconfigure-module], Spring Boot provides a {{spring-boot-autoconfigure-processor}}.This should be added as an optional dependency to each module that contains AutoConfiguration classes (and the `spring.factories` file declaring them).Once configured, this annotation processor will generate metadata at compile time and will help Spring Boot process those auto-configurations without loading the actual classes in some cases.In this project, the several modules are declaring auto-configurations but are not using this annotation processor. Could you add it to the build files?{code:xml}<dependency> <groupId>org.springframework.boot</groupId> <artifactId>spring-boot-autoconfigure-processor</artifactId> <optional>true</optional></dependency>{code}Once added, this should generate a {{spring-autoconfigure-metadata.properties}} file in the {{target/classes/META-INF}} folder of earch module.
DefaultExchangeFormatter: Make it easy to override the header and property formatting  To omit certain headers (or mask their values) in ExchangeFormatter, one can write a custom implementation. In [DefaultExchangeFormatter|[https://github.com/apache/camel/blob/apache-master/camel-core/src/main/java/org/apache/camel/processor/DefaultExchangeFormatter.java],] ... it would be nice if the header-formatting (maybe the Property formatting) was done as separate methods that we could over-ride, while keeping the rest of the functionality.Not sure if it would be acceptable to do this without also changing the ExchangeFormatter interface to add such methods. Improvement DefaultExchangeFormatter: Make it easy to override the header and property formatting  To omit certain headers (or mask their values) in ExchangeFormatter, one can write a custom implementation. In [DefaultExchangeFormatter|[https://github.com/apache/camel/blob/apache-master/camel-core/src/main/java/org/apache/camel/processor/DefaultExchangeFormatter.java],] ... it would be nice if the header-formatting (maybe the Property formatting) was done as separate methods that we could over-ride, while keeping the rest of the functionality.Not sure if it would be acceptable to do this without also changing the ExchangeFormatter interface to add such methods.
camel-servlet - Add whitelist for accepted file types Reported on user forumhttp://camel.465427.n5.nabble.com/Report-Issues-Apache-Camel-Servlet-Component-td5820710.html Improvement camel-servlet - Add whitelist for accepted file types Reported on user forumhttp://camel.465427.n5.nabble.com/Report-Issues-Apache-Camel-Servlet-Component-td5820710.html
camel-stream - Add support for configuring timeout for HTTP urls So you can set connect and read timeouts. New Feature camel-stream - Add support for configuring timeout for HTTP urls So you can set connect and read timeouts.
camel-stream - Add support for HTTP headers Asked on user forumhttp://camel.465427.n5.nabble.com/url-http-streaming-issue-tp5820467.html New Feature camel-stream - Add support for HTTP headers Asked on user forumhttp://camel.465427.n5.nabble.com/url-http-streaming-issue-tp5820467.html
Using cxf new LoggingFeature CXF deprecated the old LoggingFeature, we need to switch to [new one|http://cxf.apache.org/docs/message-logging.html]. Improvement Using cxf new LoggingFeature CXF deprecated the old LoggingFeature, we need to switch to [new one|http://cxf.apache.org/docs/message-logging.html].
rest-dsl - Allow to configure rest configuration via spring boot auto configuration There are some global configurations you can configure on restConfiguration. We should make it possible to configure these via spring boot auto configuration, eg application.properties etc. Improvement rest-dsl - Allow to configure rest configuration via spring boot auto configuration There are some global configurations you can configure on restConfiguration. We should make it possible to configure these via spring boot auto configuration, eg application.properties etc.
rest-dsl - Should check for required parameters generally See SO[https://stackoverflow.com/questions/50489713/camel-rest-dsl-required-param-ignored]There is AFAIR a little bit of required validation. But we could might as well do this if the user has specified those in the rest-dsl. Currently we rely a bit on the chosen http component to do its own validation. But since we have the rest-dsl contract at hand in the rest-dsl we should let camel-core figure this out. Improvement rest-dsl - Should check for required parameters generally See SO[https://stackoverflow.com/questions/50489713/camel-rest-dsl-required-param-ignored]There is AFAIR a little bit of required validation. But we could might as well do this if the user has specified those in the rest-dsl. Currently we rely a bit on the chosen http component to do its own validation. But since we have the rest-dsl contract at hand in the rest-dsl we should let camel-core figure this out.
Dynamic Router implementation behavior inconsistent with Dynamic Router EIP specification Currently, the Dynamic Router component of camel-core repeatedly routes messages back through the dynamic router, as indicated in the documentation. However, when examining the Dynamic Router EIP specification at [http://www.enterpriseintegrationpatterns.com/patterns/messaging/DynamicRouter.html], we can see that this behavior is not consistent with the specification.The description is:{quote}Use a Dynamic Router, a Router that can self-configure based on special configuration messages from participating destinations.Besides the usual input and output channels the Dynamic Router uses an additional control channel. During system start-up, each potential recipient sends a special message to the Dynamic Router on this control channel, announcing its presence and listing the conditions under which it can handle a message. The Dynamic Router stores the 'preferences' for each participant in a rule base. When a message arrives, the Dynamic Router evaluates all rules and routes the message to the recipient whose rules are fulfilled. This allows for efficient, predictive routing without the maintenance dependency of the Dynamic Router on each potential recipient.{quote}Since the documentation specifies the re-routing nature of the dynamic router quite clearly, this is obviously not an unintended side-effect or consequence but, I believe, a misunderstanding of the EIP itself.  It appears that there _might_ be a point of confusion with the control channel that connects the potential endpoints to the rule base. This is not for re-routing of the messages, but for the potential endpoints to register rules with the dynamic router. While I am not certain how this should (or would) be implemented within Camel, the current behavior is not quite consistent with the description of the EIP Improvement Dynamic Router implementation behavior inconsistent with Dynamic Router EIP specification Currently, the Dynamic Router component of camel-core repeatedly routes messages back through the dynamic router, as indicated in the documentation. However, when examining the Dynamic Router EIP specification at [http://www.enterpriseintegrationpatterns.com/patterns/messaging/DynamicRouter.html], we can see that this behavior is not consistent with the specification.The description is:{quote}Use a Dynamic Router, a Router that can self-configure based on special configuration messages from participating destinations.Besides the usual input and output channels the Dynamic Router uses an additional control channel. During system start-up, each potential recipient sends a special message to the Dynamic Router on this control channel, announcing its presence and listing the conditions under which it can handle a message. The Dynamic Router stores the 'preferences' for each participant in a rule base. When a message arrives, the Dynamic Router evaluates all rules and routes the message to the recipient whose rules are fulfilled. This allows for efficient, predictive routing without the maintenance dependency of the Dynamic Router on each potential recipient.{quote}Since the documentation specifies the re-routing nature of the dynamic router quite clearly, this is obviously not an unintended side-effect or consequence but, I believe, a misunderstanding of the EIP itself.  It appears that there _might_ be a point of confusion with the control channel that connects the potential endpoints to the rule base. This is not for re-routing of the messages, but for the potential endpoints to register rules with the dynamic router. While I am not certain how this should (or would) be implemented within Camel, the current behavior is not quite consistent with the description of the EIP
FluentProducerTemplate.withExchange() does not seem to send exchange When I use the following simple but complete code example:{code:java}public static void main(String[] args) throws Exception {    CamelContext camelContext = new DefaultCamelContext();    camelContext.start();    camelContext.addRoutes(new RouteBuilder() {        @Override        public void configure() {            from("direct-vm:start").process(exchange -> {                String incoming = exchange.getIn().getBody(String.class);                exchange.getIn().setBody("Message received: " + incoming, String.class);            });        }    });    Exchange exchange = ExchangeBuilder.anExchange(camelContext)            .withBody("Hello!")            .withPattern(ExchangePattern.InOut)            .build();    System.out.println(            camelContext.createFluentProducerTemplate()            .withExchange(exchange)            .to("direct-vm:start")            .request(String.class)    );}{code}The message body appears to be missing, as indicated in the program output:{code:java}Message received: null{code}I have tried this with java 1.8 and 1.9, and with camel 2.19.2 and 2.21.1, and both camel versions exhibit the same behavior when run with both java versions. Improvement FluentProducerTemplate.withExchange() does not seem to send exchange When I use the following simple but complete code example:{code:java}public static void main(String[] args) throws Exception {    CamelContext camelContext = new DefaultCamelContext();    camelContext.start();    camelContext.addRoutes(new RouteBuilder() {        @Override        public void configure() {            from("direct-vm:start").process(exchange -> {                String incoming = exchange.getIn().getBody(String.class);                exchange.getIn().setBody("Message received: " + incoming, String.class);            });        }    });    Exchange exchange = ExchangeBuilder.anExchange(camelContext)            .withBody("Hello!")            .withPattern(ExchangePattern.InOut)            .build();    System.out.println(            camelContext.createFluentProducerTemplate()            .withExchange(exchange)            .to("direct-vm:start")            .request(String.class)    );}{code}The message body appears to be missing, as indicated in the program output:{code:java}Message received: null{code}I have tried this with java 1.8 and 1.9, and with camel 2.19.2 and 2.21.1, and both camel versions exhibit the same behavior when run with both java versions.
Camel breadcrumb - Consider turning it off by default This was added many years ago with the breadcrumbId header. But today there is standards with opentracing / zipkin etc.So ideally we should turn this off by default, and then point people to these other standards.[http://camel.apache.org/mdc-logging.html]  Improvement Camel breadcrumb - Consider turning it off by default This was added many years ago with the breadcrumbId header. But today there is standards with opentracing / zipkin etc.So ideally we should turn this off by default, and then point people to these other standards.[http://camel.apache.org/mdc-logging.html] 
Kafka component should be able to propagate camel headers to kafka Since 0.11.0 Kafka support headers, and it would be awesome to have such feature available also in camel component. New Feature Kafka component should be able to propagate camel headers to kafka Since 0.11.0 Kafka support headers, and it would be awesome to have such feature available also in camel component.
Placeholders are not resolved in Simple language while using resource: prefix This behavior was found in question https://stackoverflow.com/questions/50063874/load-camels-body-dynamically-depending-on-headerThis is because expression with prefix *resource* is resolved in LanguageSupport#loadResource before property placeholders are resolved. This is reasonable, as placeholders are resolved in expression loaded from file. But it prevents from dynamic resource loading.It would be nice to allow property resolution in resource in this way{code:java}.transform().simple("resource:classpath:${header.myFileName}"){code}I would expect this behavior: # Resolve placeholders in expression (now missing) # Load String from resource as new expression (exists) # Resolve placeholders in new expression (exists)I have tried to create patch for *SimpleLanguage*, but I failed. Attaching patch to *SimpleResourceTest* with expected behavior based on master. Wish Placeholders are not resolved in Simple language while using resource: prefix This behavior was found in question https://stackoverflow.com/questions/50063874/load-camels-body-dynamically-depending-on-headerThis is because expression with prefix *resource* is resolved in LanguageSupport#loadResource before property placeholders are resolved. This is reasonable, as placeholders are resolved in expression loaded from file. But it prevents from dynamic resource loading.It would be nice to allow property resolution in resource in this way{code:java}.transform().simple("resource:classpath:${header.myFileName}"){code}I would expect this behavior: # Resolve placeholders in expression (now missing) # Load String from resource as new expression (exists) # Resolve placeholders in new expression (exists)I have tried to create patch for *SimpleLanguage*, but I failed. Attaching patch to *SimpleResourceTest* with expected behavior based on master.
toD with HTTP endpoints - Optimise dynamic query to leverage HTTP_QUERY header We can consider for some HTTP components that support dynamic parts of their endpoints from Camel headers such as HTTP_QUERY and others.We can then in toD detect those components and then build a processor chain that does # setHeader - set dynamic header HTTP_QUERY # toD - call the endpoint with a more static uriThis optimises to reuse the toD with more static uris, especially if you hit the same host for each toD and its only the query parameters that are dynamic.Today developers would need to use setHeader and to combo to do this, instead of a single toD.The trick is to separate the query parameters and the endpoint parameters and only set query parameters in the setHeader, and the endpoint parameters in toD. Improvement toD with HTTP endpoints - Optimise dynamic query to leverage HTTP_QUERY header We can consider for some HTTP components that support dynamic parts of their endpoints from Camel headers such as HTTP_QUERY and others.We can then in toD detect those components and then build a processor chain that does # setHeader - set dynamic header HTTP_QUERY # toD - call the endpoint with a more static uriThis optimises to reuse the toD with more static uris, especially if you hit the same host for each toD and its only the query parameters that are dynamic.Today developers would need to use setHeader and to combo to do this, instead of a single toD.The trick is to separate the query parameters and the endpoint parameters and only set query parameters in the setHeader, and the endpoint parameters in toD.
camel-twitter - Should support extended mode by default So we can receive > 140 chars. See this PRhttps://github.com/apache/camel/pull/2292 Improvement camel-twitter - Should support extended mode by default So we can receive > 140 chars. See this PRhttps://github.com/apache/camel/pull/2292
