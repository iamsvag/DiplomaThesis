[
  {
    "key":"CAMEL-14041",
    "title":"scheduled poll consumer - Add option to limit number of polls",
    "description":"In the timer\/scheduler component you can set a max number of polls so the consumer stop after that.\r\n\r\nWe could add something similar so you can eg tell the consumer to run only once etc.",
    "assignee":"davsclaus",
    "type":"Improvement",
    "priority":"Major",
    "status":"Resolved",
    "text":"scheduled poll consumer - Add option to limit number of polls In the timer\/scheduler component you can set a max number of polls so the consumer stop after that.\r\n\r\nWe could add something similar so you can eg tell the consumer to run only once etc."
  },
  {
    "key":"CAMEL-14040",
    "title":"DefaultRegistry - findByType should return merged result incl fallback",
    "description":"Reported by Luca in camel-quarkus",
    "assignee":"davsclaus",
    "type":"Improvement",
    "priority":"Major",
    "status":"Resolved",
    "text":"DefaultRegistry - findByType should return merged result incl fallback Reported by Luca in camel-quarkus"
  },
  {
    "key":"CAMEL-14035",
    "title":"JDBC StreamList and outputClass does not work",
    "description":"Situation is simple:\r\n\r\nI try to load data from jdbc by Stream to Java object\r\n\r\nwith such command jdbc:dbBean?outputType=StreamList&outputClass=myClass.\r\n\r\nI estimate Java object on exit of flow? but i have Map<String, Object>.\r\n\r\nBug in\u00a0JdbcProducer at lines 326.\r\n\r\nif (outputType == JdbcOutputType.StreamList) {\r\n exchange.getOut().setBody(iterator);\r\n exchange.addOnCompletion(new ResultSetIteratorCompletion(iterator));\r\n \/\/ do not close resources as we are in streaming mode\r\n answer = false;\r\n}\r\n\r\nHere need wrap iterator to map objects by method\u00a0newBeanInstance",
    "assignee":"davsclaus",
    "type":"Bug",
    "priority":"Major",
    "status":"Resolved",
    "text":"JDBC StreamList and outputClass does not work Situation is simple:\r\n\r\nI try to load data from jdbc by Stream to Java object\r\n\r\nwith such command jdbc:dbBean?outputType=StreamList&outputClass=myClass.\r\n\r\nI estimate Java object on exit of flow? but i have Map<String, Object>.\r\n\r\nBug in JdbcProducer at lines 326.\r\n\r\nif (outputType == JdbcOutputType.StreamList) {\r\n exchange.getOut().setBody(iterator);\r\n exchange.addOnCompletion(new ResultSetIteratorCompletion(iterator));\r\n \/\/ do not close resources as we are in streaming mode\r\n answer = false;\r\n}\r\n\r\nHere need wrap iterator to map objects by method newBeanInstance"
  },
  {
    "key":"CAMEL-14034",
    "title":"Orderes RoutesBuilder",
    "description":"RoutesBuilder are now loaded according to the order the user add them but in some cases it may be needed to load them according to an order.\r\n\r\nWe should then make the RoutesBuilder interface extends Ordered and take it into account i.e. in MainSupport.",
    "assignee":"davsclaus",
    "type":"Improvement",
    "priority":"Minor",
    "status":"Resolved",
    "text":"Orderes RoutesBuilder RoutesBuilder are now loaded according to the order the user add them but in some cases it may be needed to load them according to an order.\r\n\r\nWe should then make the RoutesBuilder interface extends Ordered and take it into account i.e. in MainSupport."
  },
  {
    "key":"CAMEL-14033",
    "title":"multiple consumers for namedReplyTo results in a cryptic nullPointer",
    "description":"Per [https:\/\/camel.apache.org\/components\/latest\/sjms-component.html#_clustering]\u00a0you should not have multiple inOut producerEndpoints using the same replyTo address but if you do it results in a cryptic null pointer exception it would be nice to have a better error message of some sort directing you to use a unique replyTo address or temporary queue. Additionally if the replyTo is a topic then I don't believe it should result in an error and it may be better to actually use a message selector for this case.\r\n\r\njava.lang.NullPointerException: nulljava.lang.NullPointerException: null at org.apache.camel.component.sjms.producer.InOutProducer$MessageConsumerResourcesFactory$1.onMessage(InOutProducer.java:103) ~[?:?] at org.apache.activemq.artemis.jms.client.JMSMessageListenerWrapper.onMessage(JMSMessageListenerWrapper.java:110) ~[254:org.apache.activemq.artemis-server-osgi:2.8.1] at org.apache.activemq.artemis.core.client.impl.ClientConsumerImpl.callOnMessage(ClientConsumerImpl.java:1031) ~[?:?] at org.apache.activemq.artemis.core.client.impl.ClientConsumerImpl.access$400(ClientConsumerImpl.java:50) ~[?:?] at org.apache.activemq.artemis.core.client.impl.ClientConsumerImpl$Runner.run(ClientConsumerImpl.java:1154) ~[?:?] at org.apache.activemq.artemis.utils.actors.OrderedExecutor.doTask(OrderedExecutor.java:42) ~[?:?] at org.apache.activemq.artemis.utils.actors.OrderedExecutor.doTask(OrderedExecutor.java:31) ~[?:?] at org.apache.activemq.artemis.utils.actors.ProcessorBase.executePendingTasks(ProcessorBase.java:66) ~[?:?] at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149) [?:?] at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624) [?:?]",
    "assignee":"davsclaus",
    "type":"Bug",
    "priority":"Minor",
    "status":"Resolved",
    "text":"multiple consumers for namedReplyTo results in a cryptic nullPointer Per [https:\/\/camel.apache.org\/components\/latest\/sjms-component.html#_clustering] you should not have multiple inOut producerEndpoints using the same replyTo address but if you do it results in a cryptic null pointer exception it would be nice to have a better error message of some sort directing you to use a unique replyTo address or temporary queue. Additionally if the replyTo is a topic then I don't believe it should result in an error and it may be better to actually use a message selector for this case.\r\n\r\njava.lang.NullPointerException: nulljava.lang.NullPointerException: null at org.apache.camel.component.sjms.producer.InOutProducer$MessageConsumerResourcesFactory$1.onMessage(InOutProducer.java:103) ~[?:?] at org.apache.activemq.artemis.jms.client.JMSMessageListenerWrapper.onMessage(JMSMessageListenerWrapper.java:110) ~[254:org.apache.activemq.artemis-server-osgi:2.8.1] at org.apache.activemq.artemis.core.client.impl.ClientConsumerImpl.callOnMessage(ClientConsumerImpl.java:1031) ~[?:?] at org.apache.activemq.artemis.core.client.impl.ClientConsumerImpl.access$400(ClientConsumerImpl.java:50) ~[?:?] at org.apache.activemq.artemis.core.client.impl.ClientConsumerImpl$Runner.run(ClientConsumerImpl.java:1154) ~[?:?] at org.apache.activemq.artemis.utils.actors.OrderedExecutor.doTask(OrderedExecutor.java:42) ~[?:?] at org.apache.activemq.artemis.utils.actors.OrderedExecutor.doTask(OrderedExecutor.java:31) ~[?:?] at org.apache.activemq.artemis.utils.actors.ProcessorBase.executePendingTasks(ProcessorBase.java:66) ~[?:?] at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149) [?:?] at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624) [?:?]"
  },
  {
    "key":"CAMEL-14031",
    "title":"Move process control from Main to MainSupport",
    "description":"org.apache.camel.main.MainSupport is now in charge to parse command line arguments, keep the process up according to some policies, intercepts shutdown events and so on.\r\n\r\nTo make it easier to re-use MainSupport in other projects such as camel-quarkus where as example there's no control over command line arguments, it would be nice to move the process control logic to org.apache.camel.main.Main.\r\n\r\n[~davsclaus] does it make sense or there is something I haven't taken into account ?",
    "assignee":"davsclaus",
    "type":"Improvement",
    "priority":"Major",
    "status":"Resolved",
    "text":"Move process control from Main to MainSupport org.apache.camel.main.MainSupport is now in charge to parse command line arguments, keep the process up according to some policies, intercepts shutdown events and so on.\r\n\r\nTo make it easier to re-use MainSupport in other projects such as camel-quarkus where as example there's no control over command line arguments, it would be nice to move the process control logic to org.apache.camel.main.Main.\r\n\r\n[~davsclaus] does it make sense or there is something I haven't taken into account ?"
  },
  {
    "key":"CAMEL-14030",
    "title":"camel-ftp - streamDownload=true and move options dont work",
    "description":"Reported on mailing list\r\nhttps:\/\/camel.465427.n5.nabble.com\/Bug-Camel-FTP-streamdownload-move-options-tp5843791.html",
    "assignee":"davsclaus",
    "type":"Bug",
    "priority":"Major",
    "status":"Resolved",
    "text":"camel-ftp - streamDownload=true and move options dont work Reported on mailing list\r\nhttps:\/\/camel.465427.n5.nabble.com\/Bug-Camel-FTP-streamdownload-move-options-tp5843791.html"
  },
  {
    "key":"CAMEL-13999",
    "title":"Salesforce Component IDLE_TIMEOUT Blocks Async Request Responses for 2.x",
    "description":"Bulk, Composite Batch, etc. all throw an exception when trying to return on more than a few records due to [static final IDLE_TIMEOUT|https:\/\/github.com\/apache\/camel\/blob\/master\/components\/camel-salesforce\/camel-salesforce-component\/src\/main\/java\/org\/apache\/camel\/component\/salesforce\/SalesforceComponent.java#L80] on the instantiated salesforce component httpClient:\r\n\r\n\u00a0\r\n\r\nCaused by: org.apache.camel.component.salesforce.api.SalesforceException: Unexpected error \\{0:null} executing \\{POST:https:\/\/genericSFDCInstance.salesforce.com\/services\/data\/v38.0\/composite\/batch}\r\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 at org.apache.camel.component.salesforce.internal.client.AbstractClientBase$1.onComplete(AbstractClientBase.java:199) ~[camel-salesforce-2.23.0.jar:2.23.0]\r\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 at org.eclipse.jetty.client.ResponseNotifier.notifyComplete(ResponseNotifier.java:202) ~[jetty-client-9.4.12.v20180830.jar:9.4.12.v20180830]\r\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 at org.eclipse.jetty.client.ResponseNotifier.notifyComplete(ResponseNotifier.java:194) ~[jetty-client-9.4.12.v20180830.jar:9.4.12.v20180830]\r\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 at org.eclipse.jetty.client.HttpReceiver.terminateResponse(HttpReceiver.java:470) ~[jetty-client-9.4.12.v20180830.jar:9.4.12.v20180830]\r\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 at org.eclipse.jetty.client.HttpReceiver.abort(HttpReceiver.java:552) ~[jetty-client-9.4.12.v20180830.jar:9.4.12.v20180830]\r\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 at org.eclipse.jetty.client.HttpChannel.abortResponse(HttpChannel.java:156) ~[jetty-client-9.4.12.v20180830.jar:9.4.12.v20180830]\r\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 at org.eclipse.jetty.client.HttpChannel.abort(HttpChannel.java:149) ~[jetty-client-9.4.12.v20180830.jar:9.4.12.v20180830]\r\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 at org.eclipse.jetty.client.HttpExchange.abort(HttpExchange.java:257) ~[jetty-client-9.4.12.v20180830.jar:9.4.12.v20180830]\r\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 at org.eclipse.jetty.client.HttpConversation.abort(HttpConversation.java:141) ~[jetty-client-9.4.12.v20180830.jar:9.4.12.v20180830]\r\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 at org.eclipse.jetty.client.HttpRequest.abort(HttpRequest.java:767) ~[jetty-client-9.4.12.v20180830.jar:9.4.12.v20180830]\r\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 at org.eclipse.jetty.client.http.HttpConnectionOverHTTP.abort(HttpConnectionOverHTTP.java:204) ~[jetty-client-9.4.12.v20180830.jar:9.4.12.v20180830]\r\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 at org.eclipse.jetty.client.http.HttpConnectionOverHTTP.close(HttpConnectionOverHTTP.java:190) ~[jetty-client-9.4.12.v20180830.jar:9.4.12.v20180830]\r\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 at org.eclipse.jetty.client.http.HttpConnectionOverHTTP.onIdleExpired(HttpConnectionOverHTTP.java:145) ~[jetty-client-9.4.12.v20180830.jar:9.4.12.v20180830]\r\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 at org.eclipse.jetty.io.ssl.SslConnection.onIdleExpired(SslConnection.java:286) ~[jetty-io-9.4.12.v20180830.jar:9.4.12.v20180830]\r\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 at org.eclipse.jetty.io.AbstractEndPoint.onIdleExpired(AbstractEndPoint.java:401) ~[jetty-io-9.4.12.v20180830.jar:9.4.12.v20180830]\r\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 at org.eclipse.jetty.io.IdleTimeout.checkIdleTimeout(IdleTimeout.java:166) ~[jetty-io-9.4.12.v20180830.jar:9.4.12.v20180830]\r\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 at org.eclipse.jetty.io.IdleTimeout$1.run(IdleTimeout.java:50) ~[jetty-io-9.4.12.v20180830.jar:9.4.12.v20180830]\r\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511) ~[?:1.8.0_201]\r\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 at java.util.concurrent.FutureTask.run(FutureTask.java:266) ~[?:1.8.0_201]\r\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.access$201(ScheduledThreadPoolExecutor.java:180) ~[?:1.8.0_201]\r\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:293) ~[?:1.8.0_201]\r\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149) ~[?:1.8.0_201]\r\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624) ~[?:1.8.0_201]\r\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 ... 1 more\r\n\r\n\r\n*Caused by: java.util.concurrent.TimeoutException: Idle timeout 5000 ms*\r\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 at org.eclipse.jetty.client.http.HttpConnectionOverHTTP.onIdleExpired(HttpConnectionOverHTTP.java:145) ~[jetty-client-9.4.12.v20180830.jar:9.4.12.v20180830]\r\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 at org.eclipse.jetty.io.ssl.SslConnection.onIdleExpired(SslConnection.java:286) ~[jetty-io-9.4.12.v20180830.jar:9.4.12.v20180830]\r\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 at org.eclipse.jetty.io.AbstractEndPoint.onIdleExpired(AbstractEndPoint.java:401) ~[jetty-io-9.4.12.v20180830.jar:9.4.12.v20180830]\r\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 at org.eclipse.jetty.io.IdleTimeout.checkIdleTimeout(IdleTimeout.java:166) ~[jetty-io-9.4.12.v20180830.jar:9.4.12.v20180830]\r\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 at org.eclipse.jetty.io.IdleTimeout$1.run(IdleTimeout.java:50) ~[jetty-io-9.4.12.v20180830.jar:9.4.12.v20180830]\r\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511) ~[?:1.8.0_201]\r\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 at java.util.concurrent.FutureTask.run(FutureTask.java:266) ~[?:1.8.0_201]\r\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.access$201(ScheduledThreadPoolExecutor.java:180) ~[?:1.8.0_201]\r\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:293) ~[?:1.8.0_201]\r\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149) ~[?:1.8.0_201]\r\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624) ~[?:1.8.0_201]\r\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 ... 1 more\r\n\r\n\u00a0\r\n\r\nNote that as IDLE_TIMEOUT is static, it cannot be set via Spring, and the httpClientProperties map is [never used to set any timeouts|https:\/\/github.com\/apache\/camel\/blob\/master\/components\/camel-salesforce\/camel-salesforce-component\/src\/main\/java\/org\/apache\/camel\/component\/salesforce\/SalesforceComponent.java#L714], instead opting to take the [hardcoded defaults|https:\/\/github.com\/apache\/camel\/blob\/master\/components\/camel-salesforce\/camel-salesforce-component\/src\/main\/java\/org\/apache\/camel\/component\/salesforce\/SalesforceComponent.java#L707].\r\n\r\n\u00a0",
    "assignee":"davsclaus",
    "type":"Bug",
    "priority":"Minor",
    "status":"Resolved",
    "text":"Salesforce Component IDLE_TIMEOUT Blocks Async Request Responses for 2.x Bulk, Composite Batch, etc. all throw an exception when trying to return on more than a few records due to [static final IDLE_TIMEOUT|https:\/\/github.com\/apache\/camel\/blob\/master\/components\/camel-salesforce\/camel-salesforce-component\/src\/main\/java\/org\/apache\/camel\/component\/salesforce\/SalesforceComponent.java#L80] on the instantiated salesforce component httpClient:\r\n\r\n \r\n\r\nCaused by: org.apache.camel.component.salesforce.api.SalesforceException: Unexpected error \\{0:null} executing \\{POST:https:\/\/genericSFDCInstance.salesforce.com\/services\/data\/v38.0\/composite\/batch}\r\n        at org.apache.camel.component.salesforce.internal.client.AbstractClientBase$1.onComplete(AbstractClientBase.java:199) ~[camel-salesforce-2.23.0.jar:2.23.0]\r\n        at org.eclipse.jetty.client.ResponseNotifier.notifyComplete(ResponseNotifier.java:202) ~[jetty-client-9.4.12.v20180830.jar:9.4.12.v20180830]\r\n        at org.eclipse.jetty.client.ResponseNotifier.notifyComplete(ResponseNotifier.java:194) ~[jetty-client-9.4.12.v20180830.jar:9.4.12.v20180830]\r\n        at org.eclipse.jetty.client.HttpReceiver.terminateResponse(HttpReceiver.java:470) ~[jetty-client-9.4.12.v20180830.jar:9.4.12.v20180830]\r\n        at org.eclipse.jetty.client.HttpReceiver.abort(HttpReceiver.java:552) ~[jetty-client-9.4.12.v20180830.jar:9.4.12.v20180830]\r\n        at org.eclipse.jetty.client.HttpChannel.abortResponse(HttpChannel.java:156) ~[jetty-client-9.4.12.v20180830.jar:9.4.12.v20180830]\r\n        at org.eclipse.jetty.client.HttpChannel.abort(HttpChannel.java:149) ~[jetty-client-9.4.12.v20180830.jar:9.4.12.v20180830]\r\n        at org.eclipse.jetty.client.HttpExchange.abort(HttpExchange.java:257) ~[jetty-client-9.4.12.v20180830.jar:9.4.12.v20180830]\r\n        at org.eclipse.jetty.client.HttpConversation.abort(HttpConversation.java:141) ~[jetty-client-9.4.12.v20180830.jar:9.4.12.v20180830]\r\n        at org.eclipse.jetty.client.HttpRequest.abort(HttpRequest.java:767) ~[jetty-client-9.4.12.v20180830.jar:9.4.12.v20180830]\r\n        at org.eclipse.jetty.client.http.HttpConnectionOverHTTP.abort(HttpConnectionOverHTTP.java:204) ~[jetty-client-9.4.12.v20180830.jar:9.4.12.v20180830]\r\n        at org.eclipse.jetty.client.http.HttpConnectionOverHTTP.close(HttpConnectionOverHTTP.java:190) ~[jetty-client-9.4.12.v20180830.jar:9.4.12.v20180830]\r\n        at org.eclipse.jetty.client.http.HttpConnectionOverHTTP.onIdleExpired(HttpConnectionOverHTTP.java:145) ~[jetty-client-9.4.12.v20180830.jar:9.4.12.v20180830]\r\n        at org.eclipse.jetty.io.ssl.SslConnection.onIdleExpired(SslConnection.java:286) ~[jetty-io-9.4.12.v20180830.jar:9.4.12.v20180830]\r\n        at org.eclipse.jetty.io.AbstractEndPoint.onIdleExpired(AbstractEndPoint.java:401) ~[jetty-io-9.4.12.v20180830.jar:9.4.12.v20180830]\r\n        at org.eclipse.jetty.io.IdleTimeout.checkIdleTimeout(IdleTimeout.java:166) ~[jetty-io-9.4.12.v20180830.jar:9.4.12.v20180830]\r\n        at org.eclipse.jetty.io.IdleTimeout$1.run(IdleTimeout.java:50) ~[jetty-io-9.4.12.v20180830.jar:9.4.12.v20180830]\r\n        at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511) ~[?:1.8.0_201]\r\n        at java.util.concurrent.FutureTask.run(FutureTask.java:266) ~[?:1.8.0_201]\r\n        at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.access$201(ScheduledThreadPoolExecutor.java:180) ~[?:1.8.0_201]\r\n        at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:293) ~[?:1.8.0_201]\r\n        at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149) ~[?:1.8.0_201]\r\n        at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624) ~[?:1.8.0_201]\r\n        ... 1 more\r\n\r\n\r\n*Caused by: java.util.concurrent.TimeoutException: Idle timeout 5000 ms*\r\n        at org.eclipse.jetty.client.http.HttpConnectionOverHTTP.onIdleExpired(HttpConnectionOverHTTP.java:145) ~[jetty-client-9.4.12.v20180830.jar:9.4.12.v20180830]\r\n        at org.eclipse.jetty.io.ssl.SslConnection.onIdleExpired(SslConnection.java:286) ~[jetty-io-9.4.12.v20180830.jar:9.4.12.v20180830]\r\n        at org.eclipse.jetty.io.AbstractEndPoint.onIdleExpired(AbstractEndPoint.java:401) ~[jetty-io-9.4.12.v20180830.jar:9.4.12.v20180830]\r\n        at org.eclipse.jetty.io.IdleTimeout.checkIdleTimeout(IdleTimeout.java:166) ~[jetty-io-9.4.12.v20180830.jar:9.4.12.v20180830]\r\n        at org.eclipse.jetty.io.IdleTimeout$1.run(IdleTimeout.java:50) ~[jetty-io-9.4.12.v20180830.jar:9.4.12.v20180830]\r\n        at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511) ~[?:1.8.0_201]\r\n        at java.util.concurrent.FutureTask.run(FutureTask.java:266) ~[?:1.8.0_201]\r\n        at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.access$201(ScheduledThreadPoolExecutor.java:180) ~[?:1.8.0_201]\r\n        at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:293) ~[?:1.8.0_201]\r\n        at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149) ~[?:1.8.0_201]\r\n        at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624) ~[?:1.8.0_201]\r\n        ... 1 more\r\n\r\n \r\n\r\nNote that as IDLE_TIMEOUT is static, it cannot be set via Spring, and the httpClientProperties map is [never used to set any timeouts|https:\/\/github.com\/apache\/camel\/blob\/master\/components\/camel-salesforce\/camel-salesforce-component\/src\/main\/java\/org\/apache\/camel\/component\/salesforce\/SalesforceComponent.java#L714], instead opting to take the [hardcoded defaults|https:\/\/github.com\/apache\/camel\/blob\/master\/components\/camel-salesforce\/camel-salesforce-component\/src\/main\/java\/org\/apache\/camel\/component\/salesforce\/SalesforceComponent.java#L707].\r\n\r\n "
  },
  {
    "key":"CAMEL-13991",
    "title":"camel-main - Configuring component options with #class dont work",
    "description":"The fast component configurer is in use before we check whether the value is a #class etc which we need to do beforehand",
    "assignee":"davsclaus",
    "type":"Bug",
    "priority":"Major",
    "status":"Resolved",
    "text":"camel-main - Configuring component options with #class dont work The fast component configurer is in use before we check whether the value is a #class etc which we need to do beforehand"
  },
  {
    "key":"CAMEL-13961",
    "title":"Reconsider default for xslt:allowStAX",
    "description":"This is currently set to true. However, Xalan (which the default XSLT processor for most) cannot handle StAXSource\r\n\r\n{code}\r\nCaused by: javax.xml.transform.TransformerException: javax.xml.transform.TransformerException: org.apache.xml.dtm.DTMException: Not supported: javax.xml.transform.stax.StAXSource@6a35603\r\n\tat org.apache.xalan.xsltc.trax.TransformerImpl.transform(TransformerImpl.java:642)\r\n\tat org.apache.xalan.xsltc.trax.TransformerImpl.transform(TransformerImpl.java:303)\r\n\tat org.apache.camel.component.xslt.XsltBuilder.process(XsltBuilder.java:132)\r\n\tat org.apache.camel.support.ProcessorEndpoint.onExchange(ProcessorEndpoint.java:95)\r\n\tat org.apache.camel.component.xslt.XsltEndpoint.onExchange(XsltEndpoint.java:121)\r\n\r\n{code}",
    "assignee":"davsclaus",
    "type":"Bug",
    "priority":"Major",
    "status":"Resolved",
    "text":"Reconsider default for xslt:allowStAX This is currently set to true. However, Xalan (which the default XSLT processor for most) cannot handle StAXSource\r\n\r\n{code}\r\nCaused by: javax.xml.transform.TransformerException: javax.xml.transform.TransformerException: org.apache.xml.dtm.DTMException: Not supported: javax.xml.transform.stax.StAXSource@6a35603\r\n\tat org.apache.xalan.xsltc.trax.TransformerImpl.transform(TransformerImpl.java:642)\r\n\tat org.apache.xalan.xsltc.trax.TransformerImpl.transform(TransformerImpl.java:303)\r\n\tat org.apache.camel.component.xslt.XsltBuilder.process(XsltBuilder.java:132)\r\n\tat org.apache.camel.support.ProcessorEndpoint.onExchange(ProcessorEndpoint.java:95)\r\n\tat org.apache.camel.component.xslt.XsltEndpoint.onExchange(XsltEndpoint.java:121)\r\n\r\n{code}"
  },
  {
    "key":"CAMEL-13955",
    "title":"SJMS-Batch does not support CompletionAware aggregators",
    "description":"SJMS-Batch isn't aware of the CompletionAwareAggregationStrategy interface and so never calls the completion method.\r\n\r\nThis prevents SJMS-Batch from working as expected with built in aggregators such as\u00a0org.apache.camel.processor.aggregate.GroupedBodyAggregationStrategy - the aggregated message remains as an exchange header instead of being the message body.\r\n\r\n\u00a0",
    "assignee":"davsclaus",
    "type":"Improvement",
    "priority":"Minor",
    "status":"Resolved",
    "text":"SJMS-Batch does not support CompletionAware aggregators SJMS-Batch isn't aware of the CompletionAwareAggregationStrategy interface and so never calls the completion method.\r\n\r\nThis prevents SJMS-Batch from working as expected with built in aggregators such as org.apache.camel.processor.aggregate.GroupedBodyAggregationStrategy - the aggregated message remains as an exchange header instead of being the message body.\r\n\r\n "
  },
  {
    "key":"CAMEL-13949",
    "title":"camel-core vs camel-core-engine",
    "description":"The camel-core-engine trims camel-core using maven exclusions which may lead to unexpected result as if both are present in the dependencies tree, then one may win over the other depending of the maven resolution.\r\n",
    "assignee":"davsclaus",
    "type":"Improvement",
    "priority":"Major",
    "status":"Resolved",
    "text":"camel-core vs camel-core-engine The camel-core-engine trims camel-core using maven exclusions which may lead to unexpected result as if both are present in the dependencies tree, then one may win over the other depending of the maven resolution.\r\n"
  },
  {
    "key":"CAMEL-13947",
    "title":"Create a configuration service instead of leveraging the properties component",
    "description":"As today the way camel resolves properties\/configuration is trough the Properties Component which leads to a chicken and egg problem as:\r\n\r\n- camel core depends on properties component\r\n- the properties component depends on camel core\r\n\r\nWe should probably have a proper configuration service part of camel core that can eventually be leveraged by the Properties Component.\r\n\r\n",
    "assignee":"davsclaus",
    "type":"Improvement",
    "priority":"Major",
    "status":"Resolved",
    "text":"Create a configuration service instead of leveraging the properties component As today the way camel resolves properties\/configuration is trough the Properties Component which leads to a chicken and egg problem as:\r\n\r\n- camel core depends on properties component\r\n- the properties component depends on camel core\r\n\r\nWe should probably have a proper configuration service part of camel core that can eventually be leveraged by the Properties Component.\r\n\r\n"
  },
  {
    "key":"CAMEL-13941",
    "title":"NullPointerException when Conduit is null",
    "description":"Hello,\r\n\r\nthe CxfProducer.doStart() retrieves a Conduit.\r\n\r\nIf this Conduit is null, should we still throw a NullPointerException or, should we check nullity before condition?\r\n{code:java}\r\nConduit conduit = client.getConduit();\r\n\r\n        if (conduit.getClass().getName().endsWith(\"JMSConduit\")) {\r\n...\r\n}{code}\r\n\r\nhttps:\/\/github.com\/apache\/camel\/blob\/camel-2.21.2\/components\/camel-cxf\/src\/main\/java\/org\/apache\/camel\/component\/cxf\/CxfProducer.java#L87\r\nhttps:\/\/github.com\/apache\/camel\/blob\/camel-2.23.1\/components\/camel-cxf\/src\/main\/java\/org\/apache\/camel\/component\/cxf\/CxfProducer.java#L87\r\nhttps:\/\/github.com\/apache\/camel\/blob\/camel-2.24.1\/components\/camel-cxf\/src\/main\/java\/org\/apache\/camel\/component\/cxf\/CxfProducer.java#L87\r\n\r\nThanks for your point of view.",
    "assignee":"davsclaus",
    "type":"Bug",
    "priority":"Minor",
    "status":"Resolved",
    "text":"NullPointerException when Conduit is null Hello,\r\n\r\nthe CxfProducer.doStart() retrieves a Conduit.\r\n\r\nIf this Conduit is null, should we still throw a NullPointerException or, should we check nullity before condition?\r\n{code:java}\r\nConduit conduit = client.getConduit();\r\n\r\n        if (conduit.getClass().getName().endsWith(\"JMSConduit\")) {\r\n...\r\n}{code}\r\n\r\nhttps:\/\/github.com\/apache\/camel\/blob\/camel-2.21.2\/components\/camel-cxf\/src\/main\/java\/org\/apache\/camel\/component\/cxf\/CxfProducer.java#L87\r\nhttps:\/\/github.com\/apache\/camel\/blob\/camel-2.23.1\/components\/camel-cxf\/src\/main\/java\/org\/apache\/camel\/component\/cxf\/CxfProducer.java#L87\r\nhttps:\/\/github.com\/apache\/camel\/blob\/camel-2.24.1\/components\/camel-cxf\/src\/main\/java\/org\/apache\/camel\/component\/cxf\/CxfProducer.java#L87\r\n\r\nThanks for your point of view."
  },
  {
    "key":"CAMEL-13939",
    "title":"camel3 - Rename camel-management-impl to camel-management",
    "description":"Lets avoid the -impl in the name as its the only Camel artifact that has this ending.\r\n\r\n\r\n",
    "assignee":"davsclaus",
    "type":"Task",
    "priority":"Major",
    "status":"Resolved",
    "text":"camel3 - Rename camel-management-impl to camel-management Lets avoid the -impl in the name as its the only Camel artifact that has this ending.\r\n\r\n\r\n"
  },
  {
    "key":"CAMEL-13936",
    "title":"SNMP Component support \u2018snmp walk\u2019",
    "description":"The current version, the SNMP Component can not support 'snmp walk'.\r\n\r\nAlthough\u00a0the source code has appear 'GET_NEXT' in SnmpActionType.java, but no found in processor.\r\n\r\nNow, i add the 'snmp walk' and in my application it run\u00a0successfully.\r\n\r\nSo, if it need add to the next camel version, please check.\r\n\r\nThanks!",
    "assignee":"davsclaus",
    "type":"New Feature",
    "priority":"Minor",
    "status":"Resolved",
    "text":"SNMP Component support 'snmp walk' The current version, the SNMP Component can not support 'snmp walk'.\r\n\r\nAlthough the source code has appear 'GET_NEXT' in SnmpActionType.java, but no found in processor.\r\n\r\nNow, i add the 'snmp walk' and in my application it run successfully.\r\n\r\nSo, if it need add to the next camel version, please check.\r\n\r\nThanks!"
  },
  {
    "key":"CAMEL-13935",
    "title":"camel-properties: Properties with types different from string are not taken into account",
    "description":"\r\nThe properties component spi has a setOverrideProperties that allow to use an arbitrary Properties object so it is possible that the properties it holds are not of type string. \r\n\r\nIn case the properties component is asked to resolve a non string property, then it will fail as DefaultPropertiesLookup uses Properties::getProperty [\u00b9] which returns null in case of the requested property is not of type string.\r\n\r\nThe error is a little bit misleading as it states: \r\n\r\n{code}\r\nbecause of PropertiesComponent with name properties must be defined in CamelContext to support property placeholders. Property with key [the.body] not found in properties from text: in.body == {{the.body}}\r\n{code}\r\n\r\n[1] https:\/\/github.com\/apache\/camel\/blob\/master\/components\/camel-properties\/src\/main\/java\/org\/apache\/camel\/component\/properties\/DefaultPropertiesLookup.java#L40",
    "assignee":"davsclaus",
    "type":"Bug",
    "priority":"Minor",
    "status":"Resolved",
    "text":"camel-properties: Properties with types different from string are not taken into account \r\nThe properties component spi has a setOverrideProperties that allow to use an arbitrary Properties object so it is possible that the properties it holds are not of type string. \r\n\r\nIn case the properties component is asked to resolve a non string property, then it will fail as DefaultPropertiesLookup uses Properties::getProperty [1] which returns null in case of the requested property is not of type string.\r\n\r\nThe error is a little bit misleading as it states: \r\n\r\n{code}\r\nbecause of PropertiesComponent with name properties must be defined in CamelContext to support property placeholders. Property with key [the.body] not found in properties from text: in.body == {{the.body}}\r\n{code}\r\n\r\n[1] https:\/\/github.com\/apache\/camel\/blob\/master\/components\/camel-properties\/src\/main\/java\/org\/apache\/camel\/component\/properties\/DefaultPropertiesLookup.java#L40"
  },
  {
    "key":"CAMEL-13931",
    "title":"camel-file - tempFileName directory is not auto-created if it is relative before the endpoint path",
    "description":"Hi,\r\n\r\nI face a requirement to place temp files in a folder at the same hierarchy as the output folder like this:\r\n * {{target\/data\/output\/claus.txt}}\r\n * {{target\/data\/temp\/claus.tmp}}\r\n\r\nUsing a simple route definition like:\r\n{code:java}\r\nfrom(\"direct:a\").to(\"file:\/\/target\/data\/output\/?tempFileName=..\/temp\/${file:name.noext}.tmp\"){code}\r\n\u00a0\r\n\r\nIf the temp folder does not exist, the GenericFileProducer should auto-create it. However, it only does so correctly for the tempFileName path, if it is *relativ \"after\" the endpoint path*. If it is above\/before the endpoint path the tempFileName path will be created as a child of the endpoint path instead:\r\n * {{target\/data\/output\/target\/data\/temp}}\r\n\r\nThis results in a NoSuchFileException when camel tries to write the temp file into the \"correct\" temp directory target\/data\/temp afterwards.\r\n\r\n\u00a0\r\n\r\n\u00a0\r\n\r\nA very easy way to reproduce this is to use the 'parentFileUrl' instead of the 'fileUrl' in the createRouteBuilder method of\u00a0FileProduceTempFileNameTest.java ([https:\/\/github.com\/apache\/camel\/blob\/master\/core\/camel-core\/src\/test\/java\/org\/apache\/camel\/component\/file\/FileProduceTempFileNameTest.java]).",
    "assignee":"davsclaus",
    "type":"Bug",
    "priority":"Minor",
    "status":"Resolved",
    "text":"camel-file - tempFileName directory is not auto-created if it is relative before the endpoint path Hi,\r\n\r\nI face a requirement to place temp files in a folder at the same hierarchy as the output folder like this:\r\n * {{target\/data\/output\/claus.txt}}\r\n * {{target\/data\/temp\/claus.tmp}}\r\n\r\nUsing a simple route definition like:\r\n{code:java}\r\nfrom(\"direct:a\").to(\"file:\/\/target\/data\/output\/?tempFileName=..\/temp\/${file:name.noext}.tmp\"){code}\r\n \r\n\r\nIf the temp folder does not exist, the GenericFileProducer should auto-create it. However, it only does so correctly for the tempFileName path, if it is *relativ \"after\" the endpoint path*. If it is above\/before the endpoint path the tempFileName path will be created as a child of the endpoint path instead:\r\n * {{target\/data\/output\/target\/data\/temp}}\r\n\r\nThis results in a NoSuchFileException when camel tries to write the temp file into the \"correct\" temp directory target\/data\/temp afterwards.\r\n\r\n \r\n\r\n \r\n\r\nA very easy way to reproduce this is to use the 'parentFileUrl' instead of the 'fileUrl' in the createRouteBuilder method of FileProduceTempFileNameTest.java ([https:\/\/github.com\/apache\/camel\/blob\/master\/core\/camel-core\/src\/test\/java\/org\/apache\/camel\/component\/file\/FileProduceTempFileNameTest.java])."
  },
  {
    "key":"CAMEL-13929",
    "title":"camel3 - ApiEndpoint should extend ScheduledPollEndpoint",
    "description":"As the ApiConsumer is scheduled poll based, but the endpoint was not its base class. Then options get out of sync and not documented either.",
    "assignee":"davsclaus",
    "type":"Improvement",
    "priority":"Major",
    "status":"Resolved",
    "text":"camel3 - ApiEndpoint should extend ScheduledPollEndpoint As the ApiConsumer is scheduled poll based, but the endpoint was not its base class. Then options get out of sync and not documented either."
  },
  {
    "key":"CAMEL-13925",
    "title":"camel-seda - SedaConsumer should extend DefaultConsumer",
    "description":"So its like the other components where we extend default classes",
    "assignee":"davsclaus",
    "type":"Improvement",
    "priority":"Major",
    "status":"Resolved",
    "text":"camel-seda - SedaConsumer should extend DefaultConsumer So its like the other components where we extend default classes"
  },
  {
    "key":"CAMEL-13919",
    "title":"\"camel-package:update-readme\" throws ArrayIndexOutOfBoundsException when there is an empty \"adoc\" file",
    "description":"Steps to produce:\u00a0\r\n * Create an empty\u00a0{{adoc}} file in any component.\r\n * Run {{camel-package:update-readme}}.\r\n * It will fail with the following error: \r\n{code}\r\nCaused by: java.lang.ArrayIndexOutOfBoundsException: Index 1 out of bounds for length 1\r\n    at org.apache.camel.maven.packaging.UpdateReadmeMojo.updateAvailableFrom (UpdateReadmeMojo.java:510)\r\n    at org.apache.camel.maven.packaging.UpdateReadmeMojo.executeComponent (UpdateReadmeMojo.java:151)\r\n    at org.apache.camel.maven.packaging.UpdateReadmeMojo.execute (UpdateReadmeMojo.java:105)\r\n{code}\r\n\r\n* As I can see [here|https:\/\/github.com\/apache\/camel\/blob\/master\/tooling\/maven\/camel-package-maven-plugin\/src\/main\/java\/org\/apache\/camel\/maven\/packaging\/UpdateReadmeMojo.java#L510], it looks it will try to retrieve index although there are empty lines",
    "assignee":"davsclaus",
    "type":"Bug",
    "priority":"Minor",
    "status":"Resolved",
    "text":"\"camel-package:update-readme\" throws ArrayIndexOutOfBoundsException when there is an empty \"adoc\" file Steps to produce: \r\n * Create an empty {{adoc}} file in any component.\r\n * Run {{camel-package:update-readme}}.\r\n * It will fail with the following error: \r\n{code}\r\nCaused by: java.lang.ArrayIndexOutOfBoundsException: Index 1 out of bounds for length 1\r\n    at org.apache.camel.maven.packaging.UpdateReadmeMojo.updateAvailableFrom (UpdateReadmeMojo.java:510)\r\n    at org.apache.camel.maven.packaging.UpdateReadmeMojo.executeComponent (UpdateReadmeMojo.java:151)\r\n    at org.apache.camel.maven.packaging.UpdateReadmeMojo.execute (UpdateReadmeMojo.java:105)\r\n{code}\r\n\r\n* As I can see [here|https:\/\/github.com\/apache\/camel\/blob\/master\/tooling\/maven\/camel-package-maven-plugin\/src\/main\/java\/org\/apache\/camel\/maven\/packaging\/UpdateReadmeMojo.java#L510], it looks it will try to retrieve index although there are empty lines"
  },
  {
    "key":"CAMEL-13918",
    "title":"camel3 - camel-http - Remove deprecate url rewrite",
    "description":"UrlRewrite has been deprecated on 2.x, and should be removed for 3",
    "assignee":"davsclaus",
    "type":"Task",
    "priority":"Major",
    "status":"Resolved",
    "text":"camel3 - camel-http - Remove deprecate url rewrite UrlRewrite has been deprecated on 2.x, and should be removed for 3"
  }]